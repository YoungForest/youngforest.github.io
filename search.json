[{"title":"2017 新年展望","url":"/2017/02/22/2017-resolutions/","content":" 前言\n现在是大年初七, 是大多数有工作的人上班的日子, 也是襄中开学的日子, 而我作为一个大学生, 居然可以放假到农历二月, 致使现在凌晨2点还有时间码字. 刚刚看了一篇文章, 作者的话很大程度上描述了我的状态, 咸鱼懒的翻身. 而作者的亲身经历和劝说也让我愧疚.\n最近刚读了蔡东藩的五代史, 了解五代混乱的历史, 感叹大多数主子昏庸误国, 英明的主子也多少有瑕疵的同时, 也将心比心, 自己是否是一个英明的帝王. 答案却是否定的. 我是一个懒惰的人, 没有意志力的人, 不喜欢批评, 只喜欢表扬. 如果把自己放在帝王的位置上, 一定是个亡国之君了. 想想还是很可怕的.\n综上两点原因, 我打算在新的一年里有所改变, 制定新年目标, 完成新年计划, 做更好地自己.\n 2017目标及计划\n\n英语每日打卡学习, 加大任务量(小镇做题家欠下的，语言关必须过)\n早起, 8点之前\n早睡, 12点之前\n坚持吃早饭\n坚持每日锻炼身体, 天气好出门跑步, 天气差在室内运动\n凡事不要以懒惰为借口\n\n 总结\n姐姐今年就要毕业找工作了, 我也要准备尽力保研了, 深感世事艰辛, 人间险阻, 唯有努力学习才能获得拯救.\n最后, 二句&quot;名言&quot;镇文.\n学习使我快乐.\n\n我爱学习, 学习爱我.\n\n","categories":["dairy"],"tags":["life","年终总结"]},{"title":"2018年终总结 与 2019新年展望","url":"/2018/12/12/2018-summary-and-2019-resolutions/","content":"Merry Christmas!\n离2019年还有5天，2018年就要结束了。一年过的真快呀。不知道你的2018年怎么样呀？一年前制定的新年计划实现了多少呢？\n我曾在2017年的新年计划中写下这样一段话：\n\n最近刚读了蔡东藩的五代史, 了解五代混乱的历史, 感叹大多数主子昏庸误国, 英明的主子也多少有瑕疵的同时, 也将心比心, 自己是否是一个英明的帝王. 答案却是否定的. 我是一个懒惰的人, 没有意志力的人, 不喜欢批评, 只喜欢表扬. 如果把自己放在帝王的位置上, 一定是个亡国之君了. 想想还是很可怕的.\n\n当时真的是处于人生中一个非常\b没有自信的阶段。大三的寒假，刚刚被编译虐了一学期，面临未来人生道路的选择，自己完全没有信心把握自己的未来，甚至对人生的职业规划完全没有一个清楚的认识。现在近2年过去了(当时是农历新年写的)，不敢说我的境遇好了多少，但起码对未来，对自己有了更清醒的认识。自信心也逐渐建立起来了。\n现在如果重新回答17年时的问题，我会有不一样的答案。\n将心比心, 自己是否是一个英明的帝王。\n我想，我可能会成为宋仁宗那样的君主。虽然在唐宗宋祖、秦皇汉武看来，完全没有帝王的权威。但宋仁宗是真正的仁主，他\b在位的40年，北宋人才辈出，经济也发展到古中国的顶峰。他是一个读书人所期待的最理想的皇帝。感兴趣的同学可以更多地了解一下那个时代，那个皇帝。类似的帝王还有汉文帝、明孝宗。\b“仁”是他们的共同特点，也是我给自己的一个很高的评价。\n 回顾与展望\n新的一年，既要坚持既往好的传统，又要摒弃坏的习惯，培养好的习性。\n坚持一切以找一份好的工作为中心。\n2018年我为此着实付出了不少努力，包括3次实习和多次实习面试。\n3次实习分别\b是，17年9月到今年3月的偶数科技的云平台开发工程师，4月到6月在快手的推荐系统算法工程师，还有11月到目前的文远知行数据平台开发工程师。3次实习极大地让我接触到业界的需求和实际工作，提高了我的代码能力，最重要的是，帮助我更好地认识自己，从而作出合理的职业规划。\n实习面试有：快手、face++、Microsoft、小红书、景驰、商汤。成功率大概只有一半，而且成功与否更多地和对方缺人程度相关。\n来年要准备的\b\b：\b2019年暑期的实习，希望可以找个大厂(最好是跨国外企)历练历练。2019年后半年，有微软的冬季实习可以争取。已经得知Google的第一次电面会在一月末，好好为之准备吧。微软的暑期实习还没有消息，改天找师兄打探打探消息。\n根据\b\b我本身的兴趣和市场需求，我确认后端的软件工程师(高级\b点的称呼叫做架构师)是我今后\b的职业方向。\n因为经过4年半时间的探索，我发觉我对计算机系统是真的感兴趣，比如数据结构、计算机组成、操作系统、编译器、计算机网络这些基础设施。相反，对计算机科学不是很感冒，尤其是最近几年特别火的CV/NLP，经过简单的尝试(\b其实也就是上了斯坦福的机器学习网课和视觉的网课CS231n)，我认为虽然这些研究确实很震撼，也挺好玩的，但比不上计算机系统带给我的快感。\n其次，从市场上的需求来说，软件工程师(SDE)的需求永远是最大的，虽然今年所谓的算法岗很火，但其实这个岗位从名字到工作内容都很可笑，明明就是不同领域的SDE嘛。弄的名字听起来和\b科学家一样。说到名字，我想起了MIT对CS的解释\n\n其实CS(Computer Science)根本就不是Science，更多的是Engineering或是art。\n– CS61A\n\n根据自己的爱好和性格，\b我想外企是一个更适合我成长的平台。一是不用加班，比较强调work-life balance。虽然比不上美帝的\b公司，但比起国内互联网公司要强好多呀。二是可以专心写代码，享受\bcoding的乐趣。外企相对来说氛围更宽松，技术气息也更浓厚。当然选择外企\b也就意味着放弃国内互联网公司快速成长的机会，财务自由的可能。我想我完全可以接受。我本身并不是一个野心很大的人，能够开开心心工作，享受coding，回家后陪老婆孩子，就是我向往的生活了。\n尤其是在文远知行\b实习的这段时间，见证了众多的大佬和同事为了事业和财富而奋斗，却置家庭和生活于不顾。这样的人我是很佩服的，也\b尊重他们的选择。但我做不到，这不是我想要的生活。我需要从家庭和生活中汲取能量，才能更好的工作，我也想活的时间更久些。\n这样的讲起来的话，其实技术移民可能是更适合我发展的一条道路。不过我现在对相关信息了解的还不清楚，留学、找工作、抽签证、绿卡这条更便捷的路线也已经与我无缘了。\n说到留学，还有一个问题我想要回答一下，要不要读博。我的观点是要的，但什么时候读、在哪里读就\b很值得考虑了。\n首先，因为我认为我对计算机系统是真正喜爱的，自己也有耐心深入地研究，读博之后无论是继续从事开发工作还是教书育人，\b都是不错的选择。我本身很看中自己的impact，如果因为自己可以给社会或他人带来一点积极的影响，我就很开心了。\n其次，获得博士学位的过程本身是一种很系统的科学训练。这种训练之后不仅可以用在科研上，\b对解决问题也有\b帮助。这也是快手的大mentor的观点。\n最后，\b博士学位本身的价值。作为一个普通人，博士学位的好处\b远大于一个牛人。无论是可以有个title，还是别人的重视，都是无形中的价值。\n\b\b那什么时候读呢？我认为当然越早越好，但是宁缺毋滥。所以，我需要先工作若干年，然后才能找到好的机会，去读名校牛导的博士。争取40岁之前获得博士学位吧。\n 2019 resolution\n之前总结和展望了一大堆大道理，最后\b却没有具体的计划和愿景？还是需要有的，虽然我认为上面那些对自己的认识才是更重要的。这些resolution很具体，是最理想的情况了，如果最后能实现80%，我就很满意了。因为具体的计划受影响的因素众多，也有自己不能加以控制的。\n\n健康的身体和良好的生活习惯。老生常谈了，但每年还是\b会给自己提个醒。因为你跑的速度已经\b比不上同行了，但你可以比他们跑的时间更长呀。\n一段大大厂(大师兄的\b说法，即指谷歌、微软等大厂，与BAT区分)的暑期实习，争取获得良好印象，得到return offer\n一段海外的交换经历，获得对进入外企有用的能力和经历\n进一步深入计算机系统 和 算法上的进阶。一方面是为了兴趣，另一方面更重要的是提升专业技能，为找工作做准备。\n\nLeetCode 300+题。今年做了115道，虽然绝大多数都是Easy难度的题目，明年的努力\b方向在于可以在限定时间内解决Medium的题目。\n书籍：\n\nCTCI(Cracking the Coding Interview)，美帝程序员\b准备面试的神书\n剑指Offer，\b国内程序员准备面试的神书\nCSAPP，CMU\b\b镇校神课及其参考书\n\bSICP，计算机程序的构造和解释\nC++ Primer, 精通一门面试/工作语言\n算法 第四版，基础算法\n算法导论，同样是算法\n编程之美，面试和算法\n设计模式，OO\bP\n\n\n多参加些实际的面试\n\n\n\n","categories":["dairy"],"tags":["life","年终总结"]},{"title":"2019年终总结 与 2020新年展望","url":"/2020/02/20/2019-summary-and-2020-resolutions/","content":"转发自我的博客\n2020年注定对我是一个不平凡的一年，主要原因在于我面临着毕业和求职的关口。这一关口是我近2年面临的最重要的挑战和任务，我也为之筹备良久，期待可以厚积薄发。然而事实却并不如愿。\n 2019年工作回顾\n在去年的规划中，我写了自己对2019年的规划和畅想。\nLeetCode 刷题任务超额完成，如今已经刷了800+道了。\nC的学习虽然没有按照预期学完C Primer，但是基本学完了 Effective C系列 和 C Standard Library。也算是成为我的主语言了。（最近在搞Rust，学完C后学Rust有很多好处，2者有许多共性。不过这次折腾更多的是兴趣使然，不会改变C是我的主语言的身份。\nCTCI 基本看完。\n其他的书就几乎没有进展了，愧疚。\n实际的面试，3月份参加了 字节跳动广告系统 的 后端开发实习生面试，因为实习时间原因没过。8月底参加了为期一周的字节跳动夏令营的工程组。这个夏令营我只在6月份参加笔试，由于笔试成绩还可以，免了面试。11份收到参加A day with Google的邀请，但由于我已人在比利时，当然无法参加。好是遗憾。\n大厂的实习依旧是0。上半年在商汤实习了半年，得到了一些技术上的历练。但总体还说不是很满意。首先，实习对课题研究起了负面作用，并没有之前预计的两者兼顾。其次，商汤的环境也不大令我满意。科研实力业界有目共睹，但工程技术方面的实力着实一般，内部项目管理也相当混乱。最后，商汤本身是个中厂。规模和产品、技术和快手都差一个档次。\n强身健体方面更是不进则退，办了的健身卡，一年也去了只有大约20次。\n去年的OKR完成度60%吧。\n在这一年里，我也发现了自己一些比较明显的缺点：\n 学习脱离社交\n由于家庭环境的整体内向和“万般皆下品，唯有读书高”的家训，长久以来，我养成了独立思考学习的习惯。这点在过去看来并不是缺点，反而是优点，可以向内更多地寻求力量。然而，到了研究生阶段，这却成了一个大问题。研究生不比从前，你不需要刻意在学习方面寻求社交，也不会过分脱离社交。因为周围的同学大体上学习内容和学习要求与你相同，大家彼此之间的交流就不可避免。而现在，尤其是研一过后连课程也没了，只有科研任务。我的研究课题又是只有我一个人做的。之前实验室有很多人做，最多时多达4人，都成了一个课题组。然而最近该走的走，该毕业的毕业，只剩下我一个人苦苦支撑。如果我不去寻求社交帮助，真的是没有人会和我交流。\n脱离社交的坏处是明显的。我经常会剑走偏锋，在错误的道路上越走越远；得不到情感支持和技术支持；懒惰、退缩的情绪被放大。\n可行的解决方法：\n无论时候求职还是课题研究，多与同学进行交流。虽然大家的研究课题不同，但可以提供起码的情感支持和技术建议。\n在工作中多与老师沟通。我本人与老师的沟通特别少，得益于从小对老师的恐惧之情。虽然大学老师和之前的老师差别很大，很大程度上亦师亦友，但我小学和初中被老师体罚的阴影却一直挥之不去，成为我现在与导师交流的心里障碍。\n提高沟通的欲望和经验。之前在与人的接触交流中，我的宗旨是能少说话就少说话，能关系不进一步就保持原地。这一宗旨是时候发生改变了。我的目标是维护一个庞大的普通朋友的圈子，至少50人，包括维持原先认识的人和今年新认识的人。标准是一年累计的交流时间超过1个小时，或微信交流条数超过50条。\n 2020年美好生活的向往\n继续以毕业和找工作为重心。两手都要抓，双手都要硬。\n\n坚持每天刷题，培养手感和bug-free, debug能力。今年争取攻克hard题目，在半小时内可以解决绝大多数hard题目。\n大厂实习。认真准备暑期实习面试，高质量地完成可能是有生之年最后一次实习了。目标是谷歌、微软、hulu等外企。\n求职和面试准备。秋招时可以找到满意的工作，有个体面的饭碗。\n完成毕业设计和导师的要求，绝不耽误毕业。目前看可能需要延期半年。这也应该是有生之年最后的科研时光了。\n强身健体。希望穿衣显瘦、脱衣有肉。体重增重到70公斤。把剩下的3颗智齿拔了，右下槽牙加冠。\n\n","categories":["dairy"],"tags":["life","年终总结"]},{"title":"2020年终总结 与 2021新年展望","url":"/2020/11/25/2020-summary-and-2021-resolutions/","content":"转发自我的博客\n今年也年终总结有些早，还没有步入12月份。不过因为今天刚交了大论文查重，虽然很多事儿要做，但完全没有工作的心情。不如就利用这种烦躁的心情写个年终总结的初稿，不知道会不会受影响。\n2020年从一开始就是注定不平凡的一年，之前我只预见到因为我要毕业，只是对我而言，没想到一场席卷全球的疫情使得它成为了对所有人都很有挑战的年份。\n 2020年工作回顾\n首先，我对照我去年写的展望，回顾一下完成度。\n每天刷题算是如愿完成，尤其是加入残酷打卡群后，刷题还可以领红包真开心。在群里还可以认识一堆大佬，个个都是人才，说话又好听。研究生2年半刷题1k+，LeetCode周赛参加近100场，世界排名一度进入前500，rating稳定在2200+，rating排名稳定在前1000，周赛一半以上可以完成4题，保证3题，排名经常前500，最高前100，国服也3次拿礼物，虽然不值钱，但很开心。残酷群排名最高11名，稳定前40，偶尔稳定前20。这些成绩还是让我小骄傲的。虽然别人可能并不会很看重这些，但我自己乐在其中，取得了成就感，形成了刷题的正反馈。\n但之后我不会投入更多的时间刷题了，如今已经过了刷题高峰，暂时没有找工作的压力，而且刷题的水平已经到了一定高度，刷题的收益没之前那么大了。之后计划每日做一两题保证手感，周末争取每周打周赛，继续在残酷群当镰刀。更多时间会被投入到其他技能上，如工作技能、系统设计、英语口语等。\n外企大厂也如愿完成。虽然由于疫情原因，第一志愿Google全面取消了今年的暑期实习项目，本来一面都过了。甚至之后的秋招也直接没了。不过如愿到第二志愿亚马逊参加了6个月的远程实习。虽然不是一开始报的后端岗位，而是iOS客户端岗位，但是好在亚麻SDE都是全栈的，工作中也有不少涉及后端的工作；自己这几个月的实习体验也还不错；之后也有不少转组和transfer的机会。\n之后如果不出意外的话还是会转正留任。\n今年求职主要分2个部分，春季的实习面试和秋招。\n因为目标明确再加上准备充分（4段实习经历+1k道leetcode+科班背书），虽然上半年疫情半年呆在家，不少公司都缩招了，尤其是外企，我仍然拿到不少不错的offer。最后综合考虑（也是一直以来的规划导致）选择在亚马逊这样的外企大厂实习和留任，放弃了国内互联网企业和高薪的独角兽。总体求职和面试过程加结果都比较顺利和满意。\n科研和毕设这块也十分满意。虽然上半年花了不少功夫写了篇小论文投了3m，但惨被拒，但完成小论文过程中的实验和经历很好的帮助我按时写完了大论文，今天刚递交查重，不出意外可以按时毕业不需要延毕。最近一年也是研究生涯中最投入科研的一年，虽然没啥成果，但也尽力了。自己真的不是做学术这块料。还是好好做个软件开发工程师实在。\n12月更新。按时毕业的期望还是出了意外。由于去年下半年在外交换，和导师商量下学期开学再开题。然而，到了下学期竟然直接半年没开，也是醉了。导师一直拖到8月份才给我开了题。到12月答辩时不足6个月，不符合学校规定，无法参加答辩。只能改为明年6月的第二批答辩。\n随之带来一系列影响，最大的还是只能7月份才能正式入职公司。\n原来以为马上就要脱离苦海了，没想到又要多呆半年。学院也是最后一步才卡你。早些告知我不能按时答辩，我之前也不用为了12月的答辩那么赶了。学院领导也是不顾学生的死活和疫情的事实，只关心自己的乌纱帽。我就差从学院跳楼了。导师也找学院领导求情了也是不行。\n锻炼身体却像往年一样没有进展。穿衣一直显瘦，脱衣一直没肉。智齿也因为疫情和学业实习太忙的原因没能处理。\n总的来说，虽然今年充满了黑天鹅和坎坷，也没完美实现预期，但总体上还是十分满意，给自己点个赞。继续加油！\n 2021年美好生活的向往\n\n顺利毕业。\n业余时间投入到需要的技能上，主要包括工作技能、系统设计、英语口语等。\n认真实习和工作，平安度过试用期。为之后升职L5做准备。\n解决智齿和其他牙齿问题。\n坚持每日刷题，当作一种爱好和习惯。\n\n","categories":["dairy"],"tags":["life","年终总结"]},{"title":"2021年终总结 与 2022新年展望","url":"/2021/12/28/2021-summary-and-2022-resolutions/","content":"新年快乐，离2021年结束还有3天。我终于提笔开始了我一年一度的年终总结和新年展望。最近发现写年终总结的同学越来越多，但我其实不是跟风。我很早就开始每年写年终总结。一开始是在日记本里，后来在博客里。除了每年辞旧迎新的时候，我还会在人生阶段性里程碑写下总结和展望，比如本科毕业和硕士毕业。\n之前的年终总结：\n\n2020年终总结\n2019年终总结\n2019年中总结(生日随想)\n2018年终总结\n2017新年展望\n\n里程碑回顾:\n\n硕士3年复盘\n大学4年复盘\n\n这些重要的博文都放在我博客的dairy分类下。\n 2021年工作回顾\n很多时候，很难相信，明年就是2022年了。有些时候，在写日期的时候，都不得不想一想今年是哪一年。大概是年龄大了。之前就听说过，人越长大，对时间的感觉就越匆忙。因为增加的时间占自己的记忆比重会越来越小，也是十分有道理的。现在的我，甚至很难相信疫情已经持续了快2年。之后的时间也会越来越快，比较好的应对方法是：1. 好好地把握当下，不虚度年华；2. 增加生活的多样性，不变的生活会让人感觉过的更快。3. 多增加记录，无论是照片还是文字，记录下来的会让记忆变厚。\n针对我去年的新年展望，我一条一条地分析进展：\n 顺利毕业\n虽然经历了半年的延毕风波，我最终还是成功在6月份通过毕业答辩，拿到了毕业证和学位证。一开始延毕时很难接受，觉得自己掉队了。但时间是最好的解药，而且毕竟因为疫情和各种各样的原因，三分之一的人延毕了，甚至我们宿舍4个人延毕了3个，反而正常毕业的成了少数。\n虽然被牛老师恐吓，研究生生涯心理压力很大，但最终我还是挺过来了。\n毕业之后，一切都顺利了很多，尤其是工作。\n 业余时间投入到需要的技能上，主要包括工作技能、系统设计、英语口语等。\n人和人最大的区别就在于业余时间的有效利用。虽然我有一定的目标和较为充足的业余时间（相比996的同胞），但老实说，利用效果并不好。究其根源，还是因为懒惰。虽然懒惰是人之天性，但确实是一个缺点，还是需要想办法克服的。\n业余时间的3个目标，都算是完成了部分，但仍然不理想。需要反思并之后投入更多的时间，减少娱乐和无效的时间利用。\n工作技能：看了部分的Effective Java，Core Java。但Java博大精深，可能只看了大概十分之一。读完了不少iOS开发的书，包括《Effective Objective-C 2.0》，《Programming in Objective-C》。学习了部分Stanford CS193p的课程，但由于公司开发还是以Objective-C为主，所以中途放弃了。为了学习优化APP，看了大部分的《High Performance Browser Networking（Web性能权威指南）》。\n系统设计：关注了一些YouTube博主，其实系统设计挺适合看视频学习的，重点在于交流和表达。2本早打算读的书《Alex Yu - System Design Interview》和著名的野猪书 ddia《Designing Data Intensive Applications》，我只读了一小部分。反而是工作中需要大量的系统设计，我学习了不少AWS组件，完成了几个项目的设计和实现。设计完通常会有Senior的同事review和指导，从这个过程中学了不少。创建了“佛系系统设计群”，罗列了不少资源在上面，然而很少有人说话。\n英语口语：公司给报了英文培训，每周2个小时。一个现在居住在泰国的南非老师，教我语法、词汇和表达。内容都相对简单，大概就是初中难度的。重要的是，课程是1对1的，对听力和口语的练习有很大帮助。除此之外，我还通过 播客，YouTube 做一些输入练习。在工作中，偶尔也需要和国外同事交流。很多时候，同事也是非英语母语的，如印度人、中东人、东欧人，在交流中我往往只能听懂一半，确只能硬着头皮说。不过好在每次都应付下来了。现在，我已经能比较好的完成1:1的问题咨询/解答，以及在会议中做演示和回答问题。为了准备以后的英语面试，我尝试了模拟面试，并选择用视频记录它.\n 认真实习和工作，平安度过试用期。为之后升职L5做准备。\n还有几天就过试用期了，算是成功完成目标。上半年实习的时间也比较久，直到4月份才离职，共实习了8个月。因为一直是WFH，相对也比较方便和轻松。因此，虽然只正式工作了半年，我现在的Tenure 已经是1年3个月了。\n虽然我工作很认真，但升职L5可能赶不上了。因为我发现大多升职的年限是2年。虽然每季度都有升职的人，但我想要赶在去欧洲前升职还是不太稳当的。只能全力以赴、问心无愧了。因为无论升不升职，我都得去欧洲陪读。升职当然是锦上添花，可以让我transfer到欧洲/在欧洲找工作时起点更高。\n 解决智齿和其他牙齿问题。\n今年把上面2颗比较好拔的萌生智齿拔了，算上18年拔的那个，完成了3/4了。因为最后一刻是阻生智齿，神经长得和下颚很近，不好拔。因此医生建议我如果以后不疼就不处理了。鉴于客观原因，我解决智齿的任务也算是圆满完成。\n除此之外，还做了之前杀神经的槽牙的“装冠”以及牙周炎的治疗。因为疫情期间，所有喷溅治疗都得提前做核酸检测，牙科基本都要做，而且北医三院的检测虽然是免费的，但是只能捅鼻孔，十分难受。好在同一个医生的几次治疗只需要做一次核酸。\n经历了痛苦的牙周炎治疗和龋齿问题，我现在每天除了认真刷牙外，还会每晚用牙线。可谓十分麻烦。但经历过治疗的痛苦后，感觉麻烦也都能接受了。\n 坚持每日刷题，当作一种爱好和习惯。\n今年我仍然呆在“残酷刷题群”里，参加了几乎每一场周赛（只缺席2场），刷题虽然谈不上每天都刷，但也是有近一半的天数在刷。刷题已经对我来说不是负担，而是消遣了，真正成了爱好和习惯。现在美服和国服rating都是2450+, 也算是小有成就。\n新的一年，我会继续保持这一爱好和习惯。但并不是每天刷题，而是随心所欲不逾矩。想刷就刷。之后如果去了欧洲，因为时差原因无法参加LeetCode周赛，我会换一个平台继续刷题，比如 CodeForces。\n总的来说，在这关键的一年，因为之前长期准备，我过的还算顺利和平安上岸。人无远虑，必有近忧。我向来是喜欢提前谋划，长期努力的人。新的一年，加油！\n 2022年美好生活的向往\n\n继续利用好业余时间，提升工作技能、系统设计、英语口语等。\n积极的英文面试准备、模拟和实战。\n顺利去欧洲陪读，并找到合适的工作。\n多读书。包括技术书籍、兴趣书籍（历史、投资、小说）。\n多输出。包括口语表达、博客、视频等。\n\n","categories":["dairy"],"tags":["life","年终总结"]},{"title":"2020 暑期实习 求职总结","url":"/2020/04/30/2021-summer-intern-interview-summary/","content":"从在牛客网发暑期实习的第一篇面经开始，到现在已经过去近2个月了。中间陆陆续续参加了8个厂的招聘。岗位均为后端/服务器开发。base地点为北京。\n 失败\n 字节跳动\n一面就凉。字节跳动还是一家和我很有缘分，我也很喜欢的一家公司。去年参加过一次广告系统的暑期实习面试，经历残酷四面。面到lead力哲。最后因为实习时间不合适没去。去年暑假还参加了ByteDance 的夏令营。由于是长久以来的第一次面试，准备不足、发挥也不是很好。算法题 编辑距离 没做出来，遂一面即凉。\n 微软\n找了之前在微软工作的一位师兄，托他又联系到正在微软工作的一位同事，做了内推。18年时曾面过一次苏州微软, 当时水平有限，无奈地凉了。今年踌躇满志，想要一雪前耻。没想到同样翻船了。不过吸取了很重要的经验，不要吹牛打过比赛。\n一面面试官问我打过什么比赛吗？我当时作死回答说，打过一些LeetCode、kickstart、codeforces、atcoder。实际上，只有LeetCode我是经常参加周赛，kickstart参加每月的轮次（如果时间合适的话）。其他平台的赛事加起来也只有几场。面试官因此误解了我的实力，认为是cf水平的（实际上，我cf的rating都不到1500）。只问了我系统设计的问题，没有手撕代码，我尽管在LeetCode上刷了900题，也没发发挥。\n二面面试官上来就问了2道很难的算法题，感觉是准备给ACM选手的。都怪我一面时吹了牛，二面被安排了。\n\nfind the closet point pair\n在平面上找到任意直线，将N个点分为数量相等的2部分\n\n 结束\n 谷歌\n通过了电话一面，但无奈因为疫情的原因，Google中国取消了暑期实习项目。我的面试进程也止于一面了。\n 钉钉\n因为之前以为蚂蚁金服是独立的公司，所以投了蚂蚁和钉钉。正式在阿里系统里投递时，才得知只能投递一个。因为蚂蚁在北京，遂选择了蚂蚁。录入系统前参加了一次面试。\n钉钉一面\n 成功上岸\n 蚂蚁金服\n收到意向书。今年暑期情况不明，也不知道是否可以会北京参加实习。\n一面\n二面\n三面\n四面\n 米哈游\n通过了面试，但是因为暑假不可能去上海实习，遂拒绝了。\n一面\n二面\n三面\n 进行中\n 腾讯\n由于工作岗位base地点的原因，换着面了很多组。都聊到HR了，但北京这边就是恰好没有HC。\n一面\n二面\n三面\n四面\n五面\n七面\n八面\n九面\n笔试\n 华为\n参加了线上的笔试，难度不大。LeetCode medium吧。\n 美团\n参加了线上笔试。效果不佳。5道编程题，只A了2道，有2道过了一半，还有最后一道最后一直没有调出来。题目看起来难度不是很大，但做的效果实在不行。感觉要凉。\n美团还是实验室亲师兄推我的，感觉辜负了期望。\n 一面\n由于2位很强的亲师兄在美团，我还是被抬进面试了。而且面试也没问很难的题目，感觉被大佬担保了。瑟瑟发抖。\n字符串查找。以为要写KMP，这不抄模版哪里是最后10min能写出来的。最后解释了下，写了个N*M的brute force的解法。\n 二面\ntwoSum，找到所有和为target的两数下标对。\n","categories":["interview"],"tags":["intern"]},{"title":"2022年终总结 与 2023新年展望","url":"/2022/12/25/2022-summary-and-2023-resolutions/","content":"转身之间，2022年已经要过去了。不知道是因为疫情限制地原因，还是因为自己本身年级大了。感觉现在是时光飞逝，真的如白驹过隙。古人诚不欺我。\n之前的年终总结：\n\n2021年终总结\n2020年终总结\n2019年终总结\n2019年中总结(生日随想)\n2018年终总结\n2017新年展望\n\n里程碑回顾:\n\n硕士3年复盘\n大学4年复盘\n\n这些重要的博文都放在我博客的dairy分类下。\n 2022年个人回顾\n这一年，我个人生活的工作的变化还是很大的。\n 工作\n今年按照预期的计划，换了工作，润到了欧洲。虽然职级没有变，还都是Junior。\n工作方向仍旧不变，还是做后端。但内容和公司文化差异还挺大的。\n不过总体氛围和工作压力上讲，都柏林微软比国内亚马逊还是轻松不少的。\n语言仍是一大关卡，我操着自己的散装英语，和全世界各地的人交流，还是不能十分称意的。\n这里Nationality Diversity超标，组里都是不同国家的人。不过Gender diversity要差很多，以男性为主。这点不如北京亚麻。不过也可以理解，都柏林这边从全世界，尤其是第三世界招人，它们的女性受教育和机会远不如社会主义中国，供给的不平衡最后导致招上来的人也十分不平衡。\n 疫情\n首先，新冠疫情来到了第三个年头，由于病毒扩散的增强和动态清零的严格防疫政策。这一年经历了前所未有的常态化核酸。即在北京3天做一次核酸，否则哪里都去不了。公交地铁，商场超市都需要。北京健康宝也成了最常用的应用，毕竟去哪里都需要扫码。\n前半年疫情肆虐的时候，我在炫特嘉园经历了2次封锁，都是因为同小区别的楼出现了阳性。每次大概十天。只能通过外卖/快递购买食物，实时性还很差。因为当时很多小区在封，需求大，快递员好多也被封了，供给有限。管控区的要求是足不出楼，最多在楼下一小块地方活动。\n第一次大家还都很听话，也就做核酸的时候出来放放风。第二次周日的时候发生了一场聚集事件，居民集中在小区广场，要求社区领导停止层层加码，解封。当然没有成功，还是等了10天才解的。\n我当时做的一居室只有35平米，真的是连走路的地方都没有。每天蜗居着实辛苦。\n下半年病毒又重新肆虐。我在6月底之前自如租房到期后，又在同楼一层找了个2个月的房子，8月底房子到期。我一个人在北京呆着也没意思，还可以省些房租钱，就回老家了。等着润。9月底回北京办工签还算顺利。然而国庆节开始，一轮病毒重新肆虐，二十大也来临了，各地管控十分严格。当时我所在的县也有了疫情三年以来的第一个病例，我的北京健康宝也弹窗去不了北京。当时和弹窗宝斗智斗勇，我10月底就要坐飞机走了。因为一直学习工作在北京，就让公司买了从北京出发的机票。幸好最后还算顺利。我提前一周来到北京，完成里离职、和亚马逊的同事告别晚餐、打包几箱搬家行李，最后成功登记离境。\n当时走之前家人同事们还担心关怀我在海外有感染风险。没想到世界变化的太快。我走的时候已经是黎明前最黑暗的时刻了。各地动态清零层层加码风控政策已经让人民受不了了。我离开前后发生了不少事件，最后乌鲁木齐火灾终于成了导火索，全国各地上街表达不满和解封诉求。不少关注的公众号和朋友圈也都在声援，说实话太勇敢了，反正我是不敢的。不过斗争的成果还是显著的。防疫政策180度转向，让许多人措手不及，也没做好准备。到年底的情况是，北京和其他城市陆续迎来高峰。我之前的同事已经有三分之二都被感染了。这种情况下，国外反而更加安全。不过因为被国内吓到了，所以我社保号办下来后马上去接种了辉瑞Covid疫苗，还是特别针对BA4.5变种的。mRNA疫苗确实猛，第一天只是感觉胳膊很疼，后2天浑身疼、乏力，些许低烧。\n 生活\n自从去年底，我就开始了居家办公的生活。本身亚马逊自从20年疫情一开始就开始了WFH(Work from home)，但办公室是一直开着的，可以过来。基本每天来的人很少，大多数时候只有经理和少数经常来的同事，绝大多数同事还是选择了长期居家，偶尔只有聚餐/团建的时候才能看到大家。长期居家工作的生活在国内也是比较罕见的。虽然工作交流效率有所降低，但通勤的节省和自由的工作地点和时间真是太爽了。尤其是你有家庭或伴侣可以一起的时候。\n离职前还享受了2个月的在老家办公，也是太爽。低廉的物价，不需要交房租，和家人的陪伴，都让我十分怀念。\n最大的生活变动就是最后2个月从国内润到了爱尔兰，在都柏林开始了第二段打工生涯。\n微软给安排了2个月的临时住宿。也是一个公寓，而且还是2间卧室2间卫生间（2b2b），但我一个人住。然后每周有阿姨过来简单打扫一下。距离办公室也不是很远，走路20分钟。不过身在郊区，去超市很不方便。离最近的商业区也得20多分钟。\n最后一个月找到了长期公寓。也是一个2b2b的公寓，总价2550欧，但是我选了小的卧室，1225欧每月。而且不包含电费（做饭和烧水都用电）和网费。爱尔兰的租房市场真是变态，垃圾的基础设施，但各种物价房费简直上天。租售比之高属于欧洲之首，同事买房月供比租房还划算地多。\n因为组里做的工作过于基础，Onboarding的时间很长，而且12月是Non-Fly zone，不做生产代码的修改。这2个月感觉还是十分轻松的。这边认识的人也都是公司里其他国家的同事，他们下班时间喜欢聚会和聊天。我喜欢一个人的活动，晚上下班和周末都窝在家里看书、视频和电影。\n 学习\n首先，因为准备欧洲的面试，学习了大量面试相关的知识。包括 刷题、系统设计、和 行为问题。因为面试都是英文的，所以花了大量时间提升英语，尤其是口语表达和交流能力。DDIA也看了大半，Grokking the System Design Interview 看了一小部分。\n其次，工作上也学到大量的知识。我本人是十分喜欢学习新知识的，获得新知识的快感类似购物和游戏。在工作中需要的技能，我一般是倾向于花更多的时间系统学习下的。比如 对Java看了 Effective Java，Core Java，对C#看了 More Effective C#。\n最后，自己感兴趣的杂事。尤其是最后2个月来到欧洲这边，空余时间空前多和对知识的热爱也很旺盛。主要是 人体简史，极简欧洲史，和 量子科学史话。除此之外，还看了不少经典电影，豆瓣TOP250.\n 2023年美好生活的向往\n\n未来2年升职和Transfer到美国。\n\n经过8年的了解，终于还是下定决心去美国发展。原因是多方面的。首先，对于程序员来说，美国毕竟还是计算机的核心。从职业发展机会和薪水上来说，都远好于其他国家。其次，欧洲一直在走下坡路。虽然底子很厚，处于第二世界，生活质量很高，但未来不属于欧洲。下次技术爆炸大概率会发生在中国或是美国。最后，美国算是一个生活和工作的平衡点。欧洲生活很不错，甚至可以说是过于躺平了。中国工作压力大，生活被挤占的很严重。如今，因为互联网信息产业的红利，程序员的收入有明显的溢价，尤其是在中美。这种红利迟早要减弱消失，但不知道多久。我想趁着红利多赚些钱，做些投资。不过我有信心，下个红利也将是计算机领域的，可能或多或少还是能享受些。\n\n\n锻炼身体，增强体魄。\n\n身体是革命的本钱。越长大，接触的人事越多，越觉得 好身体，家庭幸福 比啥都重要。多花些时间在锻炼和家人上，工作只是为了养家糊口。“老婆孩子热炕头，两亩薄田一头牛”依旧是我的生活理想。\n\n\n保持学习的热情，无论是工作上的，还是个人兴趣上的。\n\n心理健康也是很关键的。活到老学到老。\n\n\n\n","categories":["dairy"],"tags":["life","年终总结"]},{"title":"2023年终总结 与 2024新年展望","url":"/2023/12/23/2023-summary-and-2024-resolutions/","content":"转自我的博客\n圣诞假期将至，爱尔兰微软的办公室早早就充满着节日气氛。各种张灯结彩，圣诞树和圣诞老人的装饰，不亏是爱尔兰最大的节日。爱尔兰圣诞节会放2天假，12月25号和26号，比美国还多一天。更多的人，尤其是基督教国家的同事，会在节日前后请年假，回家和家人一起过节。因此12月是一个工作比较轻松，大家十分放松的时间。\n距离新年还有半个月，我的生活和想法应该不会在这段时间内发生改变。不少朋友也在期待着我的年终总结，都成为一年一度的固定项目了。从17年到现在，已经第7年了。\n往年的年终总结：\n\n2022年终总结\n2021年终总结\n2020年终总结\n2019年终总结\n2019年中总结(生日随想)\n2018年终总结\n2017新年展望\n\n里程碑回顾:\n\n硕士3年复盘\n大学4年复盘\n\n这些重要的博文都放在我博客的dairy分类下。\n 2023年个人回顾\n不同于前几年，大概是三年大疫情的原因，感觉时光飞快，每年都很快过去了，分不清今夕是何夕。今年感觉时光还是稍慢的，大约是换了一个环境，而且工作相对轻松，有了更多的时间旅行和读书，增加了很多记忆和思考。而且今年，生活也发生了一些剧变，隐约感觉到，大概是未来几年的一个转折点，一个新的起点。\n 工作\n今年西方和国内经济环境，其实都是充满了严峻考验的。\n2022年西方疫情结束之后，消费反弹，再加上前些年量化宽松，放水太多，叠加俄乌战争，造成了严重的通胀高企。仅次于70年代，石油危机时期的高通胀了。通胀有多严重呢，就我来爱尔兰的这一年时间，在超市就感受到了10%的涨价或是减量。更不用提相比疫情前的价格了。\n美国，欧洲，英国疯狂加息，到23年中，才停止。通胀是控制住了，但物价只是不会继续疯狂涨了，已经涨的不会降了。\n不同于70年代的长期“滞涨”，本轮通胀持续时间并不长，而且发达经济体经济发展并不停滞，反而欣欣向荣。\n反应到科技大厂这边。疫情期间，由于线下消费萎缩，线上需求猛增，再加上量化宽松带来的充足自信，互联网企业的营收增长都很快。绝大多数厂子的领导层都认为增长是可持续的，疯狂扩张招人。21年大包满天飞。今天面试，第二天发offer。大厂都是几万几万地招，有些部门扩充了2、3倍。把之后2-3年的人都招进去了。其实在那种情况下，很难保持理智。你不招人，别人疯狂招。谁扩招，华尔街就看好谁，谁股价就涨。美股也在21年低到达当时的历史最高点（写本文的时候，23年低，美股也恢复过来，再创新高了）。\n到22年疫情结束，线下恢复，线上需求回调，加息也是的资金缩少。美股也是一路下跌。IT公司才又开始Hire Freeze (冻结招聘)，然后就是23年上半年的疯狂裁员。这次反过来了，谁裁员，华尔街就看好谁，谁股价就涨。虽然裁员对美国影响最大，毕竟美国程序员收入高，也就是公司的成本高，但爱尔兰也受到一些影响。我的HC也因此被砍掉，送给另外一个部门。但另外一个部门在爱尔兰其实没有一个人，所以我和另外一个同事就被分配给了最近的，在 以色列 的一个组里。\n我的工作因此也发生了巨变。原先以为的理所当然的Work Life Balance, 人性化的管理，rest &amp; vest，Growth, Diversity 都没有了。取而代之的是，Micro-management, Agile, 全组的 犹太人 和 希伯来语。workload直接翻倍，新老板还不满意，工资不变。旧老板是经常夸我，很鼓励我的输出和工作。旧组在美国，8个小时时差，早上十分轻松。一周一次站会。新组因为2小时时差的原因，每天早上8点半早起开站会，睡懒觉的机会都没有了。原来每天去白嫖办公室的健身课，后来也没时间去了。旧老板2周一次1:1, 新老板一周2次1:1，还都是谈项目。 旧组国籍种族Diversity很足，来自不同国家的人，还有几个很好的老中。新组除了我，和另外一个之前一起在爱尔兰的白俄罗斯人，都是犹太人。旧老板30年老微软，主要精力是manage up，挡烂活，拉好活，手下几个Principle和Senior；新老板2年新微软，扩招期进来的，manage up不行，每天manage down，手下没几杆枪，唯一的Senior还在休产假，我反正是没见过她人。旧组每个人有自己的长期大项目；新组是一直在做没有impact的小活和bug fix. 美国把边缘项目给以色列，以色列的老板再把脏活累活丢给爱尔兰。我从第一次和新老板1：1就感觉出不对劲，他给我讲他的Principles（他真不适合微软，适合去亚马逊）, 3个孩子 和 40岁中年危机（华人应该对此比较敏感，国内的35岁危机）。\n真是从天堂来到了地狱。上半年天堂，下半年地狱。一开始来了 爱尔兰微软，感觉微软和欧洲工作都名不虚传，真是爽。现在领着爱尔兰的工资，交着爱尔兰的高税收，给以色列打工，真是难受。\n今年公司也以业绩不好，裁员为理由，没有了薪资的普调。办公室食堂还涨价了10%。真是物价什么疯狂涨，只有工资不涨。\n唯一聊以慰籍的是，今年美股涨势很好，以科技7姐妹为代表，苹果、微软、谷歌、亚马逊、买它、特斯拉、英伟达。我去年找工作的时候，虽然遇到Hire Freeze, 因此错失了不少机会，也冒着很大风险，但顶着Hire Freeze入职的好处就是股价比较低。这一年已经涨了50%了。\n21年加入亚马逊的时候，当时的股价是170刀（当时还未拆20股，因此股价是3400刀），真是高位站岗。到现在虽然已经从低点85涨了一年了，也才涨到150。不如直接重开。\n更惨的是，因为科技厂裁员和在华外资撤退的原因，今年9月份，我之前的组几十个人整个被裁了，虽然有N+6的丰厚补偿包。这2年我的经历真是 塞翁失马焉知非福。\n国内经济以通缩为标志。但我们仍要唱响中国经济光明论. (这句话中的辛酸和梗，也许只有2023年底的中国人才能理解。)\n对近30年，国内的经济发展和问题，推荐一本 兰小欢老师的新书：置身事内 – 中国政府与经济发展. 也可以听听之前“忽左忽右”的一期播客“269 陶然谈土地财政与经济增长的未来”。笔者也不敢展开讲讲。\n 感情\n本来很犹豫是否写这个篇章，因为毕竟要揭开伤疤回忆和复盘这些事情还是极其痛苦的。但是，我想，还是留下些文字，给这段3年的感情一个圆满的句号吧。\n因为记忆都是被塑造的，所以也可以通过文字，留下美好的记忆，忘记痛苦。\n分手的原因主要有3点：\n\n异地，我在爱尔兰工作，她在荷兰读书\n性格不合，我是ISFJ 守卫者，她是ENTP 辩论家 + 严重的ADHD。\n对未来生活的目标不一致，我是“老婆孩子热炕头”，她是恐婚恐育\n\n3个原因其实是互相关联，有因果性的。\n3年的相处，从学生到工作，从北京到欧洲，也是我第一段长期的亲密关系。从中，我也学会了很多。如何制造浪漫，过节日；如何照顾人；怎样解决矛盾和冲突，尤其是在紧密关系中；学会 欣赏 鼓励 和 治愈；更重要的是，更了解了自己，知道自己真正想要什么，需要什么，和自己能做到什么。\n甚至分手后的疗愈阶段，也是一段学习、反思和成长的过程。分手后的失落，也让我更加认识到亲人和朋友的可贵。\n5年前，初恋去美国读书，我当时没有能力也没有勇气去解决异地问题（12/13小时时差，真是隔了半个地球），甚至不敢做出承诺和画饼。而是选择了分手这种简单的解决方法，充满遗憾。多年以后，我终于有了能力，也有勇气去世界上任何地方。因此，当上天再次把类似的问题丢给我时，我选择了奋不顾身地来了欧洲陪读，十分顺利地来到爱尔兰。\n但最后这段恋爱关系还是失败了。再次经历这种 撕心裂肺，刻骨铭心 的感觉。就像《潜伏》中，余则成 得知 翠平 死讯的时候，人在极度悲伤的情况下会干呕，什么也干不了。这段时间，感觉每首歌都在唱自己，每一首歌都那么地悲伤和感情充沛。也明白了，异地只是亲密关系的障碍之一，还是有很多其他问题需要解决和经营。我虽然一直以来能力和认知都提升了不少，但仍然不够。\n这里推荐几本书给大家，如果对好的亲密关系有向往的话：\n\n《欲望的演化：人类的择偶策略》 很多道理都十分符合直觉，作者把这些整合在一起，令每个人都受益匪浅，无论是男人，还是女人。 相见恨晚呀。这本书系统地讲解了人类求偶的心理和进化背景，令人醍醐灌顶。如果早日读过，之前的求偶和恋爱生活将会更加顺利。印象比较深刻的知识点是 随机性关系和长期性关系，男性女性的求偶需求，分手的方式和痛苦，如何构建长久的婚姻，婚外情、更换配偶、强奸的进化心理。涉及的方面之广，兼顾了各种人的需求和阶段。尤其是和自己之前的求偶、恋爱、分手经历相应和，解释了我许多困惑。之前虽然自己会无意识地实行部分书本中的策略，但直到读过此书后，才真正意识到背后的原理和普适性。看来确实很多性策略是刻在基因里的。建议自己以后常读常新，能够在理论的加持下，实现自己的人生理想：愿得一人心，白首不分离。\n《How to Not Die Alone 如何避免孤独终老》 作为畅销书，英文版门槛不高，比较容易读下来。全书从多个方便讲找对象的道理和具体方法，虽然以美国为主要研究对象和经验，但对其他地方，尤其是欧洲也是适用的。真是相见恨晚，如果能早点看这本书（虽然是21年才出版的），可以走不少弯路，也能少浪费些青春和感情。我Romanticizer，Maximizer，Hesitater 其实都有一些。Overthink也比较明显。明显是 Avoidant attached，不是Anxeity. Hitcher而不是Ditcher。还有寻找长期伴侣需要关注的那些特质，我不能再继续恋爱脑和过于同情心了。\n《Eight Dates 爱的八次约会》 就像书的副标题说的那样，这本书是为了教会大家怎么“创造一生的亲密关系”，尤其是通过和伴侣的对话和交流，对关键主题进行深入探讨。不是讲怎么找到伴侣，更多的是，找到后怎么更好地去经营这么一段关系。\n\n 生活\n今年生活在爱尔兰，工作相比国内轻松很多，有不少业余时间。再加上恢复了单身，节省了更多的时间和精力。（当然，独行快，众行远。虽然一个人可以快速成长，但长期看，还是得找个伴侣的长相厮守的）因此：\n这一年读了很多书，大概快50本。可以参考我的豆瓣。给每本书都写了短评，有些自己有很多思考的，还写了长的书评。\n后来为了保护眼睛，专门买了个Kindle。不同于之前被吐槽的压泡面神器，我觉得kindle还是今年买的最值得一个物件。主要是我从小本身就有阅读的习惯，上学得时候在图书馆借书，上班后用电脑看电子书。再加上微软也是每年有500欧的报销额度，鼓励大家学习、提升自己的知识和身体、包括心理，电子书阅读器也在列。\n这一年去了很多地方，见了很多朋友。\n我去年一来就办了荷兰签证，参考我办荷兰签证的经验。年初去荷兰，去看异地了4个月的ex。后来也自己办了英签，去了2次英国。去 谢菲尔德 看了读硕士的表弟，去剑桥和赖博、马哥吃了饭，参观了微软剑桥研究院 MSRC，去伦敦参观了谷歌（曾经的Dream company，谢谢 丁瑜同学 的款待）和 亚马逊办公室（谢谢 好哥 和 样哥 的招待），以及 UCL（谢谢 浩洋同学 的款待）。又写了 法签抢号机器人，帮自己和很多朋友抢到了法签。去了巴黎看了 高中同学 也是 高能物理的人才 聪聪，和 大强哥 吃了饭。去瑞典斯德哥尔摩看望 狮哥（虽然被鸽了），朝圣了诺贝尔奖博物馆。去希腊雅典面基了 雷哥 和 平头哥。去 马耳他 蹭了个学术会议，回忆了校园时期的青葱岁月。\n这一年也认识了很多新朋友，和他们交流聊天。\n他们来自不同的国家，不同的出身和阶层，不同的年龄和生活经历。谢谢他们提供给情绪价值、社交需求、各种有用的信息和实际的帮助。尤其是在我情绪的低谷和有需要时。\n通过这种亲身接触，也更明白了国际大公司，或者是所谓的“白左”宣扬的，Diversity 和 Inclusive的重要性和价值，不只是政治正确，而是确实是一种进步，对生产力和人类文明的推进。\n相比我一年前对“政治正确”的思考（去年底写了一篇博客），现在的认识更深和更进一步了。也进一步摆脱了之前的偏见和文化烙印了。\n我之前很早就认识到自己的问题，不是读书学习太少，而是思考少。也就是古人说的“学而不思则罔”。其实一直以来也有下意识地去改变。\n究其原因，也是大环境所然。从国内受教育出来的朋友应该有感受，尤其是从小城市出来的。这种应试教育从小就不鼓励独立思考，而是听老师和家长的话，长大后听老板和政府的话。最受人诟病的就是语文和其他文科教育了，主观题都有标准答案，按点给分。爱思考和自学的人，在这种环境下是被打压的，被迫接受填鸭和塑造。尤其是在教育资源落后的地方，老师的水平其实不高，很多大专毕业，本科毕业的就算是好的了。像 罗永浩 在他的演讲“我的奋斗”里讲的就很能引起我的共鸣。\n后来，我也明白了更根本的原因，为什么很难改变：历史和体制。压抑思考有利于统治者，虽然不利于整个社会和文明，和个人。\n中国历史渊源流长，上下四千年。\n先秦以前，分封制度，百家争鸣。思考和竞争很多。自秦以降，以统一的集权国家为主，内法外儒，以控制人民思想，为皇帝所用为主。因此不鼓励独立思考，而是鼓励顺从和接受被灌输的思想。自宋以来，更是出现理学这种极端的儒家思想，儒家从此真正一家独大，无可制约。\n后来，集权甚至演变成了极权。这种情况下，任何的思考和自学都成了反动，要付出极大的代价。\n“拨乱反正”后，虽然情况有些好转，但从根本上并未彻底解决问题。\n今年以来，因为环境的改变，我有了更多思考的自由，结合一直以来爱学习的习惯，效果惊人，有的时候自己都害怕。\n 2024年美好生活的向往\n其实每年的新年愿望都差不多，无非是工作，身体，心理 和 学习。\n 脱亚入欧，以后还要脱欧入美\n熟悉我的朋友，或者是看过我之前的年终总结和博客的网友们，可能也知道，我去年来欧洲最主要的原因是来陪读的。我去年来爱尔兰之前，从来没有想过要来爱尔兰，甚至没有考虑过这个国家。事实上，在爱尔兰认识了很多朋友后，惊奇地发现，爱尔兰就是这么一个默默无闻的神奇的小国家。都柏林外地人很多，但大家都是因为各种各样不同的奇怪原因，偶然间来到爱尔兰的。很少有人一开始，就把爱尔兰当作第一选择。比如 留学投递的学校，很多也是顺便投的爱尔兰，都是优先英国。我去年找工作也是，主要投的荷兰，顺便投的爱尔兰。大家之前对爱尔兰都不太了解，都是有了offer后，才开始深入了解的。我去年离家的时候，亲戚朋友们都不知道爱尔兰在哪，很多还以为还是英国的一部分呢。\n或许，正是这种信息差，导致爱尔兰其实是一个价值洼地。这边留学和工作的机会很多，但知道的人不多，竞争也没那么激烈。大多数人，无论是打算定居，还是把爱尔兰当跳板，都是冲着这些很好的留学和工作的机会来的。\n想了解更多从国内润到爱尔兰的经验的话，可以参考我 之前的博客: 从北京到都柏林 一名程序员的润欧之旅 和 播客 (国内的朋友也可以在小宇宙上听)\n因此上半年，和ex分手后，我在爱尔兰就很尴尬了。进退失据。没有去处，没有家。回国是肯定回不去了，也不好意思回去。当时出国的时候，家人也不那么同意，我也是一意孤行出来的。而且，我还有梦想没有实现，“两亩薄田一头牛，老婆孩子热炕头”的理想生活。显然是在发达国家更容易实现得多。国内近些年改革的方向，也是令我比较失望和担忧的。既然无法兼济天下，现在只能独善其身了。\n爱尔兰还是蛮适合生活的，尤其适合家庭生活（老婆孩子热炕头）。自然环境好，十分安静。虽然福利可能比北欧差些，但毕竟是福利国家，比美国、新加坡、香港、中国都要好不少。工作机会和薪资也很不错，尤其是作为IT员工。在欧洲算是顶流的了，除了伦敦和瑞士，其他地方都更差了。\n不过这里有些过于躺平了，有上进心的人还是更适合去美国发展。有点田忌赛马的意思。上等马都去美国了，爱尔兰都剩下中等马 或是 更青睐躺平的同学。因此，在爱尔兰工作生活都十分轻松，正好趁着这几年休息一下，多学习和思考，了解世界，更重要的是了解自己。\n我从18年到20年，就一直想去美国发展，包括后来20年确立来欧洲的目标后，也是想把欧洲当作跳板，最后还是要去美国的。但是当时这种“美国梦”都是基于比较原始、和朴素的理由。\n\n美国的薪资十分有吸引力。作为程序员，明显地超过其他国家，包括中、欧、日本、新加坡。大概是欧洲的2倍。爱尔兰薪资在欧洲已经算是高的了，但跟美国还是差很远。机会（包括 工作、教育、赚钱）众多，也就是所谓的“美国梦”。\n我认识的优秀的人，很多都去了美国。也有很多人都有着美国梦。正所谓英雄所见略同。\n美国文化的强势输出。电影，美剧是最明显的了。基本一家独大，而且质量的特别好。基本上全世界其他国家加起来也无法抗衡。不那么明显，但更重要的是读书出版业。我读书比较多。无论是计算机专业书籍，还是其他通识读物，基本都是美国产的，也是英文的。比较引人注意的是，其实很多作者也都是非美国出生，或移民二代。他们的美国梦故事更是激励着一代又一代人。比如 AI届的华裔移民二代女神 李飞飞 今年的新书：《The Worlds I See》\n\n今年以来，我有了更多的阅读、思考 和 交流。对“美国梦”有了进一步理解。其实，和之前的朴素理解是一脉相承的。但更加深入和内在。\n为什么美国薪资如此有吸引力，尤其是计算机行业？\n美国是计算机产业的源头和中心，有着悠久的历史优势，并在计算机产业的很多部分形成了垄断。信息技术又代表着当今世界的最先进生产力，大幅提高了效率和人类的生产力。因此，创造了很多价值。这些价值是有溢出的，因此 首先是美国的程序员薪资相比其他行业有很大优势，之后就是美国薪资相比其他国家和地区有优势。这些溢出是由近及远惠及的，你离它越近，获益就愈多。\n推荐本书给想了解更多的朋友：美国创新简史 – 科技如何助推经济增长.\n当今科技含量最多的行业，大概就是 计算机 和 生物医药 了。以后还有 航天（以星舰Starship为代表） 和 新能源（以可控核聚变技术为代表）。在这些领域，也都是美国暂时领先。这是现在和未来。\n事实上，之前的日美、欧美竞争，虽然贸易战打的火热，但最后分出胜负的还是通过科技产业的发展。比如 日本。当年汽车、半导体、电子，都打的美国和欧洲落花流水。人均GDP都超过欧美不少。但90年代后，美国的互联网，和10年后的移动互联网，日本都落下了，也是失去的30年的直接原因。同样落败的，还有欧洲。欧盟两千年初成立的时候，可谓潜力巨大，不仅西欧人均GDP超过美国，经济总量也是大于美国的。但经济危机后，一蹶不振，失去了15年。人均GDP被美国甩到后面，总量也被美国甩到后面，甚至都被中国短暂超过。欧洲从此沦为Europoor。在生物医药领域也是类似，但我并不在业内，因此不展开讲了。\n事实上，爱尔兰 发展的这么好，到现在人均GDP和人均收入都是世界前5，很大程度上也是接受了美国的价值溢出。支撑这么高的人均收入，靠的也是外资，尤其是美资。支柱产业也是 IT 和 医药。而且爱尔兰体量很小，只有5百万人，美国吃肉，随便给爱尔兰喝点汤就能吃饱。爱尔兰 可以接收美国这么多溢出，有很多原因。最关键的还是，因为历史原因，爱尔兰人有大量移民去了美国。正所谓，世界上爱尔兰人最多的国家不是爱尔兰，而是美国。这种血缘和文化上的亲近，就方便了资本的青睐。\n更长远，更宏观，和更深层的视角和理解可以参考书籍 全球通史: 从史前史到21世纪 和 我的书评. TLDR：科学技术是第一生产力，自由主义是对科学技术发展的  保障，民主制度是对自由的保障。\n由于人性的贪婪，随着时间的推移，分配不公是必然的。虽然可以减缓，但没法消除，是人类的本性。在资源有限的情况下，财富会不断集中，最后造成社会不稳定和崩溃。也是王朝周期律的根本原因。只有通过发展，把蛋糕做大，才能解决和缓解社会矛盾。幸运的是，现代化的人类文明已经找到了正确的路径和方法。回顾过去10年，20年，50年，100年，200年，科技现在是发展越来越快的，指数型发展。\n这本书其实也是解释美国科技领先的更深层次的原因。受欧洲启蒙运动影响的宪法先贤们在新世界，创立了一种新的政治制度。这制度别说放在两百多年前，就是当今也是十分先进的。对美国制度和相关历史感兴趣的朋友，推荐 林达 的 “近距离看美国”系列丛书，《历史深处的忧虑》，《总统是靠不住的》，《我也有一个梦想》，《如彗星划过夜空》. 作者是一位中国人，经历过文革，后来定居美国。因此也是从中国视角来理解和学习美国，书中用了很多例子，而且是以给朋友写信的方式呈现。就像给你讲故事一样，十分容易读。\n这也就是中国为什么要追求产业升级，才能迈过中等收入陷阱，努力成为发达国家的原因。当然，中国在产业升级上有很多阻碍和难度，这里就留给读者们自己思考了。\n结合上面的“溢价理论”，我总结出了自己的“摸鱼理论”。\n今年11月，OpenAI 上演董事会驱除 CEO奥特曼 的大戏，中间又有大股东微软高薪收编奥特曼，最后以CEO在员工的支持下回归，旧董事会解散结束。真个过程跌宕起伏，持续快一周，让科技圈的吃瓜群众直呼精彩程度堪比网飞剧集“硅谷”。\n由于微软参与其中，是其中的重要角色。股票也是随之上下波动，最后以大涨收尾。因为微软加强了对OpenAI的影响力，特别是对其中的员工。\n虽然OpenAI 是去年底发布的ChatGPT 3.5, 但AI 发展的影响一直持续到今年。微软也由于在此领域取得先筹，意外领先之前一直领跑的谷歌，股价今年的走势十分亮眼（全年56%，跑赢SP500 的25%，但和Nasdaq-100 55%差不多，谷歌其实也不差）。当然更亮眼的是，卖铲子的 英伟达（今年涨了244%）。\n相反，今年另外一件大事是 10月底开始的 以色列与加沙的战争。以色列也有很多科技产业，包括微软有2千员工。整个办公室基本停摆了半个月，后来生产也才慢慢恢复。总的来说，有近1个月的生产损失。我的部门也在其中。但我意外的发现，几千个人不工作，对公司竟然没啥影响。股价也没啥影响。无论是我个人摸鱼，甚至消失上半年，对部门或许有些影响，但不大，对公司其实没啥影响，对全世界更无区别了。\n小到公司发展，大到人类文明，其实都是少数优秀的人在推动。比如，在学术领域，大多数论文是在灌水，在某些关键论文出来后，证明成功或正确后，很多之前的论文就变成了垃圾。当然，只有回头看，才知道是哪些人，哪些技术会成功。在当时，是不知道的。因此，很多人去努力探寻，尝试也是十分必要的。因此，规模效应，养很多人是有用的。因为为了获得那1%的突破，必须从100%的人的工作中去胜出。类似，达尔文的进化论，之所以要维持生物和种群的多样性，是因为无法预测环境变化。即使可以预测环境变化，也很难人为地正确地选择出来个体。只能让事实和时间说话，看看谁存活了下来。人类基因组溯源也发现，确实是存在亚当和夏娃的，当年其他个体的基因很多都消亡了。（这也从一个角度解释，为什么计划经济不行，完败于市场经济）。\n但对于个体而言，虽然不知道你是不是那1%，但从概率学上来说大概率是不是的。因此，个体其实没啥努力的必要，只需要可以蹭到别人的溢出就可。你生而为人，就已经享受到了大量人类文明的溢价，相比动物而言。你生在现代，就享受到了大量工业文明的溢价，相比我们茹毛饮血的狩猎采集的祖先，或是农业文明的前辈，看看人均寿命和人均能源消耗。你生在发达国家，就会更加明显，机会多，工作轻松，赚的还多。\n当然，个体也不是什么也不做。因为出生是我们没法改变的，但还是有不少后天因素可以自己掌握的。平台和大环境对个人成功来讲十分重要，选择比努力更重要。比如 移民就是可以做的选择之一。\n至于如何做出更好的选择，就需要提高自己的认知、眼界、消除偏见、阶级和家庭局限性。我的方法其实也很简单：\n读万卷书，行万里路，和一万个人聊天。\n读万卷书可以消除时间上的差异，行万里路可以消除空间上的差异，和一万个人聊天可以消除人生阶层和生活阅历上的差异。\n更具体地，可以参考我对今年诺兰的新电影《奥本海默》的影评。\n你也得有能力蹭到溢出价值，比如 移民，进大公司摸鱼，和优秀的人一起共事，都还是稍微有些门槛的。\n这就是为什么要移民到发达国家，尤其是去美国，去美国科技产业聚集的地区，为自己，也为子孙后代可以自己不用努力，蹭到更多优秀的人和科技发展的溢出。肉身去蹭溢价，其实还是稍微有些挑战、折腾和麻烦的。另一种更方便快捷的方法，就是直接买股票。尤其是美股市场十分开放，每个人都可以享受到科技发展带来的好处。不像A股市场，都是用来集资和割韭菜的。正所谓“相信国运，定投纳指”。美股体验也十分友好，长牛短熊，经历了长期的考验。今年尤其如此，大盘标普500涨了25%，收复去年失地，又创新高。\n买股票需要开通券商账户（Broker），欧洲的朋友推荐 Trade Republic，欧元买卖。现金也有4%的利息，比放在银行好。而且是放在德国的Citibank，有10万欧元的存款保险。另外一个更强大，功能更多，股票市场更多，全球大多数国家都能用的推荐是 IBKR，也是大多高手的选择, 但它操作门槛稍高，特别适合进阶用户。我基本只买大盘指数ETF （标普500 和 纳斯达克100）, 而且长期持有，也是 财务自由运动 FIRE (Finacial Independent, Retire Early) 的推荐。长期持有很考验心态，需要你对所投资的标的有信仰，才能在股市的波动中一直拿住，坚持定投。比如 投资美股大盘标普500，就要对美国有信仰；买Nasdaq 100，就要对科技有信仰。对财务自由感兴趣的朋友，可以参考《Early Retirement Extreme: A Philosophical and Practical Guide to Financial Independence》.\n可以发现，无论是对美国，还是对人类文明，科学技术都是最重要的推动力。我们现在生活在工业文明，是何其幸运。生活质量如此之高。现在人类群星如此闪耀。现在就是历史上最好的时代，以后还会越来越好。如果信心不足，可以看看 茨威格 的《人类群星闪耀时》。算是我“摸鱼理论”中的成功学书籍了。\n这种思维也和我过去27年的思想不同。因此，今年也是我摆脱“小镇做题家”身份和思维的元年。不再去无脑刷题，在有限的一亩三分地上精耕细作，去内卷了。而是发现更多更大的世界，摸鱼去学习，去提升自己，而不是努力工作。这样效率和结果反而更好。也就是用战略上的勤奋，来取代战术上的努力。也是可以不“努力”就取得成功的一条路。\n 工作\n结合上面的思考，长期大方向是不变的，先在爱尔兰苟着拿身份，再去美国发展。\n因为美国身份风险比较高，失业的话，有不得不离开的可能。\nL1B 与雇主绑定，没法跳槽。H1B需要抽签，有抽不中的风险。美国排绿卡是按照出生地排的，中国人现在要可能10年。\n移民在外，身份是十分重要的，很多时候比赚钱更重要。而爱尔兰身份十分容易和友好，也挺强大的。因此可以当作一个不错的退路和托底。如果将来有了E-3签证，那更是可以十分方便地去美国工作了。\n明年，要么可以换回原来的组，回到rest &amp; vest的快乐生活。如果换不回去，等到9月份拿永居就直接换公司了。大家给犹太老板打工还是要当心，比华人还卷。\n另外，虽然之前也有耳闻，但今年接触更多的一个领域是“量化”，Quant Dev, 属于著名的高薪赛道。认识了其中不少优秀的同学，真是让人看着眼红呀。明年，会多了解些，看看自己有没有机会分一杯羹。\n 身体\n今年算是我的健身元年。以前在国内的时候，虽然办过健身卡，也尝试过健身，但因为时间和经历的原因，并没有坚持下去。今年从3月份开始，因为公司办公室有健身房和各种免费的课程，十分方便，总算养成了带薪健身的习惯。\n身体确实好了很多，精力更旺盛了，心情也好了很多。各个肌群也有了轮廓，胸背，6块腹肌，臀腿。\n其实回过头来看，我的很多习惯和技能成就，都是靠摸鱼达成的。有些理解 刘慈欣 了。\n习惯一旦养成，坚持下去就很容易了。新的一年，包括以后的人生，健身都是我的长期习惯了。关于习惯，推荐大家一本书，《Atomic Habits》, 从原理和方法出发，摒弃坏习惯，培养好习惯。我本身是ISFJ人格，J型属于比较有规划，有行动力的人。因此，对我来说，培养习惯反而不难，而且很适合我。\n 生活\n既然已经决定了给爱尔兰一个机会，就要认真对待了。\n今年买了一辆二手丰田卡罗拉，算是人生第一辆车了。\n明年\n\n考到爱尔兰驾照。\n买个公寓。都柏林这边租房太贵了，租售比不错。自出或投资都划算。\n申请下来美签 B1/B2 旅游，去美国旅游看一看。上周去美国大使馆美签面试，不出意料地被check了（221g Administrative Processing），没有辜负母校的厚望（德才兼备，知行合一）。敏感学校+敏感专业。希望明年check能过，不过据说也只能最多给1年了。\n\n 后记\n生而为人，我很幸运。\n希望大家都能在新的一年里，平平安安，健健康康，快快乐乐。实现自己的愿望和梦想。\n","categories":["dairy"],"tags":["life","年终总结"]},{"title":"2024年终总结 与 2025新年展望","url":"/2024/12/28/2024-summary-and-2025-resolutions/","content":"转自我的博客\n往年的年终总结：\n\n2023年终总结\n2022年终总结\n2021年终总结\n2020年终总结\n2019年终总结\n2019年中总结(生日随想)\n2018年终总结\n2017新年展望\n\n里程碑回顾:\n\n硕士3年复盘\n大学4年复盘\n\n这些重要的博文都放在我博客的dairy分类下。\n 十年编程经验\n此处BGM应为，叶圣涛的“还有多少个十年&quot;,唱尽了多少人生的感悟。\n14年，18岁的我，离开家乡，前往北京读书。当时的那个少年，对前途一无所知。从此颠沛流离。这10年间，无论是我自己，还是这个世界，都发生了天翻地覆的变化。\n从“沙河镇”到“知春路”到“十里堡”，从“昌平”到“海淀”又到“朝阳”，从“北京”又到了“都柏林”。经历了许多的光荣和梦想，烦恼和心碎。走过了万里路，读遍了万卷书，也认识了许多不一样的人。从小镇做题家，成长为打工人。幸运的选择了计算机这个充满科技红利的专业，见证了 移动互联网的崛起和饱和，AI 的方兴未艾，全球化的鼎盛和倒退，和平和冲突，人类科技的不断进步。标普500 从1900点涨到6000点。\n当年“计算机”也算是热门专业，但绝对没有如今的TOP1的地位。当年北航计算机本科学科排名据说是第4. 上大学起，我才正式写下第一行代码。同时开始学习C语言和Python，对于新手来说，同时2门语言意味着傻傻分不清楚，花括号&#123;和换行，printf 和 print，编译 与 解释，静态 和 动态。当年Python甚至还有2,3。好多概念也是日后慢慢才搞清楚的，直到现在如数家珍。后来陆续学了 C++,Java,GoLang,TypeScript,C# 都作为一时的主力语言，根据兴趣，也学过 Lisp,Rust 等小众语言。大二大三，正式有了感觉。那2年自己折腾和自学了很多，也有学校硬核课程的帮助。大四开始实习，正式接触业界。之前总结的 大学4年复盘，硕士3年复盘。不得不说，读硕士真是浪费时间。也就是国内太卷，找份好工作都要研究生。毕业就25岁了。到了海外后，基本都是本科就出来工作的，早早进入业界，早早升职加薪。现在又全职工作了3年多，加上之前实习，也算体验和经历了6家公司了. 回头看看，这么多年，很多东西浅尝辄止，简历也十分花里胡哨和充实。\n真是如金庸所言，独孤求败 一开始“青光利剑，过刚则折”，之后&quot;紫薇软剑，灵活变通&quot;, 中年“重剑无锋，大巧不工。”, 最后&quot;草木之剑，返璞归真&quot;，花草树木，皆可为剑。达到最高境界。程序员也是如此。\n还有一首歌，我也很喜欢。“你曾是少年”是电影《少年班》的主题曲。其中的每句歌词，真是都唱出了我的心声，曾经的浪漫主义和理想主义，到如今的现实主义、怀念和憧憬。历史的车轮滚滚向前，命运推着我走过不可想象的路，前往未知的道路。虽然我每年都会做新年展望，但一旦拉长到10年的尺度，人生就无法预测，更不能设限。我现在的生活是10年前无法想象的，而现在的我，也无法想象10年后的生活。人往往高估自己和世界短期的进步，但低估长期的进步。这就是指数增长的可怕之处。希望自己永远是少年！继续保持对世界的好奇心和善良乐观。\n 2024年个人回顾\n今年又是按部就班的一年，像往年一样。J人属性拉满。\n虽然没有石破天惊和惊心动魄，基本一直呆在舒适圈里，但现在内心已经十分强大，可以做到心安理得地呆在舒适圈:) 不求走的快，只求走的远。\n其实也是近年来学习到的知识使得内心更强大，正所谓知识就是力量。站在巨人的肩膀上。\n郝旭烈 的 “做的舒服才能做的久，做的久才能做的好”。相信 巴菲特 和 芒格 倡导的“时间的复利”，和 罗振宇 一起“做时间的朋友”。\n 买房\n按去年的新年愿望，今年成功在爱尔兰买房了。\n本身不是非要买房不可，我也不是觉得是刚需。\n按照《持续买进》中的数据，从投资角度看，买房并不是好的选择。当然这是数据上的分析，因为房产增值和地区和年代关系很大，另外因为流动性差的原因，反而容易拿的久，获得还可以的投资收益。但从回测分析，买SP500其实比房产更强。不过，买房有很多其他精神和社会上的好处，比如稳定的生活。\n我也并不是打算在爱尔兰呆很多年，稳定的生活其实也需求也不大，以后还想想去天花板更高的美国发展。\n不过按照 彼得林奇 的观点，从投资心态上来讲，年轻人推荐先买房，再买股票投资。因为买房要准备头款，而股票投资是推荐用常年（5年，10年，甚至永远）不用的钱做的。买房后，头款已经花了，只每月换月供，相对确定性更高，钱的规划会更容易。否则，你也不确定准备多少钱，未来买房。\n买房贷款是一种相对安全的杠杆，对资产的放大作用明显。尤其是第一套房的时候，银行和政府一般都会有不少优惠政策可以利用。如 爱尔兰，贷款最多年基本工资的4倍，头款10%，因此 最大是9倍杠杆。\n然而，我买房的最大动力还是因为 都柏林 变态的租金，由于租售比偏高，买房反而比租房更划算。房贷低租金不少。另外，虽然都柏林房价已经涨了十年，但相比收入和经济增长不像国内那么变态，再加上，作为美企大厂程序员的收入溢价，还是蛮容易上车的。\n买房比租房麻烦很多，需要贷款，看房，竞价（最后还是买了新房，一口价。不需要像二手房那样变态竞价），联系律师。\n交房后，又是装修，还有暖房。我本身也不是十分勤快的人，后花园（Terranced house) 甚至一直是野草旺盛，不想收拾。\n生活质量感觉提升了不少，也享受了5个月的自由，没有了合租舍友。不过仍有些孤单，以后考虑也找寻些租客。\n最重要的经验就是，买房最重要的是位置，其他都是次要。\n爱尔兰 实现 中国梦 的难度是真的低。之前在北京生活了8年，也是“墙板砸烂，头款也凑不齐”，感叹“安得广厦千万间，大庇天下寒士俱欢颜”。\n 读万卷书\n今年读了差不多25本书: 读后感列表\n特别推荐的有：\n\n纳瓦尔宝典 财富与幸福，人生智慧的集合\n埃隆·马斯克传\nJust Keep Buying 持续买进\n历代经济变革得失\n枪炮、病菌与钢铁\n\n如果像我一样，对科学十分比较感兴趣:\n\n现实不似你所见 量子引力之旅\nA Little History of Science\n迷人的温度 温度计里的人类、地球和宇宙史\n深奥的简洁 从混沌、复杂到地球生命的起源\n\n也经常有朋友让我推荐些投资理财的书，我一般推荐:\n金钱心理学，持续买进，小乌龟投资智慧，战胜华尔街，邻家的百万富翁。\n看完这些，其实就是为了明白几件事情。1. 安全边际。投资要用长期不用的钱，5年以上。手头要留半年到3年的生活费（现金等价物），具体多长取决于年龄，家庭状况，工作。2. 股票大幅强于房产，债券，黄金，等其他标的。3. 被动指数基金大幅强于个股和主动基金。4. 直接梭哈强于定投和择时。5. 只买不卖，强于择时。6. 美国和美股强于其他国家。7. 投资最难的是心理，追涨杀跌，感性短视要克服。\n总有人说 “悲观者正确，乐观者前行。”。但读多了历史和科学，我认为，“乐观者正确且前行”。\n 行万里路\n今年只出了3趟门，一次去 爱尔兰 Wexford, 看呆萌的Puffin鸟。\n 英国 瑞士\n一次去英国（苏格兰高地自驾游）和 瑞士（苏黎世，Interlaken, 少女峰，卢塞恩，Rigi峰）。\n从 都柏林 去 爱丁堡 坐了 ART72 螺旋浆飞机。第一次坐非 波音 空客 的飞机，十分紧张。\n遇到爱丁堡国际艺术节到处是卖艺的，各种表演和“奇怪”的人。people mountain people sea。\n苏格兰高地自驾游路线真是名不虚传，山路开车体验十分不错，一路山光水色。\n“让”的三角路牌上，爱尔兰是写YIELD，英国是GIVE WAY，瑞士是空白。\n再次感叹伦敦人杰地灵，TOP人才浓度大概是欧洲最高了。参观了 TikTok，CAMEL AI，Bloomberg，Amazon 的办公室和朋友。TikTok的饭是我在欧洲吃过最好的食堂了，甚至比谷歌还好。\n体验了 从 伦敦 到 巴黎 的Eurostar，“一地两检”, 通过英吉利海峡隧道，确实方便。不过价格和飞机相比没有竞争力，主要优势在于方便。毕竟火车站一般都在市里，飞机场在郊区。\n恰好错过巴黎奥运会，不过巴黎城市建设确实有很大进步，多了很多自行车道。道路上homeless和闲杂人等也少了很多。巴黎适合穷人，生活舒适，社会福利好。也适合华人，中餐甚至比伦敦还好，也更便宜。伦敦适合精英，机会多。\n也体验了从 巴黎 到 苏黎世 的欧洲高铁，是我在海外做过最好的火车了。速度和舒适度不输中国高铁, 还有WIFI。\n瑞士真是太适合J人了。公共交通发达，准时，密度高，频次大，火车、船、巴士、Tram联动。本次玩了中部 Interlaken 的 图恩湖, 格林德瓦 的First山，是韩剧“爱的迫降”的取景地。流量真大，吸引了太多韩国人来。北部的 卢塞恩湖，Rigi山。真是“日出江花红胜火，春来江水绿如蓝。”。幸亏先去了苏格兰，后来的瑞士，要不然会落差很大。可惜没机会参观谷歌的苏黎世办公室。最重要的，参观了曾经的梦校ETH，尤其是爱因斯坦上学用的柜子，也算是完成了朝圣。下次有机会再去南部的，阿尔卑斯山区。\n 美国\n此处BGM应为，德沃夏克 的 “自新世界”。上次听这首曲子还是在大一时的“西方音乐鉴赏”选修课。当时知识还不够，不是特别理解此中的表达。如今，在美国的土地上，一遍遍听这个曲子，才更好地体会到其中对新大陆地热爱和赞颂。虽然已经是19世纪末创作的音乐，现在的美国年龄已经翻了一倍，26年就是250年庆典了。\n和旧大陆不同，新大陆是非民族国家，通过共识建立。类似BTC，所有的价值都在于人和人之间的共识。而不是三权分立的制度和成文宪法。很多照搬三权分立的国家，也照样陷入独裁。\n需要强调的是 这一共识是“自由”而非“民主”。\n一次去了美国，逛了东北部的几个大城市 纽约，华盛顿，费城，波士顿。同为发达国家，美国确实比欧洲更发达的多。基础建设很多，路上车水马龙，车也很大，都是SUV起步。欧洲流行的小轿车在美国很少，Europoor果然名不虚传。美国开车还是野，比国内更甚。好多车门，车头，车尾都撞烂的车，还在路上跑。爱尔兰开车大家一般都很谦逊，车道也很窄，以单车道为主，基建比中美差不少。\n比较有趣的是，我去的很多州，车牌都只强制后车牌，前车牌很多人都不挂。转向灯有不少车是红色的，和示廓灯和刹车灯不是很容易区别开。不知道为什么不像其他地方强制黄色的，辨识度更高。\n自由女神像 真是大IP。堪比巴黎埃菲尔铁塔，而且确实也是由埃菲尔建造的。X战警在上面打过架，红警里盟军第一关谭雅也见证了其毁坏。所有涉及美国19，20世纪初期欧洲移民的影视，也都拍出了，新移民从海上坐船进港，见到自由女神像的经典场景，比如 海上钢琴师，教父，泰坦尼克号。当然还有蜘蛛侠，游戏也算是纽约旅游模拟器。\n深入理解了曼哈顿距离。之前在北京的时候，因为规划原因，已经感觉比较规正了，道路都是正南正北，正东正西的。曼哈顿才是严格按照长方形规划，类似唐朝的长安城，坊市都是块。也深入理解LeetCode里，城市Skyline的那些问题了。\n也去百老汇看了火爆的“汉密尔顿”音乐剧，也是名不虚传。用Rapper唱国父的故事，演员大多是黑人，音乐天赋十分契合。主要国父都是黑人演员，也是见证了美国的包容，政治正确，毫无违和感。\n去华尔街摸牛，为A股祈福[偷笑], 在纽交所前看看美股，当时SP500都快5800点了。\n参观了世贸，有些像北京的国贸。装修都很好，店也属于高端大气上档次的。当然还有911纪念馆，从中和其他历史的很多发展，都可以看出911对美国和世界的深刻影响和改变。\n纽约有些地铁站设计比较坑，花钱进站了才发现要做反方向的车，但换方向要出战。这种情况，如果坐过站了，也得出站才能坐回来。\n还逛了世界上最大的唐人街曼哈顿下城，地理位置很不错，名不虚传。怪不得唐人街探案 第二部就选扭腰。历史悠久，规模很大，还有不少前朝遗老。\n还有法拉盛的新唐人街，更夸张。在别的地方见到的唐人街，都是中外双文。法拉盛的唐人街，只有中文。\nEU现在和CN一个待遇，Apple Intelligent不能用。到了美国就行了。EU 现在真是太拉了，别的不行，搞监管和立法世界第一，创新和经济发展阻碍成这样子。\n华盛顿特区 才是十分震撼。如果纽约是资本主义的象征，华盛顿就是美国宪法的象征。林肯纪念堂，华盛顿纪念碑，国会山，最高法院，白宫。之前很多书本里读到的历史，和现实联动了起来。\n比如 长者 引用的“Of the people, by the people, for the people”。\n国会山也有很亲民的免费参观导游，进参众两院接受教育（当然是和办公区有些区隔，但也只是一道简单的线，议员走里面，观众走外面），普及立国制度和历史，告诉观众公民的权力和政府的权力。\n当然美国也有很多缺点啦。而且很多其实都是优缺点一体两面，是双刃剑。比如 比较极端的自由主义。虽然自从大萧条以后，自由主义有所衰败，但仍是发达国家中最自由的国家。这带来了经济的增长，人才的汇集，创新的发生，但也有社会保障相对较差，贫富差距大，枪支暴力多。\n我个人还是更推崇自由主义的，后面再细说。\n 身份\n来爱尔兰2年了，也拿到永居（Stamp 4）了。爱尔兰可以说是移民和身份十分友好的国家了，还没见过其它国家有如此友好的条件。可能也和缺人有关。\n办工签的列表中，屠宰工人（畜牧业发达），医院，IT，会计都是名列前茅的职业。\n从国籍来说，印度人最多，占1/4，其次 巴西，印度，土耳其，埃及 也很多人。中国人是算在Other（5%）里的，不算是华人热门的移民目的地。在爱华人也不多。华人还是喜欢去传统的老牌帝国主义，美国，加/澳，英国法国。\n爱岛每年发2-4万张工签，对于人口5百万的国家也算不少了。除此之外，还有大量英国，欧盟的人来打工，他们不需要工签。虽然流入很大，但流出也很大，基本都是呆几年就走，作为一个跳板的存在。因为这边工作机会很好，跨国大企业不少。不少欧洲人镀个金就走了。\n至于第三世界的人，很多人也是拿个身份就走。在程序员这个群体里，很多人是有美国梦的，已经/正在/将要去美国打工。美国身份虽然难拿，但主要是针对中印这2个人口大国，其他国家的人还是蛮快的。\n爱尔兰虽然有主题民族，爱尔兰人（凯尔特人，盖尔人），还是一个蛮古老的民族，从欧洲大陆迁移而来。其他地方（比如 欧陆，不列颠岛）的盖尔人，早就被新的民族（如 拉丁人，盎格鲁撒克逊，日耳曼人）所取代，现在仅剩爱尔兰和苏格兰还有。历史上也经历了很多磨难，好不容易幸存到现在。这也是一个生物进化很自然的过程，很多其他洲也存在类似的民族取代。比较 有名的是 日本北海道的阿努人，太平洋夹缝中生存的南岛人，北美的印第安人。爱尔兰人还算幸运，在边缘地带苟活下来，近2百年又主动和被动地开枝散叶，现在海外有7千万爱尔兰后裔了（如拜登）。相比之下，本土只有7百万人（加上北爱），其中还有15%的外国人，尤其是在都柏林，有一半都是外国人。外国人也主要生活在城市里。爱尔兰近数十年的经济快速增长也是离不开移民的一分功劳。类似北上广深基本一多半都是外地人一样。\n出来打工，身份其实是最重要的。主要是自由和抗风险。\n 自由主义，保守主义\n今年办了YouTube Premium，听了 罗振宇 罗辑思维 4季节目，可能有200小时吧。罗胖总结他人知识，输出观点可谓熟练和精彩。自由主义 和 保守主义 是他所拥趸的。尤其是，这期83 他真的拯救了美国?，直接批判 罗斯福新政 和 凯恩斯主义，为 胡佛 部分翻案，为自由主义市场经济完全翻案。\n还有，读了 纳西姆 的《反脆弱》，当然有很多观点，自由主义也是他所宣扬的。\n从小长在社会主义国家，Party管一切。政府作为大家长，对每个人的照顾和管束可谓无微不至。虽然现在相比毛主席时代，已经放松了很多，但仍然不少。虽然自己没有经历过之前的时代，体会不到计划生育，大跃进，WG，但疫情三年基本全部呆在国内，“享受”了十分的不自由。\n当然，不少同胞是愿意用自由交换安全的。但人各有志，用脚投票吧。\n结合之前读的 吴秀波 的《历代经济变革得失》，自由也是经济发展的前提。正所谓“一抓就死，一放就活，一活就乱”。\n爱尔兰 其实蛮自由的，但税收高是一项很大的缺点。对于很多有上进心人才来说，很多还是去了收入更高，税收更低的地区（如 美国，中东，新加坡，瑞士）。当然，按照“无知之幕”的理论，福利社会也是优点吧。如果开局不知道自己的出厂配置，肯定更喜欢福利国家。\n 世界局势\n爱尔兰共和国 政治制度继承英国，也就是 议会制。今年底也大选了，中间偏右的统一党和共和党继续组成联合政府。相比世界其他国家，政局还算是十分平稳。当然，最大的原因应属经济一直平稳发展，每个人都能收益，因此矛盾没有那么尖锐。\n今年夏天，我也近距离观察和参与了爱尔兰的地方选举和投票活动，有意培养一下自己的公民意识。5年一度的当地理事会Local Council 的代表选举，类似县人大代表。只要有地址和税号就行，不需要公民身份。同时投票的还有欧盟议会，这个就需要欧盟公民身份了。我上次投票还是很多年前给海淀区的人大代表投票。当然，地方理事会的权力很小，平时也就是决定当地的税收资金（主要是房产税归地方）怎么用，比如建学校，图书馆 这些民生小事儿。\n马路边路灯上的到处挂着竞选人宣传头像；邮箱里也收到很多竞选宣传单；区投票地点Polling station，是一个小学；选票，按照支持的程度，填1，2，3… 即可，可以都填，也可以在任意数字停下。投票的过程是，首先提前一个月会开始造势，路灯上会挂上竞选人头像，邮箱里会收到竞选宣传单。选民也要先线上或线下注册，获得选举资格，会收到选举卡，上面有分配的号码。选举日的7-20点，选民到所在区的投票站，出示身份证件和选举卡或只报上面的号码就行，工作人员会在注册单上找到你的名字，划掉，给你张选票，用机器打孔，以示是发出的选票。然后有个填票区，有隔板互相挡着，用那里提供的铅笔填上数字。最后把选票投到票箱里就好。\n对所谓的民主，有几点感受：\n\n被选举权比选举权更重要。被选举人有各种党派，和不少独立候选人。被选举人的资格认证十分简单，不需要被审查或审批。进行差额选举而非等额选举。\n法制保障自由，民主依赖自由。不得不说，社会主义核心价值观遥遥领先。\n公民社会有赖传统和传承，需要培养，教育和维护。这是法制，民主，自由的基础。就像 利比里亚 和 海地 照搬了美国的制度，但只有表，没有里，一样发展不好。公民的民主和权利意识，要比简单的民主过程重要得多。\n\n世界很多国家和地区今年也都进行了大选。英国左转，其他国家右转。当然大家关注的最多的还是 美国大选，川普“三权合一”。当然，我对美国的权力制衡还是蛮有信心的。历史上，华盛顿 最有称帝的威望。罗斯福 也是大幅拓展联邦政府权力，“三权合一”，甚至突破2次的任期默契，连任到死。我最近也是在读罗胖推荐的《光荣与梦想》，讲的就是32年之后的美国总统史。美国的制度韧性还是很强的。罗斯福 的威望空前，民意汹涌。有些民众甚至愿意为了他烧掉掣肘的国会（当然没有执行，不像21年国会山叛乱）。后来，改选后，参众两院也被民主党把持，最高法院还是否定了很多法案。到最后，最高法院也被民主党把控，已经很多年过去了。但仍有民主党内部的限制和州权的制约。罗斯福 一去世，国会也很快通过宪法修正案，明文规定总统的任期限制。这一法案，也意味着川普2.0已经是最后一个任期了。论民主，比如在经济学人的民主指数里，美国排名并不靠前。但论自由和权力制衡，美国可算是名列前茅。\n欧洲人可能也会关注一下年中的，欧盟议会选举，右翼当选不少席位。\n除此之外，战争和冲突也在延续。\n俄乌战争第三年了，继续焦灼。不过听说川普上台后要要求乌克兰和俄国媾和。\n巴以冲突也第二年头了, 哈马斯被干没了，黎巴嫩真主党和伊朗也遭到了报复。巴勒斯坦确实是惨，现在的国际秩序可谓崩坏，拳头比讲理有用。以色列也是抓住这一机会，大打出手。大家都自顾不暇，欧洲也都停留在口头支持上。之前对乌克兰，就是再现了二战前的经典，绥靖政策。\n叙利亚 的 阿萨德 也顷刻倒台，反政府军直接是传檄而定，大概是抓住了好时机。国内外环境都十分有利。国外，支持 阿萨德 的 俄国，深陷战争泥潭；伊朗 和 黎巴嫩真主党被以色列报复地自顾不暇。国内，50年的 阿萨德 父子统治，也已经是不得人心，经济上也一直无法恢复。新政府如何被建立，如何重建和恢复叙利亚，也只能明年拭目以待。\n韩国 年底上演了 总统 戒严，派军队取缔国会 的俄国剧本。大韩民国民主化30年来，确实民主深入人心，这剧本果然结局不一样。军队保卫国会，但允许议员进去，议员投票废除戒严令，军队撤退。总统 6个小时后也宣布取消名存实亡的戒严了。最新的进展是，总统已经被弹劾停职，等待最高法院裁决。估计最后难逃坐牢的命运。\n不过，我关注新闻，其实并没有什么用，只是出于兴趣。我对未来还是十分乐观的，对人类文明的信心空前。从历史上来看，现在世界的动荡其实并不算特别突出，甚至可以算是相对很好的年代了。堪比欧洲1848年到1914年的黄金时代，以和平为主，经济发展，科技不断突破，人民生活水平也提高不少。都以指数形式发展，根据复利的原理，势不可挡。AI 的如火如荼，SpaceX的星舰也激动人心。人类发展到现在，按照卡尔达肖夫指数，已经是一个0.7级文明了。我对以后继续发展成1级，2级，3级都是蛮乐观的。\n刘慈欣 虽然说，“给岁月以文明，而不是给文明以岁月”。但作为人类文明的一分子，我还是希望能给文明以多些岁月。(想起，今年网飞也出了“三体”新剧，我写了一些观后感：网飞三体有感：质疑程心，理解程心，成为程心)\n 投资\n和去年一样，今年也是遍地股神。光大盘就涨了26%，多次历史新高，已经到6000点了。\n年初读了 艾萨克森 的埃隆·马斯克传，确实激动人心。买了10股TSLA，成本价190，最低跌到160，最后涨到260卖了。也算是卖飞了，没一个月，美国大选后，TSLA一飞冲天，最高涨到460，现在也有430. 波动很大，没有盲目的信仰，果然是拿不住，没有暴富的命。买入的也少，基本是玩一玩的心态。\n今年继续按照《持续买进》的建议，梭哈标普500. 大盘指数的信仰相对好建立，尤其是我对历史和科技比较感兴趣，因此，也是对人类文明十分有信心。标普500 背后的根本增长动力还是人类生产力的加速提高和经济的长期复利发展。\nCN 也有924行情。网友们戏称，从ICU直接打强心剂，到夜店蹦迪。和很多人一样，我也是趁此政策短牛，把A股和中概股都分批清完了。中概股指数 甚至陆续买了3年，都回本了。当然，算上时间成本还是蛮亏的。当年同期买的标普和纳指都涨了70%了。A股也是买了沪深300和某些行业指数，本身本金其实不多。也小亏出货了，再也不玩缅A了。\n非自由市场经济，还是别碰为好。让别人玩吧。相信国运，珍爱身心健康。\n当年出国的时候，1欧元等于6.8人民币。现在 1 EUR = 7.8 CNY，也是后悔22年没多换点汇。当时也没有很周全的未来安排，很多事情不确定，风险蛮高的。\n直到去年，才慢慢规划好未来近几年的人生。有了买房买车等想法，也近几年不打算回国发展了。\n 2025年憧憬\n回家。来爱岛2年了，都没有回家，各种原因吧，总是拖着。当年出来的时候，还是三年大疫情封控期间，就做好了多年不回的准备。结果形式变化太快，走在了黎明前最黑暗的时候\n也办了入台证，打算顺便去宝岛台湾省看看。正好去参加一个在爱尔兰的台湾朋友的婚礼。行万里路，TW也算是蛮有特点，值得去旅游体验的地方。小时候也算是听“周杰伦”长大，和一家人一起看湖南卫视金鹰剧场“恶作剧之吻”，还有“那些年一起追的女孩”，各种偶像青春剧吧。也有人说是“华人之光”，实现了“社会主义核心价值观”，风土人情也十分有特色。\n考到 爱尔兰 驾照。这一路考驾照之旅也是坎坷，我都有些难以置信。考了4次路考了，每次都因为各种原因没有过。明年继续。虽然 一鼓作气，再而衰，三而竭。明年回爱尔兰重新开始，Fighting！我还就不信了。\n坚持健身。买房后，离公司远了，也就不怎么去办公室了，办公室的健身房也就不能白嫖了。办了家附近购物中心健身房的卡，一月35欧，一周去3次。明年继续。\n事业上，可以有所进步和更好的转机。前2年，因为layoff和reorg，还是蛮颠沛流离的。24年，经济环境明显转暖，公司也开始重新扩招，也算是苟到了好时候。今年下半年，重新转到美国旧组。虽然前老板提前退休，有很大遗憾，但仍比去年以色列组强不少。重新和新老板（也是前同事）建立了Trust，工作也按部就班，有所impact。明年继续。\n生活上，希望可以多出门，多认识不同的人，多参加社交活动。今年下半年搬进新家，没了舍友。也基本在家办公，完全过上了日本青年的独居宅男生活。就算是70% 的I 也顶不住。\n","categories":["dairy"],"tags":["life","年终总结"]},{"title":"网飞三体有感：质疑程心，理解程心，成为程心","url":"/2024/03/25/3-body/","content":"最近网飞版的三体火了，誉谤满身。我也没看，不好评价，但勾起了我和三体的往事回忆。\n三体的小说。我还是在大概十年前，在沙河图书馆看的。当时虽然还没有得雨果奖，三体系列已经在慢慢变火了。当时印象中还是，一开始书名是 “地球往事 之 三体，黑暗森林，死神永生”。三体虽然只是第一部和其中虚拟现实游戏得名字，但因为太火了，就慢慢变成了整个系列得名字。搞笑的是，图书馆里只能借到第一部和第三部，第二部永远预约不到。因此，我读的顺序是 一，三，二。还看了宝树狗尾续貂得 三体X。我对三部书的喜爱顺序是：死神永生&gt;黑暗森林&gt;三体。也算入了科幻坑，之后看了大刘的其他小说。也接触了阿西莫夫的“基地”和“银河帝国”系列，中篇“永恒的终结”，都十分不错，推荐给大家。\n最神奇的感受是。当年不到二十岁，读完后，对罗辑崇拜，对韦德敬畏，对程心鄙夷。现在要奔三了，却发现自己越来越像程心了。不知是年龄大了，还是怎得，对他人、世界和人类越来越温柔善良。质疑程心，理解程心，成为程心。也更理解了书中的一些细节：为什么罗辑会愿意交出手中的执剑人权力，即使知道对自己和对人类的后果。为什么章北海在执行黑暗森林操作对付友舰时会有所迟疑。为什么即使是威慑度快满的韦德，最后也遵守诺言，交出权力，即使预见到对自己和对人类的后果。人类是智慧，情感，兽性的结合，大刘的观点显然是对人类生存来说 智慧&gt;兽性&gt;情感 的。借韦德口说出的”失去人性，失去很多；失去兽性，失去一切“就十分有代表性。但就是这情感，每次在关键时刻起到重要作用，改变历史和人类命运。当然，每次都是往万劫不复的方向改变。即使如此，人类仍然无法摆脱人性的束缚，强如韦德，最后也无法剔除所有人性，完全按照理性和兽性做决定。\n剧集，讨论最多的应该就是第一集。著名的”爱因斯坦他有奶便是娘“，不了解那段历史，十年”艰辛探索“，也就不会理解叶文洁的反人类人格如何被塑造出来，也不好理解，她的行为和立场（其实是 降临派）。虽然剧集改编很多，但这一段确实是还原原著了，部分反映历史。大刘 其实已经很克制表达和隐晦了，20年前还能写出来出版，现在估计够呛。\n","categories":["读后感"],"tags":["Reading","3 body"]},{"title":"全球通史 从史前史到21世纪","url":"/2023/10/01/A-Global-History-From-Prehistory-to-the-21st-Century/","content":"豆瓣链接 全球通史 从史前史到21世纪 A Global History: From Prehistory to the 21st Century\n强烈推荐每一个中国人阅读这本书，可能有些大部头，有些地方也比较简略。毕竟是全球通史，无法做到面面俱到。但读完之后，收获是巨大的。尤其是对于“生在红旗下，长在新中国”的我，从小学习的历史都是人教版历史课本。就算看些课外书，也是基于中国人的视角和经验，他们有着类似的教育和文化背景。本书是一个生在加拿大，后来又在美国执教的美国人写成，可以算是完全的西方视角。从这个角度，可以对我们之前的历史教育去媚化，减少意识形态的影响，更加接近现代历史。\n最重要的感悟是，为什么中国一定要实现现代化。包括经济现代化，政治现代化，思想现代化，科技现代化。科学技术是第一生产力，自由主义是对科学技术发展到保障，民主制度是对自由的保障。历史和现在充分证明了这点。\n也引用我上学时，人教版高中物理课本里的一句话，据说现在已经删掉了。“没有学术的民主和思想的自由，科学就不能繁荣。”\n按照马克思政治经济学的理论，生产力决定生产关系；经济基础决定上层建筑。很明显，苏联的专制和计划经济已经已经严重阻碍了生产力的发展。正如之前流行的“加速师论”一样，苏联就像一辆巨大的卡车，这辆卡车的驾驶员用一只脚使劲往下踩加速器，用另一只脚踩刹车。在21世纪的全球竞争中，尤其是中美竞争，不改变上层建筑是没法追赶上美国的，只能回复到一个二流区域大国的地步。\n\n1970年3月 萨哈罗夫 《苏联科学家致苏维埃社会主义共和国联盟党政领导人的呼吁书》\n为什么我们不仅未能成为第二次工业革命的先驱者，相反还如人们所知道的，不能在这场革命中跟上发达的资本主义国家呢？难道社会主义制度没有像资本主义制度那样为生产力的发展提供同样的种种机会？难道资本主义将在资本主义和社会主义之间的这场经济竞争中获得胜利？\n当然不是。我们所处的困境的根源根本不在于社会主义制度，而是正好相反，在于我们生活中与社会主义相抵触、与社会主义格格不入的那些特点和情况。这一根源在于反民主的传统和在于在斯大林主义时期已制定、至今仍未被废除的公共行为规范……在社会政治范围内，阻碍我们经济发展的障碍物很多，凡是不能除去这些障碍物的措施都是注定无效的……\n从我们的国外朋友那里，我们有时听到有人把苏维埃社会主义共和国联盟比作一辆巨大的卡车，这辆卡车的驾驶员用一只脚使劲往下踩加速器，用另一只脚踩刹车。更明智地利用这一刹车的时刻已经到来了！……\n如果不采取一种导向民主化的做法，我们的国家还能指望什么呢？它只能期待自己在第二次工业革命中落后于资本主义国家，逐渐回复到一个二流区域大国的地步。\n\n正是科技发展，才打破了人类发展的王朝历史周期律。和社会主义和资本主义这些意识形态无关。只能说，目前为止，资本主义所追求的自由市场经济对生产力和科技的促进作用大得多。科学技术是第一生产力，自由主义是对科学技术发展到保障，民主制度是对自由的保障。\n\n历史清楚地表明，只有发展技术，为帝国大厦提供必要地经济基础，才能打破这种恶性循环。但是，技术却停滞不前，其根本原因在于，各地统治集团只知道剥削现有地财富，不知道怎样去创造更多地新财富。\n\n\n邪恶获得成功所需的是善良的人们保持沉默和无所作为.\n– 埃德蒙.伯克\n\n让我想起早年看过的06年的央视纪录片《大国崛起》，虽然拍的已经算是含蓄了，也并未涉及任何政治改革的话题。\n大国崛起现在在豆瓣上都没法评论了，真是搞笑。老大哥怕成这样。最近在读斯塔夫里阿诺斯的“全球通史”，中间部分介绍西欧所以强大并主宰世界，真的是让人激动人心。\n","categories":["读后感"],"tags":["Reading","全球通史"]},{"title":"迷人的温度 温度计里的人类、地球和宇宙史","url":"/2024/09/02/A-Matter-of-Degrees/","content":"A Matter of Degrees: What Temperature Reveals about the Past and Future of Our Species, Planet, and Universe\n豆瓣链接\n十分。“穷查理宝典”的推荐书籍，我从那本书过来的。芒格在书中强调，跨学科知识的重要性，或许这就是他推荐此书的原因吧。确实如此，本书集合多门学科大成，深入简出，是本优秀的科普书籍。虽然很多知识和历史都是我所知道的，但是通过“温度”这一物理变量，把医学，生物学（包括进化论），物理学（光、热、量子力学），地质学，化学都串在一起。当不同学科融会贯通，历史的发展交织在一起的时候，不得不感叹科学和人类文明的伟大。就像书中所说，从宇宙大爆炸，到太阳系的诞生，地球的诞生，再到生命，最后到人类来思考这些间接和直接创造人的这一切。让我读来多次拍手称快，爱不释手，3天读完。生而为人，我很幸运和骄傲。尤其是生活在21世纪，站在那么多巨人的肩膀上。享受着他们的发现和创造，过着舒适和幸福的生活。\n最有意思的部分是，在“太阳的诞生”章节，作者提到，太阳因为核心聚变的进程，核心温度是不断升高的。因为越重的原子核需要更高的温度，才能抗衡电磁斥力，产生聚变。现在的太阳是50亿年前，释放能量的30%多。之后也会越来越亮。这对地球不是什么好消息。再过10亿年，也许地球会步入金星后尘，变成一个温室效应严重，过热的星球。生命或将在地球上灭绝。但是科学家已经提出了解决方法，如果人类可以继续存在的话，可以通过驾驭小行星，利用引力弹弓（其实是发射太阳系探测器加速的常用技巧）的效应，每次从地球掠过的时候，把地球往外推一点，然后小行星会回到木星之外补充能量。然后人类再通过火箭，改变轨道，再次返回地球。每六千年一个周期，火箭的功率其实也不需要很大，因为时间长，产生的动量就大了。几十亿年后，地球就会到今天火星的轨道上。地球可以保持适宜的温度，为生命延长几十亿年的时间。真是科学版流浪地球，比大刘的行星核聚变引擎方案可行的多。当然大刘的背景是需要更快的走，引力弹弓虽然可行省力，但需要的时间也更久。当然《流浪地球》里的设定是，太阳会几千年内发生毁灭的氦闪，这不是科学的。当然50亿年后，太阳还是要变成红巨星，吞没地球和火星的。之后就生命需要移民到木星和更外的轨道了（这次没法带着地球一起走了），甚至是其他的恒星系。\n曾几何时，我也是有所谓“科学家”的理想的，初高中的时候，也是对物理十分感兴趣。差点报考南大的物理系或天文物理系了。小时候就喜欢读“十万个为什么”，“动物世界”，还订阅了科学杂志（忘记名字了，但真的很喜欢。印象最深刻的是讲，地平线号发射，将会十多年后访问冥王星的故事。当时冥王星还是九大行星之一。长大后，它真的到了，掠过冥王星。发回了探测数据，并开始离开太阳系了。但冥王星早被踢出行星行列，现在只有八大行星了）。高中的时候，也读了加来道雄的《平行宇宙》，霍金的《时间简史》，《果壳里的宇宙》。甚至是人教版的物理课本，都把物理学和那些科学家的故事讲的绘声绘色，令人神往。大学也读了加莫夫的《从一到无穷大》。来了爱尔兰后，读了《上帝掷色子吗》，《现实不似你所见》。如果你喜欢这些书的话，《迷人的温度》肯定也会十分符合你的胃口的。\n回想自己小时候也是充满了求知欲和理想主义，却在现实和社会的规训下，变得如今十分现实主义了。尤其是在国内的教育体制之下，剥夺了孩子们的多样性和求知欲，质疑与勇气。即使最后考上很好的大学，读了热门的专业，做了体面的工作，赚了可以的钱。但仍然也算是自怜自爱。唉，伤仲永呀。有些同学即使大学读了物理，大多也在社会的压力下转了码。我有个高中同学，一直读到高能物理博士，去年在巴黎联合培养两年。当时还去拜访和参观了他的实验室。但也去昧了。学物理确实是穷，就业面也窄。做的学术内容，日常也是读论文，写代码，分析实验数据和模拟。还是读科普书或看故事更精彩。身在其中的人，也是绝大多数要做很多枯燥的工作的。而且物理、数学这些很看天赋，多少知名的科学家都是年少有成，25岁之前就可以证明自己。我自己已经太老了。不过作为门外汉，关注这些科学的重大进展，还是很让人激动和开心的。多少次回想起，年少时第一次读到这些科学故事和知识的时候。\n第三章，”读懂地球“。也是十分有借鉴意义的，尤其是我一直很喜欢看B站上一个叫”芳斯塔夫“的UP主，讲生物进化的。很多地质和生活演化历史事件，和”芳斯塔夫“的都串起来了。这种感觉真是神奇。提到和分析了”温室效应“，但更加理性和客观，对二氧化碳的排放也更加从容和容忍。不像之前白左的极端观点，当然现如今白左也降温了。气候议题已经不如几十年前那么火热了。\n","categories":["读后感"],"tags":["Reading","迷人的温度"]},{"title":"SQL实践进阶","url":"/2018/05/07/Advanced-SQL-practice/","content":"这一周在公司写了很多很长功能很复杂的sql语句，深感自己的数据库和SQL学的还只是皮毛，完全没法满足工程上的要求。\n负责带我的二mentor对SQL比较也精通，对我有很多指导和建议。\n没有对比就没有伤害，自己的菜和师兄的强让我知耻而后勇，有了进阶SQL的想法和行动。\n\n我被推荐的2份教程（感谢快手师兄和二mentor）：\n\nsql必知必会\nrunoob\n\n其中《sql必知必会》我系统的看过一遍，runoob教程只是大致浏览一遍。\n我认为只看一个教程就够了。\nrunoob的优点是可以在网站提供的线上数据库进行测试和练习，这一点和w3school的教程有些像。\n《sql必知必会》的优点是内容比较多，作者会传授一些写sql的经验，还会涉及到不同数据库的移植性和区别。\nleetcode上有42道Database的面试题目，有时间一定要刷一刷。\n 实践中遇到的问题\n由于我的岗位是推荐组的算法工程师，有大量的数据挖掘的需要。\n而且写的不是纯sql，而是Hive-sql。\nHive上存在很多限制和挑战，比如不能在select中嵌套select子句，select 2 * (select 3);就是不可以的（最后摸索出得解决方案是：使用聚集函数或列之间的可计算进行需要的计算，这就很考验union或join的灵活使用了。）；数据量特别大，每次查询很耗时（学会了用小的查询验证想法，从内到外层层验证，还有在‘jupyter notebook’上进行查询和计算）。\n 回答面试中的问题\n一面的小哥哥当时问我：你会SQL吗？\n我：会，而且我之前还有在数据库公司的实习经历。\n小哥哥：那你说说‘left join’，‘right join’，'inner join’的区别。\n我：不知道…\n小哥哥：那你知道partition吗？\n我：这个我也不知道。\n小哥哥：你会的SQL仅限于上过的“数据库原理”和“课程设计”课吗？\n我：是的，而且因为一段时间不用有些生疏了。\n小哥哥就没再问SQL相关的内容了。\n经过一周的工作和SQL的重新系统学习，我现在可以回答这两个问题了。\n ‘left join’，‘right join’，'inner join’的区别\n'inner join’即内联结，对于不匹配的项，不存在于联结结果中；‘left join’，左外联结，如果左边的项在右边的表中没有匹配项，仍存在一条记录于联结结果中，此时右边表列均为NULL；‘right join’，右联结与之类似。事实上，'left join’和’right join’可以互换，只是联结的左右两表也需要互换位置。\n partition的概念\npartion是为了加快查询速度，而将一个表分成不同的区。\n限制是，select时，被partition的列必须写在where里作为filter。\n","categories":["intern"],"tags":["tech","kuaishou"]},{"title":"阿里巴巴 蚂蚁金服 后端开发 暑期实习生","url":"/2020/03/09/Alibaba-Ant-backend-intern-interview/","content":" 一面\ntime: 2020-03-09 16:45:44\n 简历经历\n对各段项目的介绍。根据项目随时提问，如RESTful API, SOAP之类的知识。\n 计算机基础\nHashMap 的实现\n\nHash值如何映射到桶中？？？？\nhashcode和equals函数的要求（修改equals为什么必须要修改hashcode)\n扩容机制和均摊复杂度\n\nJava 开箱 和 装箱 机制。（一开始没反应过来，说不会。在面试官的提醒下，基础类型 和 对象类型 的关系，我才会了。因为之前看的都是英文材料，box和unbox，对中文不是很敏感。）\n 算法题\n编辑距离的递推公式\nK-means算法。没答好，很久之前学过机器学习。但是因为放下的时间太久了，几乎都忘记了。\n 对面试官的反问\n问面试官的问题：我投递的岗位是 后端开发，是否需要复习机器学习的算法？\n答：这和公司的产品线有关，蚂蚁金服的产品和机器学习密切相关。开发不需要对机器学习有很深的了解，但需要有基础的了解。如果会的话，有加分。\n 二面\ntime: 2020-03-24 16:20:56\n距离一面已经2周了，昨天收到电话，约了今天下午3点的电话面试。时长半个小时。\n商汤实习项目。\nArrayList（自增数组）实现，底层链表和数组的区别。\n1千万个数共10M，内存只有2M, 寻找出现次数最多的10个数字。\n答：先分组，可以按照数字的个别数位来分成小组，在每个组里寻找这10个数字。在合并，寻找总的10个数字。\n看了哪些书？\n熟悉SQL是个啥意思？\n并发的知识:\n\nConcurrencyHashMap\n无锁编程\n\n职业规划。\n大概回答的不是很好，面试官催促我完成笔试，要不然只能问我简历上的内容。笔试完会有人再联系我。今天下午状态不大好，没发挥好。没有手撕代码环节，差评～\n 笔试\n阿里笔试有多场。我做的是3.25这天的。\n笔试难度不大，在牛客网上完成，2道算法题，LeetCode medium难度。拿了满分，导致貌似阿里那边觉得我很优秀，后面的流程就顺风顺水，特别想我过去。好多同事和lead加我微信，打电话劝我。所以最后拒阿里offer时还挺不好意思的。\n\n给3xn的矩阵，每列选择其中的一个数, 形成最后的数组。\n使得最后的\n\n\n∑i=0n−1∣bi+1−bi∣\\sum_{i = 0}^{n-1} |b_{i+1} - b_i|\ni=0∑n−1​∣bi+1​−bi​∣\n最小。\n输出最小的这个值。\n\nDP求解即可。\n时间复杂度: O(3N),\n空间复杂度: O(3).\n```cpp#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;int main() &#123;    int n;    cin &gt;&gt; n;    vector&lt;ll&gt; last_dp(3, 0);    vector&lt;vector&lt;ll&gt;&gt; matrix(3, vector&lt;ll&gt; (n));    for (int i = 0; i &lt; 3; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            cin &gt;&gt; matrix[i][j];        &#125;    &#125;    for (int i = 1; i &lt; n; ++i) &#123;        vector&lt;ll&gt; dp(3);        for (int dp_index = 0; dp_index &lt; 3; ++dp_index) &#123;            dp[dp_index] = abs(matrix[dp_index][i] - matrix[0][i-1]) + last_dp[0];            for (int j = 1; j &lt; 3; ++j) &#123;                ll new_value = abs(matrix[dp_index][i] - matrix[j][i-1]) + last_dp[j];                if (new_value &lt; dp[dp_index]) &#123;                    dp[dp_index] = new_value;                &#125;            &#125;        &#125;        last_dp = move(dp);    &#125;    cout &lt;&lt;  min(&#123;last_dp[0], last_dp[1], last_dp[2]&#125;) &lt;&lt; endl;    return 0;&#125;\n\n\n一个n x m的矩阵，每列每行都是等差数列，公差为整数。\n输入n x m个数，如果为0表示不知道，否则知道。\nq个查询，特定位置（下标1开始）的值是否可确定。\n\n递归求解，进行推测即可。可以用一些数组维护：每行/列是否已经被推断、每行/列已知道的数的下标、行列信息。\n时间复杂度: O(N * M),\n空间复杂度: O(N * M).\n#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;using namespace std;using ll = long long;const int INF = 0x3f3f3f3f;int main() &#123;    int n, m, q;    cin &gt;&gt;  n &gt;&gt; m &gt;&gt; q;    vector&lt;vector&lt;int&gt;&gt; A(n, vector&lt;int&gt; (m, INF));    vector&lt;int&gt; row(n, -1);    vector&lt;bool&gt; row_ok(n, false);    vector&lt;int&gt; col(m, -1);    vector&lt;bool&gt; col_ok(m, false);    function&lt;void(int, int, int)&gt; fill = [&amp;](int i, int j, int value) -&gt; void &#123;        A[i][j] = value;        if (col_ok[j] &amp;&amp; row_ok[i]) &#123;            return;        &#125; else &#123;            if (!col_ok[j]) &#123;                if (col[j] == -1 || col[j] == i) &#123;                    col[j] = i;                &#125; else &#123;                    col_ok[j] = true;                    int diff = (A[i][j] - A[col[j]][j]) / (i - col[j]);                    for (int r = i - 1; r &gt;= 0; --r) &#123;                        fill(r, j, A[r + 1][j] - diff);                    &#125;                    for (int r = i + 1; r &lt; n; ++r) &#123;                        fill(r, j, A[r - 1][j] + diff);                    &#125;                &#125;            &#125;            if (!row_ok[i]) &#123;                if (row[i] == -1 || row[i] == j) &#123;                    row[i] = j;                &#125; else &#123;                    row_ok[i] = true;                    int diff = (A[i][j] - A[i][row[i]]) / (j - row[i]);                    for (int c = j - 1; c &gt;= 0; --c) &#123;                        fill(i, c, A[i][c + 1] - diff);                    &#125;                    for (int c = j + 1; c &lt; m; ++c) &#123;                        fill(i, c, A[i][c - 1] + diff);                    &#125;                &#125;            &#125;        &#125;    &#125;;    for (int i = 0; i &lt; n; ++i) &#123;        for (int j = 0; j &lt; m; ++j) &#123;            int v;            cin &gt;&gt; v;            if (v != 0) &#123;                fill(i, j, v);            &#125;        &#125;    &#125;    for (int i = 0; i &lt; q; ++i) &#123;        int r, c;        cin &gt;&gt; r &gt;&gt; c;        --r;        --c;        if (A[r][c] == INF) &#123;            cout &lt;&lt; &quot;Unknown&quot; &lt;&lt; endl;        &#125; else &#123;            cout &lt;&lt; A[r][c] &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;\n 测评\n笔试没难倒我，测试却花了我不少时间。\n主要是测试\n\n语文：阅读理解、成语使用、归纳和排除 10min\n数学：表格、图、经济用语 10min\n智商：看图找规律 10min\n性格：是否抗压、反社会 30min\n\n全靠高中学习到的知识和技能。智商就天生的呗。\n据说和公务员的考试很像，行测。有了解的朋友可以看看。\n应该也不会用测评去筛人，又不是考公务员，手撕代码才是王道。\n 三面\ntime: 2020-04-03 11:36:14\n昨天电话约了今天的电话面试，11:30，聊了40分钟。\n昨天下午做了阿里的线上笔试，晚上做了测评。\n面试官很NICE，还加了我微信进行沟通。\n主要聊了项目，还有一些数据处理的知识和Java的了解。\n\n数据预处理，对缺失值的处理\n给一个信用评估的数据，如何利用和上线\nJava了解程度和使用，Spring boot\n\n最后问了英语怎样，口语如何。可能是因为对方是 国际化事业群 吧。\n我最后问了面试官所在的组和业务。\n面向海外的个人信贷业务，类似花呗和借呗。\n 四面\ntime: 2020-04-03 15:22:02\n上周和HR约了这周的交叉面。本来是周一的视频面试，后来面试官出差了，换了一个面试官，改约周三（4.1）。而且新的面试官很忙，没有约具体时间，只是让我下午和晚上等电话。晚上7点半收到电话，聊了40min。\n面试因为只是电话面试，无法手撕代码，只问了一个简单的算法题：桶排序。\n除此之外都是项目，但项目问的很深，很细节。我简历上的实习项目都是当时花了很大功夫完成的，但无奈过去的时间过于久远，很多细节和考虑一时也无法答上来。而且当时做实习的时候更多的是着眼眼前遇到的困难，而不是深入了解整个公司的架构，所以答的并不是很好。面试官问了很多BQ(Behavior Question)的问题。如：\n\n你之前项目上遇到的最大的困难是什么？\n你实习时发生的最难过的事是？\n你之前坚持过最久的事是？\n了解的都很细，很多问题我从未遇到，也没有认真思考过。之前听说外企才有BQ，而且也大都是HR问。所以虽然不手撕代码，但全程依然很累。\n\n最后面试官问 我还有什么问题吗？我竟然说“没什么问题了，我家长叫我吃饭呢！”这样的大实话。哈哈～\n昨天接到电话，又约了下周二(4.7)的HR面。愿一切顺利。\n现在最担心的是因为疫情的原因，暑假都不一定有了，暑期实习恐怕也去不了。\nGoogle的面试进度也停了3周。说是因为实习生招收政策的调整，要推迟到4月中。听过美国疫情很严重，发的offer很多都鸽了。难倒谷歌中国也要减少HC，有同学知道内部消息不？我苦呀！\n","categories":["interview"],"tags":["intern","Alibaba"]},{"title":"阿里钉钉 服务器开发 暑期实习生 面试","url":"/2020/03/04/Alibaba-Dingding-backend-intern-interview/","content":"通过钉钉电话视频面试，手撕代码通过阿里在线平台完成。\n算法题2道：\n1. 实现一个双向链表的数据结构。\n2. twoSum。寻找数组中2数和等于target的下标。\n难度属于LeetCode Easy吧。但是面试时，需要自己和面试官询问沟通好理解题目。并且面试官很注重代码的整洁和效率。比如 函数参数的检查，实现本身的预设。\n//评测题目: 实现一个简单的双向链表，要求完成 node和list的构造函数，以及 list类的void push_back(node*), void remove(node*) 方法class node&#123;public:\tnode* prev;\tnode* next;public:    node() &#123;      prev = nullptr;      next = nullptr;    &#125;&#125;;class list&#123;private:\tnode* head;\tnode* tail;public:\tlist() &#123;      head = nullptr;      tail = nullptr;    &#125;\t\tvoid push_back(node* n) &#123;      // 假设n不在list中    \tif (n) &#123;          if (tail) &#123;          \ttail-&gt;next = n;          &#125; else &#123;            head = n;          &#125;          n-&gt;prev = tail;          tail = n;        &#125;    &#125;\tvoid remove(node* n) &#123;      if (n == nullptr) return;      auto current = head;      while (current) &#123;        if (current == n) &#123;          // find          if (current-&gt;prev &amp;&amp; current-&gt;next) &#123;            auto p = current-&gt;prev;            auto n = current-&gt;next;            p-&gt;next = n;            n-&gt;prev = p;          &#125; else if (current-&gt;prev) &#123;            tail = current-&gt;prev;            tail-&gt;next = nullptr;            current-&gt;prev = nullptr;          &#125; else if (current-&gt;next) &#123;            head = current-&gt;next;            head-&gt;prev = nullptr;            current-&gt;next = nullptr;          &#125; else &#123;            head = nullptr;            tail = nullptr;          &#125;          break;        &#125;        current = current-&gt;next;      &#125;          &#125;&#125;;//给定一个vecotr&lt;int&gt;v和一个目标target，找到v中两个数字的和等于target，返回数字在原数组中的下标（多个解的返回任意一个即可），无解返回空vector。//Example:  v=[7,11,2,15],target=9,//因为nums[0]+nums[2]=7+2=9, //return[0,2].vector&lt;int&gt; helper(vector&lt;int&gt;&amp; v,int target) &#123;\tvector&lt;int&gt; copy = v;    sort(copy.begin(), copy.end());    int left = 0, right = v.size() - 1;    while (left &lt; right) &#123;        int current_sum = copy[left] + copy[right];    \tif (current_sum == target) &#123;          return &#123;copy[left], copy[right]&#125;;        &#125; else if (current_sum &lt; target) &#123;          ++left;        &#125; else &#123;          --right;        &#125;    &#125;    return &#123;&#125;;&#125;vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; v,int target) &#123;    if (v.size() &lt;= 1) return &#123;&#125;;\tauto values = helper(v, target);  \tif (values.empty()) return &#123;&#125;;    vector&lt;int&gt; ans(2);    int index =  0;  \t      if (values[0] == values[1]) &#123;        for (int i = 0; i &lt; v.size(); ++i) &#123;          if (v[i]  == values[0])  &#123;            ans[index] = i;            ++index;            if (index == 2)              break;          &#125;        &#125;      &#125; else &#123;        for (int i = 0; i &lt; v.size(); ++i) &#123;          if (v[i] == values[0]) &#123;            ans[0] = i;          &#125; else if (v[i] == values[1]) &#123;            ans[1] = i;          &#125;        &#125;      &#125;    &#125;      return ans;&#125;\n我的主语言是C++，所以问了很多C++相关的题目。\n从我的简历里，看了我的GitHub主页。询问了最想介绍的项目。我介绍了自己大三时实现的编译器。然后询问了编译的一些过程和数据结构，如 词法分析、语法分析、中间代码生成、目标代码生成、优化，符号表、DAG图优化等。\nC++中输入&gt;&gt;和模版嵌套时’&gt;&gt;在编译时如何区分。我答应该是语法分析时就可以区别开。然后聊了些这个故事的历史，之前模版的&gt;&gt;必需写成&gt; &gt;`才能编译通过。\nC++ HashMap容器的实现，和hash值如何映射到桶中。\nSTL 中vector的扩容实现。\nnew 和 malloc的区别。\nmove语义和右值引用。\nweak_ptr, shared_ptr, unique_ptr的区别。\n平时对什么感兴趣，高级的数据结构:\nOrder tree, 线段树。\n快排和堆排的实现。最小堆的维护。\n进程和线程的区别。\n锁的种类 和 读写控制。\nLinux内存管理机制。\n常用的shell命令。文件操作、进程信息(top, ps)、堆栈信息(lldb).\nTCP丢包处理。这题我答的不好，大三下学的计算机网络很多知识都忘记了。\n24点的智力游戏，4 4 10 10， （10 * 10 - 4) / 4。\n我一开始以为是编程问题，答曰回溯。后来才发现是纯考智力。\n职业规划。\n","categories":["interview"],"tags":["intern","Alibaba"]},{"title":"阿姆斯特丹","url":"/2019/09/23/Amsterdam/","content":"来到欧洲安顿下来的第一周，我们去了美丽的荷兰-阿姆斯特丹和周围的2座村庄。\n由于是第一次出来玩，许多行程安排的有问题，花费也相对不菲。人均大概450欧。相比之下，一周之后的巴黎之旅只花了300欧，并且体验也更棒。\n我认为荷兰绝对是欣赏北欧乡村风光的最佳地点。\n本次成行人员：zfn, lxf, lsd, zjz（张导）和 我。\n 第一天 落脚羊角村\n第一天大多数 时间 都 花在路上了。因为张导住在鲁汶，所以我们选择在布鲁塞尔集合。因为是第一次出行，中间误了一趟车，并且开启了本次旅行的首次奔跑，为了帮张导赶车，在站台上3个人提着行李狂奔。鉴于之后的为了赶行程狂奔，本次狂奔只能算是前菜。\n吸取 的教训是，安排行程要量力而为，不要对自己和队友太过自信。\n由于 中途大量 时间浪费在火车站和等人上，我们晚上11点 才到达羊角村预定的民宿。最后的民宿离镇上有10min的车程，我们有5个人，打车不方便，最后打了一辆7座的车。开车的司机脾气也比较火爆，对我们换车貌似有些不满，开的比较猛，大家纷纷晕车。虽然路途颠簸，但到达 民宿后，感觉一切都是值得的。\n首先，house的女主人超级nice。到达 鸟不拉屎的住处后，我先下车，和女主人聊了起来。因为她下腹比较胖，我很友善地问她是不是pregnant了？本想着和女主人套套近乎。没成想，女主人回复 不不，她已经有3个男孩子了。瞬间气氛变得很尴尬。不过女主人并不放在心上，继续很愉快的招待起我们。\n在这里，我看到了多年未见的银河，甚至 有幸看到流星。也足见这里的偏僻程度。我们开心地就像一群孩子一样，在后院里看了一个多小时银河。银河真是太美了，我们这样的星空震撼的哇哇叫。自从大概 上小学后，我就再也没能亲眼看到银河了。足以原谅我的激动。天空真的是分外清澈，银河和各个星座清晰可见。随着我们在外面呆的时间越长，眼睛对光线越发适应，看到的星空越美。洁白的月亮也出现在地平线上，并不与银河争光，所以银河就像一道牛奶的带子一样清晰可见。难怪叫做milky way. 因为照片拍不出银河的效果，只有肉眼可见，才能感受到震撼和美。\n 第二天 阿姆斯特丹\n高空秋千。\n游船。\n集市。\n啤酒博物馆。\n逛街。\n海鲜大餐。\n红灯区。\n 第三天 风车村\n风车村\n梵高博物馆\nFlixBus.\n","categories":["dairy"],"tags":["travel","游记"]},{"title":"反脆弱 从不确定性中获益","url":"/2024/08/24/Antifragile-Things-That-Gain-from-Disorder/","content":"保守主义，自由主义，乐观主义 的盛宴。\n纳西姆.塔勒布 是 纳瓦尔 和 李总 都很推荐的一位作家，或许他们也叫他哲学家。\n反脆弱更像是成功学书籍，告诉人们要拥抱压力、坏的东西，从而获得恢复性的成长。其实就像是“七龙珠”里赛亚人的被动技能一样，每次从濒死状态恢复过来，战斗力都会成倍增长。贝吉塔就用过此技能开挂刷战斗力，但最后还是被弗利沙杀死了。\n在爱尔兰的2年，真是躺平和安逸。少不入欧。人都要呆废了。虽然生活很幸福，但没有了恢复性成长。\n也让我想起中学时代接受的教育，为了高考作文学的那些名言。想想之前的掉书袋和爱用典故，真是年轻气盛。\n\n孟子云：天将降大任于是人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。入则无法家拂士，出则无敌国外患者，国恒亡。生于忧患，死于安乐。\n\n司马迁在“史记 太史公自序”和“报仁安书”中也说：\n\n盖西伯拘而演《周易》；仲尼厄而作《春秋》；屈原放逐，乃赋《离骚》；左丘失明，厥有《国语》；孙子膑脚，《兵法》修列；不韦迁蜀，世传《吕览》；韩非囚秦，《说难》、《孤愤》；《诗》三百篇，大底圣贤发愤之所为作也。\n\n回顾自己的成长经历，不也是如此吗。发现自己的反脆弱性还是蛮强的。去年（23年）从各个角度讲，都是我近几年的人生低谷。但慢慢地，开始触底反弹。今年获得的成长性真的是超越过去任何阶段。现在的我，似乎又来到一个新的高度。\n\n大公司和政府似乎并不明白信息的反作用力，事实上，信息有能力控制那些试图控制它的人。当你听到一家公司或一个负债累累的政府表示要”重新注入信心“，那么你就应该知道它们是脆弱的，注定失败。信息是无情的：越是召开新闻发布会来”安抚“投资者，越会吓跑投资者，导致死亡螺旋或银行挤兑。\n\n\n反脆弱性的产生是有条件的。压力源的刺激频率非常重要：人类在急性刺激下会比在慢性刺激下表现得更出色，尤其是在急性刺激后给予较长得恢复期，这将使得这些压力源成为信息得传导渠道。…比一个温和但连续不断的压力源有益，后者大多是让你在生活中感到压抑的东西，包括按揭贷款、税务问题、因拖欠报税而产生的内疚、考试压力、琐碎事务、电子邮件回复、填写表格、每天上下班通勤，等等。换句话说，这是文明带来的压力。\n\n我是J人喜欢确定性。看来不确定性也要很大益处，有时要主动接受不确定性，拥抱变化。但之后一定要给自己恢复和成长的时间。\n\n如果你还或者，你的内心深处就会喜欢一定程度的随机性和混乱。\n\n平均斯坦 VS. 极端斯坦\n平均斯坦：平时存在许多波动和不确定性，长期来看反而更加稳定。\n极端斯坦：平时相对稳定，长期来看反而不稳定。\n自由职业者 VS. 打工人\n出租车司机 VS. 银行白领\n城邦制 VS. 中央集权\n论述完为什么反脆弱性，在谈如何建立反脆弱性的一些策略。不对称性（杠铃策略），完全消减毁灭性事件，等待好事件自然而然发生。可选择性。\n反现代化，崇尚古人的生活方式。\n反思科技，反对过于理性。\n用否定法，减法来提高反脆弱性，而不是加法。没有证据表明 vs. 有证据表明没有 的区别。\n\n在政治领域，一个好的体制就是有助于社会淘汰坏人的体制，它不必考虑做什么事或者有谁执政。因为一个坏人造成的伤害可能大于一群好人集体所做出的努力。\n\n\n公司都热衷于制订战略计划。它们需要花钱来弄明白自己究竟该走向何方。然而，没有证据表明，战略规划起到了作用—否定它的证据倒有很多。\n\n国家不也是这样吗。尤其是大政府，市场经济国家。\n\n在医学界的黑暗时代，医生曾经非常依赖于一些天真的理性主义想法，比如必须平衡身体的体液，疾病被认为源于某些不平衡，根据这些想法所衍生出的一系列治疗方法被认为是恢复身体平衡的必要手段。\n\n比如，臭名昭著的放血疗法。然而，即使到了21世纪，中医仍然甚嚣尘上。回顾历史，其实没有所谓中西西医的对立，而是现代医学和传统医学的对立。西方之前也有各种类似中医的疗法和观点，只不过被历史所淘汰了。当我像外国人表达中医时，我说traditional doctor，然后说了疗法。他说，你意思是witch doctor\n作者旁征博引，让我一个从小受东方教育的人，也意识到，西方同样也有着悠久的历史和文化传承。塔勒布是黎巴嫩人，东正教区域。从苏美尔文明，到希腊罗马文明，再到其实不那么黑暗的中世纪，文艺复兴，科学和工业革命的现代文明，其实也是一脉相承的呀。美索不达米亚的苏美尔文明是最早的人类文明，公元前4500年就创造了灿烂的文明。黄帝（公元前2600年）的车轮和很多发明，其实就是从地中海东岸一步一步传过来的。即使是夏朝（当然有所争议，因为历史记载和考古发现对不上。我是倾向于存在的，考古发现之后也许会跟上。因为夏朝也是所谓的部落联盟，也没有文字，考古发现更难些。我也比较认同，二里头文明就是夏朝），也是公元前2000年。现在民族主义是，法国大革命才诞生的，距今不过200多年。中国的民族主义也是鸦片战争后才慢慢建立，抗日战争后完备的。所以不必为了民族主义，阻碍文明认同。三星堆的事实和发掘大概就是受阻于此。\n","categories":["读后感"],"tags":["Reading","反脆弱"]},{"title":"你的灯亮着吗? 发现问题的真正所在","url":"/2024/01/23/Are-Your-Lights-On-How-to-Figure-Out-What-the-Problem-Really-Is/","content":"豆瓣链接\n从别的程序员的GitHub书籍推荐过来的。 一本很小的书，一天可以读完。读来十分有趣，提供了一些思考问题和解决方案独特的方法和案例，很有启发。尤其是结合自己生活和工作中的一些经验和历史，互为印证，十分有趣。过去的很多困扰和烦恼也就没有了。比如，人们嘴上说要解决问题，其实上很多人并不是真心想解决的。这时候你去帮他，就是吃力不讨好。反而发现他真正的问题才是更重要的。很多问题都来源于某些人，因此，远离他们，很多问题和不幸就消失了。比如糟糕的老板和伴侣，原生家庭等。不过，作为我这样的按部就班的S人和J人还是很难操作和不适应，不过启发是巨大的。N人和P人怕是可以学到不少，而且十分适合。有意思的是，作者估计是上个世纪的程序员，举得例子和故事好多都是相关的。虽然只是几十年前的事情，但对于计算机行业来说已经是中古时代了。\n","categories":["读后感"],"tags":["Reading","你的灯亮着吗"]},{"title":"BUAA daily health report","url":"/2021/04/01/BUAA-daily-health-report/","content":"Auto daily health report solution for BUAA.\n\n 报告脚本\nimport requestsimport jsonimport timeimport datetimeheaders = &#123;    &#x27;Accept&#x27;: &#x27;application/json, text/javascript, */*; q=0.01&#x27;,    &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate, br&#x27;,    &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh;q=0.9,en;q=0.8&#x27;,    &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=UTF-8&#x27;,    &#x27;Host&#x27;: &#x27;app.buaa.edu.cn&#x27;,    &#x27;Sec-Fetch-Dest&#x27;: &#x27;empty&#x27;,    &#x27;Sec-Fetch-Mode&#x27;: &#x27;cors&#x27;,    &#x27;Sec-Fetch-Site&#x27;: &#x27;same-origin&#x27;,    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/80.0.3987.87 Chrome/80.0.3987.87 Safari/537.36&#x27;,    &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;,&#125;def report(uesrname, password, dataform):    x = requests.session()    # login, fetch cookies    print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime()))    print(&#x27;Logging in......&#x27;)    rep = x.post(        &#x27;https://app.buaa.edu.cn/uc/wap/login/check&#x27;,        data=&#123;            &#x27;username&#x27;: uesrname,            &#x27;password&#x27;: password         &#125;,        headers=headers,        timeout=360    )    print(rep.text)    print(rep.status_code)    print(&#x27;Save report......&#x27;)    saveReport = x.post(        &#x27;https://app.buaa.edu.cn/buaaxsncov/wap/default/save&#x27;,        headers=headers,        data = dataform    )    print(saveReport.text)    print(saveReport.status_code)    content = &#x27;sfzs=1&amp;bzxyy=&amp;bzxyy_other=&amp;brsfzc=1&amp;tw=&amp;sfcxzz=&amp;zdjg=&amp;zdjg_other=&amp;sfgl=&amp;gldd=&amp;gldd_other=&amp;glyy=&amp;glyy_other=&amp;gl_start=&amp;gl_end=&amp;sfmqjc=&amp;sfzc_14=1&amp;sfqw_14=0&amp;sfqw_14_remark=&amp;sfzgfx=0&amp;sfzgfx_remark=&amp;sfjc_14=0&amp;sfjc_14_remark=&amp;sfjcqz_14=0&amp;sfjcqz_14_remark=&amp;sfgtjz_14=0&amp;sfgtjz_14_remark=&amp;szsqqz=0&amp;sfyqk=&amp;szdd=1&amp;area=%E5%8C%97%E4%BA%AC%E5%B8%82%20%E6%B5%B7%E6%B7%80%E5%8C%BA&amp;city=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;province=%E5%8C%97%E4%BA%AC%E5%B8%82&amp;address=%E5%8C%97%E4%BA%AC%E5%B8%82%E6%B5%B7%E6%B7%80%E5%8C%BA%E8%8A%B1%E5%9B%AD%E8%B7%AF%E8%A1%97%E9%81%93%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%E5%AD%A6%E9%99%A2%E8%B7%AF%E6%A0%A1%E5%8C%BA&amp;geo_api_info=%7B%22type%22%3A%22complete%22%2C%22position%22%3A%7B%22Q%22%3A39.980937228733%2C%22R%22%3A116.35092936197998%2C%22lng%22%3A116.350929%2C%22lat%22%3A39.980937%7D%2C%22location_type%22%3A%22html5%22%2C%22message%22%3A%22Get%20geolocation%20success.Convert%20Success.Get%20address%20success.%22%2C%22accuracy%22%3A29%2C%22isConverted%22%3Atrue%2C%22status%22%3A1%2C%22addressComponent%22%3A%7B%22citycode%22%3A%22010%22%2C%22adcode%22%3A%22110108%22%2C%22businessAreas%22%3A%5B%7B%22name%22%3A%22%E4%BA%94%E9%81%93%E5%8F%A3%22%2C%22id%22%3A%22110108%22%2C%22location%22%3A%7B%22Q%22%3A39.99118%2C%22R%22%3A116.34157800000003%2C%22lng%22%3A116.341578%2C%22lat%22%3A39.99118%7D%7D%2C%7B%22name%22%3A%22%E7%89%A1%E4%B8%B9%E5%9B%AD%22%2C%22id%22%3A%22110108%22%2C%22location%22%3A%7B%22Q%22%3A39.977965%2C%22R%22%3A116.37172700000002%2C%22lng%22%3A116.371727%2C%22lat%22%3A39.977965%7D%7D%5D%2C%22neighborhoodType%22%3A%22%E7%94%9F%E6%B4%BB%E6%9C%8D%E5%8A%A1%3B%E7%94%9F%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%89%80%3B%E7%94%9F%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%9C%BA%E6%89%80%22%2C%22neighborhood%22%3A%22%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%22%2C%22building%22%3A%22%22%2C%22buildingType%22%3A%22%22%2C%22street%22%3A%22%E5%AD%A6%E9%99%A2%E8%B7%AF%22%2C%22streetNumber%22%3A%2237%E5%8F%B7%22%2C%22country%22%3A%22%E4%B8%AD%E5%9B%BD%22%2C%22province%22%3A%22%E5%8C%97%E4%BA%AC%E5%B8%82%22%2C%22city%22%3A%22%22%2C%22district%22%3A%22%E6%B5%B7%E6%B7%80%E5%8C%BA%22%2C%22township%22%3A%22%E8%8A%B1%E5%9B%AD%E8%B7%AF%E8%A1%97%E9%81%93%22%7D%2C%22formattedAddress%22%3A%22%E5%8C%97%E4%BA%AC%E5%B8%82%E6%B5%B7%E6%B7%80%E5%8C%BA%E8%8A%B1%E5%9B%AD%E8%B7%AF%E8%A1%97%E9%81%93%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%E5%8C%97%E4%BA%AC%E8%88%AA%E7%A9%BA%E8%88%AA%E5%A4%A9%E5%A4%A7%E5%AD%A6%E5%AD%A6%E9%99%A2%E8%B7%AF%E6%A0%A1%E5%8C%BA%22%2C%22roads%22%3A%5B%5D%2C%22crosses%22%3A%5B%5D%2C%22pois%22%3A%5B%5D%2C%22info%22%3A%22SUCCESS%22%7D&amp;gwdz=&amp;is_move=0&amp;move_reason=&amp;move_remark=&amp;realname=%E6%9D%A8%E6%A3%AE&amp;number=ZY1806711&amp;uid=305542&amp;created=1614692203&amp;date=20210302&amp;id=28752&amp;gwszdd=&#x27;def lambda_handler(event, context):    print(&#x27;Checking health info at &#123;&#125;...&#x27;.format(event[&#x27;time&#x27;]))    try:        report(&#x27;学号&#x27;, &#x27;密码&#x27;, content)    except:        print(&#x27;Check failed!&#x27;)        raise    else:        print(&#x27;Check passed!&#x27;)        return event[&#x27;time&#x27;]if __name__ == &#x27;__main__&#x27;:    print (lambda_handler(&#123;&#x27;time&#x27;: datetime.datetime.now()&#125;, &#123;&#125;))\n如果python脚本报错\n\n‘ascii’ codec can’t encode characters in position 12-15: ordinal not in range(128)\n\n应该是编码的问题，按照网络上的教程. 在命令前增加环境变量解决：\nPYTHONIOENCODING=utf-8 python report.py\n Cron 定时\n配合Unix/Linux的crontab，可以达到每天定时打卡的效果.\nrentaocron文件内容:\n16 18 * * * PYTHONIOENCODING=utf-8 python3 /home/rentao/workspace/report.py\n启动定时任务:\ncrontab rentaocron\n查看定时任务：\ncrontab -l\n 获得打卡地址\n Mac 配置代理服务器\nbrew install mitmproxy\n","categories":["折腾"]},{"title":"走单列指标拿北京户口","url":"/2022/01/12/Beijing-residence/","content":"户口作为中国特色的制度，一直以来是人们考虑工作、生活、定居的重要内容。从三十年前父辈们费尽心机从农村户口转到城市户口，到现在的我们，为了北京户口而煞费苦心。很多东西变了，但又有些东西没变。\n幸运的是，北京市今年也出台了《户口新规》。大多数内容都没变，只是其中的“单列指标”给了我们机会。\n 单列指标 解读：\n\n第十一条 以下引进项目实行计划单列：\n市委市政府重点支持的集成电路、人工智能、医药健康等高精尖产业，“两区”建设重点落地项目，本市市级“服务包”企业，重点税源、重点引进、重点培育企业以及独角兽企业，招聘世界大学综合排名前200位的国内高校本科及以上学历毕业生，或“双一流”建设学科硕士研究生；\n\n企业有资质。一般大公司基本都在名单上。如BAT，TMD，诸多外企也包含在内。\n员工有资质。世界前200本科及以上，被官方认可的是7所学校，清北交复浙南中（清华大学、北京大学、复旦大学、上海交通大学、浙江大学、中国科学技术大学、南京大学）。至于双一流硕士就多了，详见教育部名单。有很多学校和专业和名单上的不大一致，这个时候就需要看学校和学院的解释和往年案例了。因为我们今年是第一年，没有往年案例，只能摸着石头过河了。因为我们毕业时的专业是 北航 “计算机技术”，与名单中的“计算机科学与技术”不完全一致。但在实践中，还是算双一流的，符合落户要求的。\n一般去优秀的公司校招生基本都符合要求。比如我司今年17位国内院校的硕士毕业生，只有4个不在名单上。幸运的是，因为之前有2个户口名额。之前抽中户口的同学可以走单列了，把这2个名额空出来了。因此，4个人再分这2个名额。最后的结果是，绝大多数人都拿到了户口名额。\n另外，因为单列说的是2年以内毕业的同学。因此，除了我们21届的同学，20届和19届的也可以参加。最后，全公司有40+人走了单列。\n另外大家关心的一个很重要的问题是，1年指标 还是 3年指标。\n办理落户的2种名额需要满足交社保半年或三年，不过即使半年的名额，到落户完成基本也需要近一年，因此大家还是叫做 一年指标。\n不同于之前的名额指标，单列政府并不限制1年还是3年，交由公司和毕业生协商。比较良心的公司（比如 我司亚马逊），就会让同学们自己选。当然大家都选一年的了。\n但我也听说很多公司，甚至是大家熟悉的大厂（美团、字节等），会强制3年的，有甚者会签一个5年服务期的协议。3年落户后，如果干不到5年，需要赔偿公司钱。政府的用意是给公司节约用人成本，但这些厂真是吃相难看到不行。同情这些厂的同学们，人数还不少。在这5年服务期里任人宰割，薪资待遇还不涨，没法跳槽。\n 落户流程\n走不走单列，落户流程都差不多。像我们办手续都是和不走单列的2个同学一起办的。单列只是多出来了名额。\n这里的流程针对北京学校。但外地学校类似，区别可能只在三方和就业推荐表不同，需要提交补充材料。\n\n提交 就业推荐表 和 其他材料（如 毕业证、学位证 复印件） 给公司，公司整理后提交给人社局。（入职第一年的10月份）\n人社局公布引进名单。\n再次向公司提交材料，如 户口页复印件、首页等。公司审核通过后会有 接收函。（入职第一年的12月份）\n使用接收函在学校官网填写派遣信息。\n去学校领报到证，办理档案和户口迁出。\n等待第二年公司通知，会拿到派出所的落户单，然后就可以把户口落到公司的集体户口了。\n\n以上的公司，有时不是你签的公司，可能是为公司办理各种业务的中介公司。\n比如外企会把这些业务外包给FESCO，最后户口也是落在FESCO的集体户口上。\n细心的同学可以发现，上述步骤中并没有三方。是这样的，三方是先自己签，然后公司签，最后回学校签。有些学校办理派遣必须先签完三方，才能办理派遣。\n但像我们学校并没有这样的要求，所以三方签不签也问题不大。我还是跑了几趟签完三方了，以防之后有用得到的地方。\n 落户完成\n第二年4/5月份地时候。当你交社保超过半年，符合落户要求后，就可以提交社保证明了。有些如果是3年落户的朋友，那就需要交3年社保了。\n差不多第二年年底的时候，市人社局才会集中处理落户，我们会拿到集体户口所在地的派出所的落户单。这个时候，我们就可以去派出所落户，完成最后的落户流程。比方说 FESCO是北京朝外大街派出所。\n 时间线\n2021年9月，提交 就业推荐表 和 其他材料（如 毕业证、学位证 复印件） 给公司，公司整理后提交给人社局.\n人社局公布引进名单。\n2021年12月， 再次向公司提交材料，如 户口页复印件、首页等。公司审核通过后会有 接收函。（入职第一年的12月份）\n2022年3月，提供社保记录。\n2023年2月，拿落户单到派出所。FESCO是北京朝外大街派出所。\n","categories":["Life"],"tags":["北京","户口"]},{"title":"比利时交换之旅","url":"/2019/09/17/Beligum/","content":"今年的下半年，有幸有机会来比利时交换一学期，大概5个月时间。\n这是我首次出国这么长时间。之前也是参加学校的项目，去英国游学了半个月，详情可以看我3年前写的英伦游学所见所思。\n接下来，我从城市、生活、学习和旅行四个方面总结我的交换项目。\n 城市\n列日处于比利时的东南部，也是列日省的省会所在，与卢森堡、荷兰和德国接壤，也是比利时法语区第三大城市。很多前往欧洲上学的同学十分担心当地的治安和自身的安全。然而，列日就是一个十分安全的城市。在欧洲，往往越是小城市，越安全。像巴黎和布鲁塞尔相较之下可能遇到危险的概率就更大。我曾经就在布鲁塞尔差点被偷了包。在列日这样的小城市，街上的汽车都会主动为行人让路。有时候，一车公交的人等我过马路，我还有些不好意思，加快了脚下的步伐。虽然欧洲老龄化十分严重，但是列日作为一个大学城，这样的感觉并不明显，年轻人依然很多，整个城市充满活力。\n\n 生活\n西欧的生活节奏十分慢。一方面因为纬度高的原因，列日很早就天黑；另一方面，欧洲人生活压力小，十分讲究工作和生活的平衡。大多数商店都是6点关门，公共服务设施基本上5点关门，超市8点关门。从国内996的生活状态刚过来时会又些不适应，回来之后也是。\n比利时的生活成本在欧洲还是比较高的。欧洲是越靠北、越靠西的地区，越富有生活成本越高。维持最低生活水平的话，大概需要每月700欧元。如果想过的好些，再出去玩一玩，每个月大概需要1000欧元。\n西欧的天气在冬天以阴雨连绵为主，经常半个月见不到太阳，真的会影响心情。\n\n 学习\n我学习的是计算机专业的课程，在列日大学分属应用科学学院，所有的课程都被安排在一个位于城市南部的山上。而为了生活便利，我和大多数学生一样，选择住在市里。每天上课通勤乘坐40分钟的公交上山上学。课程难度整体并不大，但知识量很大，又是英文教学，所以需要投入大量时间。最 令我印象深刻的一点是，这里的课程和考试的时长几乎都为4个小时，有时会提前下课。长时间的课程对集中注意力是一项重大的考验，每次上完课都感觉筋疲力尽。\n\n 旅行\n比利时布鲁塞尔作为欧盟的总部，欧洲的交通枢纽，前往其他国家的机票都十分便宜。经常可以找到10欧的廉价机票，背上行李，来场说走就走的旅行。可以说，这里和欧洲的联系十分密切。欧洲作为近现代工业革命的起源地和西方列强的根据地，拥有从全世界搜集的众多瑰宝。其中，以卢浮宫和大英博物馆居首。像中国一样，列日也有一些公共假期。除了比利时的假期外，还专门有一天法语区的放假。利用这些假期，我们在欧洲进行了充分的旅游，极大地增长了自己的眼界和阅历。读了二十多年书后，终于有机会走万里路了。\n\n\n","categories":["dairy"],"tags":["travel","游记"]},{"title":"逃不开的经济周期 历史，理论与投资现实","url":"/2025/05/26/Business-cycles-history-theory-and-investment-reality/","content":"前30%特别有趣。因为其古老，充满故事性和传奇，人物也相对比较少，经济学知识对于现代人也容易理解。进入后凯恩斯时代后，变难好多。人物众多，学派众多，分歧也多。\n关于自由市场的最重要的核心事实在于，除非交易双方都获得好处，否则交易根本不可能发生。\n微观经济学是科学。宏观经济学就相对像是社会学。就像之前读过的“深奥的简洁 : 从混沌、复杂到地球生命的起源”。系统微小的变化带来不可计算的影响。\n通过研究股票市场来预测经济活动，要比通过研究经济来预测股票市场容易得多。\n狂热与崩溃曾是和普遍的非理性或者暴民心理结合在一起的。\n16种心理偏误：\n\n代表性效应：我们往往认为我们所观察到的趋势会继续下去。\n错误公式效应：我们往往高估与我们所见略同者的人数。\n后悔理论：我们试图避免可证实我们已经犯错的行为。\n定锚/框架：我们的决策受到隐约按时正确答案的信息的影响。\n同化误差：我们会误解接收到的信息，以为该信息认同我们所做的事。\n选择性接受：我们只能接受似乎认同自己行为与态度的信息。\n心理区隔：我们把现象区分为不同的隔间，并试着把每个隔间最适化，而非整体。\n选择性认知：我们曲解信息，好让其认同我们的行为与态度。\n过度自信行为：我们高估自己做出正确决策的能力。\n后见之明偏误：我们高估自己预测过去一连串事件后果的可能性。\n确认偏误：我们的结论不当地偏向我们想要相信的事。\n适应性态度：我们与熟识的人往往持相同的态度。\n社会比较：面对一个我们觉得难以理解的主题，我们以他人的行为作为信息的来源。\n认知不协调：我们试图回避或扭曲表明我们的假设错误的证据，我们也会避免强调这类不协调的行为。\n自我防卫功能：我们调适自己的态度，好让其似乎认同我们所做的决策。\n展望理论：我们有一种不理性的倾向，比较愿意赌亏损而不是赌获益，这意味着我们持有亏损头寸的时间长于持有获利头寸的时间。\n\n保罗 沃尔克：人们认为通货膨胀是一种残酷的，而且可能是最为残酷的税收，因为它给许多部门造成了意想不到的打击，而且给那些固定收入者造成了最大的损失。\n弗里德曼：无论何时何地，通货膨胀都是一种货币现象。要想控制通货膨胀，只需要控制货币供给。\n熊彼特 1939年：周期并不像扁桃体那样，是可以单独摘除的东西，而是像心跳一样，是有机体的核心。 约瑟夫\n","categories":["读后感"],"tags":["Reading","Business cycles history theory and investment reality","Economics"]},{"title":"2019 字节跳动夏令营","url":"/2019/09/06/ByteDance-Camp/","content":"总的体验是很开心，收获很大。\n很幸运可以参加今年的Byte Camp，我认为这一周的活动是我今年参加过的最有意义的活动了。今年的夏令营共分为3个赛道：工程、算法、和 产品。我参加的是工程赛道。\n工程和算法赛道进入夏令营的选拔都是通过笔试和面试完成的。笔试的题目也都一样，就是通过牛客网的平台在线完成。笔试有2次机会，都参加的话取分高的。笔试题目分为基础题（操作系统、计算机组成原理、计算机网络）和编程题。编程题有4题，难度依次递增。我参加的是第一场，AC了前3道，难度大约等于是LeetCode medium，最后一题的难度直接飙升到 ICPC world final的难度，要用费用流的知识。我也没打过ACM，第一次听说费用流，就没做出来。由于笔试答的还行，面试我没参加，直接拿到入营资格了。不过听参加面试的同学反映，面试也挺水的，难度很低。\n然后就是夏令营的正式活动了。活动虽然只有一周，但是日程安排的十分紧凑，基本是9 10 6。开幕式是有 AI-lab的主管 李航老师 主持。以前只在网上和书上久闻大名，这次竟然可以见到真人了，还有一起合影的机会。学机器学习的同学应该都听说过他，他的《统计学习方法》也是入门算法岗工作的维几之选。我们每人还获赠他签名的《统计学习方法》一书（工程赛道的同学可能对此不是很感冒，哈哈）。\n\n之后的日程主要分为2天的听课和3天的做项目。课程安排和项目都可以在官网上看到，每天要上7节课之多。课上也是干货满满，每个主题都是字节跳动内部负责相关技术的资深工程师负责讲解，从基础设施架构到前后端，覆盖工程的同学可能感兴趣和从事的所有内容。\n算法那边除了请公司内部的大牛之外，还有像 Yoshua Bengio、Oren Etzioni 这样的外部嘉宾参与。因为这2个人实在是太牛了（我也是后来才知道的，毕竟不搞算法），我们工程的也被要求参加他们的课程。课程内容倒是一般，比较入门和浅显（难道是为了照顾我们工程的孩子？），实质内容反而不多。\n我选择的项目是“服务治理：基于共享内存的高性能通信中间件”。说实话，我对共享内存和进程间通信不是特别熟，但是当时选题目的时候只有这个题目能看懂，其他的题目更是一头雾水，所以选择了“中间件”这一看起来比较靠谱的项目。（后来证明，这样的项目反而不如小游戏这样的项目容易拿奖，也更难完成）。项目的具体细节就不便透露了。我和交大的一位大佬一起完成，3天的时间里，完成了设计、实现、测试、性能测试、PPT和展示。别的组都是4～5人，我们组因为有2个队友提前退营了，只有2人。这3天的代码不是我写的最难的，但算是我这一年来写的最开心的了。白天写一天代码，晚上10点回到酒店里接着肝到一两点。（有五星级酒店住，也是我学校在北京，但仍和大家一起住酒店的原因。标间一晚九百多，很舒服）。我俩甚至把项目开源了：Yellow-Pay/MakeTheAmericanGreatAgain。在GitHub上可以搜到很多shm-ipc的库，我们的目的更多的是为了用git协同工作。\n\n\n上周五下午刚刚结束夏令营，回学校正式开工，才发现字节跳动的总部中航广场离学校如此之近。本来想坐地铁回来，可是走到知春里的时候发现，学校竟然只有半站路，就直接走回宿舍了。期待以后有机会可以和字节跳动有更多的接触，这么近的距离，偷偷出来实习一定很方便。\n总结一下我这一周的收获，重要程度从前向后：\n\n结识了很多小伙伴，其中不乏大佬。\n对字节跳动这个公司的氛围、技术栈有了比较深的了解。\n虽然很累，但整个活动我都很开心。\n\n最后，感谢为此次夏令营奔波劳碌的蔓莲姐姐和其他工作人员及志愿者。\n整个夏令营需要吐槽的地方有，希望明年能有所改善：\n\n开幕晚宴的饭菜比较难吃，不是太咸、就是太甜。\n中午没有休息的地方。虽然坐着6k元的椅子，但是靠背没有放脖子和脑袋的地方，每天只能靠着墙凑活睡了。到现在我腰还因此疼。\n\n","categories":["dairy"],"tags":["ByteDance","interview"]},{"title":"字节跳动 暑期实习 广告系统后端开发 面试","url":"/2020/02/27/Bytedance-Ads-backend-intern-interview/","content":"\nHashMap\n数据库\n\n索引、优化、事务\n聚簇索引和非聚簇索引\n\n\n并发编程\n网络编程，RPC\n算法题:\n\n编辑距离\n\n\n\n算法题问了一道计算编辑距离(Levenshtein Distance)的问题。编辑距离的问题恰好我在之前度《图解算法》的时候有所涉及，用DP解决即可。但本题目稍微复杂度写，需要在很多字符串中，寻找距离最近的字符串。可以理解为&quot;Fuzzy matching&quot;。\n题面大概为：\n莱文斯坦距离，又称 Levenshtein 距离，是编辑距离的一种。指两个字串之间，由一个转成另一个所需的最少编辑操作次数。允许的编辑操作包括：插入一个字符删除一个字符将一个字符替换成另一个字符需要你编写一个程序，实现以下功能：给定一个字符串集合 S 以及一个模板串 P，从 S 中找出与 P 莱文斯坦距离最小的字符串 T，输出 T 以及其对应的编辑距离 D。如果 S 中出现多个满足条件的字符串，则取按字典序排列的第一个。\n并没有想到很好的解法，暴力解法的话, 比较所有字符串和P的距离 时间复杂度为: O(P.size() * sum(S_i.size()).\n后在网上搜索解法，并不难找到。利用Trie以避免不同字符串的DP重复的计算，时间复杂度为: O(P.size() * Trie的节点数). 虽然最坏时间复杂度没有变好，但是实实在在的优化。应该这就是面试官想要的解法了。\n#include #include #include #include #include #include using namespace std;struct Node &#123;    array, 26&gt; children;    vector distance;    Node() = delete;    Node(int n) &#123;        distance.resize(n);    &#125;&#125;;pair solve(const string&amp; target, const vector&amp; s) &#123;    const int k = target.size() + 1;    auto root = make_shared(k);    for (int i = 0; i distance.size(); ++i) &#123;        root-&gt;distance[i] = i;    &#125;    int ans_distance = 0x3f3f3f3f,  ans_index = -1;    for (int j = 0; j &lt; s.size(); ++j) &#123;        const string&amp; str = s[j];        auto current = root;        // cout &lt;&lt; endl &lt;&lt; &quot;debug: &quot; &lt;&lt; str &lt;&lt; endl;        int distance_from_empty = 0;        for (char c : str) &#123;            if (current-&gt;children[c - &#x27;a&#x27;] == nullptr) &#123;                current-&gt;children[c - &#x27;a&#x27;] = make_shared(k);                auto next_current = current-&gt;children[c - &#x27;a&#x27;];                next_current-&gt;distance[0] = distance_from_empty;                for (int i = 1; i &lt; k; ++i) &#123;                    if (c == target[i - 1]) &#123;                        next_current-&gt;distance[i] = current-&gt;distance[i - 1];                    &#125; else &#123;                        next_current-&gt;distance[i] = min(&#123;                            current-&gt;distance[i - 1],                            current-&gt;distance[i],                            next_current-&gt;distance[i - 1]                        &#125;) + 1;                    &#125;                    // cout distance[i] &lt;&lt; &quot; &quot;;                &#125;                // cout &lt;&lt; endl;            &#125;            current = current-&gt;children[c - &#x27;a&#x27;];            ++distance_from_empty;        &#125;        if (current-&gt;distance[k - 1] &lt; ans_distance) &#123;            ans_distance = current-&gt;distance[k - 1];            ans_index = j;        &#125; else  if (current-&gt;distance[k - 1] == ans_distance) &#123;            if (s[ans_index] &gt; s[j])                ans_index = j;        &#125;    &#125;    return &#123;ans_distance, s[ans_index]&#125;;&#125;int main() &#123;    string P;    cin &gt;&gt; P;    int N;    cin &gt;&gt; N;    vector S(N);    for (int i = 0; i &lt; N; ++i) &#123;        cin &gt;&gt; S[i];    &#125;    auto ans = solve(P, S);    cout &lt;&lt; ans.first &lt;&lt; endl;    cout &lt;&lt; ans.second &lt;&lt; endl;    return 0;&#125;","categories":["interview"],"tags":["intern","ByteDance"]},{"title":"Bytedance 秋招面试 2020","url":"/2020/06/23/Bytedance-new-graduate-interview/","content":"我字节跳动提前批投了 技术中台 的 后端开发岗位。\n计算机基础没复习到位，答得不好。\n许愿offer。\n 一面\n我自介绍。\n 算法题\n先给暴力解，再优化。\n\n题目：数组代表股票每天价格，每天只允许买或者卖一次，也可以不买卖，需要先买入才能卖出，在只交易一次（即只买和卖一次）的情况下求最大收益。\n输入：[2,1,4,1,5,6,1]\n输出： 5\n\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int solution(const vector&lt;int&gt;&amp; prices) &#123;    // time: N ^ 2    // space: 1    int ans = 0;    for (int buy = 0; buy &lt; prices.size(); ++buy) &#123;        for (int sell = buy + 1; sell &lt; prices.size(); ++sell) &#123;            int profit = prices[sell] - prices[buy];            ans = max(ans, profit);        &#125;    &#125;    return ans;&#125;int solution2(const vector&lt;int&gt;&amp; prices) &#123;    // time: O(N)    // space: 1    int ans = 0;    if (prices.empty()) return 0;    int minPrices = prices[0];    for (int sell = 1; sell &lt; prices.size(); ++sell) &#123;        int profit = prices[sell] - minPrices;        ans = max(ans, profit);        minPrices = min(minPrices, prices[sell]);    &#125;    return ans;&#125;int main() &#123;    //int a;    //cin &gt;&gt; a;    //cout &lt;&lt; a &lt;&lt; endl;    vector&lt;int&gt; prices = &#123;2,1,4,1,5,6,1&#125;;    cout &lt;&lt; solution2(prices) &lt;&lt; endl;&#125;\n 计算机基础\n 操作系统\nIPC 种类\n信号量\n进程 和 线程\n各有几种状态、状态转移图。\n虚拟内存\nLinux的一些常用命令, 今天刚复习过。\n如 查看端口、内存、进程状态.\n进程的current working directory: lsof -p &lt;PID&gt; | grep cwd\n 计算机网络\n3次握手 4次挥手 的过程和必要性. 答的很糟糕。\n 数据库\n几种范式\n深入了解吗？不了解\n 语言\npython\n\nGIL\n引用还是值\n\n贵组大概率是写python的。\n 总结\n昨天约了今天的面试，失误呀。太过仓促。本来秋招提前批是很重要的，计算机基础知识就是题库里的那些题，花3天时间背背还是有必要的。要不靠着本科时学的知识，回答不会太好，会很伤。\n好多同学问题库在哪里。我也是在网上找的，https://github.com/CyC2018/CS-Notes\n感觉还是挺全的. 已经在背了。\n","categories":["interview"],"tags":["ByteDance","New Graduate"]},{"title":"深奥的简洁 从混沌、复杂到地球生命的起源","url":"/2024/09/15/Chaos-Complexity-and-the-Emergence-of-Life/","content":"每周一本书22：深奥的简洁 从混沌、复杂到地球生命的起源\n“穷查理宝典”推荐的书籍，从混沌的角度理解宇宙、生命和社会，十分有趣的角度。通过混沌，这一数学上的概念，把宇宙中很多事情都穿起来了。虽然我们有许多的物理学知识，看似对世界了解很多，可以做到预测历史和未来，像拉普拉斯认为的那样。但事实和理论证明了，这是不可能的。计算宇宙最好也是唯一的方案就是宇宙本身，无法在宇宙中制作出这样的机器或生命，去计算和预测宇宙。这是数学的限制，如果像很多先贤说的那样，数学是上帝的语言。那看来这一语言也是天生有限制的，不是全知全能的。当然数学也一直在进展，但从目前的证明来看，很多方程是没有解析解的。迭代解注定是蝴蝶效应。相比“迷人的温度”那本书稍差。虽然我自认为有一定的数理基础背景，但还是被本书的数学和论证搞得有些糊涂了。\n有意思的是，前一本书提到“流浪地球”的方案。本书则是以，“三体”问题开端。三体问题不可解，不是物理的错，而是数学的错，而且是数学已经证明了不可解。因此，如果“地球往事”里，三体组织的拯救派看过这部作品，也就会放弃拯救“主”的想法。当然，“三体”书中，最后拯救派也证明了此事，并且在与降临派的斗争中失败。可以说，他们的策略从根上就是不可能和注定失败的。\n","categories":["读后感"],"tags":["Reading","深奥的简洁"]},{"title":"Codeforces Educational Codeforces Round 151","url":"/2023/07/01/Codeforces-Educational-Codeforces-Round-151/","content":"比赛链接\n官方题解\n做出了前2题，卡在第三题了。\nRating change: 1407 -&gt; 1378\n A. Forbidden Integer\n分类讨论。如果可以选1的话，那肯定可以组成任意数字。\n如果不能的话，可以选2和3，也可以组成除1以外任意的数字。\n如果只能选2的话，那么只能组成偶数。\n时间复杂度: O(t * n),\nt = int(input())for _ in range(t):    n, k, x = map(int, input().split())    if x == 1:        if k == 1:            print(&#x27;NO&#x27;)            continue        elif k == 2:            if n % 2 == 0:                print(&#x27;YES&#x27;)                print(n//2)                for _ in range(n//2):                    print(2, end=&#x27; &#x27;)                print()            else:                print(&#x27;NO&#x27;)                continue        else:            print(&#x27;YES&#x27;)            print(n//2)            while n &gt; 3:                print(2, end=&#x27; &#x27;)                n -= 2            print(n)    else:        print(&#x27;YES&#x27;)        print(n)        for _ in range(n):            print(1, end=&#x27; &#x27;)        print()\n B. Come Together\n分类讨论，B，C 在不同象限，最长公用路线不同。\n时间复杂度: O(t),\n空间复杂度: O(1).\nt = int(input())for _ in range(t):    A = list(map(int, input().split()))    B = list(map(int, input().split()))    C = list(map(int, input().split()))    B[0] = B[0] - A[0]    B[1] = B[1] - A[1]    C[0] = C[0] - A[0]    C[1] = C[1] - A[1]    # if B and C are in the same quadrant    if (B[0] * C[0] &gt; 0 and B[1] * C[1] &gt; 0) \\        or (B[0] * C[0] == 0 and B[1] * C[1] &gt; 0) \\        or (B[0] * C[0] &gt; 0 and B[1] * C[1] == 0):        print(min(abs(B[0]), abs(C[0])) + 1 + min(abs(B[1]), abs(C[1])) + 1 - 1)    elif B[0] * C[0] &lt;= 0 and B[1] * C[1] &gt; 0: # the same side but different quadrant        print(min(abs(B[1]), abs(C[1])) + 1)    elif B[0] * C[0] &gt; 0 and B[1] * C[1] &lt;= 0: # the same side but different quadrant        print(min(abs(B[0]), abs(C[0])) + 1)    else: # opposite quadrant        print(1)\n C. Strong Password\n暴力方法很简单，回溯枚举所有符合l, r限制的密码，然后判断是否是s的子序列。\n然而，回溯这步时间复杂度就是对数的了。\n正确的解法是贪心，对于每个位置，尽量取其在s中最靠右的数。\n时间复杂度: O(m*D + n), n = s.length, D = r_i - l_i = 10\n","categories":["Programming"],"tags":["codeforces","contest"]},{"title":"日常 | 去景驰实习前发些牢骚","url":"/2018/10/28/Complain-before-Weride-internship/","content":"版权归作者所有，任何形式转载请联系作者。\n作者：YoungForest（来自豆瓣）\n来源：https://www.douban.com/note/694767558/\n最近总有一种感受，自己无法掌控自己的生活和人生。\n首先，快快乐乐的活着 和 努力成为别人期望的样子 到底哪个更重要些？现在我更认可后者。我从小就是别人家的孩子，很乖、很听话。不玩电子游戏、不早恋、不打架，学习成绩好。但是这样的日子开心吗？不见得。现在即使大学都毕业了，早已泯然众人了，仍然免不了越来越活成别人期望的样子，甚至自己也认为这样的生活好像更有意义一些。说到底，我还是一个“社会”中的人。需要父母、同学、老师、朋友的肯定 才能继续走下去。\n其次，读了研究生后，我的生活一点也不开心。因为要上很多我不想上的课，为了那个不知道究竟有什么用的破航的学位证。还有，有了导师后，很多时候还需要应付导师。我并不是一个“会办事”和会“阳奉阴违”应付老师的人。所以很多时候，需要花时间做老师要求的，但自己不想做也看不到好处的事情。比如说 写论文（水会论文而已，不知道有什么用），去景驰搬砖（每月才发1k，连吃饭都不够）。\n最后，motivation。我做事的motivation总是不够，在加上自己比较懒，许多事情竟然就做不成了。比如说 考英语，比如说 找一份很好的实习。这些事情明明做好了长期看好处还是很大的，然而还是motivation和passion不足。我现在好像对什么都提不起兴趣了，竟然只想浑浑噩噩。真是太可怕了。\n吐槽归吐槽。我还是会全力以赴去实习的，然后不断地试着去掌控自己的生活和人生，利用零碎时间去成为自己想成为的人。\np.s. 为什么说是零碎时间呢？我们现在课程压力已经很大了，我又要去实习，整块的时间可以说已经很少了。\n","categories":["Life"],"tags":["Weride"]},{"title":"C++ 中实现生成器(Generator, yield in Python)","url":"/2019/12/15/Cpp-generator-implement/","content":"问题的起因是因为LeetCode上的一个题目1286. Iterator for Combination。最完美的实现是利用 生成器(Generator)，也就是Python中的yield。但是我不会，只实现了一个提前计算，然后存起来的解法。并不优雅，赛后，学习了一个C++中Generator的实现，在此分享下。因为我并未在网上找到很好的中文的关于此的文章。\n","categories":["Programming"],"tags":["C++"]},{"title":"民主的细节","url":"/2024/01/17/Details-of-Democracy/","content":"全书都是由小文章和小故事组成，本身是作者在报纸专栏上地投稿（“南方人物周刊”，想想南方系的下场和现状，和15年前的鼎盛。真是唏嘘），然后才集合成本书。因此，对于某项主题和故事地讨论并不深入和细致，相比 林达 地《近距离看美国》差很多。但是，还是推荐每个国民，尤其是对公民运动感兴趣地中国人去阅读。读书门槛很低，也相当直白和有趣。成书于09年，主要是01-08年写就地故事。而国内外局势在近15年已经发生了很大变化。所以有些可能过时和不切实际。但并不影响现在的阅读价值。当年还可以反思和说话，现在已经噤若寒蝉。尤其是最近24年1月份，TW也进行了大选，更是“皿煮”成为大家感兴趣和反思的事情。虽然现状可能离作者的期许越来越远，但希望大家都平安无事吧。待天下有变，这些早年的公众人物还可以发光发热。总之，去读，但不要说话。\n真是很多金句和讽刺对比。\n\n没有自由的“民主”，最终会蜕化成为以民粹面目出现的极权主义。\n\n书中竟然还可以对比和反思WG和3年，可以想象15年前出版审查和言论管制的相对放松。\n\n把牛鬼蛇神死死关进盒子里不让透气，民意反而像个不断升温却没有出气口的高压锅一样，慢慢凝聚越来越危险的压力。\n\n国服的体制真是被美国吊打。同时推荐 林达 的《近距离看美国》系列，更好地了解美国背后的制度运行和历史。\n\n民意无法得到反映，最后只能迎来剧烈的革命\n\n尤其是在2024年的今天，越发的明白了自由的重要性。\n","categories":["读后感"],"tags":["Reading","你的灯亮着吗"]},{"title":"Django使用总结","url":"/2017/01/23/Django-note/","content":"[摘要] Django 是一个高水平的Python Web框架, 可以帮助我们迅速开发, 设计一个干净, 程序化的应用. 虽然Django比较臃肿(现在大神都用Flask?), 适合大型Web应用的开发, 笔者的数据库课程设计是一个小型工程, 但Django名声是在太大, 笔者之前在实验室也稍稍接触过, 所以和队友果断选择了Django. 我们的课设, 在Django的帮助下, 实现起来就和切菜一样.\n\n数据库课设最近出分了, 只得了良好, 未如愿取得优秀. 但两天完成数据库的经验确实使笔者学到了很多, Django框架的使用, 前后端的概念, 结对编程的合作… 其中最想和大家分享的是Django框架的使用, 幸亏有该框架, 让我们可以专注于后端和数据库的设计实现, 还能轻松实现一个看得过去的前端. 事半功倍, 没有被拖延症害死.\n 时间分配:\n完成数据库用了两天(而且有一天是边刷&quot;潜伏&quot;边写程序的), 之前都是在学习Django, 文档甚至大部分是答辩完之后补完的.\n 人员分配:\n原本的计划是抱tls大腿, 所有前后端由tls完成, 笔者帮助写写文档. 不过后来, 鉴于tls经常养精蓄锐, 一直在学习Django, 最后几个小时仍未有看的见的成果. 笔者就慌了, 在之前练习的基础上, 修补完善, 勉强实现预计功能, 完成课设. 最后文档是两个人一起紧急补完的, tls最后一个小时又帮助实现了两个新功能.\n Django使用总结\n官方文档是很完善和亲民的, 需要用的功能都可以在上面找到. 缺点是, 太庞大, 不好找; 而且是英文的, 官方文档更新太快, 中文文档的翻译根本跟不上, 笔者的六级刚刚飘过, 很是头疼, 不过仍是喜欢看官方的英文文档, 感觉更有帮助.\n 练习\n笔者是跟着andrew-liu的用Django搭建博客的教程, 熟悉一步步的命令和操作的. 这个教程很适合初学者用来熟悉Django的基础命令和文件结构. 但一个明显的恶果是, 最后, 我们的课设电动汽车充电站管理系统的效果看上去和博客差不多.\n 总结\n这篇post干货比较少, 实在是因为笔者学艺不精, 没有更过可以分享的. 如果下次要需要再次使用Django, 笔者一定会回来再次补充的.\n","tags":["Database","Django"]},{"title":"Effective Modern C++","url":"/2019/05/05/Effective-Modern-C/","content":"我的书评\n","categories":["书评"],"tags":["C++","C++11"]},{"title":"埃隆·马斯克传 Elon Musk","url":"/2024/03/07/Elon-Musk/","content":"豆瓣链接\n放弃英文版，转到翻译版果然是个正确的选择。38万字，一周看完，太爽了。尤其是从2000后第一个十年那段，关于SpaceX和Tesla的初创阶段，真的是振奋人心，改变人类历史进程的冒险。相比原版，是有些删减的，主要是关于中国部分。我对照着看了下，其实不多，为了过审可以理解。\n全书其实可以分为几个部分：\n71-94: 南非的成长，移民妈妈的祖籍加拿大，转学美国宾夕法尼亚。\n95-02: 互联网泡沫，转战硅谷创业，公司黄页Zip2, 支付网络X.com, PayPal\n00-10: 我最喜欢的部分，关于SpaceX和Tesla的初创阶段。尤其是SpaceX，真是靠一己之力改变整个行业和美国，仍是私有企业，甚至不用上市融资。\n10-20: Tesla和SpaceX 的成熟阶段。虽然也有星舰和Model 3+Y，但没那么激动人心了。同期还有人工智能OpenAI，脑机接口 Nerolink，挖隧道公司 Boring Company,\n21-23: 最后的几年，作者写的很详细。主要还是作者为了写传记一直跟着马斯克这几年，有很多信息和资料。收购推特是其中最引人注目的剧情。推特员工真是从天堂掉入地狱，私有化后，被裁75%。不像Tesla 和 SpaceX的工程师，他们一开始就在马斯克手下，已经习惯了。推特真是天降暴君。作为一名程序员，真是十分同情他们。\n看完之后不敢坐特斯拉了，马斯克为了节省成本太拼了。他有一套5步工作法，用来加速制造和节省成本。简单来说，就是质疑一切标准（行业标准，国家标准），删掉尽可能多的东西（删掉后，如果不行，再拿回来。如果拿回来的东西不够删的10%，说明删的不够多）。比如本来行业标准应该拧4棵螺丝，他就拧2棵，认为够了，一测试，也没问题。他做事情很激进。给我一种国服领导人的感觉，喜欢搞运动式生产，各种大跃进。造火箭也是类似的。炸了没事儿，都是实验，快速推动测试。\n正如书中所说，没有马斯克的话，电动车也会出来，只是晚十年。但火星殖民可能会晚更多。甚至在人类灭亡之前能不能出去也未可知。人类是在和AI赛跑。AI的优势在于发展快，但人类有先发优势，积累很多。在地球呆着或早或晚要灭绝。就像卡尔萨根说的那样，人类要么遍布星辰大海，要么彻底灭绝，没有中间状态。我对人类文明的未来还是充满希望的。\n更坚定了我All in TSLA的信念。今天股价176，市值5600亿美元。我的成本 190。\n","categories":["读后感"],"tags":["Reading","埃隆·马斯克传"]},{"title":"留学在欧洲，聊聊关于银行和钱的事儿","url":"/2019/12/07/Europe-bank-accounts/","content":"本学期有幸来比利时交换一学期，在“钱”上遇到很多困难，在同学的帮助下逐步克服。在此感谢帮助过我的一系列好友，并将自己的经验分享给大家，让更多的人收益。\n在全球化的今天，来到欧洲，如何方便的花钱，省钱，是每个留学生关心的事情。在欧洲花钱基本可以分为2类：现金、刷卡。2者是相辅相成的关系，并不像在国内，一部手机走天下。\n我的经历是：在国内换了700欧的现金带过来，还带了一张招商银行的Visa全币种信用卡。因为办签证需要经济证明，我还提前转了3000多欧给学校的账户，学校之后每个月给我的账户返还666欧，作为生活费。来了之后，我分别办了 ING的Green Account，网上银行 Revult, Curve, Bunq, Monese; 配置了Google Pay 和 PayPal。并经过到欧洲到处自由行，结合不同的花钱方式，达到最便利和最省钱。\n接下来，我分别介绍各种方式的办理方法和优缺点。\n 现金 和 刷卡\n在刚来比利时的时候，从国内带足够的现金是必要的，心里也有底。我带了700欧，事实证明，在有信用卡夹持的情况下，这些绰绰有余。比利时作为欧洲最发达的地区之一，刷卡几乎可以覆盖大多数消费场景。甚至一些大额的消费，如交房租，必须刷卡。幸好我信用卡的额度足够，在第一次交房租时，我还需要替同行的2个同学帮付。这时候就体现出国带信用卡的好处了。\n 现金\n\n在欧洲，身上带少量现金是必要的。尤其是50分的硬币，因为这里很多公共卫生间都是收费的，大多数是50分, 这可是救命钱。我建议多带些5欧的钱，面额越大，用处越小，越不方便。在某些消费场合，比如集市、地摊，也只能用现金。在欧洲某些相对欠发达地区，如希腊、意大利，不能刷卡的场合也比较多。西欧和北欧相对好很多，丹麦甚至上厕所都能刷卡。\n 信用卡\n\n信用卡最大的好处是方便，支持全币种，人民币还款。还款可以直接向信用卡转账，所以父母在国内也可以很方便地还款。招商银行还根据你的消费地点，提醒你可以提高临时额度，满足境外的大额消费需求。招行也是相对容易给学生办下卡的一家银行，并且额度还不错。\n缺点是：\n\n并不足够经济。具体的汇率可以在kylc网站上查到。招行信用卡的还款策略是：当你消费非美元的货币时，先根据Visa的汇率购入美元入账，过2天再根据招行的汇率换成人民币。虽然没有所谓的货币转换费（DCC），但其实招行的汇率并不好，尤其是相比 中国银行。相比下面介绍的网上银行，和私下换hui, 也不很经济。\n容易多花钱。这是信用卡的通病，在国内也一样。每个月出账单和还款的时候，才发现自己竟然花了这么多钱。\n\n如果有想办该卡的小伙伴，可以找有卡的同学推荐，这样2个人都可以获得不错的礼物。\n 传统银行 ING\n\n因为我门需要学校返还生活费，必须办理账户。在大多数银行办理账户都需要居留卡，只有在ING办理只需要临时的居留证明即可，也即15号文件。我办的是一种年费40欧的Green Account，每3个月扣10欧。后来听说可以办更实惠的Lion Account，这种账户面向25岁以下青年，还会给你40欧。\nING办卡需要先预约，然后再开户。前前后后大概需要2周多时间才能拿到卡片。拿到卡片后，如果使用网上银行或是手机银行，还需要一个类似U盾的Reader。这个Reader按理说会和卡片一起寄给你。但是我们几个人都没有收到，后来特意从官网上又重新申请了一个，大概3天后就得到了。\nING卡会给你一个比利时的账户和一张卡片。\n账户可以用来收钱和转账。同银行间转账一般即刻到账，跨行转账需要一个工作日。这个账户还可以绑定PayPal进行网上支付。\n卡片支持Maestro支付和Bancontact支付。2种支付渠道都比较有限，无法和Visa或MasterCard相比。尤其是Bancontact, 是比利时的一家公司控制的支付渠道，基本上出了比利时就不能用了。Bancontact也支持手机和线上支付，不过基本上也是比利时的公司和网站会使用。而且这张卡片没有CVV码，这意味着很多线上支付的场景无法使用。\nING的刷卡消费也不是即时提醒的，需要等几个工作日。所以消费起来无法立刻知道扣了多少钱。作为国人可能心中不安，这里的人好像都习惯这种消费方式了，也不会出现多扣钱的情况。\n我通常的处理方式是，把大钱放在ING账户里，转小钱给其他网上银行的账户，方便消费。\nING 还有个缺点是换汇的汇率比较差，大概会比市场上的汇率差个10%。而且需要提前预约。线上预约需要7个工作日，可以订面值，线下预约快一些，大概3个工作日，但不可以订面值，十分不方便。我换过一次匈牙利福林，拿了9张1万块就回来了（事实上只相当于大概300欧）。\n 网上银行\n欧洲是银行业的起源地，银行业十分发达，金融经济等制度十分完善。除了传统的银行外，还有很多网上银行的存在。这些网上银行解决了传统银行的诸多痛点：\n\n收费高\n效率底\n不方便\n余额变更提醒不及时\n\n经台湾同胞Benjemin推荐和我的自己摸索，我共尝试了4种网上银行，它们功能和解决的需求各不相同。大家有旅行需求和线上消费需求的一定要尝试下，会发现欧洲的生活其实还是很方便的。\n\nRevult\nCurve\nBunq\nMonese\n\n各家网上银行的认证大同小异，都需要上传你在欧洲居住的证明，可以是 护照 + 签证，也可以是 居留卡。从我的经验看来，用居留卡办审核更容易通过些。\n Revolt\n\n名气最大的网上银行，会给你一个英国的账户，支持多种货币，每种货币之前兑换的话，使用很经济的interbank rate。可以免费预订一张实体卡片和多张虚拟卡。\n我开通了一张实体卡片和一张虚拟卡。\n虚拟卡可以用以网上支付，绑定Google Pay和 PayPal，和Curve（结合Curve使用有奇效）。\n实体卡片会邮寄给你，大约2周时间，使用起来和普通的卡片没有区别。\n实体卡片就有丢失和被盗的风险。我的卡片就在伊斯坦布尔取钱的时候被ATM吞了，好在网上银行都可以立刻冻结和挂失，没有造成更大的损失。我马上预定了第二张实体卡片，不过第二张就要花大概2欧了。\nRevolt作为我的主力网上银行使用。我通常从ING转账到Revolt，保证它的余额在100～200欧。实体卡随身携带，方便消费。虚拟卡 绑定Google Pay，PayPal，Curve，发挥最大作用。\n去非欧元区旅行时，提前在APP上换好汇，再去机场的ATM取出来即可。可能有3.5%左右的取款费，但省掉了货币转换费（DCC），也比从ING换汇或机场换汇要好很多。\n其突出的优点是：\n\n下卡快、开户方便\n余额变化实时提醒\n换汇汇率比较好\n支持虚拟卡，有CVV码\n\n推广链接\n N26\nN26 是一家德国的网上银行，和Revult类似。也是给你一个德国的账户，支持多种货币消费，使用很经济的interbank rate。\n虚拟卡是免费的，可以绑定到Google Pay上消费。\n实体卡片需要10欧的邮寄费。我没有申请，只花钱买了张Revolut的卡。大多数情况下，Google Pay就够用了。实习卡只是以防极端情况下手机没电了。\nN26 推广链接\n Curve\n\nCurve也是一家英国的网上银行，主打功能是 集合多张银行卡到一张卡，省去货币转化费。\n这也是我的第二主力卡。英国果然是金融中心，网上银行的先行者。\n它工作的原理是：你申请通过后，会给你发一张MasterCard的贮蓄卡。但并没有真正的银行账户，你可以在APP上绑定多张别的银行的卡片，只要有CVV码就可以。刷卡消费时，真正扣款的是后面的这张卡。Curve卡相当于是一个代理的功能。\n学过设计模式之代理模式的同学应该都知道，有了这层代理，我们可以干很多事情。比如，\n\n免除货币转化费。消费外币时，用Curve进行购汇，实际扣除后面那张银行卡的货币类型就是它本身的货币类型了。即 将换汇的操作挪到Curve进行。Curve采用的也是很好的interbank rate。需要注意的一点是 千万不要周末使用换汇功能，周末伦敦货币交易市场关门，就产生0.5%-1.5%的货币转换费。\n伪装信用卡到储蓄卡。信用卡有许多好处，少数场合需要信用的地方不能使用储蓄卡，如 租车、在 booking上担保。但也有一些场合只能用储蓄卡（我目前还没有遇到，国内支付宝消费的时候，倒是经常遇到不能用花呗的场景）。这时，就可以刷Curve卡，扣款的其实是信用卡。\n出门只带一张卡。这也是其杀手特性。现代社会，很多人有多张银行卡，在不同的场景下需要使用不同的卡片，这时，只需要在APP里切换卡片就可以了。\n\n缺点是目前还不支持欧洲地区的Google Pay。无法和Google Pay结合实现更骚的操作。\n推广码，可以赠送5英镑哦：\nI’m using @imaginecurve! All my cards in one + a great way to save &amp; manage money. Sign up with code DL6LOLZE &amp; get £5 https://curve.page.link/HyuYB\n Bunq\n\n这是一家荷兰的银行。会给你一张银行卡（彩虹卡）和一个荷兰的银行账户。主打的也是旅行时消除货币转换费。荷兰账户也可以干更多的事情，比如开通iDEAL Payment，这是荷兰版的Bancontact。一些荷兰的公司和网站用此支付手段有优惠。\n另外改账户还有一个杀手特性：从信用卡中Top Up，也就是我们常说的套现。结合信用卡，可以发挥各种资产运作，如 扩大现金流。\n Monese\n同样是一家英国的网上银行，会给你一个英国的账户和一张银行卡。\n优点和其他网上银行类似，我也用的比较少，开发程度低。\n缺点是 只有英镑(GBP)和欧元(EUR) 的账户。\n 支付方式\n除了常见的用卡支付外，欧洲还流行2种支付方式\n\nGoogle Pay\nPay Pal\n一些功能有些像 支付宝。\n\n Google Pay\n支持线下的非接触支付和线上支付（通常通过手机）。\n由于国内买的安卓手机，Google服务一般是被阉割的，是否能用还需要看你具体的手机型号。\n我使用的是 小米9，通过一些配置就可以正常使用Google Pay。\n只需要把系统默认的钱包从 “小米钱包”更改为“HEC钱包”即可。\n线下刷手机真的是及其方便，不需要掏卡，甚至不需要解锁。比国内扫二维码 或 出示付款码 都更方便。\n除此之外，Google Pay还可以集合各种会员卡。在欧洲这里和国内一样，许多超市会发行会员卡，有积分和打折。可以使用Google Pay录入会员卡的 条形码 或 二维码，付款时可以很方便地调出来，减少了保管和掏实体卡片的麻烦。\n Pay Pal\nPayPal 主要解决的是线上支付问题。在欧洲买个机票，订个旅店，除了直接用卡支付外，很多支持且只支持PayPal。PayPal可以绑定ING的银行账户和网上银行的卡，也可以绑定信用卡，和支付宝很像。除了方便网上支付外，它还有个汇率上的优点。当你支付货币和卡里的钱不一样时，你可以选择通过PayPal直接换汇，可能会比银行的汇率要好。\n","categories":["Life"],"tags":["bank","money","Europe"]},{"title":"从北京到都柏林 一名程序员的润欧之旅","url":"/2022/12/09/Find-a-Europe-SDE-job-from-China/","content":"转自我的博客\n今年，我按照预期计划，从国内投欧洲程序员的岗位，虽然赶上宏观经济下行，各个公司纷纷hire freeze甚至layoff。幸运地，还是拿到了2个offer，并在11月成功入职完成肉翻。虽然历经了不少坎坷，回过头看也算是一切顺利。在“润”地道路上被很多有经验地群友帮助，因此我也撰写一篇博客，总结自己地经验和教训，以方便后来人。\n\n 背景\n首先给不熟悉我的朋友简单介绍一下我的背景。\n在北京某校读了计算机本硕。\n读书时从大四开始有过不少实习经历，先后在小厂、大厂，人工智能、自动驾驶，国内互联网、外企干过一段时间，在学校也有长期的科研经历。\n实习是不错的成本比较低的试错机会。\n经过这些尝试，结合自己的实际情况，我确定了自己的目标。找工作，而非科研。去大厂，而不是小厂。来外企，而非国内企业。\n在2020年初，因为ex的原因，确定了要润到欧洲工作的计划。她因为10043的限制，去不了美国读书。她也对国内深造不感兴趣，所以当时决定选择欧洲的院校深造。打算2022年秋来读硕士。\n2021年硕士毕业后，如愿在北京某国际知名外企工作了一年零4个月时间。这段经历在简历上也极大地帮助我拿到不少面试。\n新加坡、日本、欧洲、加拿大、澳洲 都是程序员润的热门目的地。\n和美国相比，这些地区工签制度十分友好，基本只要拿到offer，都能轻松办下工签。\n同时很多发达国家拥有从出生到坟墓的福利制度，尤其适合逃离国内996而且拖家带口的同行们。\n最重要的是工作机会多，竞争压力小，有大量面向海外招人的岗位。从我的经验来看，不考虑语言挑战的话，面试难度是远小于国内的。\n本文虽然是以投欧洲为背景，不过大多数经验也是对其他地区有帮助的。尤其是投谷歌、亚马逊、微软这种美企的。\n 时间线\n3月开始在Stack Overflow（现在Jobs板块已关闭）、Google Jobs、LinkedIn上海投，也找了不少朋友内推。我投的工作地点主要以荷兰为主，也投了德国、爱尔兰、英国等其他国家。\n这段时间以中小公司为主，想在投大厂前多练练。但并不理想，大多数直接被据，只有4个面试。\n4月底开始投大厂，当然海投一直没停，最后投了近40个厂，有8家面试，2家offer。阿姆本地的大厂岗位只有 Amazon、Uber和Booking。微软投了都柏林，谷歌投了慕尼黑。\n因为我本身在Amazon工作，因此外部没法投。内部投又有跨国岗位需要L5(SDE 2) + 1年的限制，我不满足。虽然内部聊了几个经理，但都不能给exception。因此错失了Amazon在欧洲的工作机会。Uber 在约Phone Interview时，hire freeze了，对面直接找不到人了。Booking干脆没拿到面试。\n6月面了微软和谷歌。\n微软是一次Online Assessment (3道算法题，LeetCode Medium难度) + 3 轮Virtual Onsite (Algorithm + Behavior Questions, Software Design + Behavior Questions, System Design + Behavior Questions) + 1轮Virtual Onnsite (Behavior Questions)。可以看出微软Behavior Questions的比重很大，每轮都有。Software Design其实就是OOD (Oriented Object Design), 我因为理解错了没有准备对，第二轮面的有些糟糕。不过最后还是拿到了Offer。\n谷歌是 1轮Phone Interview (Algorithm) + 4轮 Virtual Onsite (3轮 Algorithm + 1轮Behavior Questions)。可以看出，谷歌的算法比重很大，Senior以下是不面系统设计的。因为我刷题十分多，因此谷歌的这种面试模式让我很享受，感觉效果也不错。之后就是漫长的Team Match。最后因为HC Freeze结束了申请流程。谷歌的流程十分冗长，推荐的做法是，最先投谷歌，等谷歌面试结束后，再投其他大厂。这样可以使得出offer的时间差不多，方便compete。\n7月份同一天拿到2个Offer，谈薪资。\n8月份接offer。9月办签证。10月离职。11月入职。\n可以看出，从开始投大厂，到入职，基本半年就过去了。大家可以酌情准备。\n另外，我花了不少时间在 Pramp模拟面试 和 中小厂的面试上。主要是前期没有自信，想要练习一下再冲大厂。回头看看其实用处不大。\n首先是小厂和大厂面试模式和内容差别很大，练习效果一般。\n其次，因为我只有1年工作经验。投小厂我收到面试其实很少，毕竟从海外搬用入职时间比较长，成本也不低，他们更愿意招一些Senior的人。\n最后，因为赶上了今年恶劣的大环境，晚几个月投大厂太致命了。到6、7月的时候，陆续传来Hire Freeze或Layoff的消息。大厂虽然看实力，但运气也很重要。如果再晚些就更惨了。我最后拿微软offer的组，也不是一开始面的组。因为一开始的组Hire Freeze了，幸运地是，我入职的组因为十分基础和重要，在整个公司Hire Freeze的背景下，仍然争取到了少量的Head Count。\n 面试准备\n这部分是大家最关心，也是最花时间的了。\n首先推荐一下V2WORLD 群主的频道. 有包括 简历准备、英文、算法、技能 等十分干货的视频，尤其是适合德国岗位。\n我这里主要结合我自己的经验，分享一下面试准备的心得。\n 英文\n英文对于很多同学可能是比较恐惧和担忧的一个挑战。我也是这样，因此很能理解。\n作为一名小镇做题家，高考英语听力都不算分，从小到大的英语老师也都是二本甚至专科毕业的，自己英文都说的不利索。四六级倒是有听力，但口语当时还是可选的，也没多少人专门去考。大学英语老师水平倒是很高，但无奈基础已经摆在那里了。而且大学英语也更侧重于科研需求。大一的时候是最恐惧的时候，英语课都改成全英文的了，上课都听不懂了。也有部分同学游刃有余，对应着城乡，发达与落后地区的差距就十分明显了。从大学开始，我开始了漫长的和英语搏斗之路。虽然四六级都是一次性裸考过，但我深知那只是代表了应试能力和我阅读的强势，听说仍然比大城市的同学差很多。当时尝试了不少英语App，包括流利说和扇贝网。其中扇贝网因为网页做的不错，我身为程序员，也更习惯PC端的产品。而且扇贝听力的精听功能深得我心。我和舍友每日打卡，差不多打了有快2年时间。\n另外，我也尝试参加一些学校的英语活动。包括尝试了几次英语社，每日大早在沙河南湖边大声背诵。以志愿者身份，参加了2次暑期学校，解决外国学生的各种问题。也以学生身份上了一次暑期学校的课。\n以考促学也是一个不错的途径。当时还没有10043法案，北航的同学出国比例还是挺高的，最后大概有20%，再加上剩下有些许留学想法的，可能有50%。我当时也受影响，考了托福。虽然最后只考了91分，但准备的过程中，确实让我英语进步很多，尤其是听力。\n再到后来去比利时交换，也有了机会锻炼自己的英文和交流。\n虽然到目前为止，我发现自己的英语和周围人之间还是有不小差距的，但可以基本不大影响工作。在面试过程中，因为欧洲这边基本也都不是英语母语，所以要求和水平相对较低。即使如此，还是有面试据我的理由是，他们目前想找一个英文更好的人。\n在我看来，面试中的英文并不难，最重要的是你敢说，愿意交流。如果遇到不会表达的，或没表达清楚，只要和面试官反复沟通和确认，基本上还是可以沟通无碍的。其实在工作中也是一样。\n因此，我给出的建议是：用模拟面试（如pramp）或 真正的面试(可以先投一些小厂) 去练习，找到短板和技巧。无论是英文还是技术，欧洲的面试真没大多数人想象中的那么难。\n 简历投递\n主要靠网友内推和Linkedin海投为主。花些时间维护好Linkedin profile。基本大厂靠内推，其他靠海投。\n 算法题\n还是得靠刷题 LeetCode基本刷上300题就差不多了。\n之前写的经验在这里分享一下: 大家都是如何刷 LeetCode 的？ - youngforest的回答 - 知乎\n 软件设计 Software Design, OOD\n基本这一本书就够了：\n\nGrokking the Object Oriented Design Interview\n其他进阶资料：\nThe System Design Primer\n\n 系统设计 System Design\n准备面试基本看2本书就够了，\n\nGrokking the System Design Interview\nAlex Yu - System Design Interview_ An Insider’s Guide\n\n如果没时间，优先看第一本。\n除此应付面试外，其实系统设计对于工作也是十分重要的。我这里也推荐一些资源，提升自己本身系统设计的能力，而不是为了应付面试。\n\nDDIA (Designing Data Intensive Applications)\n一本分布式电子书和视频资料\n\n 行为面试\nBehavior questions 很好准备，用一两周即可。网上有大量的问题，自己提前根据自己的过往经历准备几个故事，足以应付大多数问题即可。一定要基于自己过往经历，可以添油加醋，但不要无中生有，要不面试时如果问follow up有可能圆不上露馅。\n文章\n\n一亩三分地\n一亩三分地 Behavior questions合集\n\nPodcast\n\nsoftskills\nSoft Skills Engineering\n\nYouTube\n\nDanCroitor\n\n 爱尔兰 怎么样？\n我这两年也加入了一起志同道合润的微信群（V2WORLD），也认识了不少已经润，正在润和将要润的群友。说实话，2022年因为国内经济和疫情封控的原因，润的人更多了。\n从这个小范围样本来看（大概2百人，大概率会有幸存者偏差），润到新加坡/欧洲（其中德国占大部分）的居多，日本、加拿大、澳洲的其次。\n爱尔兰算是一个不大热门也不引人关注的国家。其实我投递的时候也是没以爱尔兰为主的，但是后来发现这里大厂很多，包括很多美企巨头的欧洲总部，如 Microsoft，Apple，Google，AWS （Amazon的欧洲总部在卢森堡）。基本上都有3千研发的办公室。比如微软这里有2栋楼，3500+个研发。工作机会很多，尤其是如果你偏爱美企大厂，或者以后想通过L1润美的话。以后跳槽和职业发展也不错，也被称为欧洲小硅谷。\n除了程序员比较好找工作外，药企也是爱尔兰支柱产业。\n另外爱尔兰移民政策十分友好，有offer就能办工作许可，也就能办工签。程序员的话基本都是Critical Skill Work Permit。头1年不能换工作，头2年（Stamp 1）需要雇主担保Work Permit。2年后（Stamp 4）就可以自由换工作和自雇了。配偶签证也都可以学习工作。最快5年可以换护照（不过爱尔兰也有移民监，每年离境时间需要不超过6周，否则这年是不算在你的5年里的。）。不像其他国家，需要语言要求和融入考试。推荐一下我微软同事的帖子: 爱尔兰移民签证体系讲解 和 各种居留签官方说明. 感觉爱尔兰其实是价值洼地。岗位多，竞争少。和不少人聊过，感觉面试都更简单。\n大家润出来一部分人最主要的目的是逃离国内996的卷，更好的生活。爱尔兰像其他国家一样都可以满足这样的需求，也有相对完善的福利制度，完全足以过上“老婆孩子热炕头”的生活。\n爱尔兰缺点的话，也有很多。\n都柏林基础设施极差。比大多数欧洲发达国家的首都都差，甚至比不上希腊。没有地铁，轻轨线路也只有2条，公共交通公交是主流。去不同方向的地方都需要去市中心转车。机场不通轻轨或火车，只有大巴和公交。机场设施，如安检，也都相当原始和缓慢。我分析爱尔兰基础设施比较差的主要原因有：1. 人口密度低。爱尔兰人口只有4百万，相比中国和欧洲其他地区人口少，所以基础建设性价比低，跟不上。2. 底子差。因为历史上长期是英国的殖民地，面对着长期的剥削，以发展农业为主，经济腾飞成为工业国是二战后的事儿。不像欧洲其他国家有几百年的工业历史和建设。\n气候谈不上恶劣，但绝对不十分宜人。这方面其实西北欧都差不多，属于温带海洋性气候。气温上还比较好，夏天不大热，低于30度，冬天不大冷，-10度以上。但每年有半年的雨季，集中在冬天，刮风下雨实在是物理加法术伤害。因为纬度比较高，冬天日照时间短，再加上雨季阴天不大能见到太阳，容易让人抑郁。建议通过补剂或食物额外补充维生素D。我在国内都是北方长大到现在，实在是顶不住。不过据南方（杭州）的朋友说，这里气候其实是比南方要好的。\n比较村，也被称为“爱村”。除了之前提到的基础设施差之外，商场娱乐也不像大城市的样子。不过这点对我来说也挺好，我其实就喜欢这个样子。作为一名典型的“小镇做题家”，从小在小县城长大。虽然后来通过高考来到了大城市，但头两年呆在沙河（北京昌平郊区一镇），十分荒凉。后来来到了北四环学院路，总算是城市了。但海淀相比朝阳还是破旧许多。工作后在朝阳呆了一年，总算是品尝了些大城市的灯红酒绿，但也不习惯。所以，此番来到爱尔兰都柏林郊区，也算是能接受，感觉比长大的县城还是好上不少的。\n高税收。爱尔兰属于高税收高福利国家，更看重公平而非效率。本身就比美国薪水低很多，再加上最高52%的各种税，到手其实和国内差不多，甚至更少。再加上高昂的房租和物价，存下来的钱必然是更少的。\n变态的房租。我之前在年终总结里分享过，都柏林的房租直追欧洲一线城市，但享受到的基础设施、服务都是三线的。\n FAQ\n有想润的朋友经常咨询我一些问题，统一在这里整理出来。\n** Q: 你当时在职面海外岗位，会不会时间太紧完全没法准备啊？以及请假会不会很难？**\nA: 我还好。因为我本身在国内就在外企工作，工作压力小，请假也十分方便，而且还长期居家办公。另外我面的欧洲工作，我会优先选择晚上面试，最差情况是下午面试，就得请假了。准备方面的话。因为我长期刷题，这方面基本不怎么需要再花时间。英语、系统设计、Behavior questions倒是花了不少时间练习。你如果当前工作压力大，确实会顶不住。建议你慢慢来，如果真想润的话，别放弃润的目标，长期准备。正好现在大环境不好，到处裁员和缩招。另外以面代练，广撒网也很重要。不需要等准备充分了才开始投。\n** Q: 我想去美国。为什么大家分享从海外投美国的经验的很少呢？**\nA: 因为美国是计算机技术的中心，薪资、机会也很多。有不少年轻的同学可能比较向往。\n不过因为美国工签（H1B）是抽签制度，十分难抽。现在从海外直接投已经几乎不可能了。\n主流的方式是 1. 读美国硕士，毕业后用OPT签证（29个月）工作。2. 去美企的海外办公室，1年后 L1签证（5年） transfer到美国本土总部。\n不过去了后，还是需要抽H1B才能换工作。\n排绿卡又是按出生地，中国大陆和印度属于地狱级别，现在已经6年往上了。要知道，在海外工作，身份问题可是决定幸福程度的重要影响因素。\n","categories":["dairy"],"tags":["life","Tech"]},{"title":"hexo next 配置 Google AdSense","url":"/2021/02/25/Google-AdSense-for-hexo-next/","content":" 动机\n最近由于看了“半佛仙人”的一些视频，我对钱更感兴趣了。除了拿出积蓄的一部分投资A股外，还想着怎么提高被动收入。自己一直有写博客的习惯，写了有5年多，攒了一百余篇文章。虽然每日浏览量只有几十，但苍蝇再小也是肉。参照大佬的一些经验，尝试着通过投放广告来牟利。\n一般网站的广告收入都是通过广告联盟接入的。简而言之就是，你只用出租广告位给广告联盟，他们在此投放针对用户的广告，然后按照流量给你钱。\n面向国际的主要就是Google AdSense了，国内也有一些，如百度。\n因为我本职是一名程序员，博客内容也不分国界，因此选择了Google AdSense作为广告商。Google AdSense的配置十分简单。\n 具体步骤\n注册新的AdSense账号.\n从Google AdSense上获取针对你网站的广告脚本，类似这样\n&lt;script data-ad-client=&quot;ca-pub-9*******6&quot; async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;\nOption1:\n将广告脚本粘贴在./themes/next/layout/_partials/head/head-unique.swig的末尾。\n然后进行验证。一般几天就会通过，发邮件通知到你。\n通过审核后，需要去AdSense上进行配置。基本上把 自动广告 打开即可。\nOption2:\n在博客根目录下创建_config.next.yml文件，内容如下：\ncustom_file_path:  head: source/_data/head.swig\n创建source/_data/head.swig文件，内容如下：\n&lt;script data-ad-client=&quot;ca-pub-9046219176772396&quot; async src=&quot;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9046219176772396&quot;&gt;&lt;/script&gt;\nOption2的优势在于对next不侵入，方便用Github Action做CD.\n ads.txt 的设置\n该文件放置在 ./source/ 下即可，和_posts/ 同级。\nhexo d -g部署后，对应的文件就会自动部署到/public/也就是你的博客上了。\n其他需要生成放置在博客根目录下的文件也是类似的处理。\n","categories":["折腾"],"tags":["Hexo"]},{"title":"枪炮、病菌与钢铁","url":"/2024/01/08/Guns-Germs-and-Steel/","content":"豆瓣链接 Guns, Germs, and Steel: The Fates of Human Societies\n为什么当今国际社会如此？（也就是书中新几内亚农民土著 亚力问的问题）欧亚大陆及欧亚大陆的移民地（如北美、澳洲）占主导。近因是1492年开始的大航海时代，欧洲人带着枪炮（马匹）、病菌、钢铁（各种技术）和先进的政治体制（如 国家），开启了殖民时代，同期配合西欧的工业革命，奠定了西方社会当今的领先状态。而后起之秀是 东亚（日韩中）和南亚（印度）、东南亚（越南、印尼），他们要么已经成为发达国家，要么是发展的很快的。而非洲（尤其是撒哈拉以南）仍处于贫困。这些近因一目了然，讨论也很多。\n那是什么导致了这些近因？次近因是农业和技术的发展，导致人口增长，可以供养非农人员，如工匠 进一步促进技术发展，和官僚 国家等体制。作者致力于追寻终极原因：地理和和地理紧密相关的生态。也就是”地理决定论“。1. 环境差异，各大陆可供驯化的动植物资源不同。2. 欧亚大陆的轴线是东西向的。非洲和美洲是南北向。影响了传播和迁移速度。3. 大陆之间植物、牲口和技术的传播。美洲和澳洲相对与世隔绝，非洲撒哈拉沙漠以南其次，中国的东亚也在亚欧大陆相对独立。4. 各大洲面积和人口总数的差异。\n作者也讨论了其他学者观点并加以反驳，如”人种决定论“，”文化决定论“，”个人（英雄）史观“。\n感恩生在中华，虽然比不上西欧，北美，澳洲等西方社会，也比不上日韩台等东亚发达地区，但起码比非洲强得多。投胎没法改变，剩下的只能靠自己移民了。\n","categories":["读后感"],"tags":["Reading","枪炮、病菌与钢铁"]},{"title":"Happy birthday 2019","url":"/2019/07/15/Happy-birthday-2019/","content":"今年仍然是在学校度过了自己23岁的生日。下午和舍友出去看了电影《狮子王》，晚上去 城南旧事 吃了“北京菜。算是庆祝了自己的生日吧。祝我生日快乐。\n自从18岁之后离开家，独自来到帝都读书。过生日就不再像在家里那么热闹和有人情味了。在外地漂泊，虽说还有同学或朋友祝你生日快乐，亲近的还会陪伴我一起过生日，但家人的温暖却再也没有了。大家来来往往，身边的人也基本只能陪伴一段时间。每每此时，都会怀念小时候。\n最近北京的天气特别热，不由的心情烦躁。持续性混吃等死，间断性踌躇满志。经常思考些所谓的人生意义，努力的价值，自己的目标。\n我本人可以说是胸无大志，从小读过不少书，尤其是历史书。早早地就明白了自己与王侯将相无缘，只是个贩夫走卒。现在想要的也不多，在大城市有立锥之地，有个温暖的家。这样的想法，恐怕也是千千万万北漂一族的目标吧。这也是我努力学习的动力所在呀。\n最近在看一部很火的网剧“长安十二时辰”，里面有句台词很引起我的共鸣：有些人生来就是长安人，有些人到死都没成为长安人。剧中无数长安底层人的生活，不正是影射的北漂族的生活嘛。\n时间如白驹过隙。匆匆之间，2019年已经过了一半。回望自己半年前写下的新年愿景，有些容易的已经实现，难的只能推迟到后半年，甚至来年了。\n\n健康的身体和良好的生活习惯。这点做的很不够，因为贪睡、怕热、懒等缘由，跑步、健身 并没有坚持下来。我需要做自我批评。\n一段大大厂的实习。在ST实习了一学期，并不算大厂。大大厂的实习需要推迟到明年实现了。\n一段交换经历。预计下学期执行。\n计算机系统 和 算法 的进阶。LeetCode的最初任务已经超额完成了，算法相关的书CTCI也翻过一遍，这点是值得肯定的。事实上，我在此下的功夫不少。除此之外，对C的熟悉也基本完成了，可以在简历上或面试上大胆的说C是自己的主语言了。剩余的 CSAPP、SICP、设计模式，并没有很大的进展，聊胜于无。\n实际面试经历。参加了字节跳动广告组的面试，和 字节跳动夏令营的笔试、以及 Google的电话面试。这些面试经历真的很刺激人，让人深入的认识到自己的短处。比如算法上离Kick start的标准还差的远呢！\n\n我认为自己需要牢记的2点：\n\n时间就是金钱！\n身体是革命的本钱！\n\n","categories":["dairy"],"tags":["life"]},{"title":"Hexo + github 搭建个人博客","url":"/2016/11/02/Hexo-github-building-personal-blog/","content":" 动机(放在前面)\n之前在cnblog上有个博客, 但是也不经常维护, 到现在满打满算也才有3篇随笔, 1个粉. 主要是因为自己没有写东西的习惯. 高中的时候记过一段时间的日记, 零零总总写了有大半本, 都是一些励志(自欺欺人)的东西, 写给自己看的.\n\n首先, 之前感觉没有可写的, 但现在觉得可写的还是挺多的.自己这两年也折腾了不少东西.但折腾完后, 说实话忘得挺快的, 下次自己再弄或者给别人处理相同问题的时候, 基本上又要重新来过. 记下来下之后, 不管是自己日后需要, 还是给小伙伴们借鉴都是极有用的.\n其次, 经高人安利, 经常写博客, 总结自己的工作学习, 和网络上的大牛们交流是学习计算机的基本技能. 写下来, 不仅可以系统地记录自己的学习历程, 供后日回顾, 或后人参考, 还可以督促自己坚持下来. 何乐而不为呢?\n最后, 最近在搞编译课设的时候, 看到了这篇博客. 学习编译知识的同时, 感觉这个博客设计的很美观, 博主也很nice. 了解到使用Hexo搭建的时候, 便有了自己搭建博客的想法, 现在也终于有时间实现了.\n 介绍Hexo\n有很多专门用来搭建博客的框架, 如 WordPress, Jekyll, Octopress, Joomla等. 这些我都没有用过, 就不评论了. 事实上, 这是我第一次搭建博客的经历, 也算是一种猿粪吧, 遇上了Hexo.\n这里我就自己的感受, 说说Hexo的优点:\n\n文档完善.\n中文支持好, 包括文档各个方面. 事实上, 开发者就是中国人.\n主题丰富.(作为一个看脸的人)\n\n 搭建过程\n 本地Hexo安装配置\n关于如何搭建, 我这里推荐官方的文档. 文档中说的已经很详细了, 而且遇到问题的话, 还可以直接在文档最下面的讨论区提问, 貌似遇到奇奇怪怪问题的人挺多的, 我遇到问题一般靠谷歌, 事实上, 很多时候都被谷歌引到讨论区或者文档中的Troubleshoot了.\n我安装hexo使用的环境的Ubuntu14.04, 在安装hexo的时候$ npm install -g hexo-cli, 会遇到这样的问题\nsh: 1: node: not foundnpm WARN This failure might be due to the use of legacy binary &quot;node&quot;npm WARN For further explanations, please read/usr/share/doc/nodejs/README.Debian\n通过搜索可以很快找到解决问题的方法. 只需要sudo apt-get install nodejs-legacy就可以了.\n出现这个问题的原因是, debian社区发现, nodejs解释器的命令是node. 然而, 这个命令和其他的包有命名空间的冲突, 比如 node 包中的 ax25-node. 所以, 他们决定把nodejs解释器命令改为nodejs, 大家需要用到nodejs的解释器时需要nodejs命令, 而不是node. 但是这样就会带来向后兼容的问题, 之前的nodejs脚本中的命令还用的是node, 其他Linux发行版也一直在用node. 所以他们想了一个兼容的方法, 创建一个符号链接, 将/usr/bin/node链接到/usr/bin/nodejs. 这个工作又node-legacy包来实现, 不推荐用户自己手动链接. 并且他们也规定, 'nodejs’的源代码包应该也提供一个node-legacy的可执行包. 这样就&quot;完美&quot;地解决了兼容问题.\n由此看来, debian系的发布版都会出现这个问题.\n 发布到github上\n在github上新建一个库, 库名为 “{your name}.github.io”, 比如, 我的是&quot;youngforest.github.io&quot;. 事实上, 以这样的格式命名, github会默认配置好你的[GitHub Pages](https://pages.github.com/), 默认发布到&quot;https://{your name}.github.io/“, 比如我的就是&quot;https://youngforest.github.io/”.\n当然, 如果你不这样命名的话, 自己也可去库中的设置中设置发布GitHub Page.\n在本地的博客目录下, 运行hexo generate, 即可在public/中生成你博客的静态页面, 在这个文件夹下, 将其中所有的文件推到你在github上建好的库就可以了.\n关于具体如何将本地的文件夹推到新建好的库, 在你新建好空库的时候, github应该会告诉你.\n\n如果你想要一条命令完成github部署的话, 可以参考相关文档.\n我在运行hexo deploy是会遇到这样的错误ERROR Deployer not found: git.\n查了半天在hexo的isuue中找到了解决方法. 在bash中运行如下命令就好了.\nnpm install hexo-generator-index --savenpm install hexo-generator-archive --savenpm install hexo-generator-category --savenpm install hexo-generator-tag --savenpm install hexo-server --savenpm install hexo-deployer-git --savenpm install hexo-renderer-marked@0.2 --savenpm install hexo-renderer-stylus@0.2 --savenpm install hexo-generator-feed@1 --savenpm install hexo-generator-sitemap@1 --save\n当你在浏览器中访问你的&quot;GitHub Pages&quot;时, 就会看到部署好的博客.\n在这里可以看到我部署好的博客.\n","categories":["折腾"],"tags":["Hexo"]},{"title":"李宗吾 厚黑学","url":"/2024/07/20/Hou-Hei-Xue/","content":"豆瓣链接\n千万别被书名骗了，望文生义，以为这是一本成功学书籍，看完后，就能学到脸厚心黑，成为英雄豪杰。其实不然，这本书主要是一本讽刺历史和社会现实得书。厚黑学成书于民国初年，正是社会剧烈变革之际。中国传统的学说被反思和打倒，西方现在学说又未被完全接受。厚黑学教主，正是在这个背景下，写出了这部讽刺学说。真是把旧中国的仁义道德撕个粉碎，揭露了社会黑暗的现实。\n虽然已经过了一百多年，中国社会已经初步实现现代化，进步了不少。但书中很多讽刺竟然仍然可以针砭时弊。果然优秀的作品都是经久不衰的，因为讲的都是人性。纵使社会变迁，科技进步，但人类的进化是很慢的，只是在不同环境下激发出不同的表现。所以，只要掌握深层的人性，表象的东西就不会怎么变。比如 鲁迅 的文章，放在今天仍然让大家彷徨呐喊。比如 是，大臣or首相. 虽然写的是英国50年的政坛，但今天很多台词依然适用，甚至适用于其他国家。\n本书说的“做官六字真言”，就是如此，”空、恭、绷、凶，聋、弄“，”空，即空洞的意思。一是文字上，凡是批呈词、出文告，都是空空洞洞的，其中奥妙，我难细说，请到军政各机关，把壁上的文字读完，就可恍然大悟；二是办事上，随便办什么事情，都是活摇活动，东倒也可，西倒也可，有时办得雷厉风行，其实暗中藏有退路，如果见势不佳，就从那条路抽身走了，绝不会把自己牵连着。……”其他的也十分准确，对上恭，对下绷。真是把官僚体制讽刺个透透的。这些一百多年前的文字，今天仍然如此，甚至由于社会的发展，更是如此。民国时那种百家争鸣，反思和批判的声音反而没有了。\n还有“厚黑经”，模仿论语的话术，写了很多  宗吾说。真是把讽刺效果拉满。类似现在互联网论坛上的各种段子手，真是又讽刺又搞笑。又把自己的“厚黑学”和王阳明的“致良知”所对应，真是从先秦，到宋儒，再到心学，都剖析了个遍。\n孟子云：君之视臣如草芥，则臣视君如寇仇。厚黑学其实只是李宗吾写的很多议论文中的几篇，也是最著名的。剩下的文章也值得一读，很多是对传统儒学，尤其是宋代及以后的程朱理学的反对和抨击。正是近代以来，不断有这些文人，借用西方理性和科学的方法，对儒学的反思。中国文化才能渐渐摆脱糟粕，接近现代文明。\n","categories":["读后感"],"tags":["Reading","厚黑学"]},{"title":"爱尔兰驾照申请 Ireland Driving License Application","url":"/2023/06/10/Ireland-Driving-License/","content":"爱尔兰作为一个岛国，公共交通不甚发达，城市也十分小。拥有一辆汽车对长期生活的质量提高十分重要。尤其是如果你打算成家的话，没有车肯定是十分不方便的。所以，我来爱尔兰不久，就开始了驾照申请之旅。\n不像国内报个驾校，交一次钱 就有完整的服务。爱尔兰的驾照申请流程还算比较复杂，需要自己一步步去办理。\n这篇博文就是记录申请流程和攻略，方便在爱华人。\n\n 中国驾照在爱尔兰的使用\n中国大陆的驾照可以在爱尔兰开一年车，整个翻译件就可以了。我出国前还特意办了公证，算是更加保险。之后再开就需要考当地驾照了。有许多国家和地区可以在爱尔兰直接换驾照，如 中国台湾地区，可惜大陆不在此列。欧盟或英国驾照也可以无缝在爱尔兰继续使用。具体不同国家驾照在爱尔兰使用要求可以参考这里.\n 爱尔兰驾照申请流程\n官方步骤：理论考试，视力证明，申请Learner驾照，外国驾照减免，上驾校，路考，申请正式驾照。\n 理论考试 （Theory Test）\n类似国内的 科一 和 科四。\n理论考试报名链接. 报名费45欧。\n考试30分钟，40道题，答对35道就算通过。通过后有效期2年。\n和国内一样，刷题就完了。对年轻人或小镇做题家很容易。题库有700+题。官方有APP：Official Car/Bike DTT Ireland, 可以在Google Play 或 Apple App Store直接下载. 收费15欧。\n我自己用一个非官方的刷题网站，免费，很多人推荐：theory-tester.com\n虽然功能有限，但对于绝大多数人都够用了。\n我基本是把所有题目刷了一遍，然后把错题截图到Notion上，多刷几遍。\n然后进行了3次模拟考试，都通过了。\n提前一周左右准备即可，太早了刷完容易忘记。\n\n我最后39分高分通过。满分40分，35分算过。\n结束考试后，在现场等5分钟就可以拿到结果和成绩单。\n\n\n 视力证明 (Eyesight test report)\n我是去家附近的Specsaver预约的下个月的视力检查。因为驾照的视力检查与普通检查不同，每天只有一个名额，推荐提前至少一个月预约。而且Specsaver必须线下预约，普通的可以线上直接约。通过理论考试后，在申请Learner Permit(实习驾照)的时候，还需要有个一个月以内的视力检查表，视力要求其实也不高，矫正后超过0.5即可。不用特别紧张。我也是高度近视。从这里可以下载视力检查表，提前打印好到店里就成。店里也有检查表，我当时是店里给我提供的，没用到自己打印的。不过还是推荐自己打印更保险些。\n费用的话，不同店不同。我的是40欧，还被推销了一个OCT的眼底检查（25欧）。公司买的私人保险Laya会报销35欧。\n如果工作久的话，比如超过2年，交的PRSI会给你一个10欧检查的优惠。不过我只来了半年，久没有这个优惠。可以在预约的时候问下店员，店员会用的你的PPSN查一下，过几天会收到信件是否符合优惠条件。\n视力检查内容和国内类似。果然被推荐配新眼镜了，不过因为我的眼镜是出国前不久配的就没接受。\n特别的是一个专门给驾驶检测的机器。需要你盯着红点，然后屏幕上其他地方出现白点，就按一下手中的按钮。感觉是为了测试你反应能力。正常人应该都能通过。\n\n视力检查表只有3个月有效期，需要尽快申请实习驾照。\n 申请实习驾照 Learner Permit\n申请地址\n注意要选择Apply apply for first time learner permit, 而不是with foreign license。因为大陆的驾照并不支持。后面还有问是否有外国驾照的，那里可以填Yes, 国家Other，驾照号就是国内身份证号。\n还有一些健康问题调查。除了佩戴眼镜，其他都选No就可以了。因为眼镜，会在驾照上打印一个01, 代表需要佩戴眼镜。\n还有一个问是否自愿捐献器官，如果选Yes，驾照上会多一个25. 如果发生车祸，你不幸没了。会把能用的器官捐献了。但是我选的No.\n然后上传IRP和视力检查表就可以。然后交35欧，等邮递。\n会有一个2年有效的卡片，就是实习驾照了。\n然后你就可以在一定条件下开车了：\n\n需要Full License 陪同\n在车上佩戴L标志\n\n不过很多本地人都是L驾照就随便开很久，路上也没人查。想想也是蛮危险的。我比较遵纪守法，自然不会这么干的。\n 外国驾照减免 Reduced Essential Driver Training (EDT)\n持有中国驾照至少2年，可以减免课时从12小时到6小时。每小时课差不多50欧，可以省不少钱。\n持有中国驾照6个月，可以免除 实习驾照 获取后，6个月才能参加路考 的限制。\n然后驾照不能过期超过6个月。\n需要的材料有:\n\nReduced EDT的说明和申请表\n中国驾照原件\n安全驾驶记录 可以在“交管12123”APP上申请下载，不过需要翻墙回国内才行。爱尔兰貌似访问不了。我是翻墙到HK，才能登陆下载的。还需要多试几次。如果不方便翻回墙里的话，可以找国内的亲戚朋友帮忙下载。申请后，需要等一个工作日才能下载。\n驾照 和 安全驾驶记录 翻译件。需要Irish Translators Association认证的翻译，中文到英文的只有一个人符合翻译资质: Lichao。邮件联系即可，收费45欧。\n我把国内的公证书也寄过去了，不过貌似没什么用。\n\n我是在公司邮寄的，选了最便宜的：2.85 欧\n邮寄地址参见 Reduced EDT的说明和申请表：Reduced EDT, National Driver Licence Service, PO Box 858, Southside Delivery Offi ce, Cork\n\n下一步就可以联系ADI教练了。\n 上驾校\n在 小红书 上找了一个华人教练，叫“人在旅途”/Jun，但他只有自动挡的车。我想学手动挡，因为选择更多。和国内一样，手动挡驾照可以开自动挡和手动挡的车，但自动挡驾照只能开自动挡的车。\n后来经Jun 推荐，找了一个National driving School的教练 Keith. 联系方式为：\n+353 85 151 4076\n收费每小时55欧。\n上过6小时课程后，就可以报名路考了。\n 路考\n在rsa.ie上报名路考，建议上完6小时课程后，尽快报名。因为排队的人多，只能加入waiting list。大概过半年才能排到。我是9月14号报的名。\n我住在都柏林南边，选这个考场最好 Dun Laoghaire/Deansgrange\n等路考期间，可以自己买个二手车多练练。虽然理论上L驾照，需要一个正式驾照2年的副驾驶陪同才能上路，但实践中你买车上路都没啥问题。如果爱尔兰有熟人，可以借车给你练也是再好不过的了。还可以坐在副驾驶上，符合法律要求。当然也可以再花钱约教练学课程。\n虽然约教练蛮贵的（55欧一小时），但其实自己买车，车钱+保险也不便宜。看自己的需求和计划了。\n确定考试日期后，可以和教练约一个pre test. 教练到时候根据日期，会知道考试线路，可以帮你过一下，提高通过率。\n 申请正式驾照。\n","categories":["爱尔兰"],"tags":["Ireland","Life"]},{"title":"爱尔兰法签抢号辅助","url":"/2023/09/20/Ireland-France-visa-monitor/","content":"申根签太难了。终于还是用科技打败了黄牛，成功抢到了法签。不枉学了9年计算机，程序员从不向黄牛低头。\n爱尔兰有抢法签需求的同学可以试试我开发的这个法签通知工具，使用说明见文档。有问题可随时找我反馈：\nGoogle Docs\n本工具目前仅支持 爱尔兰，和 法国签证。\n听说英国的朋友抢法签也蛮难的。\n","categories":["爱尔兰"],"tags":["Ireland","Life","法国签证","法签","申根签证","Side Project"]},{"title":"Ireland Microsoft probation period","url":"/2023/06/10/Ireland-Microsoft-probation-period/","content":""},{"title":"刚来爱尔兰必看的生活攻略","url":"/2022/11/11/Ireland-Onboarding/","content":"成功润到爱尔兰2周时间了，因为刚一直在办各种东西。慢慢的生活开始步入了正规。从今天开始，我会陆续分享一些来爱尔兰工作留学初期的一些攻略。一方面自己经历了很多坑，另一方面现在终于成功了一些，也算是有些经验可以帮助到大家。\n\n 第一篇 电话卡\n\n初来国门，办爱尔兰电话卡往往是大家需要做的第一件事。\n\n上蜂窝网络（也就是流量）。虽然国内电话卡可以通过漫游上网，但一则比较贵25CNY一天，二则没法上外网，这里经常用的谷歌地图/搜索用不了，还得翻墙。\n很多 办理各种证件 或 注册账号 的地方没法用号码，比如银行卡、当地人互相联系用的WhatsApp(类似微信)、居留卡。\n电话联系当地人。初来乍到有很多要联系的当地人，如 接机的司机，临时住宿的房东，学校/公司联系人。有本地电话会方便实惠很多。\n\n上面陈述了这么多办爱尔兰电话卡的必要性，那么怎么办呢？\n一般有3个办电话卡的地方：\n\n机场。在机场的Arrival大厅，就有很多提供给外地人的服务，包括 货币兑换、机场到市中心的交通服务、和 SIM卡。机场办卡的优点就是可以第一时间拿到SIM，缺点就是一般会比较贵，套餐也不划算，可供的选择也相对少很多。\n线下门店。包括运营商的门店和顺便卖SIM卡的Newsagent（卖报纸杂志的店）和某些超市。优点是可供选择的多；缺点是时间窗口相对窄，基本都是早9晚6，交通成本高，不方便，尤其是你的临时住宿在郊区的话（可能性很大）。\n线上网站。优点是选择最多，便宜，方便；缺点是需要一个地址，还要等2天才能收邮件（SIM卡）。\n\n大家可以根据自己的需求和偏好选择合适的办卡方式。\n另外一个大家比较关心的问题是选哪家运营商。我介绍下爱尔兰这边比较流行的品牌、其特点和大众套餐每月的价格，以供大家选择。\n\nVodafone。爱尔兰最大的运营商，信号比较靠谱。20 Euros。\nTesco Mobile 主营是超市，门店多，在超市/网上就能买。20 Euros\nGoMo 纯线上品牌，便宜。15 Euros\nlycamobile/ 纯线上品牌，最便宜。10 Euros （前12个月）\n\n我本人最后选择了最便宜的Lyca，便宜是便宜，不过遇到两个大坑。\n\n邮件收到的速度比较慢，花了整整一周时间。官网上的承诺是2天，不过这也和你住的地方有关。感觉是我住的那个公寓的锅，邮件大概一周才集中给你分发一次。\n上网配置复杂。配置不好的话，会乱收费，被坑了有近5欧。具体配置方法是，1. 按照订购邮件的指示。先拨打“116PIN#”，你的PIN在邮件里能找到。2. 再根据官网上的这个指示的第二步打开漫游，配置APN（Name: lyca internet, APN: data.lycamobile.ie, Username: lmie, Password: plus)。之后才能正常上网。\n\n大家根据自己的预算和偏好选择运营商吧。\n","categories":["爱尔兰"],"tags":["Ireland","Life"]},{"title":"爱尔兰看牙记","url":"/2023/10/03/Ireland-visiting-dentist/","content":"笔者天生牙齿比较软，易得蛀牙。之前在北京上学的时候，就曾经和校医院和北医三院的口腔科有不解之缘，甚至久病成医。去年来到爱尔兰，在这边也是第一时间看牙，经常看牙。因此，总结和分享一下我的经验和体会。\n在离开北京的前2天，我忽然牙疼，然后发现有颗牙有个洞，也就是龋齿了，还比较严重。之前一直去公立医院看病，一来三甲医院比较受我信任，二来花销少，医保可以报销，三来学生时代转院只能转到北医三院，比较熟悉。但公立医院挂号要提前一周，也不好抢。因此，果断第二天一早去了当时住的宾馆附近的一家评价不错的口腔私立医院，甚至不需要挂号。私立医院果然服务不错，拍了X光后，牙医说龋齿已经到神经了，需要做根管治疗，然后装冠。治疗周期至少需要2周，来治疗2次。我几年前，一颗牙齿在北医三院做过类似的治疗。因此十分清楚着这意味着什么：你的牙，他其实已经死了，只是尸体还在。因为我第二天就要坐飞机走了，最后给我开了些止疼药。\n来了爱尔兰之后，我第二周就入职了。就已经有医疗保险了。但当时我还没有PPSN，有些担心，就又等了一个半月，直到有了PPSN后，才预约了公司办公室附近的一个Dentist。并且提前把保险换成了Principle Scheme + Dental Care，看牙的报销会更多些。后来我也了解到，并不需要PPSN，甚至入职，也能使用公司的保险，还是十分强大和对我们这些外地人有保障的。\n在 dentalexperts.ie 看病的体验十分不错，牙医拍了X光后说，虽然龋齿比较深，比较接近神经，但并没有伤到神经，也不需要根管治疗，优先补牙。补牙后，还是十分成功的，过了一年也没再疼过。我又做了检查和洗牙，发现了其他比较浅的龋齿，也迅速补了。过了9个月，我刷牙出血了。明白是时候再次去洗牙，顺便做了检查，补了2颗牙。来爱尔兰近一年，我前后共看了4次牙医，花费是200+200+130+280 欧元。Laya保险基本都给报了，报销后的花费是 1+0+0+0 欧元。Dental Care还是很顶用的。每次看牙报销会通过Principle Scheme报一次，Dental Care再把剩余部分报一次。用户只用提交一次申请，Laya会自动帮忙最优化。牙不好的朋友一定要加个Dental Care。我的保险费是每2周70欧元，还是挺贵的。幸运的是，这部分是公司福利，公司会出。但由于算是福利，我们其实还是要为此交个人收入税的。\n","categories":["爱尔兰"],"tags":["Ireland","Life"]},{"title":"Just Keep Buying 持续买进","url":"/2024/03/16/Just-Keep-Buying/","content":"豆瓣链接\n很不错的投资书籍，和“金钱心理学”有些像。用很多数据和回测说服读者。\n我收益最多的几个点是：\n有钱就买，不要等。择时没用。\n不要买个股，买大盘。超额收益不切实际，大概率无法达到。\n房地产并不是一个好的经济上的资产（房产回报并没有大家想象的那么高），但有很多其他精神和社会上的好处，比如稳定的生活。\n运气对投资太重要了。你出生的国家，时代，决定了你成年后的国际大环境。还有是退休前最后几年的收益，对退休后的收益和生活影响很大。\n资产中，时间才是最重要的。也就是“一寸光阴一寸金，寸金难买寸光阴”。\n年轻时，思考人生和关注事业更重要，尤其是头10年是收入增长最快的。投资是后来才更重要的事情。正如“史记 货殖列传”中所讲“是以无财作力，少有斗智，既饶争时，此其大经也。”。没有钱财只能出卖劳力，稍有钱财便玩弄智巧，已经富足便争时逐利，这是常理。\n人本身年轻时是成长股，年老时是价值股。\n","categories":["读后感"],"tags":["Reading","持续买进"]},{"title":"LCCUP 21 Fall Team","url":"/2021/09/25/LCCUP-21-Fall-Team/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (2)\nQ2 (4)\nQ3 (6)\nQ4 (7)\nQ5 (8)\nQ6(9)\n\n\n\n\n81 / 1363\n爸爸去哪儿\n19/37\n1:07:44\n0:03:40 by 爸\n0:21:39 by 爸\n0:53:13 by 宝\n1:02:44 🐞 1 by 爸\nnull\nnull\n\n\n\n今年秋季赛只参加了团队赛，没有参加个人赛。春季赛和赖叔以及羡慕哥组队，效果不是很理想。秋季赛和宝宝二人组队，效果反而不错。尤其是宝宝不仅没有拖慢我的速度，还给团队做出了重要的贡献。没有她顺利地做出Q3，我们队排名绝对没有现在这么好看。\n一个小时做了4题后，后两题只有5人AC。看了半天后并没有任何符合时间复杂度的思路。果断放弃了，后2个小时就节约下来干别的去了。\n虽然我现在用英文博客写周赛总结了。但因为春季赛和秋季赛都是国区力扣的活动，只有中国人能参加和看到，因此考虑到受众，本次比赛总结还是用中文吧。\n LCP 44. 开幕式焰火\n签到题。DFS，用set记录不同color.\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    int numColor(TreeNode* root) &#123;        set&lt;int&gt; colors;        function&lt;void(TreeNode*)&gt; dfs = [&amp;](TreeNode* root) -&gt; void &#123;            if (root) &#123;                colors.insert(root-&gt;val);                dfs(root-&gt;left);                dfs(root-&gt;right);            &#125;        &#125;;        dfs(root);        return colors.size();    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n其中，N为节点数。\n LCP 45. 自行车炫技赛场\nDFS. 因为需要关注高度，因此把高度也当作参数传入。\n需要用seen/visit记录访问过的状态。\n因为速度变化的机制h1-h2-o2，显然速度不可能超过最大高度+1，因此状态数也是有限的，大概是n\\*m\\*最大高度 = 10^6.\nclass Solution:    def bicycleYard(self, position: List[int], terrain: List[List[int]], obstacle: List[List[int]]) -&gt; List[List[int]]:        n = len(terrain)        m = len(terrain[0])        minSpeed = [[float(&#x27;inf&#x27;)] * m for _ in range(n)]        direction = ((1, 0), (0, 1), (0, -1), (-1, 0))        seen = set()        def dfs(i, j, speed):            if speed &lt;= 0: return            if (i, j, speed) in seen: return            seen.add((i, j, speed))            minSpeed[i][j] = min(minSpeed[i][j], speed)            for di, dj in direction:                ni = i + di                nj = j + dj                if ni &lt; n and ni &gt;= 0 and nj &gt;= 0 and nj &lt; m:                    newSpeed = speed + terrain[i][j] - terrain[ni][nj] - obstacle[ni][nj]                    if (ni, nj, newSpeed) not in seen:                        dfs(ni, nj, newSpeed)                dfs(position[0], position[1], 1)        minSpeed[position[0]][position[1]] = float(&#x27;inf&#x27;)        ans = []        for i in range(n):            for j in range(m):                if minSpeed[i][j] == 1:                    ans.append([i, j])        return ans\n时间复杂度: O(m * n * maxTerrain),\n空间复杂度: O(m * n * maxTerrain).\n LCP 46. 志愿者调配\n本题是宝宝独立想出解法并实现的。虽然实现之前我们有交流过解法，确定没问题她才开始实现的。\n列方程。每天每个场馆用(系数,常数)表示。比如最后一天0场馆就是(1, 0), 其他就是(0, 人数).然后往前推，更新场馆人数。到第一天再解方程。\nclass Solution:    def volunteerDeployment(self, finalCnt: List[int], totalNum: int, edges: List[List[int]], plans: List[List[int]]) -&gt; List[int]:        neighbour = collections.defaultdict(list)        for a,b in edges:            neighbour[a].append(b)            neighbour[b].append(a)        coef = [[1,0]]        for c in finalCnt:            coef.append([0,c])        for i in range(len(plans)-1, -1, -1):            num, idx = plans[i]            if num == 1:                coef[idx] = [coef[idx][0]*2, coef[idx][1]*2]            elif num == 2:                for nei in neighbour[idx]:                    coef[nei] = [coef[nei][0]-coef[idx][0], coef[nei][1]-coef[idx][1]]            else:                for nei in neighbour[idx]:                    coef[nei] = [coef[nei][0]+coef[idx][0], coef[nei][1]+coef[idx][1]]        divide = 0        for a,b in coef:            totalNum -= b            divide += a        x = totalNum//divide        ans = []        for a,b in coef:            ans.append(a*x+b)        return ans\n时间复杂度: O(m * n * avg(edges)),\n空间复杂度: O(edges + n).\n LCP 47. 入场安检\n一看到最后答案很大，需要取模。就基本不可能枚举所有的情况了，大概率是用DP。\n接下来就是像状态转移方程长什么样了。\n此题挺像约瑟夫杀人问题的，关注的是使用 栈/队 数字下标的变化。\n涉及到自顶向下的DP 和 大数取模运算，Python优势明显。\n虽然用@cache很方便，但经常忘记dp.cache_clear(), 导致一次TLE罚时。\n以后需要注意。\nclass Solution:    def securityCheck(self, capacities: List[int], k: int) -&gt; int:        MOD = 1000000007        n = len(capacities)        @cache        def dp(i, k):            # the current first capcities index, k is the number we want to pop first            # print(i,k)            if i == n - 1:                ans = 0                if k == 0: # queue                    ans += 1                if k == capacities[n-1] - 1:                    ans += 1                return ans            else:                ans = 0                c = capacities[i]                if k &gt;= c - 1:                    ans += dp(i+1, k - (c - 1)) # stack                                ans += dp(i+1, k) # queue                return (ans) % MOD                ans = dp(0, k)        dp.cache_clear()        return ans\n时间复杂度: O(n * k),\n空间复杂度: O(n * k).\n LCP 48. 无限棋局\n LCP 49. 环形闯关游戏\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"力扣2021春季赛 - 个人赛","url":"/2021/04/05/LCCUP-21-Spring-Solo/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (2)\nQ2 (4)\nQ3 (6)\nQ4 (8)\nQ5 (10)\n\n\n\n\n171 / 2750\nYoungForest\n12\n0:56:51\n0:06:21\n0:49:14\n0:56:55\nnull\nnull\n\n\n\n比赛链接\n LCP 28. 采购方案\n签到题。可以看到总共2750名选手签到。\n二分搜索。\nclass Solution &#123;    const int MOD = 1e9 + 7;public:    int purchasePlans(vector&lt;int&gt;&amp; nums, int target) &#123;        sort(nums.begin(), nums.end());        // 1 2 4 5 6/        // target = 5        // 2        int ans = 0;        for (int i = 0; i &lt; nums.size(); ++i) &#123;            const int x = nums[i];            auto it = upper_bound(nums.begin(), nums.begin() + i, target - x);            ans = (ans + distance(nums.begin(), it)) % MOD;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(1).\n LCP 29. 乐团站位\n一开始很简单想到模拟填数，时间复杂度为 O（N^2), 因为n 最大 10^9. 显然已经超时了，我们需要考虑更优的解法。\n观察发现，数字填写的规律十分明显。我们其实只需要计算其离起点的位置即可。通过计算目标点距离四周的距离，我们可以得到外侧总共有多少层，再通过等差数列求和，可以快速计算出外侧有多少数。然后，问题简化为目标点一定再最外圈的情况。分4种情况（上边，右边，下边，左边）分别计算目标点与左上角的距离。\n虽然想出这样O(1)的解法不难，但由于过程中设计数列求和，4边情况等细节，实现起来还是有些挑战，而且一不小心还挺容易出错的。我比赛过程中也是，自己写了覆盖所有情况的test case，解决了一些bug，才一次提交通过的。\nclass Solution &#123;    using ll = long long;public:    int helper(int n, int x, int y) &#123;        // Sn=n*a1+n(n-1)d/2        const ll left = y, right = n - 1 - y, up = x, down = n - 1 - x;        const ll shell = min(&#123;left, right, up, down&#125;);        const ll a1 = n - 1;        const ll d = -2;        ll shellAmount = 0;        if (shell &gt; 0) &#123;            shellAmount = 4 * (shell * a1 + shell * (shell - 1) * d / 2);        &#125;        const ll startX = shell, startY = shell, len = n - 2 * shell;        const ll start = (shellAmount) % 9;        // cout &lt;&lt; shell &lt;&lt; &quot; &quot; &lt;&lt; start &lt;&lt; &quot; &quot; &lt;&lt; startX &lt;&lt; &quot; &quot; &lt;&lt; startY &lt;&lt; endl;        if (shell == up) &#123;            return (y - startY + start) % 9;        &#125; else if (shell == right) &#123;            return (x - startX + start + len - 1) % 9;        &#125; else if (shell == down) &#123;            return (len - 1 - (y - startY) + start + 2 * (len - 1)) % 9;        &#125; else &#123; // shell == left            return (len - 1 - (x - startX) + start + 3 * (len - 1)) % 9;        &#125;    &#125;    int orchestraLayout(int n, int x, int y) &#123;        return helper(n, x, y) + 1;    &#125;&#125;;\n时间复杂度: O(1),\n空间复杂度: O(1).\n LCP 30. 魔塔游戏\n贪心。\n先遍历一遍判断和是否大于\b等于0，以决定最终的胜利与否。\n当血量少于1时，把之前减血最多的怪物放到最后。\n用一个优先队列维护怪物的减血量，方便快速找到最大的。\nclass Solution &#123;    using ll = long long;public:    int magicTower(vector&lt;int&gt;&amp; nums) &#123;        ll total = 0;        for (int x : nums) &#123;            total += x;        &#125;        if (total &lt; 0) return -1;        ll current = 1;        priority_queue&lt;int&gt; pq;        int ans = 0;        for (int x : nums) &#123;            current += x;            if (x &lt; 0)                pq.push(-x);            if (current &lt;= 0) &#123;                current += pq.top();                pq.pop();                ++ans;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n LCP 31. 变换的迷宫\n比赛时只想出了暴力的 DFS + DP 解法。\n时间复杂度: O(times * rows * cols * 2 * rows * cols * 5) = 100 * 50 * 50 * 2 * 50 * 50 * 5 = 6,250,000,000. 果不其然，TLE了。\n虽然如此，也在此给出自己TLE版本的代码。因为我认为这是一个针对类似路径问题不错的一个解法，可以针对大多数medium的题目。\nclass Solution:    def escapeMaze(self, maze: List[List[str]]) -&gt; bool:        maxT = len(maze)        rows = len(maze[0])        cols = len(maze[0][0])        nextStep = [(1, 0), (0, 1), (-1, 0), (0, -1), (0, 0)]        @lru_cache(None)        def dfs(t, i, j, temp, forever):            if t &gt;= maxT: return False            if i == rows - 1 and j == cols - 1: return True            maxTry = rows - 1 - i + cols - 1 - j            if maxTry &gt; maxT - t - 1: return False            for di, dj in nextStep:                ni = i + di                nj = j + dj                if ni &gt;= 0 and ni &lt; rows and nj &gt;= 0 and nj &lt; cols and t + 1 &lt; maxT:                    if maze[t + 1][ni][nj] == &#x27;.&#x27;:                        if (dfs(t + 1, ni, nj, temp, forever)):                            return True                    else: # &#x27;#&#x27;                        if forever == (ni, nj):                            if (dfs(t + 1, ni, nj, temp, forever)):                                return True                        else:                            if forever == (0, 0):                                if (dfs(t + 1, ni, nj, temp, (ni, nj))):                                    return True                            if temp:                                if (dfs(t + 1, ni, nj, False, forever)):                                    return True            return False                ans = dfs(0, 0, 0, True, (0, 0))        dfs.cache_clear()        return ans;\n赛后，还是要学习一下大佬们的解法。事实上，比赛中只有100名选手通过。\n这个题解 是我看了所有高赞（其实也都是个位数）回答发现最有说服力，也是最好的解法。也可以辅助另外一个题解看, 思路类似。\n问题的核心在于:\n\n如果将一个位置的陷阱 “永久” 消除，那么我们可以多次经过这一位置。但是，这等同于我们在这个位置上停留了一段时间。比如，行进的路径为 a→b→a→c→a，那么这等效于一直待在 a 不动。\n\n因此，可以把时间复杂度中用于枚举永久消失术位置的因子去掉，也就少了50*50，缩减到了5,000,000.\n LCP 32. 批量处理任务\n真正的难题，比赛时只有31人通过。题解都少了不少。\n看了不少使用高级算法做的ACM大佬，我连代码都没看懂。\n找到这个贪心解法的题解，分享给大家。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"力扣2021春季赛 - 战队赛","url":"/2021/04/11/LCCUP-21-Spring-Team/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (2)\nQ2 (4)\nQ3 (6)\nQ4 (8)\nQ5 (9)\nQ6(12)\n\n\n\n\n228 / 781\n佛系刷题\n6/41\n1:00:00\n0:42:42\n1:00:00\nnull\nnull\nnull\nnull\n\n\n\n比赛链接\n之前LC-CN举办的春季赛和秋季赛我都没参加，因为实验室之前每周六下午开组会，时间完美冲突。现在老板改为平时开小组会，一月开一次大组会，终于有机会参加2021年的春季赛了。\n周一清明节参加了个人赛，总结博客于此.\n周六和 佛系刷题群 的 老赖 还有 George 组队一起佛系出征，最后的结果果然很佛系，2题结束。我第一题，George第二题（还是我提供思路，帮忙 review + debug). 不得不说，跟2个人组队打比赛还不如我一个人效果好。怪不得ACM比赛的队伍都要磨合好久。\n LCP 33. 蓄水\n签到题。虽然是Easy，不过作为竞赛第一题，本题的难度还是相当大的。\n观察 + 暴力。\n操作共分为 升级 和 蓄水 2种。显然 蓄水操作应排在升级之后.\n一个朴素的暴力方法是，我们先枚举所有可能的蓄水次数，升级次数就因之而定，然后在其中选最小的。枚举蓄水次数也存在剪枝的过程。先试小的，如果已经比全局最小总次数大了，就直接结束了。\nclass Solution &#123;public:    int storeWater(vector&lt;int&gt;&amp; bucket, vector&lt;int&gt;&amp; vat) &#123;        // time: max(buckets[i]) * buckets.size() = 10^4 * 100        int ans = numeric_limits&lt;int&gt;::max();        const int n = bucket.size();        if (accumulate(vat.begin(), vat.end(), 0) == 0) return 0;        auto check = [&amp;](const int x) -&gt; int &#123;            int ans = 0;            for (int i = 0; i &lt; n; ++i) &#123;                const int need = vat[i] - bucket[i] * x;                if (need &gt; 0) ans += (need + x - 1) / x;            &#125;            return ans;        &#125;;        for (int x = 1; x &lt;= 1e4; ++x) &#123; // 蓄水次数            if (x &gt;= ans) break;            ans = min(ans, x + check(x));        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(max(vat[i]) * buckets.length) = O(10^4 * 100),\n空间复杂度: O(1).\n LCP 34. 二叉树染色\nDFS。需要注意的是，因为蓝色连接体节点数目为k，我们需要枚举把当前剩下的蓝色点数分配给左子树和右子树的方式。另外，观察到k的数目其实不大，只有10。更加印证了我的猜想。\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def maxValue(self, root: TreeNode, k: int) -&gt; int:        @cache        def dfs(root: TreeNode, remain: int) -&gt; int:            if not root: return 0            ans = dfs(root.left, k) + dfs(root.right, k)            for i in range(0, remain):                ans = max(ans, dfs(root.left, i) + dfs(root.right, remain - 1 - i) + root.val)            return ans        return dfs(root, k)\n时间复杂度: O(结点数 * k)，\n空间负载的: O(结点数 * k).\n LCP 35. 电动车游城市\n LCP 36. 最多牌组数\n LCP 37. 最小矩形面积\n LCP 38. 守卫城堡\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode 134 Gas Station","url":"/2019/09/06/LeetCode-134-Gas-Station/","content":"题目描述\n本题是我2月份Google实习生电话面试遇到的一道题目。我当时做的很混乱，一面直接挂了。今天看到同学发的讲解，决定重新尝试一下这道题目。毕竟自己这半年来刷了有500+道题目，算法实力有一定的增长。我只看到了讲解的题目，并没有看内容，算是自己半年后可以独立解决这个问题了吧。AC后，我竟然都哭了，为当时实力不济而伤心。不知道之后还有那么好的机会吗？\n这半年也参加了3次Kick start，除了第一次的A轮收到简历通知外，D轮和E轮都挂了。\n就像我之前反复讲的，我很想去Google，微软这样的外企，自己也为之付出了半年的努力。希望努力会有回报吧！如果可以拿到明年暑期的Google或微软的暑期实习，我就奖励自己一次端午节假期去韩国的自由行。有青梅竹马在那里，可以去找她。\n本题的思路是这样的:\n首先暴力的O(N^2)解法很简单.\n枚举所有的起点，从起点出发模拟循环的过程。\n可以用2个前缀和数组gas_prefix和cost_prefix追踪油量和花费，保证油量永远大于等于花费。\n然后尝试进一步的优化，思考不同起点之间的信息是否可以互相利用。\n观察有, 如果在第i个加油站油量小于花费了，则从起点到i（包含）的加油站都不必作为起点尝试了。因为如果起点 &lt; j &lt;= i，则j作为起点，到i时的gas_prefix = 旧起点的gas_prefix - 旧起点到j的gas_prefix, 同理cost_prefix = 旧起点的cost_prefix- 旧起点到j的cost_prefix. 因为旧起点到j是成功的，所以有旧起点到j的gas_prefix &gt;= 旧起点到j的cost_prefix, 所以gas_prefix还是小于 cost_prefix。j就不用尝试了，可以直接跳过。\n所以我们有了在O(N)的复杂度下的解法，起点直接跳到失败节点之后。\n同学的解法是通过反证法证明这一优化正确性的，也是很好的方法。\nclass Solution &#123;public:    int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123;        const int n = gas.size();        vector&lt;int&gt; gas_prefix(n);        vector&lt;int&gt; cost_prefix(n);        for (int begin_index = 0; begin_index &lt; n; ) &#123;            int i = 0;            for (; i &lt; n; ++i) &#123;                if (i == 0) &#123;                    gas_prefix[i] = gas[(begin_index + i) % n];                    cost_prefix[i] = cost[(begin_index + i) % n];                &#125; else &#123;                    gas_prefix[i] = gas_prefix[i - 1] + gas[(begin_index + i) % n];                    cost_prefix[i] = cost_prefix[i - 1] + cost[(begin_index + i) % n];                &#125;                if (gas_prefix[i] &lt; cost_prefix[i]) &#123;                    begin_index += i + 1;                    break;                &#125;            &#125;            if (i == n) &#123;                return begin_index;            &#125;        &#125;        return -1;    &#125;&#125;;","categories":["LeetCode"],"tags":["Algorithm"]},{"title":"LeetCode #136 Single Number","url":"/2018/09/12/LeetCode-136-Single-Number/","content":"Description: https://leetcode.com/problems/single-number/description/\nSolution: https://leetcode.com/problems/single-number/solution/\nDifficulty: Easy\n题目的难点在于：Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?\n我苦思冥想，实在无法同时满足时间复杂度O(n)，空间复杂的O(1)的要求。跑去看题解，Approach 4满足条件。使用了异或的位运算的性质，确实需要技巧。也可以看到评论区充满了&quot;awesome&quot;的感叹。会者不难，以后再遇到就Easy了。\nclass Solution:    def singleNumber(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: int        &quot;&quot;&quot;        ret = 0        for i in nums:            ret ^= i                    return ret","categories":["LeetCode"]},{"title":"LeetCode #215 Kth Largest Element in an Array","url":"/2018/09/15/LeetCode-215-Kth-Largest-Element-in-an-Array/","content":"Description: https://leetcode.com/problems/kth-largest-element-in-an-array/description/\nSolution: https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/\nDifficulty: Medium\n这是二师兄面试景驰的一道题目。因为他的面试在上午，我的在下午。所以，和他交流过面试内容后，我把他被面的题目都做了一遍。包括这道题目和找硬币。\n 我的动态规划\nclass Solution:    def findKthLargest(self, nums, k):        &quot;&quot;&quot;        :type nums: List[int]        :type k: int        :rtype: int        &quot;&quot;&quot;        memo = &#123;&#125;        mi = nums[0]        ma = nums[0]        for i in range(len(nums)):            ma = max(ma, nums[i])            mi = min(mi, nums[i])            memo[(i, i+1)] = mi            memo[(i, 1)] = ma                    def find(n, k):            if (n, k) in memo:                return memo[(n, k)]                        n_sub_1_k = find(n-1, k)                        if nums[n] &lt;= n_sub_1_k:                return n_sub_1_k                        n_sub_1_k_sub_1 = find(n-1, k-1)                        if nums[n] &gt;= n_sub_1_k_sub_1:                return n_sub_1_k_sub_1            else:                return nums[n]                    return find(len(nums)-1, k)\n时间复杂度 O(n^2)，memo中的每个元素需要遍历一遍;\n空间复杂度 O(n^2)，创建一个二维的memo.\n结果：TLE 超时。\n还不如直接快排找第k个值。\n 选择算法\nclass Solution:    def findKthLargest(self, nums, k):        &quot;&quot;&quot;        :type nums: List[int]        :type k: int        :rtype: int        &quot;&quot;&quot;        def partition(nums, lo, hi):            i = lo + 1            j = hi                        while True:                while i &lt;= hi and nums[i] &lt; nums[lo]:                    i += 1                while j &gt; lo and nums[j] &gt; nums[lo]:                    j -= 1                                if i &gt;= j:                    break                                    nums[i], nums[j] = nums[j], nums[i]                i += 1                j -= 1                            nums[lo], nums[j] = nums[j], nums[lo]                        return j                lo = 0        hi = len(nums) - 1        k = len(nums) - k                while lo &lt; hi:            j = partition(nums, lo, hi)            if j &lt; k:                lo = j + 1            elif j &gt; k:                hi = j - 1            else:                break                    return nums[k]\n和快排很像，尤其是partition部分。\n时间复杂度O(n)，空间复杂度O(n)。\n具体解释见Discuss。\n","categories":["LeetCode"]},{"title":"LeetCode #15 3Sum","url":"/2018/10/25/LeetCode-15-3Sum/","content":"这道很经典的题目我恰好在面试“景驰”的时候遇到过，当时是二面的Eric问的。我没做过这道题，但与之关联的2Sum做过（毕竟是LeetCode的首题，大概很多人都做过）。而且算法第4版中讨论算法复杂度的时候，用的也是一样的问题（细节可能不同，比如要求了结果中没有重复的triplet…），当时还有些印象。顺利地写出了O(n^2)时间复杂度的Solution，虽然事后发现有些小bug，比如list的sort是inplace的。但无伤大雅。\n今天我把面试时的solution整理了一下，submit后竟然Time Limit Exceeded了。\nDescription: https://leetcode.com/problems/3sum/description/\nSolution: None\nDifficulty: Medium\n 面试时的solution\nclass Solution:    def threeSum(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        mymap = &#123;&#125;        results = set()        for i in range(len(nums)):            for j in range(i + 1, len(nums)):                if - nums[i] - nums[j] in mymap:                    a = [- nums[i] - nums[j], nums[i], nums[j]]                    a.sort()                    results.add(tuple(a))            mymap[nums[i]] = i                re = []        for a in results:            re.append(list(a))        return re\n 解决超时问题\nreference[https://fizzbuzzed.com/top-interview-questions-1/]\n总的思想是，O(n^2)的时间复杂度已经不能再低了。更多的是尝试一些小的技巧，降低时间复杂度中的常数。\n 先排序\nclass Solution:    def threeSum(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        nums.sort()        mymap = set()        results = set()        for i in range(len(nums)):            if i &gt; 1 and nums[i] == nums[i-2]:                continue            for j in range(i + 1, len(nums)):                if j != i + 1 and nums[j] == nums[j-1]:                    continue                if - nums[i] - nums[j] in mymap:                    a = [- nums[i] - nums[j], nums[i], nums[j]]                    a.sort()                    results.add(tuple(a))            mymap.add(nums[i])                re = []        for a in results:            re.append(list(a))        return re\n增加了排序，和2层循环中的判断，使得重复的triplet出现的次数更少(result.add(tuple(a))被执行的次数更少)。\n观察之前TLE的Test case可以发现，leetcode卡了重复的triplet这块。python set.add操作的时间复杂度为O(1)，所以还是被卡了常数。\n two pointer, 空间复杂度降为O(1)\nclass Solution:    def threeSum(self, nums):        &quot;&quot;&quot;        :type nums: List[int]        :rtype: List[List[int]]        &quot;&quot;&quot;        nums.sort()        results = []                for i in range(len(nums)):            # never let i refer to the same value twice            if i != 0 and nums[i] == nums[i-1]:                continue                            j = i + 1            k = len(nums) - 1                        while j &lt; k:                if nums[i] + nums[j] + nums[k] == 0:                    results.append([nums[i], nums[j], nums[k]])                    j += 1                    k -= 1                    while j &lt; k and nums[j] == nums[j-1]: # never let j refer the same value twice                        j += 1                elif nums[i] + nums[j] + nums[k] &lt; 0:                    j += 1                else:                    k -= 1                return results\n第一次提交上去仍然是超时，然而啥也没改再次提交就Accepted了。看来leetcode也是看脸。\n","tags":["LeetCode"]},{"title":"LeetCode 258 Add Digits","url":"/2019/04/06/LeetCode-258-Add-Digits/","content":"今天刷题的时候遇到一个有趣的题目，求一个数字各个位相加的和，知道和小于10。链接.\n题目本身并不难，递归或者迭代都可以解决。但如何在O(1)的复杂度内求解，才是真正的考点。\n答案很简单: 1 + (num - 1) % 9.\n有兴趣的可以看看证明和扩展: wikipedia.\n","categories":["Programming"],"tags":["LeetCode"]},{"title":"LeetCode 29 Divide Two Integer","url":"/2018/10/23/LeetCode-29-Divide-Two-Integer/","content":"有4周时间没有刷LeetCode了，理由一方面是紧迫感下降，另一方面是行动力不足。\n最近又有一场面试要准备，小红书 视频组 的算法实习生。\n一面看 机器学习的知识，防止重蹈 快手 面试的覆辙；另一面回顾自己的代码能力，果然4周不刷题，连代码都写不好了。作为未来的程序员，代码能力不好怎么行呢？还是要重新有规划的开始刷leetcode的。\nDescription: https://leetcode.com/problems/divide-two-integers/description/\nSolution: 无\nDifficulty: Medium\n brute approach\n直接暴力，用减法代替除法。不出所料，果然超时。\n时间复杂度：O(m)，m为商的绝对值。\n空间复杂度：O(1), 除常量外，并未申请额外空间。\nclass Solution &#123;    public int divide(int dividend, int divisor) &#123;        if (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1) return Integer.MAX_VALUE;        if (divisor == 1) return dividend;        if (dividend == 0) return 0;                boolean positive = true;        if (Integer.signum(dividend) + Integer.signum(divisor) == 0) positive = false;                int count = 0;        int originalDividend = dividend;                while (true) &#123;            dividend = positive ? dividend - divisor : dividend + divisor;            if (Integer.signum(dividend) == 0) &#123;                count = positive ? count + 1 : count - 1;                break;            &#125;            if (Integer.signum(dividend) + Integer.signum(originalDividend) == 0) break;            count = positive ? count + 1 : count - 1;        &#125;                return count;    &#125;&#125;\n 模拟除法笔算\n\n很好的解释和python代码\nJava Solution, explanation awful though\n\npublic class Solution &#123;    public int divide(int dividend, int divisor) &#123;\t\tif(dividend==Integer.MIN_VALUE &amp;&amp; divisor==-1) return Integer.MAX_VALUE;        if(dividend &gt; 0 &amp;&amp; divisor &gt; 0) return divideHelper(-dividend, -divisor);        else if(dividend &gt; 0) return -divideHelper(-dividend,divisor);        else if(divisor &gt; 0) return -divideHelper(dividend,-divisor);        else return divideHelper(dividend, divisor);    &#125;        private int divideHelper(int dividend, int divisor)&#123;        // base case        if(divisor &lt; dividend) return 0;        // get highest digit of divisor        int cur = 0, res = 0;        while((divisor &lt;&lt; cur) &gt;= dividend &amp;&amp; divisor &lt;&lt; cur &lt; 0 &amp;&amp; cur &lt; 31) cur++;        res = dividend - (divisor &lt;&lt; cur-1);        if(res &gt; divisor) return 1 &lt;&lt; cur-1;        // 每次调用都只计算出来商里为1的一位        return (1 &lt;&lt; cur-1)+divide(res, divisor);    &#125;&#125;","categories":["LeetCode"]},{"title":"LeetCode #380 Insert Delete GetRandom O(1)","url":"/2018/10/26/LeetCode-380-Insert-Delete-GetRandomO-1/","content":"此题的重点在于理解“average O(1) time”，这是也是时间复杂度分析中的一个重要概念&quot;amortized&quot;。\n在 算法第4版 中，很多数据结构的操作的分析都是用的这个方法。所以，“amortized time complexity&quot;常常和对应的数据结构的操作相对应。我5月时面试旷世科技的时候，第二题问的是构造一个维护最大值的队的数据结构，最后要求操作的时间复杂度是“amortized O(1)&quot;。很遗憾，当时我对“amortized&quot;这一概念还不熟悉，对最差情况下的时间复杂度分析的倒是可以，虽然在面试官的引导下最后得出正确答案，但可想而知，最后的结果是no hire。\nDescription: https://leetcode.com/problems/insert-delete-getrandom-o1/description/\nSolution: None\nDifficulty: Medium\nanswer\n关键点在于，利用hashmap查找效率为O(1),ArrayList很方便用下标来产生随机数。\nclass RandomizedSet:    def __init__(self):        &quot;&quot;&quot;        Initialize your data structure here.        &quot;&quot;&quot;        self.array = []        self.index_map = &#123;&#125;            def insert(self, val):        &quot;&quot;&quot;        Inserts a value to the set. Returns true if the set did not already contain the specified element.        :type val: int        :rtype: bool        &quot;&quot;&quot;        if val in self.index_map:            return False                self.index_map[val] = len(self.array)        self.array.append(val)                return True            def remove(self, val):        &quot;&quot;&quot;        Removes a value from the set. Returns true if the set contained the specified element.        :type val: int        :rtype: bool        &quot;&quot;&quot;        if val not in self.index_map:            return False                self.array[self.index_map[val]] = self.array[-1]        self.index_map[self.array[-1]] = self.index_map[val]        self.array.pop()        self.index_map.pop(val)                return True            def getRandom(self):        &quot;&quot;&quot;        Get a random element from the set.        :rtype: int        &quot;&quot;&quot;        rnd = random.randint(0, len(self.array)-1)                return self.array[rnd]        # Your RandomizedSet object will be instantiated and called as such:# obj = RandomizedSet()# param_1 = obj.insert(val)# param_2 = obj.remove(val)# param_3 = obj.getRandom()","tags":["LeetCode"]},{"title":"LeetCode #538 Convert BST to Greater Tree","url":"/2018/09/14/LeetCode-538-Convert-BST-to-Greater-Tree/","content":"Description: https://leetcode.com/problems/convert-bst-to-greater-tree/description/\nSolution: https://leetcode.com/problems/convert-bst-to-greater-tree/solution/\nDifficulty: Easy\n此题虽为Easy难度，但一遍写对还是很困难的。\n看到二叉树，就要想到用递归解决。本题的一个trick是，如何把需要累加的值这个信息，在递归过程中传递。\n递归调用右子树时，需要返回整个右子树的和，将这个和加到根节点上。具体到我的解法，右子树的和可能存在于2个地方。1. 右子树的最左叶子节点 2. 右子树的根节点(此时，右子树无左子树)。\n递归调用左子树时，需要把根节点和右子树的和，这些信息传递进去，加到右子树的最左叶子上（也就是右子树中最大的那个值）。\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def convertBST(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        def convert(root, addition):            if root == None:                return addition            root.val += convert(root.right, addition)            if root.left == None:                return root.val            return convert(root.left, root.val)                convert(root, 0)                return root\n时间复杂度O(n)，需要遍历每个节点一次。\n空间复杂度 平均O(log n)，最差O(n)，递归调用的最大深度。\n看过Solution后，惊觉自己把问题搞得太复杂了。传递累加的值这一信息，通过一个全局变量维护即可。然后再对树右序遍历，代码写起来也简单很多。Solution中的Approach #3最好，其空间复杂度为O(1)。\n 迭代版本（无递归）\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def convertBST(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: TreeNode        &quot;&quot;&quot;        total = 0        stack = []                node = root                while len(stack) &gt; 0 or node != None:            while node != None:                stack.append(node)                node = node.right                        node = stack.pop()                        total += node.val            node.val = total                        node = node.left                return root","categories":["LeetCode"]},{"title":"LeetCode biweekly contest 1","url":"/2019/06/03/LeetCode-biweekly-contest-1/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (8)\n\n\n\n\n241 / 983\nYoungForest\n7\n0:18:23\n0:09:56\n0:18:23\nnull\nnull\n\n\n\nLeetCode开放了首届的双周赛，每周六晚上10:30~12:30。目的可能是方便欧洲的同学参赛（平时的单周赛欧洲那边都是凌晨），可以出更难的题目。因为时长扩展到2个小时了。\n由于19:00~21:30已经参加了Byte dance 的summer camp笔试。该笔试题也很难，3道编程题只有第二题过了30%。所以稍后的biweekly contest也翻车了，完成的 并不理想。只作出了2道Easy的题目。\n 1055. Fixed Point\nIntuition:\nStraight forward. One pass.\n时间复杂度: O(N)\n空间复杂度: O(1)\nclass Solution &#123;public:    int fixedPoint(vector&lt;int&gt;&amp; A) &#123;        for (int i = 0; i &lt; A.size(); ++i) &#123;            if (A[i] == i) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;;\n由于数组A是升序的，所以还可以用 二分搜索 的算法，实现O(log N).\nclass Solution &#123;public:    int fixedPoint(vector&lt;int&gt;&amp; A) &#123;        int lo = 0, hi = A.size();        while (lo &lt; hi) &#123;            int mid = lo + (hi - lo) / 2;            if (A[mid] &lt; mid) &#123;                lo = mid + 1;            &#125; else &#123;                hi = mid;            &#125;        &#125;                return A[lo] == lo ? lo : -1;    &#125;&#125;;\n 1056. Index Pairs of a String\nIntuition:\n题目为Easy，数据规模也比较小，考虑暴力解法即可。\n时间复杂度: O(words.size() * text.size() * words[i].size()),\n空间复杂度: O(words.size() * text.size()).\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; indexPairs(string text, vector&lt;string&gt;&amp; words) &#123;        vector&lt;vector&lt;int&gt;&gt; ret;        for (const string&amp; word : words) &#123;            int pos = 0;            while ((pos = text.find(word, pos)) != string::npos) &#123;                ret.push_back(&#123;pos, pos + word.size() - 1&#125;);                pos += 1;            &#125;        &#125;        sort(ret.begin(), ret.end(), [](const vector&lt;int&gt;&amp; lhs, const vector&lt;int&gt;&amp; rhs) -&gt; bool &#123;            if (lhs[0] != rhs[0])                return lhs[0] &lt; rhs[0];            return lhs[1] &lt; rhs[1];        &#125;);        return ret;    &#125;&#125;;\n 1066. Campus Bikes II\n由于数据规模很小，1 &lt;= workers.length &lt;= bikes.length &lt;= 10，考虑暴力的backtracking。\n时间复杂度: O(workers.length ^ bikes.length).\n空间复杂度: O(bikes.length).\n无奈超时了。\nclass Solution &#123;    // 因为1 &lt;= workers.length &lt;= bikes.length &lt;= 10，    // 考虑阶乘算法 + 剪枝    int global_minimum = numeric_limits&lt;int&gt;::max();    void backtracking(const vector&lt;vector&lt;int&gt;&gt;&amp; workers, const vector&lt;vector&lt;int&gt;&gt;&amp; bikes, vector&lt;bool&gt;&amp; visited, int local_distance, int step) &#123;        if (step == workers.size()) &#123;            global_minimum = min(global_minimum, local_distance);            return;        &#125;        if (local_distance &gt;= global_minimum)            return;        for (int i = 0; i &lt; visited.size(); ++i) &#123;            if (visited[i])                continue;            visited[i] = true;            backtracking(workers, bikes, visited, local_distance + abs(workers[step][0] - bikes[i][0]) + abs(workers[step][1] - bikes[i][1]), step + 1);            visited[i] = false;        &#125;    &#125;public:    int assignBikes(vector&lt;vector&lt;int&gt;&gt;&amp; workers, vector&lt;vector&lt;int&gt;&gt;&amp; bikes) &#123;        vector&lt;bool&gt; visited(bikes.size(), false);        backtracking(workers, bikes, visited, 0, 0);        return global_minimum;    &#125;&#125;;\n看了Discuss, 共有2种解法。优先队列 或 DP。\n 1067. Digit Count in Range\n首先，先解决一个更简单的问题。\nSolution\n求数字1的个数。\nint countDigitOne(int n)&#123;    int countr = 0;    for (long long i = 1; i &lt;= n; i *= 10) &#123;        long long divider = i * 10;        countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);    &#125;    return countr;&#125;\n根据以上解法，很容易扩充到任何数字。\n需要注意数字0因为不能开头，所以需要特殊处理\nclass Solution &#123;    // include n    int helper(int d, int n) &#123;        int ret = 0;        for (long long i = 1; i &lt;= n; i *= 10) &#123;            long long divisor = i * 10;            ret += (n / divisor) * i + min(i, max(0LL, n % divisor - d * i + 1)) - (d == 0 ? i : 0);            // cout &lt;&lt; ret &lt;&lt; &quot; &quot;;        &#125;        // cout &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; ret &lt;&lt; endl;        return ret;    &#125;public:    int digitsCount(int d, int low, int high) &#123;        return helper(d, high) - helper(d, low - 1);    &#125;&#125;;\n时间复杂度: O(log N)\n空间复杂度: O(1)\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 14","url":"/2019/12/14/LeetCode-biweekly-contest-15/","content":"这周没有出去玩，恰好遇到双周赛。久违地参加了一场，确实难得。\n本次双周赛都是常规题目，不难。我提前50min全部一次AC, 典型的手速场。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (2)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n119 / 2503\nYoungForest\n18\n0:39:28\n0:02:18\n0:08:49\n0:21:07\n0:39:28\n\n\n\n比赛结束之前的排名是92，参与人数为1900，赛后发现名次掉了。我猜测并验证是，赛后的排名把中国区的人也算进来了。增加的人数和第一名的变化完全符合我的猜测。到leetcode-cn上看了下，那里的排名是分为中国区和全球区的。看来以后比赛时要更加油了，有许多不知道的人在中国区打同样的比赛。\n 1287. Element Appearing More Than 25% In Sorted Array\nOne pass统计所有数的出现次数。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int findSpecialInteger(vector&lt;int&gt;&amp; arr) &#123;        unordered_map&lt;int, int&gt; count;        const int target = arr.size() / 4;        for (int i : arr) &#123;            ++count[i];            if (count[i] &gt; target)                return i;        &#125;        return -1;    &#125;&#125;;\n这个解法的缺陷在于没有利用题目中给的限制条件，数组是已经排好序的。但本题是签到题，数据规模10^4，此解法方便快速实现。\n更优的解法，利用二分搜索，每次可以递增的更快些。\n时间复杂度: O(N log N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int findSpecialInteger(vector&lt;int&gt;&amp; arr) &#123;        auto it = arr.begin();        while (it != arr.end()) &#123;            auto it2 = upper_bound(it, arr.end(), *it);            auto diff = it2 - it;            if (diff &gt; arr.size() / 4)                return *it;            it = it2;        &#125;        return -1;    &#125;&#125;;\n 1288. Remove Covered Intervals\n数据规模为1000，所以O(N ^ 2)的解法就可以过。\n最暴力的方法就是两两比较，该remove的remove。\n我的代码还使用了一个技巧，先按区间大小排序，然后从大到小开始比较。因为小的不可能包含大的，减少了比较数量。虽然时间复杂度不变，但会在常数上稍快些。\n时间复杂度: O(N ^ 2),\n空间复杂度: O(N).\nclass Solution &#123;public:    int removeCoveredIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        set&lt;pair&lt;int, int&gt;&gt; remains;        sort(intervals.begin(), intervals.end(), [](auto&amp; a, auto&amp; b) -&gt; bool &#123;            int length_a = a[1] - a[0];            int length_b = b[1] - b[0];            return length_b &lt; length_a;        &#125;);        for (auto&amp; v : intervals) &#123;            for (auto p : remains) &#123;                if (p.first &lt;= v[0] &amp;&amp; v[1] &lt;= p.second) &#123;                    goto remove;                &#125;            &#125;            remains.insert(&#123;v[0], v[1]&#125;);            remove:;        &#125;        return remains.size();    &#125;&#125;;\n更优的解法。先排序，排序规则为 区间左侧小的靠前，如果左侧相等，则右侧大的靠前。\n然后One pass遍历一边即可, 比较当前的右侧和之前最大的右侧的值。\n时间复杂度: O(N log N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int removeCoveredIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123;        sort(intervals.begin(), intervals.end(), [](auto&amp; a, auto&amp; b)  -&gt; bool &#123;            if (a[0] != b[0]) &#123;                return a[0] &lt; b[0];            &#125; else &#123;                return a[0] &gt; b[0];            &#125;        &#125;);        int right = 0;        int ans = 0;        for (auto&amp; v : intervals) &#123;            if (v[1] &gt; right) &#123;                ++ans;            &#125;            right = max(right, v[1]);        &#125;        return  ans;    &#125;&#125;;\n 1286. Iterator for Combination\n最暴力的方法是用回溯法生成所有的组合，存起来，然后封装迭代器。缺点是：空间消耗会比较大；在next调用次数小的时候，速度上没有懒运算经济。无奈我不知道C中如何实现 Python 的 yield，否则就可以懒运算了。\n当然，赛后有时间我还是研究了下C yield的实现策略。\n参考: [C++ yield实现](how C++ implement yield)\n时间复杂度: O(C^n_characters.size()),\n空间复杂度: O(combinationLength * C^n_characters.size()).\nclass CombinationIterator &#123;    void backtracking(vector&lt;string&gt;&amp; results, string&amp; current, int remain, const string&amp; characters, int index) &#123;        if (remain == 0) &#123;            results.push_back(current);            return;        &#125;        if (index == characters.size()) &#123;            return;        &#125;        if (remain &gt; characters.size() - index) &#123;            return;        &#125;        // add        current.push_back(characters[index]);        backtracking(results, current, remain - 1, characters, index + 1);        current.pop_back();        // not add        backtracking(results, current, remain, characters, index + 1);    &#125;    vector&lt;string&gt; results;    int index = 0;public:    CombinationIterator(string characters, int combinationLength) &#123;        string current;        backtracking(results, current, combinationLength, characters, 0);    &#125;        string next() &#123;        return results[index++];    &#125;        bool hasNext() &#123;        return index &lt; results.size();    &#125;&#125;;/** * Your CombinationIterator object will be instantiated and called as such: * CombinationIterator* obj = new CombinationIterator(characters, combinationLength); * string param_1 = obj-&gt;next(); * bool param_2 = obj-&gt;hasNext(); */\n 1289. Minimum Falling Path Sum II\n和Minimum Falling Path Sum I一样，属于 DP 问题。\n状态转移方程为:\ndp[row][column] = arr[row][column] + min(dp[row - 1][last_column] for last_column in [0, column_size) and last_column != column).\n而且实现寻找上一层的最小值并不需要多一层循环，只需要保存上一层中最小值和次小值即可。\n时间复杂度: O(row_size * column_size),\n空间复杂度: O(row_size * column_size)，另一个明显的优化是dp只需要保存上一层的，可以减小到O(column_size).\nclass Solution &#123;    const int MAX_N = 0x3f3f3f3f;public:    int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; arr) &#123;        const int row_size = arr.size();        const int column_size = arr[0].size();        vector&lt;vector&lt;int&gt;&gt;  dp(row_size, vector&lt;int&gt; (column_size, 0));        int row = 0;        int min_first = MAX_N, min_second = MAX_N;        for (int column = 0; column &lt; column_size; ++column) &#123;            dp[row][column] = arr[row][column];            if (dp[row][column] &lt; min_first) &#123;                min_second  = min_first;                min_first = dp[row][column];            &#125; else if (dp[row][column] &lt; min_second) &#123;                min_second = dp[row][column];            &#125;            // cout &lt;&lt; dp[row][column] &lt;&lt; &quot; &quot;;        &#125;        // cout &lt;&lt; &quot; | &quot; &lt;&lt; min_first &lt;&lt; &quot; &quot; &lt;&lt; min_second;        // cout &lt;&lt; endl;        int last_row_min_first = min_first;        int last_row_min_second = min_second;        for (row = 1; row &lt; row_size; ++row) &#123;            min_first = min_second = MAX_N;            for (int column = 0; column &lt; column_size; ++column) &#123;                if (dp[row - 1][column] == last_row_min_first) &#123;                    dp[row][column] = last_row_min_second + arr[row][column];                &#125; else &#123;                    dp[row][column] = last_row_min_first + arr[row][column];                &#125;                           if (dp[row][column] &lt; min_first) &#123;                    min_second  = min_first;                    min_first = dp[row][column];                &#125; else if (dp[row][column] &lt; min_second) &#123;                    min_second = dp[row][column];                &#125;                // cout &lt;&lt; dp[row][column] &lt;&lt; &quot; &quot;;            &#125;            // cout &lt;&lt; &quot; | &quot; &lt;&lt; min_first &lt;&lt; &quot; &quot; &lt;&lt; min_second;            // cout &lt;&lt; endl;            last_row_min_first = min_first;            last_row_min_second = min_second;        &#125;        return min_first;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 19","url":"/2020/02/10/LeetCode-biweekly-contest-19/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n179 / 3745\nYoungForest\n18\n0:41:10\n0:02:39\n0:10:36\n0:12:53\n0:36:10 1\n\n\n\n回国后第一次参加双周赛，手有些生，状态还在恢复。最近因为新型冠状病毒的瘟疫，一直在家隔离，除了买菜外几乎无法出门。今年的年味也因此没有了。我在家呆的几乎都快产后抑郁了。比赛结果还行。手速场也是我一直不擅长的类型。\n 1342. Number of Steps to Reduce a Number to Zero\n签到题。直接模拟 除2 和 减一 的2中操作即可。\n时间复杂度: O(log N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int numberOfSteps (int num) &#123;        int step = 0;        while (num &gt; 0) &#123;            if (num % 2 == 0) &#123;                num /= 2;            &#125; else &#123;                --num;            &#125;            ++step;        &#125;        return step;    &#125;&#125;;\n 1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold\n简单的滑动窗口，可以直接套用模版。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int numOfSubarrays(vector&lt;int&gt;&amp; arr, int k, int threshold) &#123;        int ans = 0;        int s = 0;        for (int i = 0; i &lt; k; ++i) &#123;            s += arr[i];        &#125;        if (s &gt;= threshold * k) &#123;            ++ans;        &#125;        for (int i = k; i &lt; arr.size(); ++i) &#123;            s = s + arr[i] - arr[i - k];            if (s &gt;= threshold * k) &#123;                ++ans;            &#125;        &#125;                return ans;    &#125;&#125;;\n 1344. Angle Between Hands of a Clock\n计算钟表上时针和分针之间的角度。分别计算时针和分针的位置，然后算夹角即可。\n时间复杂度: O(1),\n空间复杂度: O(1).\nclass Solution &#123;public:    double angleClock(int hour, int minutes) &#123;        double h = hour;        double m = minutes;        h = h * 5 + m / 12;        double x = abs(h - m) * 6;        if (x &gt;= 180) &#123;            return 360 - x;        &#125; else &#123;            return x;        &#125;    &#125;&#125;;\n 1345. Jump Game IV\n又一道Jump Game的题目，本以为和之前一样都要用动态规划。尝试一次后，发现其实需要用BFS解决。\n有一点需要注意的是，每次用过reverse数组后，需要把数组清空，这样就不会导致重复的计算。感谢hiepit的帖子。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int minJumps(vector&lt;int&gt;&amp; arr) &#123;        if (arr.size() &lt;= 1) return 0;        int target = arr.size() - 1;        unordered_map&lt;int, vector&lt;int&gt;&gt; reverse;        for (int i = arr.size() - 1; i &gt;= 0; --i) &#123;            reverse[arr[i]].push_back(i);        &#125;        queue&lt;int&gt; q;        q.push(0);        unordered_set&lt;int&gt; seen;        seen.insert(0);        int step = 1;        while (!q.empty()) &#123;            int s = q.size();            for (int i = 0; i &lt; s; ++i) &#123;                int index = q.front();                q.pop();                auto&amp; condidates = reverse[arr[index]];                condidates.push_back(index + 1);                condidates.push_back(index - 1);                for (int next : condidates) &#123;                    if (next == target)                        return step;                    if (next &lt; arr.size() &amp;&amp; next &gt;= 0 &amp;&amp; seen.find(next) == seen.end()) &#123;                        seen.insert(next);                        q.push(next);                    &#125;                &#125;                condidates.clear(); // important, avoid duplicated computing            &#125;            ++step;        &#125;        return -1;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 20","url":"/2020/02/23/LeetCode-biweekly-contest-20/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n233 / 4347\nYoungForest\n18\n0:41:39\n0:03:32\n0:13:58  1\n0:24:13\n0:31:39  1\n\n\n\n本次比赛题目比较简单，又是一次手速和bug-free的比拼。\n真的是错过比赛半年，连人数较少的双周赛都进不了前200了，吓～\n 1356. Sort Integers by The Number of 1 Bits\n利用C++标准库中的排序函数和lambda表达式。\n时间复杂度: O(n log n),\n空间复杂度: O(1).\nclass Solution &#123;public:    vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123;        sort(arr.begin(), arr.end(), [](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            auto aa = __builtin_popcount(a);            auto bb = __builtin_popcount(b);            if (aa == bb) &#123;                return a &lt; b;            &#125; else &#123;                return aa &lt; bb;            &#125;        &#125;);        return arr;    &#125;&#125;;\n 1357. Apply Discount Every n Orders\n考察对数据结构的熟悉程度。根据题意直接实现即可。\n因为读题不仔细，把discount的定义搞错了（是减价多少，而不是剩下多少），导致了一次错误提交。\n时间复杂度：O(product.length),\n空间复杂度：O(getBill.length).\nclass Cashier &#123;    unordered_map&lt;int, int&gt; m;    int d;    int nn;    int index = 0;public:    Cashier(int n, int discount, vector&lt;int&gt;&amp; products, vector&lt;int&gt;&amp; prices) &#123;        d = discount;        nn = n;        for (int i = 0; i &lt; products.size(); ++i) &#123;            m[products[i]] = prices[i];        &#125;        index = 0;    &#125;        double getBill(vector&lt;int&gt; product, vector&lt;int&gt; amount) &#123;        ++index;        bool discount = false;        if (index == nn) &#123;            index = 0;            discount = true;        &#125;        double ans = 0;        for (int i = 0; i &lt; product.size(); ++i) &#123;            ans += amount[i] * m[product[i]];        &#125;        if (discount)            ans *= 1 - d / 100.0;        return ans;    &#125;&#125;;/** * Your Cashier object will be instantiated and called as such: * Cashier* obj = new Cashier(n, discount, products, prices); * double param_1 = obj-&gt;getBill(product,amount); */\n 1358. Number of Substrings Containing All Three Characters\n滑动窗口。在右侧移动的时候，保持窗口最小，此时，左侧窗口的左边都是符合条件的子串。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int numberOfSubstrings(string s) &#123;        int right = 0, left = 0;        vector&lt;int&gt; count(3, 0);        int ans = 0;        while (right &lt; s.size()) &#123;            ++count[s[right] - &#x27;a&#x27;];            while (left &lt;= right &amp;&amp; count[s[left] - &#x27;a&#x27;] &gt; 1) &#123;                --count[s[left] - &#x27;a&#x27;];                ++left;            &#125;            if (count[0] &gt;= 1 &amp;&amp; count[1] &gt;= 1 &amp;&amp; count[2] &gt;= 1) &#123;                ans += (left + 1) * 1;            &#125;            ++right;        &#125;        return ans;    &#125;&#125;;\n 1359. Count All Valid Pickup and Delivery Options\n一个典型的递归问题。\n对于n个物件，我们从中选择任何一个作为第一个pickup, 然后计算剩余n-1个物件的排序问题。diliver可以插入在任意位置(2 * (n - 1) + 1种情况)。\n因为取余问题导致一次Wrong Answer，已经不是第一次了。下次需要注意。\n时间复杂度: O(N),\n空间复杂度: O(N) -&gt; O(1), 使用迭代解法或尾递归解法，这里就不予展示了.\nclass Solution &#123;    using ll = long long;    ll mod = 1e9 + 7;public:    ll countOrders(int n) &#123;        if (n == 1) return 1;        return (n * (countOrders(n - 1) * (2 * (n - 1) + 1)) % mod) % mod;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 21","url":"/2020/03/08/LeetCode-biweekly-contest-21/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n175 / 4729\nYoungForest\n19\n1:05:07\n0:21:38\n0:39:43\n0:50:40\n1:05:07\n\n\n\n整体难度不大，尤其是后2题并没有该有的难度。\n 1370. Increasing Decreasing String\n直接模拟构造结果字符串的过程即可。这里寻找字符串的过程可以使用二分查找，因为原始字符串需要更新，所以使用二叉查找树这一数据结构较好。\n时间复杂度: O(N * log N),\n空间复杂度: O(N).\nclass Solution &#123;public:    string sortString(string s) &#123;        string ans;        multiset&lt;char&gt; container;        for (char c : s) &#123;            container.insert(c);        &#125;        while (!container.empty()) &#123;            char smallest = *container.begin();            container.erase(container.begin());            ans.push_back(smallest);            decltype(container.begin()) it;            while ((it = container.upper_bound(smallest)) != container.end()) &#123;                ans.push_back(*it);                smallest = *it;                container.erase(it);            &#125;            if (!container.empty()) &#123;                char largest = *(prev(container.end()));                container.erase(prev(container.end()));                ans.push_back(largest);                while ((it = container.lower_bound(largest)) != container.begin()) &#123;                    ans.push_back(*prev(it));                    largest = *prev(it);                    container.erase(prev(it));                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n 1371. Find the Longest Substring Containing Vowels in Even Counts\n观察有：奇数减奇数等于偶数，偶数减偶数等于偶数。所以问题可以转化为，寻找最左边计数为奇数（或偶数）的位置。因为有5个元音字母，分奇偶，共32种状态。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int findTheLongestSubstring(string s) &#123;        vector&lt;int&gt; left_state(32, -2);        left_state[0] = -1;        auto code = [&amp;](unordered_map&lt;char, int&gt;&amp; m) -&gt; unsigned int &#123;            const static vector&lt;char&gt; position = &#123;&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;&#125;;            unsigned  int ans = 0;            for (unsigned  int i = 0; i &lt; position.size(); ++i) &#123;                if  (m[position[i]] % 2 == 1) &#123;                    ans |= (1 &lt;&lt; i);                &#125;            &#125;            return ans;        &#125;;        unordered_map&lt;char, int&gt; m;        int ans = 0;        for (int i = 0; i &lt; s.size(); ++i) &#123;            ++m[s[i]];            auto c = code(m);            if (left_state[c] != -2) &#123;                ans = max(ans, i - left_state[c]);            &#125; else &#123;                left_state[c] = i;            &#125;        &#125;        return ans;    &#125;&#125;;\n 1372. Longest ZigZag Path in a Binary Tree\n树的问题用递归解。\n时间复杂度: O(N),\n空间复杂度: O(N).\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    // left, right    // return result if root is left/right child    int ret = 0;    pair&lt;int, int&gt; recurse(TreeNode* root) &#123;        if (root) &#123;            auto l = recurse(root-&gt;left);            auto r = recurse(root-&gt;right);            ret = max(&#123;ret, r.second + 1, l.first + 1&#125;);            return &#123;r.second + 1, l.first + 1&#125;;        &#125; else &#123;            return &#123;-1, -1&#125;;        &#125;    &#125;public:    int longestZigZag(TreeNode* root) &#123;        auto ans = recurse(root);        return ret;    &#125;&#125;;\n 1373. Maximum Sum BST in Binary Tree\n仍然是 树的问题用递归解决。\n返回值依次为：\n\n子树中的最小值\n子树中的最大值\n是否为BST\n子树的和\n\n时间复杂度: O(N),\n空间复杂度: O(height).\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    int ret = 0;    // smallest, largest, BST?, sum    tuple&lt;int, int, bool, int&gt; recurse(TreeNode* root) &#123;        if (!root) &#123;            return &#123;0, 0, true, 0&#125;;        &#125; else &#123;            auto l = recurse(root-&gt;left);            auto r = recurse(root-&gt;right);            bool isBST = (root-&gt;left == nullptr || get&lt;1&gt;(l) &lt; root-&gt;val) &amp;&amp; (root-&gt;right == nullptr || get&lt;0&gt;(r) &gt; root-&gt;val) &amp;&amp; get&lt;2&gt;(l) &amp;&amp; get&lt;2&gt;(r);            int smallest = root-&gt;val, largest = root-&gt;val;            if (root-&gt;left) &#123;                smallest = min(smallest, get&lt;0&gt;(l));                largest = max(largest, get&lt;1&gt;(l));            &#125;            if (root-&gt;right) &#123;                smallest = min(smallest, get&lt;0&gt;(r));                largest = max(largest, get&lt;1&gt;(r));            &#125;                               int s = get&lt;3&gt;(l) + get&lt;3&gt;(r) + root-&gt;val;            if (isBST)                ret = max(s, ret);            return &#123;smallest, largest, isBST, s&#125;;        &#125;    &#125;public:    int maxSumBST(TreeNode* root) &#123;        recurse(root);        return ret;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 22","url":"/2020/03/23/LeetCode-biweekly-contest-22/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n1357 / 5632\nYoungForest\n12\n1:27:09\n0:05:06\n0:48:41  1\n1:22:09\nnull\n\n\n\n 1385. Find the Distance Value Between Two Arrays\n先对arr2进行排序，再对arr1中的每一个元素，利用二分搜索，判断arr2中是否有距离在d中的值。\n时间复杂度: O(arr2.size() * log arr2.size() + arr1.size() * log arr2.size()),\n空间复杂度: O(1).\nclass Solution &#123;public:    int findTheDistanceValue(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2, int d) &#123;        int ans = 0;        sort(arr2.begin(), arr2.end());        for (int i : arr1) &#123;            auto it1 = lower_bound(arr2.begin(), arr2.end(), i - d);            auto it2 = upper_bound(arr2.begin(), arr2.end(), i + d);            if (it1 == it2)                ++ans;        &#125;        return ans;    &#125;&#125;;\n 1386. Cinema Seat Allocation\n贪心。每排尝试放2个family，再尝试放一个family。因为一行10个座位，所以可以用bitmap来表示占用情况。对于没reserverd的行，直接放2个。\n时间复杂度: O(reservedSeats.size() * log reserveredSeats.size() + max(n, reservedSeats.size())),\n空间复杂度: O(1).\nclass Solution &#123;public:    int maxNumberOfFamilies(int n, vector&lt;vector&lt;int&gt;&gt;&amp; reservedSeats) &#123;        sort(reservedSeats.begin(), reservedSeats.end(), [](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            if (a[0] == b[0]) &#123;                return a[1] &lt; b[1];            &#125; else &#123;                return a[0] &lt; b[0];            &#125;        &#125;);        int ans = 0;        for (int index = 0, row = 1; row &lt;= n;) &#123;            unsigned int current_row = 0;            for (; index &lt; reservedSeats.size() &amp;&amp; reservedSeats[index][0] == row; ++ index) &#123;                current_row |= 1 &lt;&lt; (reservedSeats[index][1] - 1);            &#125;            current_row = ~current_row;            if ((current_row &amp; 0b0111111110) == 0b0111111110)                ans += 2;            else if ((current_row &amp; 0b0001111000) == 0b0001111000)                ++ans;            else if((current_row &amp; 0b0000011110) == 0b0000011110)                ++ans;            else if ((current_row &amp; 0b0111100000) == 0b0111100000)                ++ans;            if (index &lt; reservedSeats.size()) &#123;                ans += (reservedSeats[index][0] - row - 1) * 2;                row = reservedSeats[index][0];            &#125;            else &#123;                ans += (n + 1 - row - 1) * 2;                row = n + 1;            &#125;        &#125;        return ans;    &#125;&#125;;\n 1387. Sort Integers by The Power Value\n刚开始想的是BFS，从1开始搜索。但是会超时，最后返回值的下标也不好处理，浪费了很多时间调试。\n时间复杂度: O(2 ^ value of Kth),\n空间复杂度: O(2 ^ value of Kth).\nclass Solution &#123;public:    int getKth(int lo, int hi, int k) &#123;        queue&lt;int&gt; q;        unordered_set&lt;int&gt; seen;        q.push(1);        seen.insert(1);        int count = 0;        int level = 0;        if (1 &gt;= lo &amp;&amp; 1 &lt;= hi) ++count;        if (count == k) return 1;        while (!q.empty()) &#123;            int s = q.size();            for (int i = 0; i &lt; s; ++i) &#123;                int y = q.front();                q.pop();                int x = (y - 1) / 3;                if ((y - 1) % 3 == 0 &amp;&amp; x % 2 == 1 &amp;&amp; seen.find(x) == seen.end()) &#123;                    q.push(x);                    seen.insert(x);                    if (x &gt;= lo &amp;&amp; x &lt;= hi) ++count;                &#125;                if (y &lt;= numeric_limits&lt;int&gt;::max() / 2) &#123;                    x = y * 2;                    if (seen.find(x) == seen.end()) &#123;                        q.push(x);                        seen.insert(x);                        if (x &gt;= lo &amp;&amp; x &lt;= hi) ++count;                    &#125;                &#125;            &#125;            ++level;            if (count &gt;= k)                break;        &#125;        int s = q.size();        vector&lt;int&gt; remain;        while (!q.empty()) &#123;            if (q.front() &gt;= lo &amp;&amp; q.front() &lt;= hi) &#123;                remain.push_back(q.front());            &#125;            q.pop();        &#125;        sort(remain.begin(), remain.end());        // cout &lt;&lt; &quot;count: &quot; &lt;&lt; count &lt;&lt; &quot;, &quot; &lt;&lt; remain.size() &lt;&lt; endl;        return remain[k - (count - remain.size()) - 1];    &#125;&#125;;\n后来发现其实是 记忆化搜索 即可，代码实现简单，效率还高。\n时间复杂度: O((hi - lo) * log (hi - lo) * value),\n空间复杂度: O(hi  -  lo).\nclass Solution &#123;public:    int getKth(int lo, int hi, int k) &#123;        unordered_map&lt;int, int&gt; memo;        function&lt;int(int)&gt; recurse = [&amp;](int index) -&gt; int &#123;            if (index == 1) return 0;            else if (memo.find(index) != memo.end()) &#123;                return memo[index];            &#125; else &#123;                if (index % 2 == 0)                    return memo[index] = recurse(index / 2) + 1;                else                    return memo[index] = recurse(3 * index + 1) + 1;            &#125;        &#125;;        vector&lt;int&gt; v;        for (int i = lo; i &lt;= hi; ++i) &#123;            v.push_back(i);        &#125;        sort(v.begin(), v.end(), [&amp;](int a, int b) -&gt; bool &#123;            int a_value = recurse(a);            int b_value = recurse(b);            if (a_value != b_value)                return a_value &lt; b_value;            else                return a &lt; b;        &#125;);        return v[k - 1];    &#125;&#125;;\n 1388. Pizza With 3n Slices\n因为前面的题目花了太长时间，第4题只有10min，看了下题目，没有思路就放弃了。\n其实，如果将问题转换一下，解法就呼之欲出了。\n问题可以转换为：从3*n数组中挑选n个元素，要求元素不能邻接，并且不能同时挑 头和尾，使得得到的和最大。和213. House Robber II类似。\n状态转移方程:\nf(begin, end, remain, cycle)= max&#123;    nums[end] + f(begin + cycle, end - 2, remain - 1, 0), // take end    f(begin, end - 1, remain, 0)    // not take end&#125;\n时间复杂度: O(N ^ 3),\n空间复杂度: O(N ^ 3).\nclass Solution &#123;public:    int maxSizeSlices(vector&lt;int&gt;&amp; slices) &#123;        map&lt;tuple&lt;int, int, int, int&gt;, int&gt; memo;        function&lt;int(int,int,int,int)&gt; f = [&amp;](int begin, int end, int remain, int cycle) -&gt; int &#123;            auto it = memo.find(&#123;begin, end, remain, cycle&#125;);            if (it == memo.end()) &#123;                int ans = -1;                if (remain == 1) &#123;                    ans = *max_element(slices.begin() + begin, slices.begin() + end + 1);                &#125; else if (end - begin + 1 &lt; 2 * remain - 1)  &#123;                    ans = -1;                &#125; else &#123;                    ans = max(                        slices[end] + f(begin + cycle, end - 2, remain - 1, 0),                        f(begin, end - 1, remain, 0)                    );                &#125;                return memo[&#123;begin, end, remain, cycle&#125;] = ans;            &#125; else &#123;                return it-&gt;second;            &#125;        &#125;;        return f(0, slices.size() - 1, slices.size() / 3, 1);    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 23","url":"/2020/04/07/LeetCode-biweekly-contest-23/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n199 / 7026\nYoungForest\n19\n0:40:57\n0:08:05\n0:11:44\n0:33:38\n0:40:57\n\n\n\n不难，手速场。发现很多手速场的比赛，第三题甚至都比第四题更难。\n 1399. Count Largest Group\nstraight forward. 用一个hashmap统计digit_sum -&gt; count, 最后再找出count最大的几组。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int countLargestGroup(int n) &#123;        unordered_map&lt;int, int&gt; seen;        int largestSize = 0;        for (int i = 1; i &lt;= n; ++i)  &#123;            int sumOfDigit = 0;            int current = i;            while (current &gt; 0) &#123;                sumOfDigit += current % 10;                current /= 10;            &#125;             ++seen[sumOfDigit];            largestSize = max(largestSize, seen[sumOfDigit]);        &#125;        int ans = 0;        for (auto it = seen.begin(); it != seen.end(); ++it) &#123;            if (it-&gt;second == largestSize)                ++ans;        &#125;        return ans;    &#125;&#125;;\n 1400. Construct K Palindrome Strings\n统计出现的奇数字符数目，必需小于等于k。并且因为要求回文串非空，所以需要s.size() &gt;= k。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    bool canConstruct(string s, int k) &#123;        if (s.size() &lt; k) return false;        vector&lt;int&gt; count(26, 0);        for (char c : s) &#123;            ++count[c - &#x27;a&#x27;];        &#125;        int single = 0;        for (int i : count) &#123;            if (i % 2 == 1)                ++single;        &#125;        return single &lt;= k;    &#125;&#125;;\n 1401. Circle and Rectangle Overlapping\n可以根据正方形的四条边，将空间分为9个部分，把圆的圆心的位置分为9种情况。每种情况是否和正方形overlap就很好判断了。\n时间复杂度: O(1),\n空间复杂度: O(1).\nclass Solution &#123;    int distance(int x1, int y1, int x2, int y2) &#123;        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 -y1);    &#125;public:    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) &#123;        auto closeEnough = [&amp;](int x, int y) -&gt; bool &#123;            return radius * radius &gt;= distance(x_center, y_center, x, y);        &#125;;        auto inSquare = [&amp;]() -&gt; bool &#123;            return x_center &lt;= x2 &amp;&amp; x_center &gt;= x1 &amp;&amp; y_center &lt;= y2 &amp;&amp; y_center &gt;= y1;        &#125;;        return closeEnough(x1, y1) || closeEnough(x1, y2) || closeEnough(x2, y2) || closeEnough(x2, y1) ||            inSquare() ||             (x_center &lt;= x2 &amp;&amp; x_center &gt;= x1 &amp;&amp; (y_center &lt;= y2 + radius &amp;&amp; y_center &gt;= y1 - radius)) ||            (y_center &lt;= y2 &amp;&amp; y_center &gt;= y1 &amp;&amp; (x_center &lt;= x2 + radius &amp;&amp; x_center &gt;= x1 - radius));     &#125;&#125;;\n讨论区中还有一种实现起来更简单的方法，可以快速找到长方形中离一个点（圆心）最近的点。\n 1402. Reducing Dishes\n贪心。先排序, 先取satisfaction最大的dish，直到后缀和小于0.\n时间复杂度: O(N log N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int maxSatisfaction(vector&lt;int&gt;&amp; satisfaction) &#123;        const int n = satisfaction.size();        sort(satisfaction.begin(), satisfaction.end());        int currentSum = 0;        int suffixSum = 0;        for (int i = n - 1; i &gt;= 0; --i) &#123;            suffixSum += satisfaction[i];            if (suffixSum &gt;= 0) &#123;                currentSum += suffixSum;             &#125; else &#123;                return currentSum;            &#125;        &#125;        return currentSum;    &#125;&#125;;\n第一次提交用的N^2的解法，排序后枚举起点，竟然都过了。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 24","url":"/2020/04/19/LeetCode-biweekly-contest-24/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n700 / 7729\nYoungForest\n18\n1:17:49\n0:04:50\n0:10:38\n0:17:45\n1:02:49 3\n\n\n\n最近参加了2场codforces的比赛，cf的rating徘徊在1400+。cf的题目相对leetcode还是难的多的。并没有坚持下来。这也和cf没有很好的discuss区有关，每届比赛结束后，只能看官方的editorial。\n 1413. Minimum Value to Get Positive Step by Step Sum\n统计presum的最负值，需要注意的是startValue必须是正数。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution:    def minStartValue(self, nums: List[int]) -&gt; int:        min_sum = 0        current_sum = 0        for i in nums:            current_sum += i            min_sum = min(current_sum, min_sum)        return 1 - min_sum if min_sum &lt;= 0 else 1\n 1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K\n贪心，永远选用小于等于i的最大的Fibonacci数，然后递归解决剩余的数。\n时间复杂度：O((log k)^2),\n空间复杂度: O(log k).\nclass Solution:    def findMinFibonacciNumbers(self, k: int) -&gt; int:        def findLargestFibonacciLessEqualThan(i):            a = 1            b = 1            while a &lt;= i:                a, b = a + b, a            return b                def dp(i):            x = findLargestFibonacciLessEqualThan(i)            if x == i:                return 1            else:                return 1 + dp(i - x)        return dp(k)\n 1415. The k-th Lexicographical String of All Happy Strings of Length n\n回溯法按字典序枚举所有的Happy string, 直到找到第k个。\n时间复杂度: O(min(3 ^ n, k)),\n空间复杂度: O(n).\nclass Solution &#123;public:    string getHappyString(int n, int k) &#123;        int rank = 0;        string ans;        function&lt;void(string&amp;)&gt; backtracking = [&amp;](string&amp; current) -&gt; void &#123;            if (current.size() == n) &#123;                ++rank;                if (rank == k) &#123;                    ans = current;                &#125;            &#125; else &#123;                char last = current.empty() ? &#x27;0&#x27; : current.back();                for (char c : &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;) &#123;                    if (c == last) continue;                    current.push_back(c);                    backtracking(current);                    if (rank &gt;= k) return;                    current.pop_back();                &#125;            &#125;        &#125;;        string current;        backtracking(current);        end:;        return ans;    &#125;&#125;;\n 1416. Restore The Array\nDP. dp[i]: 以第i个元素结尾的array可以有多少种分割方法。\ndp[i] = sum(dp[j] for j + 1, ..., i 可以组成一个有效的数字)\n时间复杂度: O(N * log K),\n空间复杂度: O(N).\nclass Solution:    def numberOfArrays(self, s: str, k: int) -&gt; int:        dp = [0] * (10**5 + 5)        dp[0] = 1        for index in range(1, len(s)):            i = index            ans = 0            current = int(s[i])            base = 1            while current &lt;= k and 10**(index - i) &lt;= k and i - 1 &gt;= 0:                ans += dp[i-1] if s[i] != &#x27;0&#x27; else 0                i -= 1                base *= 10                current = current + int(s[i]) * base            if current &lt;= k and 10**(index - i) &lt;= k:                ans += 1            dp[index] = ans                    return dp[len(s) - 1] % int(10**9 + 7)","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 26","url":"/2020/05/17/LeetCode-biweekly-contest-26/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n115 / 7795\nYoungForest\n19\n0:33:49\n0:03:55\n0:08:25\n0:11:57\n0:28:49  1\n\n\n\n上上周是五一假期，鸽了一场双周赛。之后还是会尽量参加的。最近比赛越来越顺手了，无论是每次的排名，还是rating，或是残酷群的排名。比之前都有所上升。尤其要感谢残酷群的每日一题和不定时的讲座，让我对DP和很多Hard的题目有了解决的信心。在此，再次安利一下残酷刷题群.\n 1446. Consecutive Characters\n滑动窗口，维持整个窗口的字母相等。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int maxPower(string s) &#123;        const int n = s.size();        int l = 0, r = 0;        int ans = 1;        for (; r &lt; s.size(); ++r) &#123;            if (s[r] == s[l]) continue;            else &#123;                ans = max(ans, r - l);                l = r;            &#125;        &#125;        ans = max(ans, n - l);        return ans;    &#125;&#125;;\n 1447. Simplified Fractions\n枚举所有的分母和分子，并判断是否是最简形式。幸运的是，C++17已经内置提供gcd函数。\n时间复杂度: O(n^2),\n空间复杂度: O(n).\nclass Solution &#123;public:    vector&lt;string&gt; simplifiedFractions(int n) &#123;        vector&lt;string&gt; ans;        for (int down = 2; down &lt;= n; ++down) &#123;            for (int up = 1; up &lt; down; ++up) &#123;                if (gcd(up, down) == 1) &#123;                    ans.push_back(to_string(up) + &quot;/&quot; + to_string(down));                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n 1448. Count Good Nodes in Binary Tree\ndfs, 把祖先节点的最大值作为参数传入。\n时间复杂度: O(n),\n空间复杂度: O(n).\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;    const int INF = 0x3f3f3f3f;    int recurse(TreeNode* root, int maxValue) &#123;        if (!root) return 0;        int ans = 0;        if (root-&gt;val &gt;= maxValue) ans = 1;        maxValue = max(maxValue, root-&gt;val);        return recurse(root-&gt;left, maxValue) + recurse(root-&gt;right, maxValue) + ans;    &#125;public:    int goodNodes(TreeNode* root) &#123;        return recurse(root, -INF);    &#125;&#125;;\n 1449. Form Largest Integer With Digits That Add up to Target\nDP. 背包问题，每次尝试加入一个数字。\n可以利用Greedy的思路，如果2个数的cost相同，则只有大数有用，进行常数上的优化。\n时间复杂度: O(target * target * 9),\n空间复杂度: O(target * target).\nclass Solution:    def largestNumber(self, cost: List[int], target: int) -&gt; str:        unique = &#123;&#125;        seen = set()        for i in range(len(cost) - 1, -1, -1):            if cost[i] not in seen:                seen.add(cost[i])                unique[i + 1] = cost[i]        @lru_cache(None)        def dp(t: int) -&gt; int:            if t &lt; 0:                return -1            if t == 0:                return 0            ans = -1            for i in unique:                tmp = dp(t - unique[i])                if tmp &gt;= 0:                    ans = max(ans,  tmp * 10 + i)            return ans        ans = dp(target)        return str(ans) if ans &gt;= 0 else &#x27;0&#x27;\nDiscuss中有O(target)的解法，主要思路是，不再以dp存储最大的字符串，而只存数位长度，然后再backward构造出结果。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 27","url":"/2020/05/31/LeetCode-biweekly-contest-27/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n231 / 7926\nYoungForest\n18\n0:42:16\n0:04:51\n0:10:55\n0:22:31  1\n0:37:16\n\n\n\n质量还可以的手速场。有些问题值得思考，只有发现本质，才能迅速解决。\n 1460. Make Two Arrays Equal by Reversing Sub-arrays\n由于对reverse操作的数目不限，我们可以采用这样的策略构造将2个array转成相同的array。用类似select sort的思想，每次reverse可以将一个位置排好序。所以问题转化为，2个数组排好序后是否相等。\nC++中vector的==的作用正是如此。\n时间复杂度: O(N log N),\n空间复杂度: O(1).\nclass Solution &#123;public:    bool canBeEqual(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) &#123;        sort(target.begin(), target.end());        sort(arr.begin(), arr.end());        return target == arr;    &#125;&#125;;\n 1461. Check If a String Contains All Binary Codes of Size K\n滑动窗口。窗口大小K，判断所有0 - 2^K - 1的二进制是否出现。\n时间复杂度: O(s.size()),\n空间复杂度: O(1 &lt;&lt; K).\nclass Solution &#123;public:    bool hasAllCodes(string s, int k) &#123;        vector&lt;bool&gt; seen(1 &lt;&lt; k, false);        int current = 0;        for (int i = 0; i &lt; k &amp;&amp; i &lt; s.size(); ++i) &#123;            current = current * 2 - &#x27;0&#x27; + s[i];        &#125;        seen[current] = true;        for (int i = k; i &lt; s.size(); ++i) &#123;            current = (current - (s[i-k]-&#x27;0&#x27;) * (1 &lt;&lt; (k-1))) * 2 - &#x27;0&#x27; + s[i];            seen[current] = true;        &#125;        return all_of(seen.begin(), seen.end(), [](const auto&amp; a) -&gt; bool &#123;            return a;        &#125;);    &#125;&#125;;\n 1462. Course Schedule IV\nDFS. 这里要注意queries本身很大，但是n很小。所以需要采用记忆化的DFS，防止重复计算。\n时间复杂度: O(n ^ 3 + queries),\n空间复杂度: O(n ^ 2).\nclass Solution &#123;public:    vector&lt;bool&gt; checkIfPrerequisite(int n, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        unordered_map&lt;int, vector&lt;int&gt;&gt; edges;        for (const auto&amp; v : prerequisites) &#123;            edges[v[1]].push_back(v[0]);        &#125;        map&lt;pair&lt;int,int&gt;, bool&gt; memo;        function&lt;bool(int,int,unordered_set&lt;int&gt;&amp;)&gt; dfs = [&amp;](int root, int target, unordered_set&lt;int&gt;&amp; seen) -&gt; bool &#123;            if (memo.find(&#123;root, target&#125;) == memo.end()) &#123;                if (target == root) return memo[&#123;root, target&#125;] = true;                for (int neighbor : edges[root]) &#123;                    if (seen.find(neighbor) == seen.end()) &#123;                        seen.insert(neighbor);                        if (dfs(neighbor, target, seen)) return memo[&#123;root, target&#125;] = true;                    &#125;                &#125;                return memo[&#123;root, target&#125;] = false;            &#125; else  &#123;                return memo[&#123;root, target&#125;];            &#125;        &#125;;        vector&lt;bool&gt; ans(queries.size());        for (int i = 0; i &lt; queries.size(); ++i) &#123;            unordered_set&lt;int&gt; seen;            ans[i] = dfs(queries[i][1], queries[i][0], seen);        &#125;        return ans;    &#125;&#125;;\nDiscuss中提到可以用 Floyd-Warshall 算法，计算有向图中2点的最短距离。\n 1463. Cherry Pickup II\nDP.\ndp[i][first][second]: 机器人走到第i行，第一个机器人的位置在first, 第二个在second 时，最大的cherry pick。\ndp[i][first][second] = max(dp[i-1][for last_first in range(first - 1, first + 2)])[for last_second in range(second - 1, second + 2)] + (grid[i][first] + grid[i][second]) if first != second else grid[i][first].\n时间复杂度: O(rows * cols^2 * 9),\n空间复杂度: O(rows * cols^2) -&gt; O(cols^2).\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int cherryPickup(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        const int rows = grid.size();        const int cols = grid[0].size();        vector&lt;vector&lt;vector&lt;int&gt;&gt;&gt; dp (rows, vector&lt;vector&lt;int&gt;&gt;(cols, vector&lt;int&gt;(cols, -INF)));        dp[0][0][cols-1] = grid[0][0] + grid[0][cols-1];        vector&lt;int&gt; dj = &#123;-1, 0, 1&#125;;        for (int i = 1; i &lt; rows; ++i) &#123;            for (int first = 0; first &lt; cols; ++first) &#123;                for (int second = 0; second &lt; cols; ++second) &#123;                    int add =  first == second ? grid[i][first] : grid[i][first] + grid[i][second];                    for (int dfirst : dj) &#123;                        int last_first = first + dfirst;                        if (last_first &gt;= 0 &amp;&amp; last_first &lt; cols) &#123;                            for (int dsecond : dj) &#123;                                int last_second = second + dsecond;                                if (last_second &gt;= 0 &amp;&amp; last_second &lt; cols) &#123;                                    dp[i][first][second] = max(dp[i][first][second], dp[i-1][last_first][last_second] + add);                                &#125;                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;        int ans = 0;        for (int first = 0; first &lt; cols; ++first) &#123;            for (int second = 0; second &lt; cols; ++second) &#123;                ans = max(ans, dp[rows-1][first][second]);            &#125;        &#125;        return ans;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 28","url":"/2020/06/15/LeetCode-biweekly-contest-28/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n448 / 8571\nYoungForest\n14\n1:22:34\n0:07:28\n0:11:43\nnull\n1:17:34  1\n\n\n\n最后一题debug耽误了不少时间，最后发现是range函数的cache写错了，修改了函数的参数。以后切记memo时要把参数写成const的。\n第三题，没有想到效率比较高的DP解法，一直TLE。\n 1475. Final Prices With a Special Discount in a Shop\n寻找下一个大于的数。使用单调递增栈解决。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; finalPrices(vector&lt;int&gt;&amp; prices) &#123;        stack&lt;int&gt; increasing;        const int n = prices.size();        vector&lt;int&gt; ans(n);        for (int i = n - 1; i &gt;= 0; --i) &#123;            while (!increasing.empty() &amp;&amp; increasing.top() &gt; prices[i]) &#123;                increasing.pop();            &#125;            if (increasing.empty()) &#123;                ans[i] = prices[i];            &#125; else &#123;                ans[i] = prices[i] - increasing.top();            &#125;            increasing.push(prices[i]);        &#125;        return ans;    &#125;&#125;;\n 1476. Subrectangle Queries\nburte force.\n时间复杂度:\n\nupdateSubrectangle: O((row2 - row1) * (col2 - col1)),\ngetValue: O(1).\n空间复杂度: O(rows * cols).\n\nclass SubrectangleQueries &#123;    vector&lt;vector&lt;int&gt;&gt; rect;    int rows, cols;public:    SubrectangleQueries(vector&lt;vector&lt;int&gt;&gt;&amp; rectangle) : rect(move(rectangle))&#123;        rows = rect.size();        cols = rect[0].size();    &#125;        void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) &#123;        for (int i = row1; i &lt;= row2; ++i) &#123;            for (int j = col1; j &lt;= col2; ++j) &#123;                rect[i][j] = newValue;            &#125;        &#125;    &#125;        int getValue(int row, int col) &#123;        return rect[row][col];    &#125;&#125;;/** * Your SubrectangleQueries object will be instantiated and called as such: * SubrectangleQueries* obj = new SubrectangleQueries(rectangle); * obj-&gt;updateSubrectangle(row1,col1,row2,col2,newValue); * int param_2 = obj-&gt;getValue(row,col); */\n也有一种2个函数都是O(log N)的解法, 2D segment tree，预处理O(N log N).\n 1477. Find Two Non-overlapping Sub-arrays Each With Target Sum\n使用前缀数组快速计算和为target，以i结尾的最短子数组。更新答案，更新i之前的最短子数组。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int minSumOfLengths(vector&lt;int&gt;&amp; arr, int target) &#123;        int ans = INF;        const int n = arr.size();        vector&lt;int&gt; best_till(n, INF);        unordered_map&lt;int, int&gt; presum;        presum[0] = -1;        int sum = 0;        for (int i = 0; i &lt; arr.size(); ++i) &#123;            sum += arr[i];            auto it = presum.find(sum - target);            if (it != presum.end()) &#123;                int left = it-&gt;second;                int length = i - left;                if (left &gt;= 0)                    ans = min(ans, best_till[left] + length);                if (i &gt; 0)                    best_till[i] = min(best_till[i-1], length);                else                    best_till[i] = length;            &#125; else &#123;                if (i &gt; 0)                    best_till[i] = best_till[i-1];            &#125;            presum[sum] = i;        &#125;        return ans &gt;= INF ? -1 : ans;    &#125;&#125;;\n 1478. Allocate Mailboxes\n区段DP。每次给前面几个house分配一个邮箱，一个邮箱的问题可以采用贪心解决。\n我写了top-bottom的写法，相比bottom-top更方便实现些。\n时间复杂度: O(N log N + N * K * N + N ^ 2),\n空间复杂度L O(N * K + N * N).\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int minDistance(vector&lt;int&gt;&amp; houses, int kk) &#123;        const int n = houses.size();        sort(houses.begin(), houses.end());        map&lt;pair&lt;int,int&gt;, int&gt; memo_range;        auto range = [&amp;](int left, int right) -&gt; int &#123;            auto it = memo_range.find(&#123;left, right&#125;);            if (it != memo_range.end()) return it-&gt;second;            else &#123;                            int ans = 0;                int l = left, r = right;                while (l &lt; r) &#123;                    ans += houses[r] - houses[l];                    ++l;                    --r;                &#125;                return memo_range[&#123;left, right&#125;] = ans;            &#125;        &#125;;        map&lt;pair&lt;int,int&gt;, int&gt; memo_dp;        function&lt;int(int,int)&gt; dp = [&amp;](int i, int k) -&gt; int &#123;            auto it = memo_dp.find(&#123;i, k&#125;);            if (it != memo_dp.end()) return it-&gt;second;            else &#123;                            if (k == 1) &#123;                    int ans = range(i, n - 1);                    // cout &lt;&lt; &quot;k == 1 &quot; &lt;&lt;  i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;                    return memo_dp[&#123;i, k&#125;] = ans;                &#125; else if (n - i &lt;= k) &#123;                    return 0;                &#125; else if (i &gt;= n) &#123;                    return 0;                &#125; else &#123;                    int ans = INF;                    // n - ni &gt;= k - 1                    for (int ni = i + 1; ni &lt;= n; ++ni) &#123;                        // if (i == 2) &#123;                        //     cout &lt;&lt; &quot;2 :: &quot; &lt;&lt; ni &lt;&lt; &quot; &quot;;                        //     cout &lt;&lt; range(i, ni - 1) &lt;&lt; endl;                        // &#125;                        ans = min(ans, range(i, ni - 1) + dp(ni, k - 1));                    &#125;                    // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;                    return memo_dp[&#123;i, k&#125;] = ans;                &#125;            &#125;        &#125;;        return dp(0, kk);    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 36","url":"/2020/10/06/LeetCode-biweekly-contest-36/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (6)\nQ4 (7)\n\n\n\n\n1667 / 8332\nYoungForest\n7\n0:15:37\n0:01:46\n0:15:37\nnull\nnull\n\n\n\n这次双周赛有跪了，生活真是起起落落落落…三四题其实还是有机会做出来的，但比赛时状态不好，决策有失误。在第3题看了2分钟没思路时转到第四题了，然后第四题想复杂了，实现花了不少时间，最后还是被卡时间TLE了。\n 1603. Design Parking System\n签到题。维护各个类型剩余车位数即可。\nclass ParkingSystem &#123;    array&lt;int, 4&gt; cnt;public:    ParkingSystem(int big, int medium, int small) &#123;        cnt[1] = big;        cnt[2] = medium;        cnt[3] = small;    &#125;        bool addCar(int carType) &#123;        if (cnt[carType] &gt; 0) &#123;            --cnt[carType];            return true;        &#125; else return false;    &#125;&#125;;/** * Your ParkingSystem object will be instantiated and called as such: * ParkingSystem* obj = new ParkingSystem(big, medium, small); * bool param_1 = obj-&gt;addCar(carType); */\n时间复杂度: O(addCar calls),\n空间复杂度: O(1).\n 1604. Alert Using Same Key-Card Three or More Times in a One Hour Period\n先按时间进行排序，然后依次遍历，记录每个人进入的时间，检查最后3次进入是否处于同一个小时。\nclass Solution &#123;public:    vector&lt;string&gt; alertNames(vector&lt;string&gt;&amp; keyName, vector&lt;string&gt;&amp; keyTime) &#123;        using pss  = pair&lt;string, string&gt;;        set&lt;string&gt; ans;        const int n = keyName.size();        vector&lt;pss&gt; records;        records.reserve(n);         for (int i = 0; i &lt; n; ++i) &#123;             records.emplace_back(keyTime[i], keyName[i]);         &#125;        sort(records.begin(), records.end());        int hour = 0;        unordered_map&lt;string, vector&lt;string&gt;&gt; enter;        auto convert2int = [&amp;](const string&amp; x) -&gt; int &#123;            int h = stoi(x.substr(0, 2));            int m = stoi(x.substr(3));            return h * 60 + m;        &#125;;        auto check = [&amp;](const string&amp; x) -&gt; bool &#123;            if (enter[x].size() &lt; 3) return false;            else &#123;                int a = convert2int(enter[x][enter[x].size() - 1]);                int b = convert2int(enter[x][enter[x].size() - 2]);                int c = convert2int(enter[x][enter[x].size() - 3]);                return a - c &lt;= 60;            &#125;        &#125;;        for (int i = 0; i &lt; n; ++i) &#123;            enter[records[i].second].push_back(records[i].first);            if (check(records[i].second)) &#123;                ans.insert(records[i].second);            &#125;        &#125;        return &#123;ans.begin(), ans.end()&#125;;    &#125;&#125;;\n时间复杂度: O(N log N * nameLength),\n空间复杂度: O(N).\n 1605. Find Valid Matrix Given Row and Column Sums\n贪心。对于每个位置，选择行列和小的那个，可以证明最后一定可以得到解。\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; restoreMatrix(vector&lt;int&gt;&amp; rowSum, vector&lt;int&gt;&amp; colSum) &#123;        const int rows = rowSum.size(), cols = colSum.size();        vector&lt;vector&lt;int&gt;&gt; ans(rows, vector&lt;int&gt;(cols, 0));        for (int i = 0; i &lt; rows; ++i) &#123;            for (int j = 0; j &lt; cols; ++j) &#123;                ans[i][j] = min(rowSum[i], colSum[j]);                rowSum[i] -= ans[i][j];                colSum[j] -= ans[i][j];            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(rows * cols),\n空间复杂度: O(rows * cols).\n 1606. Find Servers That Handled Most Number of Requests\n用一个 set 维护可用server。用priority_queue维护server变空闲时间，并更新set。\nclass Solution &#123;public:    vector&lt;int&gt; busiestServers(int k, vector&lt;int&gt;&amp; arrival, vector&lt;int&gt;&amp; load) &#123;        set&lt;int&gt; availble;        for (int i = 0; i &lt; k; ++i) &#123;            availble.insert(i);        &#125;        using pii = pair&lt;int, int&gt;;        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;        vector&lt;int&gt; cnt(k, 0);        for (int i = 0; i &lt; arrival.size(); ++i) &#123;            const int time = arrival[i];            while (!pq.empty() &amp;&amp; pq.top().first &lt;= time) &#123;                availble.insert(pq.top().second);                pq.pop();            &#125;            if (availble.empty()) continue;            const int j = i % k;            auto it = availble.lower_bound(j);            if (it == availble.end()) &#123;                it = availble.begin();            &#125;            ++cnt[*it];            pq.push(&#123;arrival[i] + load[i], *it&#125;);            availble.erase(it);        &#125;        const int maxRequests = *max_element(cnt.begin(), cnt.end());        vector&lt;int&gt; ans;        for (int i = 0; i &lt; cnt.size(); ++i) &#123;            if (cnt[i] == maxRequests) &#123;                ans.push_back(i);            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(arrival.size() * k),\n空间复杂度: O(k).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 37","url":"/2020/10/18/LeetCode-biweekly-contest-37/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n893 / 8250\nYoungForest\n7\n0:27:31\n0:11:24\n0:27:31\nnull\nnull\n\n\n\n连续2次双周赛遭遇滑铁卢了。\n第3题在赛后2分钟通过了，本来是在能力范围内的题目，但最后心太急了。本来晚上状态就不好，反而是比赛结束后，就写出来了。\n 1619. Mean of Array After Removing Some Elements\n签到题。先排序，后求和，在求平均。\n这里需要注意题目中限制了arr.size() % 20 == 0.\nclass Solution &#123;public:    double trimMean(vector&lt;int&gt;&amp; arr) &#123;        sort(arr.begin(), arr.end());        const int n = arr.size();        const int x = n / 20;        double s = 0.0;        for (int i = 0; i &lt; n; ++i) &#123;            if (i &lt; x || (n - 1 - i) &lt; x) continue;            s += arr[i];        &#125;        return s / (n - 2 * x);    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(1).\n 1620. Coordinate With Maximum Network Quality\n由于数据范围比较小，只有50，直接暴力。遍历每一个位置，遍历每个塔求它的信号。\nclass Solution &#123;public:    vector&lt;int&gt; bestCoordinate(vector&lt;vector&lt;int&gt;&gt;&amp; towers, int radius) &#123;        // 50 * 50 * 50        const double r = radius;        int maxSignal = 0;        int maxI = 0;        int maxJ = 0;        auto distance = [&amp;](const int a1, const int b1, const int a2, const int b2) -&gt; double &#123;            return  sqrt((a1 - a2) * (a1 - a2) + (b1 - b2) * (b1 - b2));        &#125;;        auto getSignal = [&amp;](const int i, const int j) -&gt; int &#123;            int ans = 0;            for (const auto&amp; t : towers) &#123;                double d = distance(t[0], t[1], i, j);                if (d &gt; r) continue;                ans += static_cast&lt;int&gt;(floor(t[2] / (1 + d)));            &#125;            return ans;        &#125;;        for (int i = 0; i &lt;= 50; ++i) &#123;            for (int j = 0; j &lt;= 50; ++j) &#123;                const int signal = getSignal(i, j);                // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; signal &lt;&lt; endl;                if (signal &gt; maxSignal) &#123;                    maxI = i;                    maxJ = j;                    maxSignal = signal;                &#125;            &#125;        &#125;        return &#123;maxI, maxJ&#125;;    &#125;&#125;;\n时间复杂度: O(rows * cols * towers),\n空间复杂度: O(1).\n 1621. Number of Sets of K Non-Overlapping Line Segments\n动态规划。虽然一下子就看出是DP了，但还是走了弯路。一开始写了O(n^2 * k)的算法，没有充分利用子问题。\n其实需要多设置一个变量表示开始是否必须是一个segment就好写了。\nclass Solution:    def numberOfSets(self, m: int, kk: int) -&gt; int:        MOD = int(10**9 + 7)        @lru_cache(None)        def dp(n, k, first):            if n &lt; k:                return 0            if n == k:                return 1            if k == 1:                return ((n + 1) * n) // 2            if first:                return (dp(n - 1, k, True) + dp(n - 1, k - 1, False)) % MOD;            else:                return (dp(n - 1, k, False) + dp(n, k, True)) % MOD        return dp(m - 1, kk, False)\n时间复杂度: O(n * k),\n空间复杂度: O(n * k).\n 1622. Fancy Sequence\n本题已经超出我的能力范围了，完全没有思路。\n学习了一遍评论区，大约有2中算法：\n\n乘法逆元\n懒惰线段树\n\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 38","url":"/2020/11/01/LeetCode-biweekly-contest-38/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n318 / 7446\nYoungForest\n18\n1:07:29\n0:12:38\n0:16:42\n0:57:29  2\n0:41:26\n\n\n\n 5539. Sort Array by Increasing Frequency\n签到题。按照题意先统计频数，再按频数排序即可。\nclass Solution &#123;public:    vector&lt;int&gt; frequencySort(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int, int&gt; cnt;        for (int i : nums) &#123;            ++cnt[i];        &#125;        using pii = pair&lt;int,int&gt;;        vector&lt;pii&gt; frequency;        for (const auto&amp; p : cnt) &#123;            frequency.emplace_back(p.second, p.first);        &#125;        sort(frequency.begin(), frequency.end(), [&amp;](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            if (a.first == b.first) &#123;                return a.second &gt; b.second;            &#125; else &#123;                return a.first &lt; b.first;            &#125;        &#125;);        vector&lt;int&gt; ans;        for (const auto&amp; p : frequency) &#123;            for (int i = 0; i &lt; p.first; ++i) &#123;                ans.push_back(p.second);            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n 5540. Widest Vertical Area Between Two Points Containing No Points\n虽然看起来很复杂，但其实就是一个按x排序，找最大间隔。题目故意说难了，绕了大家一圈。\nclass Solution &#123;public:    int maxWidthOfVerticalArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        const int n = points.size();        vector&lt;int&gt; x;        x.reserve(n);        for (const auto&amp; v : points) &#123;            x.push_back(v[0]);        &#125;        sort(x.begin(), x.end());        int ans = 0;        int lastx = x[0];        for (int i = 1; i &lt; n; ++i) &#123;            ans = max(ans, x[i] - lastx);            lastx = x[i];        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n 5541. Count Substrings That Differ by One Character\n这道题也是暴力。但一开始想复杂了，以为暴力是N4（其实是N3)。就跳过先做第四题了。回来后，仍然试图用所谓的25*N^3的算法做，TLE了2次。经舍友提醒，想恍然大悟，原来真是暴力。\nclass Solution &#123;public:    int countSubstrings(string s, string t) &#123;        int ans = 0;        for (int si = 0; si &lt; s.size(); ++si) &#123;            for (int sj = 1; si + sj &lt;= s.size(); ++sj) &#123;                for (int ti = 0; ti &lt; t.size(); ++ti) &#123;                    if (ti + sj &gt; t.size()) break;                    int diff = 0;                    for (int x = 0; x &lt; sj; ++x) &#123;                        if (s[si + x] != t[ti + x]) &#123;                            ++diff;                            if (diff &gt; 1) goto end;                        &#125;                    &#125;                    if (diff == 1) ++ans;                    end:;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N^3),\n空间复杂度: O(1).\n 5542. Number of Ways to Form a Target String Given a Dictionary\n经典DP。dp(begin, i)表示可以从words的第begin个字符开始，组成target[i：]的方案数。\n状态转移方程为:\ndp(begin, i) = dp(begin + 1, i + 1) * (target[i]在words[j][begin]中出现的次数) + dp(begin + 1, i)\nclass Solution:    def numWays(self, words: List[str], target: str) -&gt; int:        MOD = int(10**9 + 7)        n = len(words[0])        dictionary = defaultdict(lambda : defaultdict(int))        for w in words:            for i in range(n):                dictionary[i][w[i]] += 1                    @lru_cache(None)        def dp(begin, i):            if i == len(target):                # print (&#x27;return &#x27;, begin, i)                return 1            if begin &gt;= n:                return 0            appear = dictionary[begin][target[i]]            # print (begin, i)            return (dp(begin + 1, i + 1) * appear + dp(begin + 1, i)) % MOD        return dp(0, 0)\n时间复杂度: O(words.size() * words[0].size() + words[0].size() * target.size()),\n空间复杂度: O(words[0].size() * target.size()).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 39","url":"/2020/11/15/LeetCode-biweekly-contest-39/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n688 / 6047\nYoungForest\n7\n0:16:02\n0:03:44\n0:11:02  1\nnull\n0:41:26\n\n\n\n本周双周赛难度还是很大的，虽然是3456，但三四题我觉得不止5/6分。当然我也只做出前2题。三四题只试图用暴力解法做，但事实证明虽然很接近正确答案了，但还是全部TLE了。\n 5550. Defuse the Bomb\n签到题。使用辅助数组，按照题目要求填充即可。\nclass Solution &#123;public:    vector&lt;int&gt; decrypt(vector&lt;int&gt;&amp; code, int k) &#123;        const int n = code.size();        vector&lt;int&gt; ans(n, 0);        if (k == 0) &#123;            return ans;        &#125; else if (k &gt; 0) &#123;            for (int i = 0; i &lt; n; ++i) &#123;                for (int j = 1; j &lt;= k; ++j) &#123;                    ans[i] += code[(i + j) % n];                &#125;            &#125;            return ans;        &#125; else &#123;            k = -k;            for (int i = 0; i &lt; n; ++i) &#123;                for (int j = 1; j &lt;= k; ++j) &#123;                    ans[i] += code[(i - j + n) % n];                &#125;            &#125;            return ans;        &#125;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 5551. Minimum Deletions to Make String Balanced\n枚举每个分割点，删除分割点前所有的b，和分割点后所有的a。找到最小删除数。\nclass Solution &#123;public:    int minimumDeletions(string s) &#123;        const int n = s.size();        int ans = n;        const int totalA = count_if(s.begin(), s.end(), [](char c) -&gt; bool &#123;            return c == &#x27;a&#x27;;        &#125;);        int a = 0, b = 0;        for (int i = 0; i &lt; n; ++i) &#123;            ans = min(ans, b + totalA - a);            if (s[i] == &#x27;a&#x27;) ++a;            else ++b;        &#125;        ans = min(ans, b + totalA - a);        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1654. Minimum Jumps to Reach Home\n算最少步数用BFS。然而，本题的关键在于如何控制状态空间，即避免一直向右走。比较自然的想法是有一个临界值，超过这一临界值后，只能向左走。关于临界值的确定，可以参考残酷群主的解说。\nclass Solution &#123;public:    int minimumJumps(vector&lt;int&gt;&amp; forbidden, int a, int b, int x) &#123;        using pii = pair&lt;int, bool&gt;; // location, backward        unordered_set&lt;int&gt; blocks;        for (int i : forbidden) blocks.insert(i);        queue&lt;pii&gt; q;        set&lt;pii&gt; seen;        q.push(&#123;0, false&#125;);        seen.insert(&#123;0, false&#125;);        const int limits = max(x, *max_element(forbidden.begin(), forbidden.end())) + b;        int level = 0;        while (!q.empty()) &#123;            const int s = q.size();            for (int i = 0; i &lt; s; ++i) &#123;                auto [location, back] = q.front();                // cout &lt;&lt; location &lt;&lt; &quot; &quot; &lt;&lt; back &lt;&lt; endl;                q.pop();                if (location == x) return level;                if (location &lt;= limits) &#123;                    // forward                    const int nextLocation = location + a;                    if (blocks.find(nextLocation) == blocks.end() &amp;&amp; seen.find(&#123;nextLocation, false&#125;) == seen.end()) &#123;                        q.push(&#123;nextLocation, false&#125;);                        seen.insert(&#123;nextLocation, false&#125;);                    &#125;                &#125;                if (!back)&#123;                    // backward                    const int nextLocation = location - b;                    if (nextLocation &gt; 0 &amp;&amp; blocks.find(nextLocation) == blocks.end() &amp;&amp; seen.find(&#123;nextLocation, true&#125;) == seen.end()) &#123;                        q.push(&#123;nextLocation, true&#125;);                        seen.insert(&#123;nextLocation, true&#125;);                    &#125;                &#125;            &#125;            ++level;        &#125;        return -1;    &#125;&#125;;\n时间复杂度: O(max(x, max_forbidden) + b),\n空间复杂度: O(max(x, max_forbidden) + b).\n 5553. Distribute Repeating Integers\n比赛时只想到了暴力的回溯，试图通过剪枝优化，然而还是超时了。\n时间复杂度为: O(50^10)，理论上就是过不了。\n看了讨论区的题解才恍然大悟，这是道状态压缩DP。\nhuahua的视频讲解也特别清楚。在这里我实现了他的python top-bottom的版本，相比bottom-top更好写一些，也更好理解。注意在集合枚举子集时，有特别的技巧。\nclass Solution:    def canDistribute(self, nums: List[int], quantity: List[int]) -&gt; bool:        cnts = list(Counter(nums).values())        m = len(quantity)        n = len(cnts)        sums = [0] * (1 &lt;&lt; m)        for mask in range(1 &lt;&lt; m):            for i in range(m):                if mask &amp; (1 &lt;&lt; i):                    sums[mask] += quantity[i]        @lru_cache(None)        def dp(mask: int, i: int) -&gt; bool:            if mask == 0: return True            if i &gt;= n: return False            cur = mask            while cur:                if sums[cur] &lt;= cnts[i] and dp(mask ^ cur, i + 1):                    return True                cur = (cur - 1) &amp; mask            return dp(mask, i + 1)        return dp((1 &lt;&lt; m) - 1, 0)\n时间复杂度: O(3^m * n),\n空间复杂度: O(2^m * n).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 42","url":"/2020/12/27/LeetCode-biweekly-contest-42/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n573 / 6631\nYoungForest\n12\n0:51:14\n0:19:42\n0:24:42  1\n0:46:14\n差一分钟debug出来，好气呀！\n\n\n\n 1700. Number of Students Unable to Eat Lunch\n模拟题目中描述的吃饭的过程。事实上因为判断结束条件的原因，实现起来还不是那么直接了当。\nclass Solution &#123;public:    int countStudents(vector&lt;int&gt;&amp; students, vector&lt;int&gt;&amp; sandwiches) &#123;        const int n = students.size();        int ans = 0;        queue&lt;int&gt; stu;        for (int i : students) &#123;            stu.push(i);        &#125;        stack&lt;int&gt; sand;        for (int i = sandwiches.size() - 1; i &gt;= 0; --i) &#123;            sand.push(sandwiches[i]);        &#125;        while (!stu.empty()) &#123;            int current = stu.size();            while (!stu.empty()) &#123;                int s = stu.front();                stu.pop();                if (s == sand.top()) &#123;                    sand.pop();                    ++ans;                    break;                &#125; else &#123;                    --current;                    stu.push(s);                    if (current == 0) &#123;                        return n - ans;                    &#125;                &#125;            &#125;        &#125;        return 0;    &#125;&#125;;\n时间复杂度: O(students.size() * sandwiches.size()),\n空间复杂度: O(students.size() + sandwiches.size()).\n其实我的实现想复杂了。因为要有遍历学生的操作，所以学生的顺序其实是无所谓的。统计学生喜欢的种类，然后不断判断sandwiches栈顶元素是否满足条件。\n 1701. Average Waiting Time\n模拟做饭的过程。对于每一个顾客，判断他来时是否可以直接开始做饭。\nclass Solution &#123;    using ll = long long;public:    double averageWaitingTime(vector&lt;vector&lt;int&gt;&gt;&amp; customers) &#123;        ll wait = 0;        ll current = 0;        for (const auto&amp; v : customers) &#123;            if (current &lt;= v[0]) &#123;                current = v[0] + v[1];                wait += v[1];            &#125; else &#123;                wait += (current + v[1] - v[0]);                current += v[1];            &#125;        &#125;        double n = customers.size();        return wait / n;    &#125;&#125;;\n时间复杂度: O(customers.size()),\n空间复杂度: O(1).\n 1702. Maximum Binary String After Change\n贪心，思路见注释。\nclass Solution &#123;    // greedy: change first two op    // 00 -&gt; 10    // 01 -&gt; change after substring, 后面可以是0吗？010 -&gt; 001 -&gt; 101, recurse i + 1    //                             是 1 变 0，找0 向后传导即可。    // 10 -&gt; do not change, recurse i + 1    // 11 -&gt; do not change, recurse i + 2        // 时间复杂度： N * 4        // 1 会越变越多，然后往后移public:    string maximumBinaryString(string binary) &#123;        int firstZero = -1;        auto updateFirstZero = [&amp;]() -&gt; void &#123;            ++firstZero;            while (firstZero &lt; binary.size() &amp;&amp; binary[firstZero] != &#x27;0&#x27;) &#123;                ++firstZero;            &#125;        &#125;;        updateFirstZero();        function&lt;void(const int)&gt; recurse = [&amp;](const int i) -&gt; void &#123;            if (i &gt;= binary.size()) return;            if (i + 1 == binary.size()) &#123;                return;            &#125;            auto begin = binary.substr(i, 2);            if (begin == &quot;11&quot;) &#123;                recurse(i + 2);            &#125; else if (begin == &quot;10&quot;) &#123;                recurse(i + 1);            &#125; else if (begin == &quot;00&quot;) &#123;                binary[i] = &#x27;1&#x27;;                recurse(i + 1);            &#125; else &#123; // &quot;01&quot;                while (firstZero &lt;= i) &#123;                    updateFirstZero();                &#125;                if (firstZero &gt;= binary.size()) return;                binary[firstZero] = &#x27;1&#x27;;                updateFirstZero();                binary[i] = &#x27;1&#x27;;                binary[i + 1] = &#x27;0&#x27;;                binary[i + 2] = &#x27;1&#x27;;                recurse(i + 1);            &#125;        &#125;;        recurse(0);        return binary;    &#125;&#125;;\n时间复杂度: O(binary.size()),\n空间复杂度: O(binary.size()).\n实际上，\n也有寒神更简单的解法.\n 1703. Minimum Adjacent Swaps for K Consecutive Ones\n枚举集合中心位置，双指针更新左右边界。\ntemplate &lt;typename T&gt;ostream&amp; operator &lt;&lt;(ostream&amp; out, const vector&lt;T&gt;&amp; a) &#123;  out &lt;&lt; &quot;[&quot;; bool first = true;  for (auto&amp; v : a) &#123; out &lt;&lt; (first ? &quot;&quot; : &quot;, &quot;); out &lt;&lt; v; first = 0;&#125; out &lt;&lt; &quot;]&quot;;  return out;&#125;class Solution &#123;    // 二分？ 如何判定？N * log N    // greedy, 向密的地方靠近    // 把1移到对应位置的花费是中间0的数目    // 遍历集合地点，然后左右找k个1. N * K    // 右边取 x 个，左边取 k - x个    // 贪心， 左边右边谁近取谁    // 更新集合位置，双指针更新左右边界public:    int minMoves(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; ones;        int zero = 0;        for (int i : nums) &#123;            if (i == 1) &#123;                ones.push_back(zero);            &#125; else &#123;                ++zero;            &#125;        &#125;        zero = 0;        int one = 0;        int left = 0, right = 0;        int ans = 0;        int currentAns = 0;        // [left, right)        for (; right &lt; k; ++right) &#123;            currentAns += ones[right];        &#125;        ans = currentAns;        for (int mid = 0; mid &lt; nums.size(); ++mid) &#123;            if (nums[mid] == 0) &#123;                ++zero;                currentAns -= right - one; // right                currentAns += one - left; // left;            &#125; else &#123;                ++one;            &#125;                        while (right &lt; ones.size() &amp;&amp; ones[right] - zero &lt;= zero - ones[left]) &#123;                currentAns += ones[right] - zero - (zero - ones[left]);                ++right;                ++left;            &#125;            ans = min(ans, currentAns);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n比赛过程中，因为写了2个 bug 调了半个小时。差一分钟没交上，亏死了。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 47","url":"/2021/03/07/LeetCode-biweekly-contest-47/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n64 / 9933\nYoungForest\n18\n0:55:55\n0:03:37\n0:07:16\n0:13:28\n0:55:55\n\n\n\n疯狂上分场。13分钟做出3题。最后一题也思路相对比较顺畅。遇到2个阻塞。1. 一开始忘记考虑没有边相连的点对；2. 求了互补问题，但返回答案时粗心误以为总数是n^2，而事实上是C_2 n = n * (n - 1) / 2， 调试又浪费了不少时间。如果更加顺利的话，说不定成绩会突破天际。拿到前20名丰盛的礼物。\n\n 1779. Find Nearest Point That Has the Same X or Y Coordinate\n签到题。遍历一遍，判断是否同列/同行，和距离是否更近。\nclass Solution &#123;    int distance(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123;        return abs(a[0] - b[0]) + abs(a[1] - b[1]);    &#125;public:    int nearestValidPoint(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        const vector&lt;int&gt; me = &#123;x, y&#125;;        int ans = -1;        int ansDistance = numeric_limits&lt;int&gt;::max();        for (int i = 0; i &lt; points.size(); ++i) &#123;            const auto&amp; v = points[i];            if (v[0] == me[0] || v[1] == me[1]) &#123;                const int newDistance = distance(me, v);                if (newDistance &lt; ansDistance) &#123;                    ansDistance = newDistance;                    ans = i;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1780. Check if Number is a Sum of Powers of Three\n三进制编码。每位只能是0或1，不能是2.\nclass Solution &#123;public:    bool checkPowersOfThree(int n) &#123;        // x = (x - 1) / 3 or x / 3        // time: log_3 (n)        int x = n;        while (x &gt; 0) &#123;            if ((x - 1) % 3 == 0) &#123;                x = (x - 1) / 3;            &#125; else if (x % 3 == 0) &#123;                x = x / 3;            &#125; else &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O(log_3 N),\n空间复杂度: O(1).\n 1781. Sum of Beauty of All Substrings\n观察到数据规模并不大，500. 暴力枚举所有子串，O(1)更新 beauty.\nclass Solution &#123;public:    int beautySum(string s) &#123;        // brute-force: n ^ 2 * log 26        int ans = 0;        for (int i = 0; i &lt; s.size(); ++i) &#123;            vector&lt;int&gt; count(26, 0);            multiset&lt;int&gt; cnt;            for (int j = i; j &lt; s.size(); ++j) &#123;                // s[i:j]                auto it = cnt.find(count[s[j] - &#x27;a&#x27;]);                if (it != cnt.end()) cnt.erase(it);                ++count[s[j] - &#x27;a&#x27;];                cnt.insert(count[s[j] - &#x27;a&#x27;]);                ans += (*cnt.rbegin() - *cnt.begin());            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N^2 * log 26),\n时间复杂度: O(26).\n 1782. Count Pairs Of Nodes\n观察到点数V还是很大的：2*10^4，所以无法枚举所有的点对。\n但E的数目不大10^5，不属于稠密图。\n所以可以暴力边。\n而且queries.size()较小，只有20.\n总的思路是，先求所有点的度，如果2点度的和小于等于query，则2点的cnt一定小于等于query。因为有cnt(a, b) &lt;= degree(a) + degree(b)，等号成立当且仅当a b不互连。\n我们可以先把度排序，然后用two sum的方式二分搜索所有的满足degree(a) + degree(b) &lt;= query的点对。\n虽然题目要求cnt严格大于query, 但是我们先求cnt &lt;= query。因为两者是互补的。除了上述符合要求的点对，还有另外一些有边的点对也可能符合要求。这些点对是:\ndegree(a) + degree(b) &gt; query and degree(a) + degree(b) - edges(a, b) &lt;= query. 只需要遍历一遍所有的边即可。\nclass Solution &#123;    using pii = pair&lt;int, int&gt;;public:    vector&lt;int&gt; countPairs(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; queries) &#123;        // time: E + 20 * (E + V log V)        map&lt;pii, int&gt; edgesCount;        vector&lt;int&gt; degree(n, 0);        for (auto&amp; e : edges) &#123;            if (e[0] &gt; e[1]) swap(e[0], e[1]);            ++degree[e[0] - 1];            ++degree[e[1] - 1];            ++edgesCount[&#123;e[0] - 1, e[1] - 1&#125;];        &#125;                vector&lt;int&gt; degreeV = degree;        sort(degreeV.begin(), degreeV.end());                vector&lt;int&gt; answers;        answers.reserve(queries.size());        for (int i : queries) &#123;            int ret = 0;            for (auto ait = degreeV.begin(); ait != degreeV.end(); ++ait) &#123;                const int j = *ait;                auto bit = upper_bound(degreeV.begin(), ait, i - j);                ret += distance(degreeV.begin(), bit);            &#125;            for (auto p : edgesCount) &#123;                if (degree[p.first.first] + degree[p.first.second] &gt; i &amp;&amp; degree[p.first.first] + degree[p.first.second] - p.second &lt;= i) ++ret;            &#125;            answers.push_back((n * (n - 1)) / 2 - ret);        &#125;        return answers;    &#125;&#125;;\n时间复杂度: O(E + queries.size() * (E + V log V)),\n空间复杂度: O(V + E).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode-biweekly-contest-48","url":"/2021/03/21/LeetCode-biweekly-contest-48/","content":"耽误了比赛，赛后补题。\n 1796. Second Largest Digit in a String\n签到题。统计所有的数字，再从大到小找第二大的。\nclass Solution &#123;public:    int secondHighest(string s) &#123;        vector&lt;int&gt; cnt(10, 0);        for (char c : s) &#123;            if(isdigit(c)) &#123;                ++cnt[c - &#x27;0&#x27;];            &#125;        &#125;        int maxNumber = -1;        for (int i = 9; i &gt;= 0; --i) &#123;            if (cnt[i] &gt; 0) &#123;                if (maxNumber == -1) &#123;                    maxNumber = i;                &#125; else &#123;                    return i;                &#125;            &#125;        &#125;        return -1;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1797. Design Authentication Manager\n用字典存储每一个tokenId的expired time.\nclass AuthenticationManager &#123;    int timeToLive;    unordered_map&lt;string, int&gt; expiredTime;public:    AuthenticationManager(int _timeToLive) : timeToLive(_timeToLive) &#123;            &#125;        void generate(string tokenId, int currentTime) &#123;        expiredTime[tokenId] = currentTime + timeToLive;    &#125;        void renew(string tokenId, int currentTime) &#123;        auto it = expiredTime.find(tokenId);        if (it != expiredTime.end() &amp;&amp; it-&gt;second &gt; currentTime) &#123;            generate(tokenId, currentTime);        &#125;    &#125;        int countUnexpiredTokens(int currentTime) &#123;        int ans = 0;        for (const auto&amp; p : expiredTime) &#123;            if (p.second &gt; currentTime) &#123;                ++ans;            &#125;        &#125;        return ans;    &#125;&#125;;/** * Your AuthenticationManager object will be instantiated and called as such: * AuthenticationManager* obj = new AuthenticationManager(timeToLive); * obj-&gt;generate(tokenId,currentTime); * obj-&gt;renew(tokenId,currentTime); * int param_3 = obj-&gt;countUnexpiredTokens(currentTime); */\n时间复杂度:\n\ngenerate: O(1),\nrenew: O(1),\ncountUnexpiredTokens: O(expiredTime.size())\n空间复杂度:\nO(expiredTime.size())\n\n 1798. Maximum Number of Consecutive Values You Can Make\nBrute-force: O(N^2), TLE.\nclass Solution &#123;public:    int getMaximumConsecutive(vector&lt;int&gt;&amp; coins) &#123;        // max : sum(coins)        // determine(X): O(N * X)        // 2 ^ n,         // 1 + 2 + 3 + .. + n        unordered_set&lt;int&gt; s;        s.insert(0);        for (int i : coins) &#123;            auto ns = s;            for (int x : s) &#123;                ns.insert(x + i);            &#125;            s = move(ns);        &#125;        for (int i = 0; ; ++i) &#123;            if (s.find(i) == s.end()) return i;        &#125;        return -1;    &#125;&#125;;\n 1799. Maximize Score After N Operations\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 49","url":"/2021/04/04/LeetCode-biweekly-contest-49/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n108 / 9082\nYoungForest\n18\n1:37:36\n0:03:39\n0:09:01\n0:14:28\n1:27:36  2\n\n\n\n最近因为放松了刷题，自己竞赛水平也有所降低。不过这算是我刻意为之的。之前疯狂刷题刷了1k+，后来遇到瓶颈，改为每天刷3题（国服每日一题，美服每日一题，残酷群每日一题。分别有积分和红包奖励），现在已经基本每日0题，只是坚持打周赛维持手感和获得快乐。\n诚然刷题和比赛是很快乐的，让人上瘾，我早已欲罢不能。\n但是因为面临毕业和毕业论文的压力，我刻意控制了自己刷题的时间和投入。\n不知道你能不能理解，在写论文的时候，什么东西都能成为诱惑。而刷题这种我平日里就很喜欢的活动更是成为了巨大的诱惑和逃避之地。究其根本，写论文和做实验真的是太痛苦了。\n甚至不需要是刷题，别的什么阻止我都足够了。比如 看书，看电影，刷论坛。\n没办法，论文总是要强迫自己投入主要精力去做的。我不是一个意志力足够坚强的人。\n因此，刷题被我刻意远离了。仅仅品尝每周竞赛的快乐就足够了。\n因为水平的降低和自己国服rating太高（2400+），我现在已经基本转战美服了。美服账号rating不到2200，尚且有不小的上升空间。打起来压力也不会太大。\n之前打国服，连跌2次，险些跌出2400俱乐部。\n我打算先把美服也打上2400. 这样不把鸡蛋放在一个篮子里，自己的rating也更稳定些。\n\n 1812. Determine Color of a Chessboard Square\n签到题。根据棋盘黑白交替的特性，推断对应坐标的颜色。\nclass Solution &#123;public:    bool squareIsWhite(string coordinates) &#123;        bool firstBlack = ((coordinates[0] - &#x27;a&#x27;) % 2) == 0;        if (((coordinates[1] - &#x27;1&#x27;) % 2 ) == 0) &#123;            return !firstBlack;        &#125; else &#123;            return firstBlack;        &#125;    &#125;&#125;;\n时间复杂度: O(1),\n空间复杂度: O(1).\n 1813. Sentence Similarity III\nStright forward. 根据题意，a 相似于 b的话，需要从头和尾各相等，然后在中间碰头。\nclass Solution:    def areSentencesSimilar(self, sentence1: str, sentence2: str) -&gt; bool:        def similar(a, b):            aa = a.split(&#x27; &#x27;)            bb = b.split(&#x27; &#x27;)            # a insert a sentence to b            if len(aa) &gt; len(bb): return False            begin = 0            while begin &lt; len(aa) and aa[begin] == bb[begin]:                begin += 1            end = len(aa) - 1            endB = len(bb) - 1            while end &gt;= begin and endB &gt;= begin and aa[end] == bb[endB]:                end -= 1                endB -= 1            return begin &gt; end                                return similar(sentence1, sentence2) or similar(sentence2, sentence1)\n时间复杂度: O(sentence.length),\n空间复杂度: O(sentence.length).\n 1814. Count Nice Pairs in an Array\nnums[i] + rev(nums[j]) == nums[j] + rev(nums[i]) 可以转化为\nnums[i] - rev(nums[i]) == nums[j] - rev(nums[j]). 问题因此转换为统计相等对。\nclass Solution &#123;    const int MOD = 1e9 + 7;    int rev(const int x) &#123;        string s = to_string(x);        reverse(s.begin(), s.end());        return stoi(s);    &#125;public:    int countNicePairs(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int, int&gt; cnt;        int ans = 0;        for (int x : nums) &#123;            const int k = x - rev(x);            ans = (ans + cnt[k]) % MOD;            ++cnt[k];        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(32 * N),\n空间复杂度: O(N).\n 1815. Maximum Number of Groups Getting Fresh Donuts\n 比赛时AC的错误贪心版本\n由于题目的数据规模比较小，1 &lt;= batchSize &lt;= 9, 1 &lt;= groups.length &lt;= 30。因此，我们可以断定，本题的时间复杂度要求不高，很可能是回溯搜索类的解法。事实证明，确实如此，Discuss区给出的答案基本都是 DFS + DP。\n比赛时，虽然我也AC了，但说实话，解法并不对。\n首先，问题可以转化成，按%batchSize分类，因为显然，余数相等的数是一样的。\n然后在对其进行分组，使得组内和等于batchSize，求最大的组数。\n我写出一种贪心的算法，认为首先一个数一组，然后2个数一组，…, groups.length 个数一组。这样的分组方式是“最优的”。然后再WA后，我也很快意识到，并不是这样的。这种分组顺序并不对。\n枚举所有分组顺序的时间复杂度是30!，显然不可取。而且当时时间也只剩下10分钟了。因此，我试着想对于大多数情况，少数一组还是符合直觉的。关键是测试用例中有违反的，所以我试着交换一些分组顺序，而且想，越小的数影响越大。因此，我尝试了交换2，3；再交换3，4，竟然就AC了。也是神奇，运气好。\nclass Solution &#123;public:    int maxHappyGroups(int batchSize, vector&lt;int&gt;&amp; groups) &#123;        vector&lt;int&gt; cntOrigin(batchSize, 0);        for (int x : groups) &#123;            ++cntOrigin[x % batchSize];        &#125;        vector&lt;int&gt; v(groups.size());        iota(v.begin(), v.end(), 1);        auto tryOne = [&amp;]() -&gt; int &#123;            auto cnt = cntOrigin;        int ans = 0;        auto updateAns = [&amp;](vector&lt;int&gt;&amp; useCnt) -&gt; void &#123;            int minOne = numeric_limits&lt;int&gt;::max();            for (int i = 0; i &lt; useCnt.size(); ++i) &#123;                if (useCnt[i] == 0) continue;                minOne = min(minOne, cnt[i] / useCnt[i]);            &#125;            for (int i = 0; i &lt; useCnt.size(); ++i) &#123;                if (useCnt[i] == 0) continue;                cnt[i] -= useCnt[i] * minOne;            &#125;            ans += minOne;        &#125;;        function&lt;void(const int, const int, vector&lt;int&gt;&amp;)&gt; backtracking = [&amp;](const int remain, const int s, vector&lt;int&gt;&amp; useCnt) -&gt; void &#123;            if (remain == 0) &#123;                if (s % batchSize == 0) &#123;                    updateAns(useCnt);                &#125;                return;            &#125; else &#123;                for (int i = 0; i &lt; batchSize; ++i) &#123;                    if (cnt[i] == 0) continue;                    ++useCnt[i];                    backtracking(remain - 1, s + i, useCnt);                    --useCnt[i];                &#125;                return;            &#125;        &#125;;                for (int r : v) &#123;            // pick r elements from 0, 1, ..., batchSize - 1            // allow duplicate            if (accumulate(cnt.begin(), cnt.end(), 0) &lt; r) break;            vector&lt;int&gt; useCnt(batchSize, 0);            backtracking(r, 0, useCnt);        &#125;        if (accumulate(cnt.begin(), cnt.end(), 0) &gt; 0) &#123;            ++ans;        &#125;        return ans;        &#125;;                int ans = tryOne();        swap(v[2],v[3]);        ans = max(ans, tryOne());        return ans;    &#125;&#125;;\n时间复杂度: 因为回溯有很多剪枝，我也不确定真正的时间复杂度是多少。算是枚举了所有可能的组合，一定小于O(2^(group.size() + 1))的。大概可能在O(2^9)左右。\n空间复杂度: O(group.length + batchSize).\n 赛后学习的正确 DFS + DP 版本\nDiscuss 中C++ 版本题解\n简而言之，是每次尝试使用可用的任意group（减一），在其中找最大的。\n也可以去看花花的视频讲解，讲的还不错。\n我的实现：\nstruct VectorHasher &#123;  size_t operator()(const vector&lt;int&gt;&amp; V) const &#123;    size_t hash = V.size();    for (auto i : V)      hash ^= i + 0x9e3779b9 + (hash &lt;&lt; 6) + (hash &gt;&gt; 2);    return hash;  &#125;&#125;;class Solution &#123;public:    int maxHappyGroups(int batchSize, vector&lt;int&gt;&amp; groups) &#123;        vector&lt;int&gt; cnt(batchSize, 0);        for (int x : groups) &#123;            ++cnt[x % batchSize];        &#125;        unordered_map&lt;vector&lt;int&gt;, int, VectorHasher&gt; memo;        function&lt;int(const int)&gt; dfs = [&amp;](const int s) -&gt; int &#123;            auto it = memo.find(cnt);            if (it != memo.end()) return it-&gt;second;            int ans = 0;            for (int i = 1; i &lt; batchSize; ++i) &#123;                if (cnt[i] == 0) continue;                --cnt[i];                ans = max(ans, dfs((s + i) % batchSize) + (s == 0 ? 1 : 0));                ++cnt[i];            &#125;            return memo[cnt] = ans;        &#125;;                return cnt[0] + dfs(0);    &#125;&#125;;\n时间复杂度: O(cnt 个非0元素之积 * batchSize);\n空间复杂度: O(cnt 个非0元素之积). (其实就是cache的空间大小).\n在花花的视频里，他认为最坏的情况发生在cnt 均匀分布的时候。此时\n时间复杂度: O(k * (n / k) ^ k) = 2,359,296,\n空间复杂度: O((n / k) ^ k) = 262144.\n其中 k = batchSize, n = groups.size().\n因此，在最坏情况下也是可以AC的。\n Rejudge\nLeetCode 每次比赛后并不会马上更新rating，而是要等3、4天。中间有个一查重和rejudge的过程，有些题目因为比赛时test cases 太弱。不对/超时的算法可能蒙混过关，比如我的第4题。白高兴了，rejudge后果然fail了。不过真心是我自己的算法不对，怪不得别人。\nrejudge只是还一个真想，对于比赛公平其实很重要。虽然本次我是rejudge的受害者，但大多数时候，我都是受益者。我也是十分支持rejudge的。只是希望LeetCode今后可以提高比赛时题目和测试用例的质量，赛后评测和更新rating的速度更快些，别让大家等4、5天。都快下周周赛了。\n更新后的成绩：\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n108 / 9082\nYoungForest\n18\n1:37:36\n0:03:39\n0:09:01\n0:14:28\n1:27:36  2\n\n\n\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 5","url":"/2019/07/27/LeetCode-biweekly-contest-5/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (3)\nQ3 (5)\nQ4 (7)\n\n\n\n\n98 / 1634\nYoungForest\n18\n0:35:23\n0:11:01\n0:10:53\n0:22:40\n0:35:23\n\n\n\n距离上次参加biweekly contest已经2个月了，编号也从1直接跳到5了。\n本次contest十分简单，都是算法里的经典的题目，属于必会的。我做完4题后还有近1个小时。\n 1133. Largest Unique Number\n签到题。遍历一遍数组，然后计数。然后从大向小找符合要求的数。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int largestUniqueNumber(vector&lt;int&gt;&amp; A) &#123;        map&lt;int, int&gt; count;        for (int a : A) &#123;            ++count[a];        &#125;        for (auto it = count.crbegin(); it != count.crend(); ++it) &#123;            if (it-&gt;second == 1)                return it-&gt;first;        &#125;        return -1;    &#125;&#125;;\n 1134. Armstrong Number\n感觉还是一道Easy的题目。根据题意做即可，考察取数中每一个位。\n时间复杂度: O(log N), N的位数。\n空间复杂度: O(log N).\nclass Solution &#123;    int pow(int x, int y) &#123;        if (y == 0)            return 1;        else            return x * pow(x, y - 1);    &#125;public:    bool isArmstrong(int N) &#123;        const int number = N;        vector&lt;int&gt; digits;        while (N &gt; 0) &#123;            digits.push_back(N % 10);            N /= 10;        &#125;        int s = 0;        int power = digits.size();        for (auto digit : digits) &#123;            s += pow(digit, power);        &#125;                return s == number;    &#125;&#125;;\n 1135. Connecting Cities With Minimum Cost\n最小生成树\n时间复杂度: O(E logE, E logV).\n空间复杂度: O(E, V)\nclass Solution &#123;    struct UF &#123;        vector&lt;int&gt; parent;        int count;                UF(int n) &#123;            parent.resize(n);            for (int i = 0; i &lt; n; ++i) &#123;                parent[i] = i;            &#125;            count = n;        &#125;        // A utility function to find the subset of an element i          int find(int i)          &#123;              if (parent[i] == i)                  return i;              return find(parent[i]);          &#125;          // A utility function to do union of two subsets          void Union(int x, int y)          &#123;              int xset = find(x);              int yset = find(y);              if(xset != yset)             &#123;                  parent[xset] = yset;                --count;            &#125;          &#125;        &#125;;public:    int minimumCost(int N, vector&lt;vector&lt;int&gt;&gt;&amp; conections) &#123;        UF uf(N);        sort(conections.begin(), conections.end(), [](const auto&amp; lhs, const auto&amp;rhs) -&gt; bool &#123;            return lhs[2] &lt; rhs[2];        &#125;);        int ans = 0;        for (const auto&amp; edge : conections) &#123;            int a = edge[0] - 1, b = edge[1] - 1, cost = edge[2];            if (uf.find(a) != uf.find(b)) &#123;                uf.Union(a, b);                ans += cost;                if (uf.count == 1)                    return ans;            &#125;        &#125;        return -1;    &#125;&#125;;\n 1136. Parallel Courses\n拓扑排序。数据结构的基础题目。\nclass Solution &#123;public:    int minimumSemesters(int N, vector&lt;vector&lt;int&gt;&gt;&amp; relations) &#123;        unordered_map&lt;int, vector&lt;int&gt;&gt; in;        unordered_map&lt;int, int&gt; out;        unordered_set&lt;int&gt; q;        for (int i = 1; i &lt;= N; ++i) &#123;            q.insert(i);        &#125;        for (const auto&amp; edge : relations) &#123;            int X = edge[0], Y = edge[1];            in[X].push_back(Y);            ++out[Y];            q.erase(Y);        &#125;        int ans = 0;        int finish_course = 0;        while (!q.empty()) &#123;            unordered_set&lt;int&gt; next_q;            for (int i : q) &#123;                ++finish_course;                for (int from : in[i]) &#123;                    --out[from];                    if (out[from] == 0) &#123;                        out.erase(from);                        next_q.insert(from);                    &#125;                &#125;                in.erase(i);            &#125;            ++ans;            q = std::move(next_q);        &#125;        if (finish_course == N)            return ans;        else            return -1;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 50","url":"/2021/04/18/LeetCode-biweekly-contest-50/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n1032 / 10097\nYoungForest\n12\n0:20:28\n0:09:10\n0:12:51\n0:20:28\nnull\n\n\n\n因为洗澡迟到了8分钟，否则应该可以进前500的。\n本次的双周赛是变相的手速场，141人作出4题。剩下的比拼前3题的手速。\n我花10min很顺利地做完了前三题，Q4却思考了一个小时也并未有重大突破。\n虽然有些许眉目，觉得是个DP，但事后发现问题早已超纲，没做出来也实属正常。\n\n 1827. Minimum Operations to Make the Array Increasing\n贪心。在保持递增的同时，使得数字尽可能小。\nclass Solution &#123;public:    int minOperations(vector&lt;int&gt;&amp; nums) &#123;        // greedy        // time: O(N)        int last = 0;        int ans = 0;        for (int i : nums) &#123;            if (i &gt; last) &#123;                last = i;            &#125; else &#123;                ans += last + 1 - i;                ++last;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1828. Queries on Number of Points Inside a Circle\n由于点数和圆数都比较小（&lt;= 500），因此直接暴力即可。\nclass Solution &#123;    bool inside(const vector&lt;int&gt;&amp; p, const vector&lt;int&gt;&amp; c) &#123;        return (p[0] - c[0]) * (p[0] - c[0]) + (p[1] - c[1]) * (p[1] - c[1]) &lt;= c[2] * c[2];    &#125;public:    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        vector&lt;int&gt; ans;        ans.reserve(queries.size());        for (const auto&amp; v : queries) &#123;            int count = 0;            for (const auto&amp; p : points) &#123;                if (inside(p, v)) ++count;            &#125;            ans.push_back(count);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(points.length * queries.length),\n空间复杂度: O(queries.length).\n 1829. Maximum XOR for Each Query\n利用前缀和（其实是前缀XOR）快速进行Remove操作，然后用互补的方式构造k。\nclass Solution &#123;public:    vector&lt;int&gt; getMaximumXor(vector&lt;int&gt;&amp; nums, int maximumBit) &#123;        int currentXOR = accumulate(nums.begin(), nums.end(), 0, [](int a, int b) -&gt; int &#123;            return a ^ b;        &#125;);        auto findMax = [&amp;](const int a) -&gt; int &#123;            // argmax a ^ k            int k = 0;            for (int i = maximumBit - 1; i &gt;= 0; --i) &#123;                if (!(a &amp; (1 &lt;&lt; i))) &#123;                    k |= (1 &lt;&lt; i);                &#125;            &#125;            return k;        &#125;;        vector&lt;int&gt; ans;        ans.reserve(nums.size());        for (auto it = nums.rbegin(); it != nums.rend(); ++it) &#123;            const int x = *it;            ans.push_back(findMax(currentXOR));            currentXOR ^= x;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(nums.length * maximumBit),\n空间复杂度: O(nums.length).\n 1830. Minimum Number of Operations to Make String Sorted\nProblem link.\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 51","url":"/2021/05/02/LeetCode-biweekly-contest-51/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n150 / 9378\nYoungForest\n18\n0:32:04\n0:05:26\n0:07:22\n0:11:24\n0:32:04\n\n\n\n手速场。最近手速已大不如从前，最后一题也因为不熟练花费了比较多的时间。\n其实，手速场中，所有题目的算法其实都不难，想到正确的解法很快，但迅速实现 + bug free就考验每位程序员的功力了。\n\n 1844. Replace All Digits with Characters\n签到题。按照题目要求完成即可。\nclass Solution &#123;    char shift(char c, int x) &#123;        return c + x;    &#125;public:    string replaceDigits(string s) &#123;        for (int i = 1; i &lt; s.size(); i += 2) &#123;            s[i] = shift(s[i-1], s[i] - &#x27;0&#x27;);        &#125;        return s;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1845. Seat Reservation Manager\n因为每次都找最小的座位号，同时有insert(unreserve)的操作。显然需要使用 priority_queue优先队列/Heap 实现这一需求。\nclass SeatManager &#123;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; pq;public:    SeatManager(int n) &#123;        for (int i = 1; i &lt;= n; ++i) &#123;            pq.push(i);        &#125;    &#125;        int reserve() &#123;        const int ans = pq.top();        pq.pop();        return ans;    &#125;        void unreserve(int seatNumber) &#123;        pq.push(seatNumber);    &#125;&#125;;/** * Your SeatManager object will be instantiated and called as such: * SeatManager* obj = new SeatManager(n); * int param_1 = obj-&gt;reserve(); * obj-&gt;unreserve(seatNumber); */\n时间复杂度:\n\nSeatManager: O(n),\nreserve: O(log n),\nunreserve: O(log n).\n空间复杂度: O(n).\n\n 1846. Maximum Element After Decreasing and Rearranging\n贪心。\n观察2种操作 Decrease 和 Rearrange 可以发现，\n其实只需要Reagrrage一次，Decrease时，优先减小的。因为大的减起来一定可以包括小的，但小的不行。\nclass Solution &#123;public:    int maximumElementAfterDecrementingAndRearranging(vector&lt;int&gt;&amp; arr) &#123;        const int n = arr.size();        sort(arr.begin(), arr.end());        int last = 0;        for (int i = 0; i &lt; n; ++i) &#123;            if (arr[i] &gt; last) &#123;                arr[i] = last + 1;            &#125; else &#123;                arr[i] = last;            &#125;            last = arr[i];        &#125;        return arr[n - 1];    &#125;&#125;;\n时间复杂度: O(n log n + n),\n空间复杂度: O(1).\n 1847. Closest Room\n首先想到暴力解法，对于每一个query, 遍历一遍rooms，就可以找到答案。时间复杂度为 O(k * n)，显然会TLE。\n解法时间复杂度应该是类似O(n log n)这种形式。\n这里需要用到一个所谓**离线计算(offline query)**的技术。\n所谓在线计算，就是queries的解答顺序是不变的，类似一个函数，每次被call，解答一次。\n所谓离线计算，就是queries的解答顺序是可以变的，需要一次性求解一个数组的queries。此时，我们可以通过对queries重新排序得到均摊速度更快的算法。\n首先，将queries按minisize排序，将rooms按size排序。\n用双指针的方式，保证对于当前的query，符合要求的rooms都被加入候选集合中。这里我们用TreeSet维护候选集合，以实现log n的搜索最近room。\nclass Solution &#123;public:    vector&lt;int&gt; closestRoom(vector&lt;vector&lt;int&gt;&gt;&amp; rooms, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        // brute force: k * n        // need: k * log n + n log n        // online, sort queries by minisize from big to small, find close candidate        const int n = rooms.size();        sort(rooms.begin(), rooms.end(), [&amp;](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            return a[1] &gt; b[1];        &#125;);        const int k = queries.size();        using pii = pair&lt;int, int&gt;;        vector&lt;pii&gt; searchOrder; // miniSize, index        searchOrder.reserve(k);        for (int i = 0; i &lt; k; ++i) &#123;            searchOrder.push_back(&#123;queries[i][1], i&#125;);        &#125;        sort(searchOrder.begin(), searchOrder.end(), [&amp;](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            return a.first &gt; b.first;        &#125;);        int i = 0;        set&lt;int&gt; candidate;        vector&lt;int&gt; ans(k, -1);        for (int j = 0; j &lt; k; ++j) &#123;            while (i &lt; n &amp;&amp; rooms[i][1] &gt;= searchOrder[j].first) &#123;                candidate.insert(rooms[i++][0]);            &#125;            const int prefer = queries[searchOrder[j].second][0];            if (!candidate.empty()) &#123;                auto it = candidate.lower_bound(prefer);                if (it == candidate.begin()) &#123;                    ans[searchOrder[j].second] = *it;                &#125; else if (it == candidate.end()) &#123;                    ans[searchOrder[j].second] = *prev(it);                &#125; else &#123;                    if (abs(*it - prefer) &lt; (prefer - *prev(it))) &#123;                        ans[searchOrder[j].second] = *it;                    &#125; else &#123;                        ans[searchOrder[j].second] = *prev(it);                    &#125;                &#125;            &#125; else &#123;                ans[searchOrder[j].second] = -1;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n log n + k log n + k log k),\n空间复杂度: O(k + n).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 52","url":"/2021/05/16/LeetCode-biweekly-contest-52/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n2217 / 10364\nYoungForest\n12\n0:51:47\n0:05:11\n0:51:47\n0:29:51\nnull\n\n\n\n\n 1859. Sorting the Sentence\n字符串问题用python。虽然题目不难，就是分割字符串，按照指定内容排序，但实现起来还是比想象中复杂的。好在Python中有很多方便的API和数据结构可以灵活使用。\nclass Solution:    def sortSentence(self, s: str) -&gt; str:        words = s.split(&#x27; &#x27;)        def f(word):            return (int(word[-1:]), word[0:-1])        tuples = list(map(f, words))        tuples.sort()        def f2(a, t):            return a + &#x27; &#x27; + t[1]         return reduce(f2, tuples, &#x27;&#x27;)[1:]\n时间复杂度: O(s.length),\n空间复杂度: O(s.length).\n 1860. Incremental Memory Leak\n本来是想用等差数列求和+解方程，O(1)解决的。但事实上实现和解方程还是太复杂了。到最后也没做出来。做完第3题后，回过来算了一下暴力的时间复杂度: O(sqrt(2^32)) = 65536. 居然如此低，果然第二题还是不能想复杂了，直接暴力怼多好。\n暴力模拟题目中描述的内存占用过程。\nclass Solution &#123;public:    vector&lt;int&gt; memLeak(int m1, int m2) &#123;        int t = 1;        while (m1 &gt;= t || m2 &gt;= t) &#123;            if (m1 &gt;= m2) &#123;                m1 -= t;            &#125; else &#123;                m2 -= t;            &#125;            ++t;        &#125;        return &#123;t, m1, m2&#125;;    &#125;&#125;;\n时间复杂度: O(sqrt(memory1 + memory2)),\n空间复杂度: O(1).\n 1861. Rotating the Box\n了解了掉落的本质，会发现，只需要统计每个障碍物/地面左面到上个障碍物的石头有多少个即可。\nclass Solution &#123;public:    vector&lt;vector&lt;char&gt;&gt; rotateTheBox(vector&lt;vector&lt;char&gt;&gt;&amp; box) &#123;        const int rows = box.size();        const int cols = box[0].size();        vector&lt;vector&lt;char&gt;&gt; ans(cols, vector&lt;char&gt;(rows, &#x27;.&#x27;));        for (int i = 0; i &lt; rows; ++i) &#123;            int stoneCnt = 0;            for (int j = 0; j &lt; cols; ++j) &#123;                if (box[i][j] == &#x27;#&#x27;) &#123;                    ++stoneCnt;                &#125; else if (box[i][j] == &#x27;*&#x27;) &#123;                    // fall down                    ans[j][rows - 1 - i] = &#x27;*&#x27;;                    for (int k = 1; k &lt;= stoneCnt; ++k) &#123;                        ans[j - k][rows - 1 - i] = &#x27;#&#x27;;                    &#125;                    stoneCnt = 0;                &#125;            &#125;            for (int k = 1; k &lt;= stoneCnt; ++k) &#123;                ans[cols - k][rows - 1 - i] = &#x27;#&#x27;;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(m * n),\n空间复杂度: O(m * n).\n 1862. Sum of Floored Pairs\n没啥好想法。首先尝试了暴力解，枚举所有的对：\nclass Solution:    def sumOfFlooredPairs(self, nums: List[int]) -&gt; int:        MOD = 10**9 + 7        n = len(nums)        ans = 0        for i in range(n):            for j in range(n):                ans += nums[j] // nums[i]        return ans % MOD\n时间复杂度: O(N^2), TLE，\n空间复杂度: O(1).\n尝试使用二分查找优化，寻找每一个数的倍数范围。\nclass Solution &#123;    const int MOD = 1e9 + 7;public:    int sumOfFlooredPairs(vector&lt;int&gt;&amp; nums) &#123;        int ans = 0;        sort(nums.begin(), nums.end());        const int MAX = nums.back();        const int n = nums.size();        int last = 0;        for (int i = 0; i &lt; n; ++i) &#123;            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123;                ans = (ans + last) % MOD;                continue;            &#125;            last = 0;            for (int j = 1; nums[i] * j &lt;= MAX; ++j) &#123;                auto l = lower_bound(nums.begin() + i, nums.end(), nums[i] * j);                auto r = lower_bound(l, nums.end(), nums[i] * (j + 1));                auto x = distance(l, r);                last = (last + x * j) % MOD;            &#125;            ans = (ans + last) % MOD;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N log N), 虽然有2个循环嵌套，但第二个其实是个调和级数。不过仍然TLE了。\n空间复杂度: O(1).\n还是看零神的题解把：\n前缀和优化。\n可以少一个log.\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 53","url":"/2021/05/30/LeetCode-biweekly-contest-53/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n219 / 12291\nYoungForest\n18\n0:57:45\n0:19:12\n0:22:21\n0:46:08\n0:57:45\n\n\n\n因为今天陪npy去参加斯巴达比赛，早上不到6点就起了，在外奔波了一天。\n比赛前想着休息一下子，就打算睡20min。没想到太累了，闹铃响了自己给关了。因此迟到了10+min，否则我排名还可以更高些。题目不难，也不简单，属于出的比较好的。\n零神大数据\n1876,Substrings of Size Three with Distinct Characters,substrings-of-size-three-with-distinct-characters,1248.7224675206\n1877,Minimize Maximum Pair Sum in Array,minimize-maximum-pair-sum-in-array,1301.3817574010\n1878,Get Biggest Three Rhombus Sums in a Grid,get-biggest-three-rhombus-sums-in-a-grid,1897.5516652727\n1879,Minimum XOR Sum of Two Arrays,minimum-xor-sum-of-two-arrays,2145.1839952670\n\n 1876. Substrings of Size Three with Distinct Characters\n签到题。因为子字符串长度是确定长度（3）。因此可以用一个滑动窗口枚举所有的长度为3的子串，判断是否每个字符都只出现一次。\nclass Solution &#123;public:    int countGoodSubstrings(string s) &#123;        const int n = s.size();        vector&lt;int&gt; cnt(26, 0);        auto ok = [&amp;]() -&gt; bool &#123;            for (int i : cnt) &#123;                if (i &gt; 1) return false;            &#125;            return true;        &#125;;        if (n &lt; 3) return 0;        int ans = 0;        ++cnt[s[0] - &#x27;a&#x27;];        ++cnt[s[1] - &#x27;a&#x27;];        ++cnt[s[2] - &#x27;a&#x27;];        if (ok()) ++ans;        for (int i = 3; i &lt; n; ++i) &#123;            ++cnt[s[i] - &#x27;a&#x27;];            --cnt[s[i - 3] - &#x27;a&#x27;];            if (ok()) ++ans;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n),\n空间复杂度: O(1).\n 1877. Minimize Maximum Pair Sum in Array\n贪心，让大的和小的组合。\n可以让最大和最小，同时让最小和最大。\nclass Solution &#123;public:    int minPairSum(vector&lt;int&gt;&amp; nums) &#123;        // greedy: match largest and smallest        sort(nums.begin(), nums.end());        const int n = nums.size();        int l = 0, r = n - 1;        int ans = 0;        while (l &lt; r) &#123;            ans = max(ans, nums[l++] + nums[r--]);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(1).\n 1878. Get Biggest Three Rhombus Sums in a Grid\n枚举所有的菱形，然后维护最大的3个菱形和即可。\n我的枚举方式是，枚举菱形的中心和4个顶点到中心的距离。\n计算菱形和可以通过前缀和presum O(1)计算。因此总的时间复杂度是 O(N^3). N最大值是100，恰好满足条件。\n后来发现LeetCode把题目的数据范围从100改到了50.之前听说比赛时有人用N^4的暴力方法过了，我以为会赛后rejudge 的，没想到人家直接改体面。让所有人都过了。可能是懒得rejudge了，还得加数据量大的case。改数据范围多省事儿。\nclass Solution &#123;public:    vector&lt;int&gt; getBiggestThree(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        // x := Rhombus number: m * n * m        // time: x log x        const int m = grid.size();        const int n = grid[0].size();                vector&lt;vector&lt;int&gt;&gt; presum(m + 1, vector&lt;int&gt;(n + 1, 0));        vector&lt;vector&lt;int&gt;&gt; presum2(m + 1, vector&lt;int&gt;(n + 1, 0));        for (int i = 0; i &lt; m; ++i) &#123;            for (int j = 0; j &lt; n; ++j) &#123;                presum[i+1][j+1] = presum[i][j] + grid[i][j];            &#125;        &#125;        for (int i = 0; i &lt; m; ++i) &#123;            for (int j = 0; j &lt; n; ++j) &#123;                presum2[i+1][j] = presum2[i][j+1] + grid[i][j];            &#125;        &#125;                        set&lt;int&gt; s;        for (int i = 0; i &lt; m; ++i) &#123;            for (int j = 0; j &lt; n; ++j) &#123;                s.insert(grid[i][j]);                for (int len = 1; i - len &gt;= 0 &amp;&amp; j - len &gt;= 0 &amp;&amp; i + len &lt; m &amp;&amp; j + len &lt; n; ++len) &#123;                    const int rhombus = presum[i+1][j+len+1] - presum[i-len][j]                        + presum[i+len+1][j+1] - presum[i][j-len]                        + presum2[i+len+1][j] - presum2[i][j+len+1]                        + presum2[i+1][j-len] - presum2[i-len][j+1]                        - grid[i-len][j] - grid[i][j+len] - grid[i][j-len] - grid[i+len][j];                    s.insert(rhombus);                &#125;            &#125;        &#125;        vector&lt;int&gt; ans;        int i = 0;        for (auto it = s.rbegin(); it != s.rend() &amp;&amp; i &lt; 3; ++it, ++i) &#123;            ans.push_back(*it);        &#125;        return ans;    &#125;&#125;;\n菱形数目x = m * n * min(m,n),\n时间复杂度: O(x log x),\n空间复杂度: O(x + m * n)。因为只需要维护最大的3个菱形和，可优化到 -&gt; O(m*n).\n 1879. Minimum XOR Sum of Two Arrays\n经典 DP + Bitmask.\n一开始想到暴力的枚举所有排列，时间复杂度是 排列数 n! = 14!。一定会超时。\n根据数据规模n = 14可以推测 需要使用bitmask.\n定义dp(i, mask) 表示 nums1[i:] 和 nums2 中的子集mask 的最小异或和。\n状态转移方程为：暴力尝试 nums[i]与mask中每一个可以的取值进行组合，取最小的。\nclass Solution:    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -&gt; int:        # time: n * n * 2 ^ n        n = len(nums2)        @cache        def dp(i, mask):            if i &gt;= len(nums1): return 0            ans = float(&#x27;inf&#x27;)            for j in range(n):                if ((1 &lt;&lt; j) &amp; mask) == 0: continue                ans = min(ans, (nums1[i] ^ nums2[j]) + dp(i+1, mask ^ (1 &lt;&lt; j)))            return ans                    return dp(0, (1 &lt;&lt; n) - 1)\n时间复杂度: O(n * n * 2 ^ n)  = 14 * 14 * 2^14 = 3211264,\n空间复杂度: O(n * 2^ n).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 54","url":"/2021/06/16/LeetCode-biweekly-contest-54/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n120 / 12076\nYoungForest\n18\n1:19:33\n0:03:17\n0:09:23 🐞1\n0:26:15\n1:04:33 🐞2\n\n\n\n继续保持好成绩，尤其是最后一题，还是挺难的。刚开始没有思路甚至想放弃，但最后还是靠自己的思考解决了难题。\n 1893. Check if All the Integers in a Range Are Covered\n签到题。对于[right, right]中每一个数，判断是否被ranges中的某个区间包含。\nclass Solution &#123;public:    bool isCovered(vector&lt;vector&lt;int&gt;&gt;&amp; ranges, int left, int right) &#123;        auto cover = [&amp;](const int i) -&gt; bool &#123;            for (const auto&amp; range : ranges) &#123;                const int l = range[0], r = range[1];                if (l &lt;= i &amp;&amp; i &lt;= r) return true;            &#125;            return false;        &#125;;        for (int i = left; i &lt;= right; ++i) &#123;            if (!cover(i)) return false;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O((right - left) * ranges.length),\n空间复杂度: O(1).\n 1894. Find the Student that Will Replace the Chalk\n先求前缀和，把k和和取余数，可以定位到最后一轮的遍历。然后用二分搜索寻找恰好大于k的位置，即为需要更换粉笔的学生。\nclass Solution &#123;    using ll = long long;public:    int chalkReplacer(vector&lt;int&gt;&amp; chalk, int k) &#123;        const int n = chalk.size();        vector&lt;ll&gt; presum(n + 1);        presum[0] = 0;        for (int i = 0; i &lt; n; ++i) &#123;            presum[i+1] = presum[i] + chalk[i];        &#125;        if (k &gt;= presum.back()) &#123;            k = k % presum.back();        &#125;        // the first index, presum[i] &gt; k        auto it = upper_bound(presum.begin(), presum.end(), k);        return distance(presum.begin(), it) - 1;    &#125;&#125;;\n时间复杂度: O(N + log N), N = chalk.length,\n空间复杂度: O(chalk.length).\n需要注意数据范围，计算前缀和时可能会int溢出。我也因此Runtime Error一次。换成long long就好了。LeetCode最近坑溢出的case越来越多了，以后遇到需要先预估一下最大的值，该用long long用long long.\n 1895. Largest Magic Square\n暴力法：从大到小枚举所有的正方形，计算所有行、列、对角的和，判断是否相等。唯一的优化是采用前缀和，快速计算行列和。\nclass Solution &#123;public:    int largestMagicSquare(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        const int m = grid.size();        const int n = grid[0].size();        vector&lt;vector&lt;int&gt;&gt; presumLeft(m, vector&lt;int&gt;(n + 1));        for (int i = 0; i &lt; m; ++i) &#123;            presumLeft[i][0] = 0;            for (int j = 0; j &lt; n; ++j) &#123;                presumLeft[i][j+1] = presumLeft[i][j] + grid[i][j];            &#125;        &#125;        vector&lt;vector&lt;int&gt;&gt; presumUp(m + 1, vector&lt;int&gt;(n));        for (int j = 0; j &lt; n; ++j) &#123;            presumUp[0][j] = 0;        &#125;        for (int j = 0; j &lt; n; ++j) &#123;            for (int i = 0; i &lt; m; ++i) &#123;                presumUp[i+1][j] = presumUp[i][j] + grid[i][j];            &#125;        &#125;                auto check = [&amp;](const int i, const int j, const int k) -&gt; bool &#123;            int target = presumLeft[i][j+k] - presumLeft[i][j];            for (int row = 1; row &lt; k; ++row) &#123;                if (target != presumLeft[i+row][j+k] - presumLeft[i+row][j]) return false;            &#125;            for (int col = 0; col &lt; k; ++col) &#123;                if (target != presumUp[i+k][j+col] - presumUp[i][j+col]) return false;            &#125;            &#123;                int diagonal = 0;                for (int row = 0; row &lt; k; ++row) &#123;                    diagonal += grid[i+row][j+row];                &#125;                if (diagonal != target) return false;            &#125;            &#123;                int diagonal = 0;                for (int row = 0; row &lt; k; ++row) &#123;                    diagonal += grid[i+row][j+k-1-row];                &#125;                if (diagonal != target) return false;            &#125;                        return true;        &#125;;                for (int k = min(n, m); k &gt; 0; --k) &#123;            for (int i = 0; i &lt; m; ++i) &#123;                for (int j = 0; j &lt; n; ++j) &#123;                    if (i + k &lt;= m &amp;&amp; j + k &lt;= n &amp;&amp; check(i, j, k)) return k;                &#125;            &#125;        &#125;                return 1;    &#125;&#125;;\n时间复杂度: O(N^4),\n空间复杂度: O(N^2).\n 1896. Minimum Cost to Change the Final Value of Expression\n递归，根据 &amp; | 和 子表达式的值 进行分类，寻找最小cost。\n括号的处理需要提前用栈，找到所有的配对。\nclass Solution:    def minOperationsToFlip(self, expression: str) -&gt; int:        n = len(expression)        leftPair = &#123;&#125;        left = 0        leftStack = []        for i in range(n):            if expression[i] == &#x27;)&#x27;:                left -= 1                leftPair[i] = leftStack.pop()            elif expression[i] == &#x27;(&#x27;:                left += 1                leftStack.append(i)        def dp(i, j):            # [i, j)            if i + 1 == j: # 0, 1                return expression[i] == &#x27;1&#x27;, 1            else:                if expression[j-1] == &#x27;)&#x27;:                    leftIndex = leftPair[j-1]                    if leftIndex == i: return dp(i+1,j-1)                    pivot = leftIndex - 1                else:                    # 0, 1                    pivot = j - 2                                    if expression[pivot] == &#x27;0&#x27; or expression[pivot] == &#x27;1&#x27;: pivot -= 1                leftResult, leftCost = dp(i, pivot)                rightResult, rightCost = dp(pivot+1, j)                if expression[pivot] == &#x27;|&#x27;:                    if leftResult == False and rightResult == False:                        return False, min(leftCost, rightCost)                    elif leftResult == True and rightResult == False:                        return True, 1                    elif leftResult == False and rightResult == True:                        return True, 1                    else:                        return True, min(leftCost + 1, rightCost + 1)                elif expression[pivot] == &#x27;&amp;&#x27;:                    if leftResult == False and rightResult == False:                        return False, min(leftCost + 1, rightCost + 1)                    elif leftResult == True and rightResult == False:                        return False, 1                    elif leftResult == False and rightResult == True:                        return False, 1                    else:                        return True, min(leftCost, rightCost)                        return dp(0, len(expression))[1]\n时间复杂度: O(N),\n空间复杂度: O(N).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 56","url":"/2021/07/12/LeetCode-biweekly-contest-56/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n998 / 10896\nYoungForest\n18\n1:27:14\n0:02:33\n0:13:25\n1:17:14  🐞2\nnull\n\n\n\n现在双周赛的参赛人数都快赶上周赛了。\n 1925. Count Square Sum Triples\n签到题，暴力枚举所有的组合。\nclass Solution:    def countTriples(self, n: int) -&gt; int:        ans = 0        for c in range(1, n+1):            for b in range(1, c+1):                for a in range(1, b+1):                    if a * a + b * b == c * c:                        if a == b: ans += 1                        else: ans += 2        return ans\n时间复杂度: O(N^3),\n空间复杂度: O(1).\n 1926. Nearest Exit from Entrance in Maze\n寻找最近的出口。标准的BFS。\nclass Solution:    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -&gt; int:        visited = set()        q = deque()        start = (entrance[0], entrance[1])        visited.add(start)        q.append(start)        step = 0        directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]        rows = len(maze)        cols = len(maze[0])        def exitCell(cell):            return (cell[0] == 0 or cell[0] == rows - 1 or cell[1] == 0 or cell[1] == cols - 1) and maze[cell[0]][cell[1]] == &#x27;.&#x27; and cell != start         while q:            s = len(q)            for _ in range(s):                current = q.popleft()                if exitCell(current): return step                for di, dj in directions:                    ni = di + current[0]                    nj = dj + current[1]                    if ni &gt;= 0 and ni &lt; rows and nj &gt;= 0 and nj &lt; cols and maze[ni][nj] == &#x27;.&#x27; and (ni, nj) not in visited:                        visited.add((ni, nj))                        q.append((ni,nj))            step += 1                return -1\n时间复杂度: O(m * n),\n空间复杂度: O(m * n).\n 1927. Sum Game\n贪心。\n尽量先取问好少的那边（直到取完），Alice尽量让差变大，Bob尽量让差变小。\n想法是好的，但我最后写的又臭又长，在比赛结束前13分钟才Accept。\nclass Solution:    def sumGame(self, num: str) -&gt; bool:        n = len(num)        leftSum = 0        rightSum = 0        left = 0        right = 0        for i in range(n):            if num[i] == &#x27;?&#x27;:                if i &gt;= n // 2: right += 1                else: left += 1            else:                if i &gt;= n // 2: rightSum += ord(num[i]) - ord(&#x27;0&#x27;)                else: leftSum += ord(num[i]) - ord(&#x27;0&#x27;)        total = right + left        # print (&#x27;total: &#x27;, total)        if total % 2 == 1: return True        alice = True        for _ in range(total):            if alice:                if left == 0 or (right != 0 and left &gt; right): # pick right                    if leftSum &lt;= rightSum or rightSum + 9 &gt; leftSum:                        rightSum += 9                    else:                        rightSum += 0                    right -= 1                elif right == 0 or left &lt; right: # pick left                    if leftSum &gt;= rightSum or leftSum + 9 &gt; rightSum:                        leftSum += 9                    else:                        leftSum += 0                    left -= 1                else:                    if leftSum == rightSum:                        return False                    elif leftSum &gt; rightSum:                        leftSum += 9                        left -= 1                    else:                        rightSum += 9                        right -= 1                                    else:                if left == 0 or (right != 0 and left &gt; right): # pick right                    if leftSum &gt; rightSum:                        rightSum +=  9 if (leftSum - rightSum &gt; 9) else leftSum - rightSum                    else:                        rightSum += 0                    right -= 1                elif right == 0 or left &lt; right: # pick left                    if leftSum &lt; rightSum:                        leftSum += 9 if (rightSum - leftSum &gt; 9) else rightSum - leftSum                    else:                        leftSum += 0                    left -= 1                                # print (left, leftSum, rightSum, right)                            alice = not alice                    return leftSum != rightSum\n时间复杂度: O(num.length),\n空间复杂度: O(num.length).\n 1928. Minimum Cost to Reach Destination in Time\n也是一道经典的题目。在限制时间的情况下，花费最小。\n国服官方的DP解\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 60","url":"/2021/09/07/LeetCode-biweekly-contest-60/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n998 / 10896\nYoungForest\n18\n1:27:14\n0:02:33\n0:13:25\n1:17:14  🐞2\nnull\n\n\n\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode biweekly contest 7","url":"/2019/08/25/LeetCode-biweekly-contest-7/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n106 / 1901\nYoungForest\n18\n1:01:13\n0:05:46\n0:27:13\n0:35:34\n1:01:13\n\n\n\n本周参加 字节跳动的夏令营，周六开幕，所以本次的双周赛是在五星级酒店的床上完成的。好不舒服，比赛结果也还能看下去。\n由于第二天上午要参加夏令营的课程，所以周赛就鸽掉了。不过下午的kick start round E还是参加了，翘掉了夏令营的课程。谁让我非常想去谷歌呢？\n双周赛题目不难，感觉像是其他OJ上类似的beginner定位。\n 1165. Single-Row Keyboard\n考察hash table的应用, 建立字母和index的反向映射即可。\n时间复杂度: O(N)\n空间复杂度: O(N)\nclass Solution &#123;public:    int calculateTime(string keyboard, string word) &#123;        vector&lt;int&gt; location(26);        for (int i = 0; i &lt; keyboard.size(); ++i) &#123;            location[keyboard[i] - &#x27;a&#x27;] = i;        &#125;        int ans = 0;        int current = 0;        for (char c : word) &#123;            ans += std::abs(location[c - &#x27;a&#x27;] - current);            current = location[c - &#x27;a&#x27;];        &#125;        return ans;    &#125;&#125;;\n 1166. Design File System\n考察基本的数据结构（树）和字符串处理。\n对路径进行建树，每个文件或目录是一个节点，节点上有value。查找和增长的过程都是类似字典树。\n时间复杂度: O(N).\n空间复杂度: O(N).\nclass FileSystem &#123;    struct Node &#123;        unordered_map&lt;string, shared_ptr&lt;Node&gt;&gt; children;        int value;        Node(int v) : value(v) &#123;&#125;    &#125;;    vector&lt;string&gt; split(const string&amp; path) &#123;        string tmp;        vector&lt;string&gt; stk;        stringstream ss(path);        while(getline(ss,tmp,&#x27;/&#x27;)) &#123;            stk.push_back(tmp);        &#125;        return stk;    &#125;    shared_ptr&lt;Node&gt; m;public:    FileSystem() &#123;        m = make_shared&lt;Node&gt;(0);    &#125;        bool create(string path, int value) &#123;        auto words = split(path);        auto current = m;        for (int i = 1; i &lt; words.size() - 1; ++i) &#123;            const auto&amp; word = words[i];            if (current-&gt;children.find(word) == current-&gt;children.end()) &#123;                return false;            &#125; else &#123;                current = current-&gt;children[word];            &#125;        &#125;        if (current-&gt;children.find(words.back()) != current-&gt;children.end()) &#123;            return false;        &#125;        current-&gt;children[words.back()] = make_shared&lt;Node&gt;(value);        return true;    &#125;        int get(string path) &#123;        auto words = split(path);        auto current = m;        for (int i = 1; i &lt; words.size(); ++i) &#123;            const auto&amp; word = words[i];            if (current-&gt;children.find(word) == current-&gt;children.end()) &#123;                return -1;            &#125; else &#123;                current = current-&gt;children[word];            &#125;        &#125;        return current-&gt;value;    &#125;&#125;;/** * Your FileSystem object will be instantiated and called as such: * FileSystem* obj = new FileSystem(); * bool param_1 = obj-&gt;create(path,value); * int param_2 = obj-&gt;get(path); */\n 1167. Minimum Cost to Connect Sticks\n贪心算法。每次选择cost最小的2个stick进行connect操作。一个stick越早被connect，它的长度越可能影响整个cost。\nclass Solution &#123;public:    int connectSticks(vector&lt;int&gt;&amp; sticks) &#123;        /*N个sticks，需要N-1次connect        4            4,5,8 9            8,9 17            17        */        int ans = 0;        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;        for (int s : sticks) &#123;            pq.push(s);        &#125;        while (pq.size() &gt; 1) &#123;            int smallest = pq.top();            pq.pop();            int second = pq.top();            pq.pop();            ans += smallest + second;            pq.push(smallest + second);        &#125;        return ans;    &#125;&#125;;\n 1168. Optimize Water Distribution in a Village\n最小生成树的变种。\npipe是边，除此之外，well也是边。可以当成是和水源连接的边。\n时间复杂度: O(E log E)\n空间复杂度: O(N)\nclass Solution &#123;    struct UF &#123;        vector&lt;int&gt; parents;        UF(int n) &#123;            parents.resize(n);            for (int i = 0; i &lt; n; ++i) &#123;                parents[i] = i;            &#125;        &#125;        int find(int x) &#123;           return x == parents[x] ? x : parents[x] = find(x);        &#125;        void unin(int x, int y) &#123;            int xp = find(x);            int yp = find(y);            parents[xp] = yp;        &#125;    &#125;;public:    int minCostToSupplyWater(int n, vector&lt;int&gt;&amp; wells, vector&lt;vector&lt;int&gt;&gt;&amp; pipes) &#123;        // 最小生成树        // 每次寻找最短的边        vector&lt;tuple&lt;int, int, int&gt;&gt; edges;        for (int i = 0; i &lt; wells.size(); ++i) &#123;            edges.push_back(make_tuple(wells[i], 0, i + 1));        &#125;        for (const auto&amp; pipe : pipes) &#123;            edges.push_back(make_tuple(pipe[2], pipe[0], pipe[1]));        &#125;        sort(edges.begin(), edges.end());        UF uf(n + 1);        int ans = 0;        for (const auto&amp; e : edges) &#123;            int cost = get&lt;0&gt;(e);            int left = get&lt;1&gt;(e);            int right = get&lt;2&gt;(e);            if (uf.find(left) == uf.find(right))                ;            else &#123;                ans += cost;                uf.unin(left, right);            &#125;        &#125;        return ans;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 115","url":"/2018/12/19/LeetCode-weekly-contest-115/","content":"有些日子没有参加LeetCode的weekly contest了，最近由于准备一月末的Google电话面试，需要重新把算法捡起来。复习算法书是一部分，另一手就是准备刷题啦。由于时间有限，LeetCode的weekly contest不失为一个更好的选择。因为contest有时间限制，和实际面试更像。\nweekly contest时长为1个半小时，4道不同难度的题目，每周末10点半开始(之前是9点半，可能是因为美国冬令时的原因，所以后沿了一小时)。\n和之前一样，只完成了2道题目，第三道题有些思路(后来证明不对)，第四题看了下题目，果断放弃。\n下面分享4道题目的思路和Solution，当然后2道是之后补题的。\n 958. Check Completeness of a Binary Tree\n判断一颗树是否是完全树。\n关于树的题目，递归、BFS、DFS是常用手段，可以很快发现，BFS最适合解决该题目。\n一旦发现某个结点缺少child，就将no_child置为True，之后再搜索的时候，其他节点就不能有child了。\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def isCompleteTree(self, root: TreeNode) -&gt; bool:        no_child = False        myqueue = collections.deque()        if root:            myqueue.append(root)                while len(myqueue) &gt; 0:            node = myqueue.popleft()            if no_child:                if node.left != None or node.right != None:                    return False            else:                if node.left != None:                    myqueue.append(node.left)                else:                    no_child = True                if node.right != None:                    if no_child:                        return False                    else:                        myqueue.append(node.right)                else:                    no_child = True                            return True\n时间复杂度：O(n), n 为节点数，因为在BFS中每个节点都要被遍历到(至少在完全树中，非完全树会提前退出)；\n空间复杂度：O(n), BFS要用到一个队列，队列中最多要存一层的节点。\n这道题的难度更像Easy，Medium真是高估了。\n 957 Prison Cells After N Days\n状态转移的题目，可以直接模拟。但缺点是但N太大时，会TLE。\n不难发现，Cells的状态最多有2^6 = 64种，所以在状态转移时，必然会出现循环。所以只要保存之前遇到的状态，如果再次遇到，就可以直接模掉循环长度了。\n把状态转移打印出来，很快就可以发现，14是一个很神奇的数，每隔14必循环。所以最后的实现很多人都是直接mod 14了事。\n时间复杂度: O(1),\n空间复杂度: O(1).\nclass Solution:    def prisonAfterNDays(self, cells, N):        &quot;&quot;&quot;        :type cells: List[int]        :type N: int        :rtype: List[int]        &quot;&quot;&quot;        last_day = cells        new_day = [0] * 8        N = N % 14 + 14                for i in range(1, 7):            if last_day[i-1] == last_day[i+1]:                new_day[i] = 1            else:                new_day[i] = 0        new_day[0] = 0        new_day[7] = 0        last_day[0] = 0        last_day[7] = 0        last_day, new_day = new_day, last_day                for _ in range(1, N):            for i in range(1, 7):                if last_day[i-1] == last_day[i+1]:                    new_day[i] = 1                else:                    new_day[i] = 0            last_day, new_day = new_day, last_day                    return last_day\n 959. Regions Cut By Slashes\n问题的关键在于被划分为多少联通的区域，我最开始想用染色做，但后来被染色的顺序搞晕了。写了100行代码，最后还是不能全部正确解决。（事实上，DFS/BFS染色也是一种正确的解法）\n看了官方的Solution后，发现Union-Find大法好。算法第4版 的第一章的最后也是着重讲解Union-Find的，解决这种联通问题最好不过了。不过因为Union-Find是太长时间前看的了，而且平时做题时几乎不用，所以根本想不到它可以很方便地解决类似的联通问题。\n在此再次推荐 算法第4版，真的对面试和提升算法技能太有用啦。多看多有益处。\nclass Solution:    def regionsBySlashes(self, grid: List[str]) -&gt; int:        class UF:            # quick union implement            def __init__(self, size):                self.parents = [i for i in range(size)]                self.count = size                            def find(self, x):                if self.parents[x] == x:                    return x                else:                    self.parents[x] = self.find(self.parents[x])                    return self.parents[x]                        def union(self, x, y):                i = self.find(x)                j = self.find(y)                                if i == j: return # already unioned                                self.parents[i] = j                self.count -= 1                        uf = UF(4*len(grid)*len(grid[0]))                for row, value in enumerate(grid):            for column, char in enumerate(value):                base = (row * len(grid[0]) + column) * 4                if char == &#x27;\\\\&#x27;:                    uf.union(base, base + 2)                    uf.union(base + 1, base + 3)                elif char == &#x27;/&#x27;:                    uf.union(base, base + 1)                    uf.union(base + 2, base + 3)                elif char == &#x27; &#x27;:                    uf.union(base, base + 1)                    uf.union(base, base + 2)                    uf.union(base, base + 3)                else:                    pass                if row &gt; 0:                    base_up = ((row - 1) * len(grid[0]) + column) * 4                    uf.union(base, base_up + 3)                if row &lt; len(grid) - 1:                    base_down = ((row + 1) * len(grid[0]) + column) * 4                    uf.union(base + 3, base_down)                if column &gt; 0:                    base_left = base - 4                    uf.union(base + 1, base_left + 2)                if column &lt; len(grid[0]) - 1:                    base_right = base + 4                    uf.union(base + 2, base_right + 1)                            return uf.count\n 960. Delete Columns to Make Sorted III\n这是一道Dynamic Programming发挥作用的典型题目。(由于时间不够了，最后还是去看了Solution才豁然开朗。)\n可惜的是 算法第4版 并未涉及DP这么重要的概念，如果要系统地学习DP的话，还是去看 算法导论 吧（虽然我从来都没有看完，向来都是挑着看的）。\n我们按照算法导论上的一步一步来吧：\n动态规划解题的4 steps:\n\n最优解结构\n递归定义最优解的值\n计算最优解的值\n从计算信息中构造最优解\n\nWhen should we look for a Dynamic Programming solution to a problem?\n\n最优解结构\n重叠子问题\n\n首先 最小删除列数 = 最大留下列数，我们把最大留下列数作为最优化目标。\n\n最优解结构：根据 算法导论 15.3中对最优子结构的讨论，子问题的空间越小（越简单）越好，所以我们选择dp[i]的子问题为dp[k]，其中 0 &lt;= k &lt; i, dp[i]表示只考虑前i个字符, 且第i列留下来的话，最大留下的列数。\n递归定义最优解的值：dp[i] = max(dp[k] + 1), for every string .indexAt[i] &gt;= .indexAt[k]\n使用 Bottom-top 方法求解答案，for i in 0～len(A[0]), 计算dp[i], 最大留下列数为max(dp)。不是dp[-1]因为最后一列不一定要留下。\n由于问题不需要求解最后删去/留下哪几行，所以构造最优解可以忽略\n\n时间复杂度: O(A.length ^2 * A[i].length),\n空间复杂度: O(A.length).\nclass Solution:    def minDeletionSize(self, A):        &quot;&quot;&quot;        :type A: List[str]        :rtype: int        &quot;&quot;&quot;        dp = [1 for i in range(len(A[0]))]                for i in range(len(dp)):            for k in range(i):                if all(s[k] &lt;= s[i] for s in A):                    dp[i] = max(dp[i], dp[k] + 1)                        return len(A[0]) - max(dp)\n 后记\n革命尚未成功，同志还需努力。\n最近在知乎上关注了一个叫做Jennica的姐姐（找她要的Google内推），小姐姐热爱生活和编程，我想我其实也是这样的。所以打算多多向其学习，万一历史进程让我阴差阳错地可以进入Google工作呐。我一直以来（起码这1年以来），一直以进入外企工作作为自己的职业规划，现在看到前人的努力和成功，更加有动力和欲望啦。我要去Google/Microsoft做程序员，哈哈。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 116","url":"/2018/12/26/LeetCode-weekly-contest-116/","content":"又到周末LeetCode weekly contest的时候了，这次战果不佳。原因主要是，二三题都想做出来，结果都没有做出来。如果把时间都集中于第二题，应该也还是能AC的。\n 961. N-Repeated Element in Size 2N Array\n这道题总觉得之前在LeetCode上已经做过了，还记得solution的方向。\n思路是这样的，既然有一半的元素是一样的，我们随机抽取2个元素，判断是否相等就可以了。从概率上来讲，虽然有永远算不出来的概率，但在实际应用中效果很好。\nimport randomclass Solution:    def repeatedNTimes(self, A):        &quot;&quot;&quot;        :type A: List[int]        :rtype: int        &quot;&quot;&quot;        while True:            s = random.sample(A, 2)            if s[0] == s[1]:                return s[0]\n 962. Maximum Width Ramp\n或许是最近dp学的有点多，遇见道题目就想着空间换时间。殊不知，忘记了dp的用武之地：\nWhen should we look for a Dynamic Programming solution to a problem?\n\n最优解结构\n重叠子问题\n找了半天最优解结构和重叠子问题：\ndp[x] = max[dp[x] + x - k] for all A[x] &gt;= A[k],\n发现时间复杂度和brute search一样，都是O(n^2)呀！\n\n真是dp学魔怔了，忘记了其他更基础的算法。其实这道题用简单的排序就能解决。\n排序可以避免二次循环，将复杂度从O(n^2)降为O(n logn)。\nclass Solution:    def maxWidthRamp(self, A):        &quot;&quot;&quot;        :type A: List[int]        :rtype: int        &quot;&quot;&quot;        min_value = math.inf        ret = 0        for i in sorted(range(len(A)), key=A.__getitem__):            min_value = min(min_value, i)            ret = max(ret, i - min_value)                    return ret\nSolution中还有一种利用二分查找的方法，我觉得很巧妙。\n关键点在于注意到，对于j1 &lt; j2, A[j1] &lt;= A[j2], 此时，我们总是倾向于选择j2的。所以，对于这样的输入[6,0,8,2,1,5]，maximum width ramp的A[j] 一定会出现在[5, 8]中。对于i的选择，就需要遍历一遍了。那么A[j]是[5, 8]中的哪一个呢？就需要根据A[i]就行二分查找了，选择比A[i]恰好大一点的A[j]。\nimport bisectclass Solution:    def maxWidthRamp(self, A):        &quot;&quot;&quot;        :type A: List[int]        :rtype: int        &quot;&quot;&quot;        condinates = [(A[-1], len(A)-1)]        ret = 0                for i in range(len(A)-2, -1, -1):            jx = bisect.bisect(condinates, (A[i],))            if jx &gt;= len(condinates):                condinates.append((A[i], i))            else:                ret = max(ret, condinates[jx][1] - i)                    return ret\n 963. Minimum Area Rectangle II\n这道题其实挺恶心的，怪不得downvote &gt;&gt; upvote。对数学的要求远大于算法的要求，brute search( O(n^3) )也能过。\nimport mathimport collectionsimport itertoolsclass Solution:    def minAreaFreeRect(self, points):        &quot;&quot;&quot;        :type points: List[List[int]]        :rtype: float        &quot;&quot;&quot;        EPS = 1e-7        points_set = set(map(lambda x: complex(*x), points))        ans = math.inf                for p1, p2, p3 in itertools.permutations(points_set, 3):            p4 = p1 + p3 - p2            if p4 in points_set and abs((p3 - p2).real * (p1 - p2).real + (p3 - p2).imag * (p1 - p2).imag) &lt; EPS:                ans = min(ans, abs(p1 - p2) * abs(p3 - p2))                        return ans if ans &lt; math.inf else 0\nSolution中还有一种\b\b时间复杂度为O(n^2 log n)的解法，利用了矩形的中心这一特点。\n 964. Least Operators to Express Number\n上一周的weekly contest竟然拖到本周六才完成，要知道明天就是新的weekly contest啦。我的效率真是感人呀。不过临近年底，真的是事情超级多。不过再忙也不能忘记以“找一份好工作”为中心的纲领。\n此题难度为Hard，果然不知道怎么做。看看题解学习学习先。\n题解看的一塌糊涂，完全不知所以。幸运的是，找到一份很好理解的Discuss。\n正如作者所云：\n\n此题归根结底还是考察对进制的理解\n\n时间复杂度: O(log target),\n空间复杂度: O(log target).\nclass Solution:    def leastOpsExpressTarget(self, x, target):        &quot;&quot;&quot;        :type x: int        :type target: int        :rtype: int        &quot;&quot;&quot;        rl = []        while target &gt; 0:            rl.append(target % x)            target //= x                    n = len(rl)                    pos = rl[0] * 2        neg = (x - rl[0]) * 2                for i in range(1, n):            pos, neg = min(rl[i] * i + pos, rl[i] * i + i + neg), min((x - rl[i]) * i + pos, (x - rl[i]) * i - i + neg)                    return min(pos - 1, n + neg - 1)","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 117","url":"/2018/12/30/LeetCode-weekly-contest-117/","content":"今天参加LeetCode weekly contest 117, 采取了不同的策略：边做题边写博客总结。期望这样可以真实地记录所思所想，提高写博客的效率。因为之前2次，事后写博客总是耽误几天时间才写完。\n 965. Univalued Binary Tree\n一道很简单、很弱智的题目，直接DFS/BFS即可。因为BFS在遇到异常节点的时候可以直接返回，更方便。我选择了BFS实现。\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def isUnivalTree(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: bool        &quot;&quot;&quot;        if root == None: return True        univalue = root.val        queue = [root]                while len(queue) &gt; 0:            node = queue.pop(0)            if node.left != None: queue.append(node.left)            if node.right != None: queue.append(node.right)            if node.val != univalue: return False                    return True\n 967. Numbers With Same Consecutive Differences\n第二题也是一道十分弱智的题目，直接搜索即可。需要注意的地方是，N == 1 和 K == 0时的特殊处理。\nfrom functools import reduceclass Solution:    def numsSameConsecDiff(self, N, K):        &quot;&quot;&quot;        :type N: int        :type K: int        :rtype: List[int]        &quot;&quot;&quot;        if N == 1:            return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]        ret = []        hashmap = &#123;&#125;        for i in range (10):            hashmap[i] = []            if K == 0:                hashmap[i].append(i)            else:                if i + K &lt;= 9:                    hashmap[i].append(i + K)                if i - K &gt;= 0:                    hashmap[i].append(i - K)                        def helper(n, digits):            if n == N:                ret.append(reduce(lambda x, y: x * 10 + y, digits))                return            for i in hashmap[digits[n-1]]:                digits.append(i)                helper(n+1, digits)                digits.pop()                        for i in range(1, 10):            digits = [i]            helper(1, digits)                    return ret\n 966. Vowel Spellchecker\n由于前2题用brute search都解决了，本题我也上来就直接干。结果TLE了，因为暴力法的时间复杂度为O(MN)，M = len(wordlist), N = len(queries)。\n怎样才能进一步降低时间复杂度呢？我脑子中闪过的第一个词是 单词书(Tire)，最近刚在 算法第四版 中学到这一技术。 时间复杂度为O(max(N * wordlist中最长单词的长度, M), 不出意料的话，可以AC，现在已经11:46了。应该写不完了，让我先看一下第4题吧。\nclass Solution:    def spellchecker(self, wordlist, queries):        &quot;&quot;&quot;        :type wordlist: List[str]        :type queries: List[str]        :rtype: List[str]        &quot;&quot;&quot;        wordlist_replace_vowel = []        vowel = [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;, &#x27;A&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;U&#x27;]        word_lower = []        for word in wordlist:            word_lower.append(word.lower())            temp = list(word)            for i in range(len(temp)):                if temp[i] in vowel:                    temp[i] = &#x27;0&#x27;            wordlist_replace_vowel.append(&#x27;&#x27;.join(temp).lower())                    ret = []        for query in queries:            flag = 0            match = &#x27;&#x27;            temp = list(query)            for i in range(len(temp)):                if temp[i] in vowel:                    temp[i] = &#x27;0&#x27;            query_replace_vowel = &#x27;&#x27;.join(temp).lower()            query_lower = query.lower()                        for wi, word in enumerate(wordlist):                if flag &lt; 4 and word == query:                    match = word                    flag = 4                    break                if flag  &lt; 3 and word_lower[wi] == query_lower:                    match = word                    flag = 3                if flag &lt; 2 and wordlist_replace_vowel[wi] == query_replace_vowel:                    match = word                    flag = 2                        ret.append(match)                    return ret\n看完Solution后，才发现这也是一道很弱智的题目。brute search会TLE，使用HashMap就可以了嘛。\n时间复杂度: O©, C为wordlist和queries的总长度。\n空间复杂度: O©。\nclass Solution:    def spellchecker(self, wordlist, queries):        &quot;&quot;&quot;        :type wordlist: List[str]        :type queries: List[str]        :rtype: List[str]        &quot;&quot;&quot;        wordlist_replace_vowel = &#123;&#125;        vowel = [&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;]        word_lower = &#123;&#125;        word_set = set(wordlist)        for word in wordlist:            wl = word.lower()            # setdefault 的使用：第一次赋值，之后忽略。保证在wordlist中先出现的词优先            word_lower.setdefault(word.lower(), word)            wordlist_replace_vowel.setdefault(&#x27;&#x27;.join(&#x27;0&#x27; if i in vowel else i for i in wl), word)                    ret = []        for query in queries:            ql = query.lower()            query_replace_vowel = &#x27;&#x27;.join(&#x27;0&#x27; if i in vowel else i for i in ql)            if query in word_set:                ret.append(query)            elif ql in word_lower:                ret.append(word_lower[ql])            elif query_replace_vowel in wordlist_replace_vowel:                ret.append(wordlist_replace_vowel[query_replace_vowel])            else:                ret.append(&#x27;&#x27;)                    return ret\n 968. Binary Tree Cameras\n看完Solution后，惊呼：动态规划还可以这样用！\n每个节点有3种状态：\n\n子树都已被cover，但此节点没有被cover。\n子树和此节点都被cover，但此节点没有camera。\n子树和此节点都被cover，且此节点有camera。\n\n对于每种状态的节点，他的子节点的状态也是确定的。\n\n左右子节点都为2。\n左右子节点为2或3，且至少有一个为3.\n左右子节点为1或2或3，但需要增加一个camera。\n\n# Definition for a binary tree node.# class TreeNode:#     def __init__(self, x):#         self.val = x#         self.left = None#         self.right = Noneclass Solution:    def minCameraCover(self, root):        &quot;&quot;&quot;        :type root: TreeNode        :rtype: int        &quot;&quot;&quot;        def solve(root):            if root is None: return 0, 0, math.inf                        L = solve(root.left)            R = solve(root.right)                        dp0 = L[1] + R[1]            dp1 = min(L[2] + min(R[1:]), R[2] + min(L[1:]))            dp2 = 1 + min(L) + min(R)                        return dp0, dp1, dp2                return min(solve(root)[1:])\n 总结\n上午参加比赛，下午5点前写完博客。\n总的来说，contest的题目的质量并没有之前的高。我之前喜欢用Liked排序刷题，体验非常好。\ncontest的优势在于有时间限制，可以逼迫自己在限定时间内解决。想不出解法也暂时不能去看题解（一种偷懒的刷题方式）。\n这几天元旦放假，打算把《C++ Primer》看一部分，这样以后就可以在简历上写自己会C++啦。\n之后是读CTCI，准备Google的第一次电面。\n然后是CSAPP，我喜欢的计算机系统。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 118","url":"/2019/01/06/LeetCode-weekly-contest-118/","content":"一周一度的LeetCode weekly contest 开始啦。本周着实比之前有所进步，首先是对C++更加熟悉了，之前都是用Python写的。答题过程也更流畅了，差点做出来3道题目。\n\n 970. Powerful Integers\n第一题只有3分，而且无法从算法上就行优化，brute approach即可。\n需要注意的是corner case, 当x == 1 or y == 1时，1^n = 1.\nclass Solution &#123;public:    vector&lt;int&gt; powerfulIntegers(int x, int y, int bound) &#123;        unordered_set&lt;int&gt; res;                for (int i = 0; ; ++i) &#123;            int ans = pow(x, i);            if (ans &gt; bound) break;            for (int j = 0; ; ++j) &#123;                int ans_new = ans + pow(y, j);                if (ans_new &lt;= bound)                    res.insert(ans_new);                else                    break;                if (y == 1) break;            &#125;            if (x == 1) break;        &#125;        vector&lt;int&gt; res_vec;        for (const auto a: res) &#123;            res_vec.push_back(a);        &#125;        return res_vec;    &#125;&#125;;\n 969. Pancake Sorting\n首先想到一种暴力方法，每次把最后一个元素排好序，类似选择排序的算法。\n即先找到最后一个元素的位置，将其flip到第一个位置，然后再flip一次，放在最后一个位置。\n不变式为，最后一个位置之后的元素都是排好序的。\nclass Solution &#123;public:    void flip(vector&lt;int&gt;&amp; A, int begin,int end) &#123;        for (; begin &lt; end; ++begin, --end) &#123;            int temp;            temp = A[begin];            A[begin] = A[end];            A[end] = temp;        &#125;    &#125;        vector&lt;int&gt; pancakeSort(vector&lt;int&gt;&amp; A) &#123;        vector&lt;int&gt; res;        for (int i = A.size(); i &gt; 1; --i) &#123;            int index = 0;            for (int j = 0; j &lt; i; ++j) &#123;                if (A[j] == i) &#123;                    index = j;                    break;                &#125;                       &#125;            if (index + 1 != i) &#123;                res.push_back(index+1);                flip(A, 0, index);                res.push_back(i);                flip(A, 0, i - 1);            &#125;        &#125;                return res;    &#125;&#125;;\n 971. Flip Binary Tree To Match Preorder Traversal\n该题也是straight forward解决即可，不断递归判断每个子树是否可以flip。由于搞错了一个参数的含义(设计的是没问题的，但实现的时候有疏忽)，voyageIndex传入的是root的位置，flip返回的是预计下一个子树的根结点在voyage中的位置。\n导致12:19才AC，超时20min。而且还WA了4次。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    int flip(int voyageIndex, TreeNode* root, vector&lt;int&gt;&amp; voyage, vector&lt;int&gt;&amp; res) &#123;        if (root == nullptr) return voyageIndex;        // cout &lt;&lt; &quot;root-&gt;val : &quot; &lt;&lt; root-&gt;val &lt;&lt; endl;        if (voyage[voyageIndex] != root-&gt;val) return -1;        // cout &lt;&lt; &quot;root-&gt;val : &quot; &lt;&lt; root-&gt;val &lt;&lt; endl;        int voyageIndexEnd;        bool flag = false;        if (root-&gt;left != nullptr &amp;&amp; voyage[voyageIndex + 1] == root-&gt;left-&gt;val) &#123;            ;        &#125; else if (root-&gt;right != nullptr &amp;&amp; voyage[voyageIndex + 1] == root-&gt;right-&gt;val &amp;&amp; root-&gt;left != nullptr) &#123;            TreeNode *temp;            temp = root-&gt;left;            root-&gt;left = root-&gt;right;            root-&gt;right = temp;            flag = true;        &#125; else &#123;            ;        &#125;        // cout &lt;&lt; &quot;voyageIndex: &quot; &lt;&lt; voyageIndex &lt;&lt; &quot; &quot;&lt;&lt; root-&gt;val &lt;&lt; endl;        voyageIndexEnd = flip(voyageIndex + 1, root-&gt;left, voyage, res);        // cout &lt;&lt; &quot;voyageIndexEnd: &quot; &lt;&lt; voyageIndexEnd &lt;&lt; endl;         if (voyageIndexEnd == -1) return -1;        voyageIndexEnd = flip(voyageIndexEnd, root-&gt;right, voyage, res);        // cout &lt;&lt; &quot;voyageIndexEnd: &quot; &lt;&lt; voyageIndexEnd &lt;&lt; endl;         if (voyageIndexEnd == -1) return -1;        if (flag) res.push_back(root-&gt;val);        return voyageIndexEnd;    &#125;    vector&lt;int&gt; flipMatchVoyage(TreeNode* root, vector&lt;int&gt;&amp; voyage) &#123;        vector&lt;int&gt; error = &#123;-1&#125;;        vector&lt;int&gt; res;                if (flip(0, root, voyage, res) == -1) &#123;            return error;        &#125; else &#123;            return res;        &#125;    &#125;&#125;;\n 972. Equal Rational Numbers\n本题并没有考察任何算法，只考察的是数据结构抽象和基础的数学知识(对有理数Rational Numbers)的理解。\n我也是看的题解才明白如此简单的。真的是一道难者不会，会者不难的题目。\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;class Fraction &#123;public:    long long numerator, denominator;    long long gcd(long long x, long long y) &#123;        return y &gt; 0 ? gcd(y, x % y) : x;    &#125;    Fraction(long long n, long long d) &#123;        long long g = this-&gt;gcd(n, d);        this-&gt;numerator = n / g;        this-&gt;denominator = d / g;    &#125;    Fraction(string S) &#123;        // &lt;IntegerPart&gt;&lt;.&gt;&lt;NonRepeatingPart&gt;&lt;(&gt;&lt;RepeatingPart&gt;&lt;)&gt;        auto dotPosition = S.find(&quot;.&quot;);        Fraction ans(0, 1);        if (dotPosition != string::npos) &#123;            Fraction integerPart(stol(S.substr(0, dotPosition)), 1);            ans.add(integerPart);                        auto leftParenthese = S.find(&quot;(&quot;);            string nonRepeatingPartString;            if (leftParenthese != string::npos) &#123;                nonRepeatingPartString = S.substr(dotPosition + 1, leftParenthese - dotPosition - 1);                                auto repeatingPartString = S.substr(leftParenthese + 1, S.size() - leftParenthese - 2);                Fraction repeatingPart(stol(repeatingPartString), pow(10, nonRepeatingPartString.size()) * (pow(10, repeatingPartString.size()) - 1));                ans.add(repeatingPart);            &#125; else &#123;                nonRepeatingPartString = S.substr(dotPosition + 1, S.size() - dotPosition - 1);            &#125;            if (nonRepeatingPartString.size() &gt; 0) &#123;                Fraction nonRepeatingPart(stol(nonRepeatingPartString), pow(10, nonRepeatingPartString.size()));                ans.add(nonRepeatingPart);            &#125;        &#125; else &#123;            Fraction integerPart(stol(S.substr(0, S.size())), 1);            ans.add(integerPart);        &#125;                this-&gt;numerator = ans.numerator;        this-&gt;denominator = ans.denominator;    &#125;    void add(Fraction b) &#123;        Fraction n(this-&gt;numerator * b.denominator + this-&gt;denominator * b.numerator, this-&gt;denominator * b.denominator);        this-&gt;numerator = n.numerator;        this-&gt;denominator = n.denominator;    &#125;    bool equal(Fraction b) &#123;        return this-&gt;numerator == b.numerator &amp;&amp; this-&gt;denominator == b.denominator;    &#125;&#125;;class Solution &#123;public:    bool isRationalEqual(string S, string T) &#123;        return Fraction(S).equal(Fraction(T));    &#125;&#125;;int main2(int argc, char const *argv[])&#123;    Solution s;    // auto res = s.isRationalEqual(&quot;0.(52)&quot;, &quot;0.5(25)&quot;);    Fraction a(&quot;0.(52)&quot;);    cout &lt;&lt; a.numerator &lt;&lt; &quot; / &quot; &lt;&lt; a.denominator &lt;&lt; endl;    Fraction b(&quot;0.5(25)&quot;);    cout &lt;&lt; b.numerator &lt;&lt; &quot; / &quot; &lt;&lt; b.denominator &lt;&lt; endl;    Fraction c(&quot;0.52(52)&quot;);    cout &lt;&lt; c.numerator &lt;&lt; &quot; / &quot; &lt;&lt; c.denominator &lt;&lt; endl;    return 0;&#125;\n事实上，如果注意到对有理数的限制的话，还有更投机取巧的解法，具体可以参考han神的解答.\nEach part consists only of digits.The &lt;IntegerPart&gt; will not begin with 2 or more zeros.  (There is no other restriction on the digits of each part.)1 &lt;= &lt;IntegerPart&gt;.length &lt;= 40 &lt;= &lt;NonRepeatingPart&gt;.length &lt;= 41 &lt;= &lt;RepeatingPart&gt;.length &lt;= 4\n我的代码很长。写的过程中，暴露出来对C类的实现十分不熟悉。本来还想用运算符重载来着，后来发现自己并不会。\n看来，我还需要把&quot;C Primer&quot;的其他部分也花时间读一下。毕竟\n\n工欲善其事，必先利其器.\n– 《论语·卫灵公》\n\n 后记\n最后附上我对“C++ Primer”的书评：\n\nC入门的神书。从大一开始就被无数人推荐，然而一直懒于去看，天真地认为学校学的那些C就够了。后来随着编程学习的继续深入，对C的敬畏之心渐渐建立起来。原来自己一直用的C根本就是假的，只是带类的C语言。尤其是学习cs107编程范式的时候，老师也一针见血地指出，大多数C程序员都是这样的。听到后羞愧难当，把C从简历里会的语言里都删去了。到了元旦假期，终于有勇气去重新入门C了。直接上手英文版，以用C刷LeetCode作为辅助，先看了前3章和9～12章（即基础部分、container 和 smart pointer）。看完之后真的是醍醐灌顶，后悔没有早点“学习”C++。由于本书面面俱到(实在太厚了），我短期内也没有计划全部看完。但是我认为，每读一章，都受益无穷。\n\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 119","url":"/2019/01/13/LeetCode-weekly-contest-119/","content":"这次contest做的比较惨，排名大致是1486 / 3845。出现的问题有：\n\n第二题，比较简单。由于是easy的题目，直接brute force了，结果TLE一次。之前由于粗心，for循环条件中的变量还写错了一次。导致2次罚时。\n第三题，也不是很难，但最后并没有想到O(n)的解法。只想到了O(n ^ 2)的。想到了要算前缀和，也注意到了divisible这一关键词。但并没有联想到前缀和相等就可以这一关键点。\n第四题，想到了dp。卡在了&quot;找寻后面数组中刚刚大一点的数&quot;这步，即没想到用TreeMap解决。归根结底是因为对基础的数据结构不熟悉。\n\n 973. K Closest Points to Origin\n直接用C++中的Map即可，用key进行排序。\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int K) &#123;        map&lt;int, vector&lt;vector&lt;int&gt;&gt;&gt; distance;        for (const auto point: points) &#123;            distance[point[0]*point[0] + point[1]*point[1]].push_back(point);        &#125;        vector&lt;vector&lt;int&gt;&gt; results;        int i = 0;        for (const auto d: distance) &#123;            for (const auto point: d.second) &#123;                results.push_back(point);                i++;                if (i &gt;= K) &#123;                    return results;                &#125;            &#125;        &#125;                return results;    &#125;&#125;;\n 976. Largest Perimeter Triangle\n只用找最大的3个可以组成三角形的数就可以了。\nclass Solution &#123;public:    int largestPerimeter(vector&lt;int&gt;&amp; A) &#123;        int result = 0;        sort(A.begin(), A.end());        for (int i = A.size() - 3; i &gt;= 0; i--) &#123;            if (A[i] + A[i+1] &gt; A[i+2]) &#123;                result = A[i] + A[i+1] + A[i+2];                break;            &#125;        &#125;                return result;    &#125;&#125;;\n 974. Subarray Sums Divisible by K\nclass Solution &#123;public:    int subarraysDivByK(vector&lt;int&gt;&amp; A, int K) &#123;        unordered_map&lt;int, int&gt; prefix_sum;        int sum = 0;        int result = 0;        prefix_sum[0] = 1;        for (int i = 0; i &lt; A.size(); i++) &#123;            sum = (sum + A[i] % K + K) % K;            result += prefix_sum[sum];            prefix_sum[sum]++;        &#125;                return result;    &#125;&#125;;\n 975. Odd Even Jump\nC++中，map的默认实现就是Tree Map.\nclass Solution &#123;public:    int oddEvenJumps(vector&lt;int&gt;&amp; A) &#123;        vector&lt;bool&gt; odd_reach(A.size(), false);        vector&lt;bool&gt; even_reach(A.size(), false);        int result = 0;        map&lt;int, int&gt; treemap;                odd_reach[A.size() - 1] = true;        even_reach[A.size() - 1] = true;        result++;        treemap[A[A.size() - 1]] = A.size() - 1;                for (int i = A.size() - 2; i &gt;= 0; --i) &#123;            auto larger = treemap.lower_bound(A[i]);            auto smaller = treemap.upper_bound(A[i]);                        if (larger != treemap.end()) &#123;                odd_reach[i] = even_reach[larger-&gt;second];            &#125;            if (smaller != treemap.begin()) &#123;                even_reach[i] = odd_reach[(--smaller)-&gt;second];            &#125;            if (odd_reach[i]) result++;            treemap[A[i]] = i;        &#125;                return result;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 120","url":"/2019/01/20/LeetCode-weekly-contest-120/","content":"本周和好友“女声男”同时参加weekly contest。有同学共同竞争还是挺有压力的。因为我练习算法题已经有半年时间了，他还是新手，如若最后还败北了，岂不丢人。不过结果还好，没有丢自己的人。我在离比赛结束还有10min时全部AC，而且所有题目都是一遍过，略胜一筹。不得不说，这次的题比往届简单不少，之前我的水平一直维持在只做出2道题目，ranking 800左右，而本次ranking 为 356 / 3870。从排名上看有所进步。\n下面我分享一下四道题目的思路。\n 977. Squares of a Sorted Array\n给定一个数组，返回各个元素的平方数组，该数组是排好序的。直接brute force即可。\nclass Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;        vector&lt;int&gt; square;                for (auto a: A) &#123;            square.push_back(a * a);        &#125;                sort(square.begin(), square.end());                return square;    &#125;&#125;;\n时间复杂度：O(n log n)，因为有个排序。\n空间复杂度：O(n)，因为要返回一个新的数组，除此之外，不实用额外空间。当然，你也可以使用传进来的数组所占的空间，更trick，但没有多大意义。\n看过Solution后，惊奇地发现竟然还有种O(n)的解法。仔细一看，原来是自己没有注意到数组A本身是排好序的。问题可以转化为合并2个排好序的数组。\nclass Solution &#123;public:    vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; A) &#123;        vector&lt;int&gt; square;                int j = 0;        for (; j &lt; A.size() &amp;&amp; A[j] &lt; 0; j++) ;                int i = j - 1;        while (i &gt;= 0 &amp;&amp; j &lt; A.size()) &#123;            if (A[i]*A[i] &lt; A[j]*A[j]) &#123;                square.push_back(A[i]*A[i]);                i--;            &#125;            else &#123;                square.push_back(A[j]*A[j]);                j++;            &#125;        &#125;        while (i &gt;= 0) &#123;            square.push_back(A[i]*A[i]);            i--;        &#125;                while (j &lt; A.size()) &#123;            square.push_back(A[j]*A[j]);            j++;        &#125;                return square;    &#125;&#125;;\n 978. Longest Turbulent Subarray\n给定一个数组，返回“升降子数组”的最大长度。所谓“升降子数组”，即 相邻2个元素对大小变化的符号相反，比如[1, 2, 1, 2, 1]。画在坐标图上就是波浪状。\n思路：遍历一遍数组，如果新的元素对变化符号与前一个元素对变化符号相反，则 当前升降子数组长度 += 1; 否则，重置当前升降子数组长度为 2。遍历的同时根据 当前升降子数组长度 更新 最长升降子数组长度。\nclass Solution &#123;public:    int maxTurbulenceSize(vector&lt;int&gt;&amp; A) &#123;        int max_length = 1;        // 1 down, -1 up        int last_state = 0;        int current_length = 2;                for (int i = 0; i &lt; A.size() - 1; i++) &#123;            int state = 0;            if (A[i] &gt; A[i + 1]) &#123;                state = 1;            &#125; else if (A[i] &lt; A[i + 1]) &#123;                state = -1;            &#125; else &#123;                state = 0;            &#125;            if (state == -last_state &amp;&amp; state != 0) &#123;                current_length++;            &#125; else &#123;                current_length = 2;            &#125;            max_length = max(max_length, current_length);                        last_state = state;        &#125;                return max_length;    &#125;&#125;;\n时间复杂度: O(n)，只需要遍历数组一遍；\n空间复杂度: O(1), 只使用常数的额外空间。\n 979. Distribute Coins in Binary Tree\nIntution: 遇到树的题目，最先先到的就是递归，dfs。无脑写dfs最难的地方在于确定参数和返回值，也就是明确子树与root之间的关系。在本题中，子树与root之间的关系就是，存在硬币的转移，从子树到root，或是从root到子树。所以只需要一个返回值，表示这一转移即可。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;private:    int move = 0;    // 把多余的给parent，问parent要不够的, positive: surplus, negative: demand    int recurse(TreeNode* root) &#123;        if (!root) return 0;        int surplus = 0;                int left = recurse(root-&gt;left);        int right = recurse(root-&gt;right);                surplus = left + right + root-&gt;val - 1;                move += abs(surplus);                return surplus;    &#125;public:    int distributeCoins(TreeNode* root) &#123;        recurse(root);                return move;    &#125;&#125;;\n时间复杂度: O(n), n为node的数目。因为每个node都要没调用一次。\n空间复杂度: 平均 O(log n), 即 树的深度。\n 980. Unique Paths III\nIntution: 寻找路径数目，最直接的brute force是直接dfs进行backtrack。由于题目规模比较小，1 &lt;= grid.length * grid[0].length &lt;= 20，所以还是可以AC的。激动人心的是在比赛结束前10min，AC掉这最后一道题目。\nclass Solution &#123;private:    int path = 0;    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt; &amp;visit, int i, int j) &#123;        // cout &lt;&lt; &quot;dfs: &quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; endl;        if (grid[i][j] == 2) &#123;            int true_all = true;            for (int xi = 0; xi &lt; grid.size(); xi++) &#123;                for (int xj = 0; xj &lt; grid[xi].size(); xj++) &#123;                    if (grid[xi][xj] == 0 &amp;&amp; visit[xi][xj] == false) &#123;                        true_all = false;                        goto end_of_outer_loop;                    &#125;                &#125;            &#125;            end_of_outer_loop:            if (true_all) &#123;                // cout &lt;&lt; &quot;find a path!&quot; &lt;&lt; endl;                path++;               &#125;            return;        &#125;        visit[i][j] = true;        if (i &gt; 0) &#123;            int new_i = i - 1;            int new_j = j;            if (visit[new_i][new_j] == false &amp;&amp; (grid[new_i][new_j] == 0 || grid[new_i][new_j] == 2))                dfs(grid, visit, new_i, new_j);        &#125;        if (j &gt; 0) &#123;            int new_i = i;            int new_j = j - 1;            if (visit[new_i][new_j] == false &amp;&amp; (grid[new_i][new_j] == 0 || grid[new_i][new_j] == 2))                dfs(grid, visit, new_i, new_j);        &#125;        if (i &lt; grid.size() - 1) &#123;            int new_i = i + 1;            int new_j = j;            if (visit[new_i][new_j] == false &amp;&amp; (grid[new_i][new_j] == 0 || grid[new_i][new_j] == 2))                dfs(grid, visit, new_i, new_j);        &#125;        if (j &lt; grid[0].size() - 1) &#123;            int new_i = i;            int new_j = j + 1;            if (visit[new_i][new_j] == false &amp;&amp; (grid[new_i][new_j] == 0 || grid[new_i][new_j] == 2))                dfs(grid, visit, new_i, new_j);        &#125;        visit[i][j] = false;    &#125;public:    int uniquePathsIII(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        vector&lt;vector&lt;bool&gt;&gt; visit(grid.size(), vector&lt;bool&gt; (grid[0].size(), false));                int i, j;        for (i = 0; i &lt; grid.size(); i++) &#123;            for (j = 0; j &lt; grid[0].size(); j++) &#123;                if (grid[i][j] == 1) &#123;                    goto find_begin_square;                &#125;            &#125;        &#125;        find_begin_square:                        // cout &lt;&lt; &quot;begin : &quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; endl;        dfs(grid, visit, i, j);                return path;    &#125;&#125;;\n时间复杂度: O(4^n)，n为网格数，因为每次要向4个方向走，而且回溯必然是指数级的。\n空间复杂度: O(n)，dfs的最深递归调用层数。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 121","url":"/2019/01/27/LeetCode-weekly-contest-121/","content":"今天放假回家，下午3点半的火车。不过我还是百忙之中抽出时间参加了每周例行的weekly contest。 结果因为回家不够专注，效果很差，只做出一道签到题。第二题TLE(结果把一个变量改成引用就可以了，也算是吸取了教训，能用引用就用引用)，第3题没有足够的时间完成了(直到下午坐上火车，心无旁骛地终于独立完成了第三题。其实思路从一开始就是对的，只不过没有时间调试细节)。第四题干脆连题干都没有时间看完。\n 984. String Without AAA or BBB\nIntution: 由于不能出现连续的a或b，我们可以试着直接构造出符合要求的字符串。多的字符出现2次，即插入一个少的字符，当剩余的2个字符一样多的时候，就一个出现一次就可以了。\nclass Solution &#123;public:    string strWithout3a3b(int A, int B) &#123;        string result;        char large, small;        int bigger, smaller;        if (A &gt; B) &#123;            large = &#x27;a&#x27;;            small = &#x27;b&#x27;;            bigger = A;            smaller = B;        &#125; else &#123;            large = &#x27;b&#x27;;            small = &#x27;a&#x27;;            bigger = B;            smaller = A;        &#125;        for (; bigger &gt; 0 &amp;&amp; smaller &gt; 0 &amp;&amp; bigger &gt; smaller; bigger-=2, smaller--) &#123;            result.push_back(large);            result.push_back(large);            result.push_back(small);        &#125;        for (; bigger &gt; 0 &amp;&amp; smaller &gt; 0; bigger--, smaller--) &#123;            result.push_back(large);            result.push_back(small);        &#125;        while (bigger &gt; 0) &#123;            result.push_back(large);            bigger--;        &#125;        while (smaller &gt; 0) &#123;            result.push_back(small);            small--;        &#125;                return result;    &#125;&#125;;\n 981. Time Based Key-Value Store\nIntution:\n使用hashmap存储&lt;key, vector&lt;pair&lt;int, string&gt;&gt; value&gt;,\n每次查找到key对应的vector后，针对pair的第一个值使用二分查找upper_bound timestamp.\n注意：用引用，千万不要用普通变量存储hashmap[key]。\nclass TimeMap &#123;private:    /** Intution:        使用hashmap存储&lt;key, vector&lt;pair&lt;int, string&gt;&gt; value&gt;,        每次查找到key对应的vector后，针对pair的第一个值使用二分查找upper_bound timestamp    */    unordered_map&lt;string, vector&lt;pair&lt;int, string&gt;&gt;&gt; hashmap;    class Cmp &#123;        public:        bool operator() (pair&lt;int, string&gt; a, pair&lt;int, string&gt; b) &#123;            return a.first &lt; b.first;        &#125;    &#125;;public:    /** Initialize your data structure here. */    TimeMap() &#123;            &#125;        void set(string key, string value, int timestamp) &#123;        hashmap[key].push_back(&#123;timestamp, value&#125;);    &#125;        string get(string key, int timestamp) &#123;        auto&amp; values = hashmap[key];    // 注意：用引用，千万不要用普通变量存储        if (values.size() == 0) return &quot;&quot;;        auto val = upper_bound(values.begin(), values.end(), make_pair(timestamp, &quot;&quot;), Cmp());        if (val == values.begin()) return &quot;&quot;;        return (--val)-&gt;second;    &#125;&#125;;/** * Your TimeMap object will be instantiated and called as such: * TimeMap* obj = new TimeMap(); * obj-&gt;set(key,value,timestamp); * string param_2 = obj-&gt;get(key,timestamp); */\n 983. Minimum Cost For Tickets\nIntution: 最优化问题，最优解依赖子问题的解，首先想到dp。\n最优解结构：f(x) = min(f(x-1) + cost[0], f(x-7) + cost[1], f(x-30) + cost[2]),\n其中，f(x)表示天数为x时的最小花费，由于x可能不存在于days中，此时，f(x)表示比x恰好大的天的最小花费。\nclass Solution &#123;    int getDp(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; dp, int day) &#123;        auto result = upper_bound(days.begin(), days.end(), day);        // cout &lt;&lt; day &lt;&lt; &quot; &quot; &lt;&lt; int(result - days.begin()) &lt;&lt; &quot; &quot; &lt;&lt; endl;        if (result == days.begin())            return 0;        else &#123;            // cout &lt;&lt; &quot;return : &quot; &lt;&lt; *(result-1) &lt;&lt; endl;            // cout &lt;&lt; &quot;return : &quot; &lt;&lt; dp[0] &lt;&lt; endl;            return dp[result - days.begin() - 1];        &#125;    &#125;public:    int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123;        vector&lt;int&gt; dp(days.size(), 0);        for (int i = 0; i &lt; days.size(); i++) &#123;            int day = days[i];            dp[i] = getDp(days, dp, day - 1) + costs[0];            dp[i] = min(dp[i], getDp(days, dp, day - 7) + costs[1]);            dp[i] = min(dp[i], getDp(days, dp, day - 30) + costs[2]);            // cout &lt;&lt; &quot;dp : &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; dp[i] &lt;&lt; endl;        &#125;                return dp[dp.size() - 1];    &#125;&#125;;\n 983. Minimum Cost For Tickets\n暴力方法是3层循环枚举所有的组合，判断是否符合按位与为0的条件。时间复杂度: O(n^3)。\n结果TLE。\n可以想到的优化:\n\n先求出所有 A[i] &amp; A[j]的组合，再根据缺少的0位搜索构造出可能的A[k], 寻找A[k]是否存在。\n时间复杂度：O(n^2 * 2^16)\n结果TLE。\n\nclass Solution &#123;    int search(unordered_map&lt;int, int&gt;&amp; hashtable, vector&lt;int&gt;&amp; add, int level, int base) &#123;        if (level == add.size()) return hashtable[base];        return search(hashtable, add, level + 1, base) + search(hashtable, add, level + 1, base + add[level]);    &#125;    int getComplementCount(unordered_map&lt;int, int&gt;&amp; hashtable, int a) &#123;        vector&lt;int&gt; add;        for (int i = 0; i &lt; 16; i++) &#123;            if (!((a &gt;&gt; i) &amp; 1)) &#123;                // 如果第i位为0                add.push_back(1 &lt;&lt; i);            &#125;        &#125;                // cout &lt;&lt; a &lt;&lt; &quot; : &quot;;        // for (auto i: add) &#123;        //     cout &lt;&lt; i &lt;&lt; &quot; &quot;;        // &#125;        // cout &lt;&lt; endl;        return search(hashtable, add, 0, 0);    &#125;public:    int countTriplets(vector&lt;int&gt;&amp; A) &#123;        unordered_map&lt;int, int&gt; hashtable;        for (auto a: A) &#123;            hashtable[a]++;        &#125;        int result = 0;        for (auto a: A) &#123;            for (auto b: A) &#123;                result += getComplementCount(hashtable, a &amp; b);            &#125;        &#125;                return result;    &#125;&#125;;\n\n每次寻找到可能的A[k]后保存起来，下次遇到相等的A[i] &amp; A[j]就可以直接用了。\n时间复杂度：O(n^3)。\n结果AC。因为A[i] &amp; A[j]重复的很多，所以实际运行时，比较接近 Omega(n^2)。\n\nclass Solution &#123;public:    int countTriplets(vector&lt;int&gt;&amp; A) &#123;        unordered_map&lt;int, int&gt; hashtable;        int result = 0;        for (auto a: A) &#123;            for (auto b: A) &#123;                int x = a &amp; b;                if (hashtable.find(x) == hashtable.end()) &#123;                    for (auto c: A) &#123;                        if ((c &amp; x) == 0)                            hashtable[x]++;                    &#125;                &#125;                result += hashtable[x];            &#125;        &#125;                return result;    &#125;&#125;;\n 后记\n结束该contest后的第二天，我在家里参加了Google的1st Phone Interview。由于保密协议的限制，并不能分享具体的题目。\n只能再次分享一些面试的体会吧。面试题目整体不难，比较接近Medium。但45分钟要解决2道题目，从思考到讨论再到编码，而且电话面试的通话质量也很差，真的是很难的一件事情。最后结果第二题最后急匆匆写完了，也没有做到bug-free就匆忙结束了已经超时的面试。我现在在LeetCode上做算法题也有170道了，其中一半以上是Medium+难度的。但仍然不足以应对Google的面试。排除掉客观原因，我失败的主观原因有：\n\n解决问题和编码的速度不够快，没有形成基本的模式(也可以说是套路);\n对面试的期待比较高，造成一定程度的紧张；\n电话面试经验不足，更喜欢On site面试。\n\n我暂时想到的应对策略：\n\n以后每次做题都计时，量化 思考、编码、测试、debug的时间\n总结算法题的类型和套路，每种套路的代码模版要非常熟练\n以兴趣为导向（我喜欢读书），多读读和编程/算法/面试相关的书籍 充实自己\n提高交流能力，多多练习，可以用语言、文字、图 清楚地表达自己的想法\n\n加油Forest！\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 122","url":"/2019/02/04/LeetCode-weekly-contest-122/","content":"由于宅在家里过节，竟然忘记了每天是星期几，只知道农历腊月几日。今天才发现已经到了周一了，错过了每周一度的weekly contest。在此除夕之夜，和家人一起看春晚之前，Forest携全家人一起祝大家新年快乐！快些刷完这4道比赛题目，好安心吃年夜饭。\n由于比赛不能用官方的Notes, 写在blog上还是蛮方便的一种替代品。\n 985. Sum of Even Numbers After Queries\n第一题直接模拟即可。每个query有2个动作：\n\nadd val to A[index];\nsum the even values of A.\n\n模拟的时间复杂度为：\nO(K * N)\n其中，N为数组长度，K为queries长度。\n因为题目中K，N都不大于10000，所以总的规模在10^8 &lt; 10^9, 是可以AC的。\nclass Solution &#123;public:    vector&lt;int&gt; sumEvenAfterQueries(vector&lt;int&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        vector&lt;int&gt; results;        for (const vector&lt;int&gt;&amp; query : queries) &#123;            A[query[1]] += query[0];            int total = 0;            for (int a : A) &#123;                if (a % 2 == 0) total += a;            &#125;            results.push_back(total);        &#125;                return results;    &#125;&#125;;\n不过Solution中给到一种复杂度为O(N+K)的。\n思想是：每次计算sum时，我们可以利用上一个query的结果。\n如果add后，\nA中数值从奇数变为偶数了，sum = last_sum + 新偶数；\nif 偶数 -&gt; 奇数，sum = last_sum - 旧偶数;\nif 偶数 -&gt; 偶数，sum = last_sum + 新偶数 - 旧偶数;\nif 奇数 -&gt; 奇数，sum = last_sum.\nclass Solution &#123;public:    vector&lt;int&gt; sumEvenAfterQueries(vector&lt;int&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        vector&lt;int&gt; results;        int total = 0;        for (int a : A) &#123;            if (a % 2 == 0) total += a;        &#125;                for (const vector&lt;int&gt;&amp; query : queries) &#123;            if (A[query[1]] % 2 == 0) total -= A[query[1]];            A[query[1]] += query[0];            if (A[query[1]] % 2 == 0) total += A[query[1]];            results.push_back(total);        &#125;                return results;    &#125;&#125;;\n 988. Smallest String Starting From Leaf\n寻找二叉树中从叶子到根的最小字符串。\nIntuition：递归左右子树，将根结点与更小的结合。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    string smallestFromLeaf(TreeNode* root) &#123;        if (!root) return &quot;&quot;;        string left = smallestFromLeaf(root-&gt;left);        string right = smallestFromLeaf(root-&gt;right);        if (!left.empty() &amp;&amp; !right.empty()) &#123;            if (left &lt; right) &#123;                left.push_back(&#x27;a&#x27; + root-&gt;val);                return left;            &#125; else &#123;                right.push_back(&#x27;a&#x27; + root-&gt;val);                return right;            &#125;        &#125; else if (!left.empty()) &#123;            left.push_back(&#x27;a&#x27; + root-&gt;val);            return left;        &#125; else &#123;            right.push_back(&#x27;a&#x27; + root-&gt;val);            return right;        &#125;                &#125;&#125;;\n 986. Interval List Intersections\n求2个有序区间列表的并集列表。\nIntuition：2个指针遍历2个列表，根据不同重合程度，选择并集和指针移动。\n/** * Definition for an interval. * struct Interval &#123; *     int start; *     int end; *     Interval() : start(0), end(0) &#123;&#125; *     Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;Interval&gt; intervalIntersection(vector&lt;Interval&gt;&amp; A, vector&lt;Interval&gt;&amp; B) &#123;        vector&lt;Interval&gt; results;                auto a = A.begin();        auto b = B.begin();                while (a != A.end() &amp;&amp; b != B.end()) &#123;            if (a-&gt;end &lt; b-&gt;start) &#123;                a++;            &#125; else if (b-&gt;end &lt; a-&gt;start) &#123;                b++;            &#125; else if (a-&gt;start &lt; b-&gt;start) &#123;                if (a-&gt;end &lt; b-&gt;end) &#123;                    Interval interval(b-&gt;start, a-&gt;end);                    results.push_back(interval);                    a++;                &#125; else &#123;                    results.push_back(*b);                    b++;                &#125;            &#125; else if (b-&gt;start &lt; a-&gt;start) &#123;                if (b-&gt;end &lt; a-&gt;end) &#123;                    Interval interval(a-&gt;start, b-&gt;end);                    results.push_back(interval);                    b++;                &#125; else &#123;                    results.push_back(*a);                    a++;                &#125;            &#125; else &#123;                if (a-&gt;end &lt;= b-&gt;end) &#123;                    Interval interval(b-&gt;start, a-&gt;end);                    results.push_back(interval);                    a++;                &#125; else &#123;                    Interval interval(a-&gt;start, b-&gt;end);                    results.push_back(interval);                    b++;                &#125;                // cout &lt;&lt; &quot;(&quot; &lt;&lt; a-&gt;start &lt;&lt; &quot;, &quot; &lt;&lt; a-&gt;end &lt;&lt; &quot;), &quot;;                // cout &lt;&lt; &quot;(&quot; &lt;&lt; b-&gt;start &lt;&lt; &quot;, &quot; &lt;&lt; b-&gt;end &lt;&lt; &quot;)&quot; &lt;&lt; endl;            &#125;        &#125;                return results;    &#125;&#125;;\n 987. Vertical Order Traversal of a Binary Tree\nIntution: 建立一个dequeue&lt;treemap&gt;, 对于每一颗子树，讲root插入当前的treemap中（使用treemap以保证同一X层内的顺序），同时递归调用左右子树，并更新当前的treemap。\n最后再转化为vector&lt;vector&gt;。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    deque&lt;multiset&lt;pair&lt;int, int&gt;&gt;&gt; results;    void recurse(TreeNode* root, deque&lt;multiset&lt;pair&lt;int, int&gt;&gt;&gt;::iterator current, int level) &#123;        if (!root) return;        if (current == results.end()) &#123;            multiset&lt;pair&lt;int, int&gt;&gt; s;            results.push_back(s);            current = results.end() - 1;        &#125;        if (current + 1 == results.begin()) &#123;            multiset&lt;pair&lt;int, int&gt;&gt; s;            results.push_front(s);            current = results.begin();        &#125;        current-&gt;insert(&#123;level, root-&gt;val&#125;);        recurse(root-&gt;left, current - 1, level + 1);        recurse(root-&gt;right, current + 1, level + 1);    &#125;public:    vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) &#123;        recurse(root, results.begin(), 0);                vector&lt;vector&lt;int&gt;&gt; ret;        for (const multiset&lt;pair&lt;int, int&gt;&gt;&amp; s : results) &#123;            vector&lt;int&gt; v;            for (const pair&lt;int, int&gt; num : s) &#123;                v.push_back(num.second);            &#125;            ret.push_back(v);        &#125;                return ret;    &#125;&#125;;\n 后记\nGoogle的电话面试的结果已经出来了。很遗憾Forest Fail掉了，没有进入下一轮面试。虽然是在情理之中的事情，但还是挺伤心的。比较了同行的实力后，我发现自己还是LeetCode刷的不够多。年初定目标竟然只定了300道，看现在程序员竞争的灿烈程度，300道估计是远远不够的。毕竟自己已经练习了有200道了，实习生的面试都应对不了。经过这次失败，我重新审视了自己的实力，决定将今年的刷题计划提高到900道，或者是把所有的可刷的题目都刷完。因为有Premium才能刷的题目，所以现在不知道能刷的有多少。把该刷的刷完，我也会买个大会员，进一步刷题的。\n我告诉快手师兄C是我的主语言，然后他问了我C11的新特性“move的语义”是什么？然后我就gg了。自己对C掌握的只是皮毛而已，还好意思说会C。春节假期一定要把《C++ Primer》看完，否则节后都不好意思找快手师兄啦！\n任重而道远啊！加油，Forest！\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 123","url":"/2019/02/10/LeetCode-weekly-contest-123/","content":"本次比赛是春节后的第一次。\n\nAdd to Array-Form of Integer\n\n思路：模拟笔算过程，一位一位地相加。（Solution中有个很形象的名字：Schoolbook Addition）\n时间复杂度：O(max(N, M)), 其中N, M分别表示A，K的长度。\n空间复杂度：O(M-N), 即deque所用的空间。\nclass Solution &#123;public:    vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; A, int K) &#123;        int index = A.size() - 1;        while (K &gt; 0 &amp;&amp; index &gt;= 0) &#123;            int last_digit = K % 10;            K /= 10;            A[index] += last_digit;            int carry = A[index] / 10;            K += carry;            A[index] %= 10;            index--;        &#125;                deque&lt;int&gt; result;        while (K &gt; 0) &#123;            result.push_front(K % 10);            K /= 10;        &#125;                A.insert(A.begin(), result.begin(), result.end());                return A;    &#125;&#125;;\n 990. Satisfiability of Equality Equations\n思路：使用并查集存储相等的关系，再遍历所有的不等关系是否在不同的集之间。\n时间复杂度：O(N),\n空间复杂度：O（N）。\nclass Solution &#123;    array&lt;char, 26&gt; parents;    void union_variables(char a, char b) &#123;        char a_parent = find_root(a);        char b_parent = find_root(b);        parents[a_parent - &#x27;a&#x27;] = b_parent;    &#125;    char find_root(char a) &#123;        while (parents[a - &#x27;a&#x27;] != a)            a = parents[a - &#x27;a&#x27;];        return a;    &#125;public:    Solution() &#123;        for (int i = 0; i &lt; 26; i++) &#123;            parents[i] = &#x27;a&#x27; + i;        &#125;    &#125;    bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123;        for(const string &amp; s : equations) &#123;            if (s[1] == &#x27;=&#x27;) &#123;                union_variables(s[0], s[3]);            &#125;        &#125;                for(const string &amp; s : equations) &#123;            if (s[1] == &#x27;!&#x27;) &#123;                if (find_root(s[0]) == find_root(s[3]))                    return false;            &#125;        &#125;                return true;    &#125;&#125;;\n 991. Broken Calculator\n思路：一旦X大于Y，就只能通过减一的操作来达到Y。\n如果X小于Y，则可以DOUBLE，也可以Decrement。\n这时候如何选择呢？可以发现Double, Decrement, Decrement 和 Decrement, Double得到的结果相同。\n这样，我们可以看出，\n如果Y是奇数，则必须Double, Decrement才能得到。\n如果Y是偶数，则必须Double才能得到(Decrement的操作次数更多)。\n时间复杂度：O(log Y);\n空间复杂度：O(log Y)，因为递归。\nclass Solution &#123;public:    int brokenCalc(int X, int Y) &#123;        if (X == Y) return 0;        if (X &gt; Y) return X - Y;        if (Y % 2 == 1) return brokenCalc(X, Y + 1) + 1;        else return brokenCalc(X, Y / 2) + 1;    &#125;&#125;;\n 992. Subarrays with K Different Integers\n最后留给最后一道题的时间是40min，争取把这道Hard题目解决。\n思路：根据问题的时间复杂度O(n ^ 2)（我们至少需要遍历一遍所有的subarray）可知，解法的时间复杂度至少为O(n^2)。\n用2层循环遍历所有的subarray, 如何快速地求出每个subarray的distinct number呢。\n可以使用动态规划来缩减复杂度。\n用每个子数组的distinct number, 我们用hashmap&lt;int, int&gt;存储，key表示distict number, value 表示该数的频数。\n设f(i, j)为子数组[i, j]的distinct number对应的hashmap,\n则f(i, j) =\nf(i, j-1).insert(A[j])\nor\nf(i+1, j).delete(A[i])\nnew(A[i]), if i == j.\n自底而上的构造hashmap的话，外层循环 new, 内层循环 delete。\n结果TLE了。\n想想有没有O(n log n)的解法。\nclass Solution &#123;public:    int subarraysWithKDistinct(vector&lt;int&gt;&amp; A, int K) &#123;        unordered_set&lt;int&gt; frequency; // 如果没有delete的操作，使用unordered_set也是可以的        int result = 0;        for (int i = 0; i &lt; A.size(); i++) &#123;            for (int j = i; j &lt; A.size(); j++) &#123;                if (i == j) &#123;                    frequency.clear();                &#125;                frequency.insert(A[j]);                if (K == frequency.size()) result++;                if (K &lt; frequency.size()) break;            &#125;        &#125;                return  result;    &#125;&#125;;\n最后还是没有想到进一步优化的算法。看了Solution，惊觉竟然有O(N)的解法。还是自己对subarray distinct number数量的性质的观察不够细致呀。\n首先，固定右边界的话，对于2个subarray (i1, j), (i2, j), 其中i1 &lt; i2，则 f(i1, j) &lt;= f(i2, j)。\n所以，对于每个右边界j，符合条件的subarray 的左边界在一定范围内，可以写作[left1, left2].\n其次，我们增长右边界，如果distinct number的数量超过K了，我们需要增长left1, left2。也即left1, left2是随着右边界单调递增的。\nclass Solution &#123;    struct Window &#123;        unordered_map&lt;int, int&gt; hashmap;        int size = 0;        void add(int value) &#123;            hashmap[value]++;            if (hashmap[value] == 1) &#123;                size++;            &#125;        &#125;         void remove(int value) &#123;            hashmap[value]--;            if (hashmap[value] == 0) &#123;                size--;            &#125;        &#125;    &#125;;public:    int subarraysWithKDistinct(vector&lt;int&gt;&amp; A, int K) &#123;        Window w1, w2;        int left1 = 0, left2 = 0, right = 0;        int result = 0;        while (right &lt; A.size()) &#123;            int value = A[right];                        w1.add(value);            w2.add(value);                        while (w1.size &gt; K) &#123;                w1.remove(A[left1++]);            &#125;            while (w2.size &gt;= K) &#123;                w2.remove(A[left2++]);            &#125;                                    result += left2 - left1;            right++;        &#125;                return result;    &#125;&#125;;\n 后记\n今天是在家里呆的最后3天，果然寒假回家都虚度光阴了。还是呆在北京学校里，和志同道合的同学在一起，学习的劲头更高。竞争的压力也更大，怪不得大家都向往更好的环境，更优秀的朋友。\n\n加油，Forest！\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weeekly contest 125","url":"/2019/02/24/LeetCode-weekly-contest-125/","content":"本周末真是忙炸，为自己的拖延和懒惰付出了代价。事情都堆在了一起，周日的deadline超级多。早上10点和老板开会，商量 怎么出本科计算机组成原理补考试题 的事儿。开完会回到实验室，contest已经开始了。在短暂犹豫是否按计划参加contest，还是先完成出补考题的任务后，我开始了本周的weekly contest。也算是自己这2个月来坚持的为数不多的事情，继续坚持下去对我来说不仅是提高算法能力的事情了，更是对掌控自己生活的信心的一种极大鼓舞。\n\n本周的weekly contest相对还说比较简单，虽然迟到了10min，但仍然提前30min完成4道题目。尤其是第4题，虽然值8分，难度是hard，但也很快解出来了。我认为难度最多Medium。\n结果：\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (4)\nQ3 (6)\nQ4 (8)\n\n\n\n\n284 / 4238\nYoungForest\n22\n1:08:40\n0:18:40\n0:31:07  WA(1)\n0:39:39\n1:03:40\n\n\n\n 997. Find the Town Judge\n使用2个hashmap，分别记录每个person trust的人数和被多少人trust。\nclass Solution &#123;public:    int findJudge(int N, vector&lt;vector&lt;int&gt;&gt;&amp; trust) &#123;        unordered_map&lt;int, int&gt; vote;        unordered_map&lt;int, int&gt; untrust;        for (vector&lt;int&gt; &amp; p : trust) &#123;            vote[p[1]]++;            untrust[p[0]]++;        &#125;                for (int i = 1; i &lt;= N; i++) &#123;            if (vote[i] == N - 1 &amp;&amp; untrust[i] == 0) return i;        &#125;                return -1;    &#125;&#125;;\n 999. Available Captures for Rook\n完全符合Easy的难度，直接模拟rook(行为应该类似中国象棋里的 车)向4个方向一步一步走就可以了。\n用discuss中的一个道友的话来说，就是 search and capture.\nclass Solution &#123;public:    int numRookCaptures(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123;        int rock_i, rock_j;        for (int i = 0; i &lt; board.size(); i++) &#123;            for (int j = 0; j &lt; board[0].size(); j++) &#123;                if (board[i][j] == &#x27;R&#x27;) &#123;                    rock_i = i;                    rock_j = j;                    break;                &#125;            &#125;        &#125;        vector&lt;int&gt; di = &#123;0, 1, 0, -1&#125;;        vector&lt;int&gt; dj = &#123;1, 0, -1, 0&#125;;        int result = 0;        for (int k = 0; k &lt; di.size(); k++) &#123;            for (int i = rock_i, j = rock_j; i &gt;= 0 &amp;&amp; i &lt; board.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; board[0].size(); i += di[k], j += dj[k]) &#123;                char current = board[i][j];                if (current == &#x27;R&#x27;) continue;                else if (current == &#x27;.&#x27;) continue;                else if (current == &#x27;p&#x27;) &#123;                    result++;                    break;                &#125;                else if (current == &#x27;B&#x27;) &#123;                    break;                &#125;                else return -1;             &#125;        &#125;                return result;    &#125;&#125;;\n 998. Maximum Binary Tree II\n本题的关键是理解所谓的Maximum Binary Tree是什么意思。\n它本身的定义就是递归定义的，给定一个数组A，A中最大值为根节点，最大值左侧的子数组为左子树，右侧的子数组为右子树。\n本题给定一个Maximun Binary Tree, 但不告诉你原数组是什么，再给一个数，求将此数追加到元素组后构造而成的Maximum Binary Tree。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* insertIntoMaxTree(TreeNode* root, int val) &#123;        if (!root) return new TreeNode(val);        if (val &gt; root-&gt;val) &#123;            TreeNode *append = new TreeNode(val);            append-&gt;left = root;            return append;        &#125; else &#123;            root-&gt;right = insertIntoMaxTree(root-&gt;right, val);            return root;        &#125;    &#125;&#125;;\n 1001. Grid Illumination\n哇！LeetCode的题号超过1000啦。虽然总的题目数还不足1k，但超过也是指日可待的事情。\n算法题现在有949道，我只做了210道。加油啊，Forest!\n本题的想法很直接，了解题意之后，直接搜索即可。问题的关键在于搜索的效率。\n通过题目的数据规模:\n\n1 &lt;= N &lt;= 10^9\n0 &lt;= lamps.length &lt;= 20000\n0 &lt;= queries.length &lt;= 20000\nlamps[i].length == queries[i].length == 2\n\n可知，搜索最好是用hashtable来实现，效率最高。然而，C++ 默认的pair不是hashable的，虽然可以通过自己实现hashable pair还进一步实现效率优化。但在这里我偷了个懒，直接用了set，而不是unordered_set。仍然AC啦。好开心，提前30min完成比赛，排名也再次进入前300了。再接再厉，保持排名在300以内。\nclass Solution &#123;public:    vector&lt;int&gt; gridIllumination(int N, vector&lt;vector&lt;int&gt;&gt;&amp; lamps, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        set&lt;pair&lt;int, int&gt;&gt; lamps_on;        unordered_map&lt;int, int&gt; lamps_x; // x, count        unordered_map&lt;int, int&gt; lamps_y; // y, count        unordered_map&lt;int, int&gt; lamps_x_sub_y; // x - y, count        unordered_map&lt;int, int&gt; lamps_x_add_y; // x + y, count        for (vector&lt;int&gt;&amp; lamp : lamps) &#123;            lamps_on.insert(&#123;lamp[0], lamp[1]&#125;);            lamps_x[lamp[0]]++;            lamps_y[lamp[1]]++;            lamps_x_sub_y[lamp[0] - lamp[1]]++;            lamps_x_add_y[lamp[0] + lamp[1]]++;        &#125;                vector&lt;int&gt; result;        vector&lt;int&gt; di = &#123;-1, 0, 1&#125;;        vector&lt;int&gt; dj = &#123;-1, 0, 1&#125;;        for (vector&lt;int&gt;&amp; q : queries) &#123;            if (lamps_x[q[0]] &gt; 0 || lamps_y[q[1]] &gt; 0 || lamps_x_sub_y[q[0] - q[1]] &gt; 0 || lamps_x_add_y[q[0] + q[1]] &gt; 0)                result.push_back(1);            else                result.push_back(0);                        for (int i : di) &#123;                for (int j : dj) &#123;                    int x = q[0] + i;                    int y = q[1] + j;                    if (lamps_on.find(&#123;x, y&#125;) != lamps_on.end()) &#123;                        lamps_on.erase(&#123;x, y&#125;);                        lamps_x[x]--;                        lamps_y[y]--;                        lamps_x_sub_y[x - y]--;                        lamps_x_add_y[x + y]--;                    &#125;                &#125;            &#125;        &#125;                return result;    &#125;&#125;;\n时间复杂度：O(max(M log N, N log N)), N = lamps.size(), M = queries.size(). 如果使用hashable pair的话，复杂度可进一步降为O(max(N, M)).\n空间复杂度：O(N)\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 124","url":"/2019/02/17/LeetCode-weekly-contest-124/","content":"今天是开工后第一次参加LeetCode weekly contest，共作出3道题目，排名为772 / 4174。看着每次排名从200+落到了700+，心情蛮失落的。我认为排名掉落的原因有：1. 排名为200是状态和运气都比较好的情况，之前大多数时候也是700左右。2. 第3题虽然为Hard，最后提交TLE了。但我认为如果再多给半个小时就可以AC了。之所以后面时间不够了，与第2、4题花了比较多时间调试直接相关。还是很多实现不够熟悉，比如bfs, backtracking，不能灵活地默写出来。甚至在做第4题的时候，还需要现场查C++的API，对语言的熟悉程度也不够。\n 993. Cousins in Binary Tree\n在一棵二叉树上找表兄弟。所谓“表兄弟”的定义为，2个节点在同一层，但父节点不同。\nIntuition: 递归地找节点的父亲和层数，比较2个节点的父亲和层数是否相同。也即，dfs遍历2遍二叉树。\n时间复杂度：O(N),\n空间复杂度: 平均O(Log N)，最差O(N), 因为需要递归栈。\n由于春节假期期间看了LeetCode上的递归专题Introduction to Algorithms - Recursion I。10min搞定该签到题。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    // parent, depth    pair&lt;int, int&gt; findNode(TreeNode* root, int value, int parent, int depth) &#123;        if (!root) return &#123;0, depth + 1&#125;;        if (root-&gt;val == value) return &#123;parent, depth + 1&#125;;        auto left = findNode(root-&gt;left, value, root-&gt;val, depth + 1);        auto right = findNode(root-&gt;right, value, root-&gt;val, depth + 1);        if (left.first != 0) return left;        if (right.first != 0) return right;        return &#123;0, depth + 1&#125;;    &#125;public:    bool isCousins(TreeNode* root, int x, int y) &#123;        auto xNode = findNode(root, x, 0, 0);        auto yNode = findNode(root, y, 0, 0);        if (xNode.first != yNode.first &amp;&amp; xNode.second == yNode.second)            return true;        return false;    &#125;&#125;;\n 994. Rotting Oranges\n给定一个网格，每个格子有3种状态\n\n什么也没有\n好橘子\n坏橘子\n每天坏橘子会将临近的好橘子变成坏橘子，求所有橘子变坏的天数。如果无穷大的话，返回-1.\n\nIntuition：\n\n从每个坏橘子开始做bfs，一次感染好橘子，并更新好橘子坏掉的天数。因为要计算好橘子距离坏橘子的最短距离，所以一定要用bfs。\n检查所有好橘子坏掉的天数，如果有无穷大的橘子，返回-1.\n\nclass Solution &#123;    void bfs(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, vector&lt;vector&lt;int&gt;&gt; &amp;minDays, int depth) &#123;        vector&lt;int&gt; di = &#123;1, 0, -1, 0&#125;;        vector&lt;int&gt; dj = &#123;0, 1, 0, -1&#125;;                queue&lt;tuple&lt;int, int, int&gt;&gt; q;        q.push(&#123;i ,j, depth&#125;);                while (!q.empty()) &#123;            tuple&lt;int, int, int&gt; current = q.front();            q.pop();                        i = get&lt;0&gt;(current);            j = get&lt;1&gt;(current);            depth = get&lt;2&gt;(current);                        visited[i][j] = true;            minDays[i][j] = min(minDays[i][j], depth);                        for (int k = 0; k &lt; di.size(); k++) &#123;                int new_i = i + di[k];                int new_j = j + dj[k];                if (new_i &lt; grid.size() &amp;&amp; new_i &gt;= 0 &amp;&amp; new_j &lt; grid[0].size() &amp;&amp; new_j &gt;= 0 &amp;&amp; grid[new_i][new_j] == 1 &amp;&amp; visited[new_i][new_j] == false)                    q.push(&#123;new_i, new_j, depth + 1&#125;);            &#125;        &#125;            &#125;public:    int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        vector&lt;vector&lt;int&gt;&gt; minDays(grid.size(), vector&lt;int&gt; (grid[0].size(), numeric_limits&lt;int&gt;::max()));        for (int i = 0; i &lt; grid.size(); ++i) &#123;            for (int j = 0; j &lt; grid[i].size(); ++j) &#123;                if (grid[i][j] != 1)                    minDays[i][j] = 0;            &#125;        &#125;                for (int i = 0; i &lt; grid.size(); ++i) &#123;            for (int j = 0; j &lt; grid[i].size(); ++j) &#123;                if (grid[i][j] == 2) &#123;                    vector&lt;vector&lt;bool&gt;&gt; visited(grid.size(), vector&lt;bool&gt; (grid[0].size(), false));                    bfs(i, j, grid, visited, minDays, 0);                &#125;            &#125;        &#125;                int result = 0;        for (int i = 0; i &lt; grid.size(); ++i) &#123;            for (int j = 0; j &lt; grid[i].size(); ++j) &#123;                result = max(result, minDays[i][j]);            &#125;        &#125;                return result == numeric_limits&lt;int&gt;::max() ? -1 : result;    &#125;&#125;;\nSolution中也是使用dfs的，不过trick的一点是，通过记录每个节点的深度，在搜索开始时把所有坏橘子加入队列，使得每个节点只需要遍历一遍。更清晰，时间复杂度也更低。比我写的代码要好。\n 995. Minimum Number of K Consecutive Bit Flips\n给定一个数组A，A中值包含0，1这两种状态。给定一个K，提供操作flip，可以将A中长度为K的子数组翻转。\n求将A全部翻转为1所需的最小flip次数。\n如果无法全部翻转为1，则返回-1.\nIntution:\n如果要最后都变为1，如果第一位是0的话，必须对从第一位开始的子数组从事flip操作。\n这样想下去，必须从头依次翻转所有为0的子数组，如果最后K位中仍然有0，则无法全部翻转。\n这其实是一种贪心(Greedy)的算法。\n时间复杂度：O(N * K), 结果超时。\n空间复杂度：O(1).\nclass Solution &#123;public:    int minKBitFlips(vector&lt;int&gt;&amp; A, int K) &#123;        int result = 0;        int i;        for (i = 0; i &lt; A.size(); i++) &#123;            if (A[i] == 0) &#123;                if (i + K &gt; A.size()) &#123;                    break;                &#125;                // cout &lt;&lt; &quot;flip A: &quot; &lt;&lt; i &lt;&lt; endl;                for (int j = 0; j &lt; K; j++) &#123;                    if (A[i + j] == 0) &#123;                        A[i + j] = 1;                    &#125; else &#123;                        A[i + j] = 0;                    &#125;                &#125;                result++;            &#125;        &#125;        if (i &lt; A.size())            return -1;        return result;    &#125;&#125;;\n其实，仔细想想，我们并不需要实际进行翻转操作，只需要记录翻转的次数就可以了。所以时间上*K 其实不是必须的。\n但是，不实际进行翻转的话，怎么确定一个位置上是0需要翻转，还是1需要翻转。\n我们每次记录翻转的结束位置，在此之前的长度为K的子数组是经过flip的，2个flip操作还可以直接抵消。\nclass Solution &#123;public:    int minKBitFlips(vector&lt;int&gt;&amp; A, int K) &#123;        int result = 0;        vector&lt;int&gt; flip(A.size(), 0);        int i;        int zero = 0;   // 初始情况，0该翻转        for (i = 0; i &lt; A.size(); i++) &#123;            zero ^= flip[i];    // 走出结束位置，回退翻转（相当于再次翻转）            if (A[i] == zero) &#123;                if (i + K &gt; A.size()) &#123;                    break;                &#125;                result++;                zero ^= 1;  // 进入开始位置，进行翻转                if (i + K &lt; A.size())                    flip[i + K] ^= 1;   // 标定结束位置            &#125;        &#125;        if (i &lt; A.size())            return -1;        return result;    &#125;&#125;;\n 996. Number of Squareful Arrays\n如果一个数组任意相邻的2个数的和是某个数的平方，则称这个数组为Squareful Array.\n给定一个数组A，求出A的全排列数组中有多少Squareful Arrays。\nIntution:\n使用backtracking，剪枝的条件是最后相邻的2个数之和不是Perfect Square。\nclass Solution &#123;    int count = 0;        bool isPerfectSquare(long double x)     &#123;         // Find floating point value of        // square root of x.       long double sr = sqrt(x);       // If square root is an integer       return ((sr - floor(sr)) == 0);     &#125;         void backtracking(vector&lt;int&gt;&amp; current, multiset&lt;int&gt;&amp; condidates) &#123;        int n = current.size();        if (condidates.size() == 0) &#123;            count++;            return;        &#125;        for (auto i = condidates.begin(); i != condidates.end();) &#123;            int c = *i;            int sum_;            if (n &gt; 0) &#123;                sum_ = current[n - 1] + c;                // cout &lt;&lt; sum_ &lt;&lt; &quot; &quot; &lt;&lt; isPerfectSquare((long double) sum_) &lt;&lt; endl;                if (isPerfectSquare((long double) sum_)) &#123;                    current.push_back(c);                    auto it = condidates.find(c);                    condidates.erase(it);                    backtracking(current, condidates);                    current.pop_back();                    condidates.insert(c);                &#125;            &#125; else &#123;                current.push_back(c);                auto it = condidates.find(c);                condidates.erase(it);                backtracking(current, condidates);                current.pop_back();                condidates.insert(c);            &#125;            i = condidates.upper_bound(c);        &#125;    &#125;public:    int numSquarefulPerms(vector&lt;int&gt;&amp; A) &#123;        // backtracking        // 剪枝条件：相邻的pair和不是平方数        vector&lt;int&gt; current;        multiset&lt;int&gt; condidates;        condidates.insert(A.begin(), A.end());        backtracking(current, condidates);                return count;    &#125;&#125;;\n 后记\n\n我还没有重新进入学习状态，保持学习的习惯。重新进入一种上进的状态是很难的，我要学会珍惜再珍惜，一定不要再次回到安逸的状态。因为我知道，安逸的状态不好，重新进入上进的状态更难。\n每天要有规律地学习和运动，完成新年目标和最初的梦想。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 126","url":"/2019/03/03/LeetCode-weekly-contest-126/","content":"今天试着边做题边录视频，由于场地的限制，无法用麦克风进行讲解，效果差强人意。虽然可以用文字注释进行一些弥补，但丧失了视频传播的最大优势。以后还是以博客为主，传播自己的思想吧。\n尤其是本次只做出2道题目，后2道题目都有尝试，但均失败了。视频效果太差。本身大家如果在B站上看视频的话，都是为了看up主秀的。这次没秀起来，遭遇了滑铁卢，甚是尴尬。不过最后我还是打算把视频放上去。就是这么脸皮厚，不怕丢人，不怕以后被翻黑历史。\n排名也直接飞到1500名开外，这周的ranking怕不是要跌。\n结果：\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (6)\nQ4 (9)\n\n\n\n\n1684 / 4564\nYoungForest\n8\n0:38:19\n0:16:17\n0:33:19  WA(1)\n\n\n\n\n\n 1002. Find Common Characters\n因为录视频的时候把思路都写在开始部分了。就只分析一下复杂度吧。\nTime complexity: O(N), N为A中所有字符串长度之和。\n空间复杂度：O(1), 因为字符被限制在26个小写字母里，否则的话，是和字符数成正比的。\nclass Solution &#123;public:    vector&lt;string&gt; commonChars(vector&lt;string&gt;&amp; A) &#123;        // 用一个vector记录出现的字母，因为只有小写，大小为26，还因为要记录出现的最小次数，所以类型为int即可        vector&lt;int&gt; record(26, numeric_limits&lt;int&gt;::max());        for (string &amp; s: A) &#123;            vector&lt;int&gt; record1String(26, 0);            for (char c : s) &#123;                record1String[c - &#x27;a&#x27;]++;            &#125;            for (int i = 0; i &lt; 26; ++i) &#123;                record[i] = min(record[i], record1String[i]);            &#125;        &#125;                vector&lt;string&gt; result;        for (int i = 0; i &lt; 26; i++) &#123;            result.insert(result.end(), record[i], string(1, char(i + &#x27;a&#x27;)));        &#125;                return result;    &#125;&#125;;\n 1003. Check If Word Is Valid After Substitutions\nTime complexity: O(N ^ 2), 因为find, 构造 nextS的操作是O(N)的，每次while循环S的长度减3, 需要 长度/3 次循环。\nSpace complexity: O(N), 因为构造了新的nextS。不过这个是可以消除的，反复利用原来的S的空间就可以。但是要写多余的代码。\nclass Solution &#123;public:    bool isValid(string S) &#123;        // 首先理解valid string的定义:        // 这个定义的递归的        // 对于任何valid的string，把&quot;abc&quot;插入任何位置的字符串仍为valid        // 初始的valid string只有&quot;abc&quot;        // 所以，判断一个string是否是valid的，我们只需要不断地把&quot;abd&quot;抽掉，如果剩下&quot;abc&quot;，则true，否则false        // 这个过程也可以递归进行                // 递归解法会stack overflow, 换迭代解法        while (true) &#123;            if (S == &quot;abc&quot;) return true;            auto index = S.find(&quot;abc&quot;);            if (index == string::npos) &#123; // 没找到&quot;abc&quot;字串                return false;            &#125; else &#123;                string nextS(S.begin(), S.begin() + index);                nextS.insert(nextS.end(), S.begin() + index + 3, S.end());                S = nextS;            &#125;        &#125;    &#125;&#125;;\n 1004. Max Consecutive Ones III\n看了讨论区，才惊觉要用sliding window。其实，如果对此类问题比较熟悉的话，还是很直觉的想法。这道题也一针见血地指出了我知识的盲区。说实话，我对sliding window(或是 2 pointers)的题目还不足够熟悉。看到这道题，一直在尝试用dp和greedy做。花费很多时间，还没做出来，也不奇怪。\nclass Solution &#123;public:    int longestOnes(vector&lt;int&gt;&amp; A, int K) &#123;        // 知道用sliding window了，题目就很简单了。用指针left, right表示窗口的范围。如果right指向1的话，继续扩充，指向0的话，如果K还有剩余，则扩充。不能扩充的时候，收缩left。        int left = 0, right = 0;        int remain = K;        int result = 0;        while (right &lt; A.size()) &#123;            if (A[right] == 1) right++;            else if (A[right] == 0 &amp;&amp; remain &gt; 0) &#123;                right++;                remain--;            &#125; else if (A[left] == 0) &#123;                left++;                remain++;            &#125; else if (A[left] == 1) &#123;                left++;            &#125; else &#123;                assert(false);            &#125;            result = max(result, right - left);        &#125;                return result;    &#125;&#125;;\n时间复杂度: O(n), 这也是sliding window的特点，只需要左右指针各走一遍就可以了。\n空间复杂度: O(1).\n同样是sliding window, 讨论区的lee215大佬的代码是这样的。\nint longestOnes(vector&lt;int&gt;&amp; A, int K) &#123;    int i = 0, j;    for (j = 0; j &lt; A.size(); ++j) &#123;        if (A[j] == 0) K--;        if (K &lt; 0 &amp;&amp; A[i++] == 0) K++;    &#125;    return j - i;&#125;\n因为我们要找最大的window，所以收缩窗口是没有必要的。所以大佬的代码如此简洁。\n 1000. Minimum Cost to Merge Stones\nLeetCode的第1k道题，果然好难。看别人的Discuss看了有1个小时才理解。\n说实话，DP也是我的一个知识盲区，运气好能做出来，运气不好，就做不出来。就像 花花酱 所说，DP是那种你刷100道，遇到新的还是可能解不出来的类型。\n因为Discuss太难理解了。所以我想自己理解后，博文也要写的尽可能详细才行。\nDP问题有2个关键：\n\n最优解结构\n重叠子问题\n\n设dp[i][j] 表示merge stone[i] ~ stone[j] 所需的最小cost。\n这里的merge表示，把这些堆石头合并到小于K为止，此时即使想要继续merge也无能为力。可以确定的是，一旦i和j固定，merge完剩余的石头堆数是确定的，即为(j - i + 1) % (k - 1)。\n此时，最优解结构为 dp[i][j]=min(dp[i][mid]+dp[mid+1][j])+(∑ki&lt;=k&lt;=jstone[i]if(j−i)dp[i][j] = min(dp[i][mid] + dp[mid+1][j]) + (\\sum_k^{i&lt;=k&lt;=j} stone[i] if (j - i) % (k - 1) == 0), for mid in range(i, j, k-1)dp[i][j]=min(dp[i][mid]+dp[mid+1][j])+(∑ki&lt;=k&lt;=j​stone[i]if(j−i)。\n(j - i) % (k - 1) == 0表示[i, j]的石头堆可以被merge成1，所以一定会执行合并操作，而且合并的花费为所有的石头数。而mid的步长为什么是k呢？因为只有这样dp[i][mid]剩余的石头堆数为1。\n找到最优解结构后，下一步是确定如何bottom-to-top地计算dp[0][n-1]。\n初始化，dp[i][i] = 0, 一堆石头是永远不需要merge的。\n根据最优解结构，我们可以得到计算的顺序下图所示:\n![](/images/leetcode1000 merge stone dp bottom to top computing order.png)\n其中红线表示最外层循环，绿线表示内层循环，黄线表示最优解结构。·\nclass Solution &#123;public:    int mergeStones(vector&lt;int&gt;&amp; stones, int K) &#123;        int N = stones.size();        if ((N - 1) % (K - 1) != 0) return -1;        vector&lt;int&gt; prefix(N);        prefix[0] = stones[0];        for (int i = 1; i != N; ++i) &#123;            prefix[i] = prefix[i-1] + stones[i];        &#125;        vector&lt;vector&lt;int&gt;&gt; dp(N, vector&lt;int&gt;(N, 0));        for (int m = K; m &lt;= N; m++) &#123;            for (int i = 0; i + m &lt;= N; i++) &#123;                int j = i + m - 1;                dp[i][j] = numeric_limits&lt;int&gt;::max();                for (int mid = i; mid &lt; j; mid += K - 1) &#123;                    dp[i][j] = min(dp[i][j], dp[i][mid] + dp[mid+1][j]);                &#125;                if ((j - i) % (K - 1) == 0)                    dp[i][j] += prefix[j] - (i == 0 ? 0 : prefix[i-1]);            &#125;        &#125;                return dp[0][N-1];    &#125;&#125;;\n时间复杂度: O(N^3 / K),\n空间复杂度: O(N^2).\n与该题相似的题目还有：312. Burst Balloons\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 127","url":"/2019/03/10/LeetCode-weekly-contest-127/","content":"本周4道题目分数分别为4 4 5 6, 应该不是很难的，加油， Forest！\n因为题目太简单，即使提前15min做完了，排名还是912 / 4712。这次比赛真的是简单，完全比拼的是写码的速度和熟练度。是否可以一次bug-free很重要。因为如果某个corner case错了，再去调试是很花时间的。我1，2题都是错了一次，耽误了很多时间。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n931 / 4059\nYoungForest\n19\n1:24:03\n0:24:49(1)\n0:44:58(1)\n1:05:12\n1:14:03\n\n\n\n 1005. Maximize Sum Of Array After K Negations\n常规签到题。\nIntution:\n有负数，先flip最小的负数;\n没负数，有0。 flip 0;\n只有正数，K为奇数，flip最小的正数;\n…, K为偶数，不flip.\n时间复杂度: O(N log N), 因为排序。\n空间复杂度: O(1).\nclass Solution &#123;public:    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;        sort(A.begin(), A.end(), less&lt;int&gt;());        int i;        for (i = 0; i &lt; A.size() &amp;&amp; K &gt; 0 &amp;&amp; A[i] &lt; 0; ++i) &#123;            A[i] = -A[i];            K--;        &#125;        if (K &gt; 0 &amp;&amp; K % 2 == 1) &#123;            if (i &gt; 0 &amp;&amp; A[i-1] &lt; A[i]) A[i-1] = -A[i-1];            else A[i] = -A[i];        &#125;        return accumulate(A.begin(), A.end(), 0, plus&lt;int&gt;());    &#125;&#125;;\n我Wrong Answer了一次，因为flip最小的正数时，没有考虑原来是负数的更小的正数，也就是需要有if (i &gt; 0 &amp;&amp; A[i-1] &lt; A[i]) A[i-1] = -A[i-1];这行代码。\n即使是签到题，在Discuss区果然还是发现了一些牛逼的代码。比如，O(N)的解法。\nclass Solution &#123;    int partition(vector&lt;int&gt;&amp; A, int low, int high) &#123;        int pivot = A[high];        int placement = low;        for (int i = low; i &lt; high; ++i) &#123;            if (A[i] &lt; pivot) &#123;                swap(A[i], A[placement]);                placement++;            &#125;        &#125;        swap(A[high], A[placement]);                return placement;    &#125;public:    int largestSumAfterKNegations(vector&lt;int&gt;&amp; A, int K) &#123;        int low = 0, high = A.size() - 1;        int index;        while (true) &#123;            index = partition(A, low, high);            if (index &lt; K - 1)  // why not K? Think the case A.size() == K                low = index + 1;            else if (index &gt; K - 1)                high = index - 1;            else                break;        &#125;            for (int i = 0; i &lt; index; i++) &#123;            if (A[i] &lt; 0) &#123;                A[i] = -A[i];                K--;            &#125;        &#125;                return accumulate(A.begin(), A.end(), 0) - ((K%2) == 1 ? 2 * *min_element(A.begin(), A.end()) : 0);    &#125;&#125;;\nTime complexity: O(N) in average.\nSpace complexity: O(1).\n如果想要worst case也是O(N)的话，可以用随机的partition.\n 1006. Clumsy Factorial\n第一次提交由于考虑错了优先级，把‘-’的优先级降低了，写了一个智障的递归解法，结果负负得正显然不对。\nIntution:\n直接根据&quot;Clumsy Factorial&quot;的定义进行计算。\nclass Solution &#123;public:    int clumsy(int N) &#123;        if (N == 4) &#123;            return 4*3 / 2 + 1;        &#125; else if (N == 3) &#123;            return 3*2 / 1;        &#125; else if (N == 2) &#123;            return 2 * 1;        &#125; else if (N == 1) &#123;            return 1;        &#125; else &#123;            unsigned int result = N * (N - 1) / (N - 2) + (N - 3);            int i;            for (i = 4; i + 4 &lt;= N; i+=4) &#123;                result += - (N - i) * (N - i - 1) / (N - i - 2) + (N - i - 3);            &#125;            if (N - i == 3) result += -3*2/1;            else if (N - i == 2) result += -2*1;            else if (N - i == 1) result += -1;            else;            return result;        &#125;    &#125;&#125;;\n时间复杂度：O(N),\n空间复杂度：O(1).\nDiscuss区惊现数学优化的O(1)解法，不得不把原地址发出来。真的是太6了。\n 1007. Minimum Domino Rotations For Equal Row\nIntution:\n想让A或B整行相同，最后可能有12种情况，即 A 1，A 2， A 3, A 4, …, B 6。\n过一遍dominoes，就能获得达到这12种情况需要的flip数目，用-1表示无法达到。\nclass Solution &#123;public:    int minDominoRotations(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;        if (A.size() != B.size()) return -1;        vector&lt;int&gt; states(12, 0);                for (int i = 0; i &lt; A.size(); i++) &#123;            int count = 0;            for (int j = 0; j &lt; 6; j++) &#123;                if (j + 1 == A[i] &amp;&amp; states[j] &gt;= 0)                    states[j] = states[j];                else if (j + 1 == B[i] &amp;&amp; states[j] &gt;= 0)                    states[j] ++;                else &#123;                    states[j] = -1;                    count++;                &#125;            &#125;            for (int j = 0; j &lt; 6; j++) &#123;                if (j + 1 == B[i] &amp;&amp; states[j + 6] &gt;= 0)                    states[j + 6] = states[j + 6];                else if (j + 1 == A[i] &amp;&amp; states[j + 6] &gt;= 0)                    states[j + 6] ++;                else &#123;                    states[j + 6] = -1;                    count++;                &#125;            &#125;                        if (count == 12) return -1;        &#125;                int result = -1;        for (int i = 0; i &lt; 12; i++) &#123;            if (states[i] &gt;= 0)                result = result &gt;= 0 ? min(result, states[i]) : states[i];        &#125;        return result;    &#125;&#125;;\n 1008. Construct Binary Search Tree from Preorder Traversal\nIntution:\n树的问题一般通过递归解决。此题的关键在于理解Binary Search Tree和Preorder Traversal。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    TreeNode* dfs(vector&lt;int&gt;&amp; preorder, int begin, int end) &#123;        if (begin &gt; end) return nullptr;        if (begin == end) return new TreeNode(preorder[begin]);        TreeNode* root = new TreeNode(preorder[begin]);        int mid;        for (mid = begin + 1; mid &lt;= end &amp;&amp; preorder[mid] &lt; root-&gt;val; mid++);        root-&gt;left = dfs(preorder, begin + 1, mid - 1);        root-&gt;right = dfs(preorder, mid, end);        return root;    &#125;public:    TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) &#123;        return dfs(preorder, 0, preorder.size() - 1);    &#125;&#125;;\n实际上，是存在O(N)解法的，即，我们并不需要找到左右子树的分界点, 只需要不断地扩展树就可以了。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    int i = 0;    TreeNode* dfs(vector&lt;int&gt;&amp; preorder, int bound) &#123;        if (i == preorder.size() || preorder[i] &gt; bound) return nullptr;        TreeNode* root = new TreeNode(preorder[i++]);        root-&gt;left = dfs(preorder, root-&gt;val);        root-&gt;right = dfs(preorder, bound);        return root;    &#125;public:    TreeNode* bstFromPreorder(vector&lt;int&gt;&amp; preorder) &#123;        return dfs(preorder, numeric_limits&lt;int&gt;::max());    &#125;&#125;;\n 后记\n最近因为同时忙水科院的项目，在刷题方面有所放松。我需要检讨自己，重新认识一下现在的情况。如果去外企的话，真的, 刷题只是基本功。套用武侠小说的概念，“数据结构和算法是一个程序员的内功“。如果连这么简单的事情也坚持不了的话，人生大概率也就一事无成了。\n计划：虽然每天晚上回来累成狗，还是要花出1个小时在刷题和计算机基础上，花出半个小时在跑步上，半个小时在英语上。我会在豆瓣上每天签到，希望各位监督。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 128","url":"/2019/03/17/LeetCode-weekly-contest-128/","content":"前3道题比较顺利，30min内解决。最后一道hard题目，思路比较混乱，1个小时愣是没做出来。\nContest给我的感觉是，还是拼的熟练度。\n因为第2、3题之前做过类似的，所以很快就做出来了。第2题甚至只用了2分钟!!!\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (2)\nQ2 (4)\nQ3 (6)\nQ4 (8)\n\n\n\n\n348 / 5164\nYoungForest\n19\n1:24:03\n0:11:33(1)\n0:13:42(1)\n0:27:37\nNone\n\n\n\n 1012. Complement of Base 10 Integer\nclass Solution &#123;public:    int bitwiseComplement(int N) &#123;        if (N == 0) return 1;        int ret = 0;        for (int i = 0; i &lt; 32; i++) &#123;            if ((1 &lt;&lt; i) &gt; N) break;            ret += ((N &amp; (1 &lt;&lt; i)) == 0) ? (1 &lt;&lt; i) : 0;        &#125;                return ret;    &#125;&#125;;\n时间复杂度: O(log N)，与数字的长度成正比。\n空间复杂度: O(1).\n由于没有注意corner case, if (N == 0) return 1;。wrong answer了一次。\n我的方法是straight forward的，没有任何技巧和trick。因为是签到题嘛，而且时间复杂度足够了。\n也有一些其他的思路：\n比如找到最大的X = 1111..11使得X &gt;= N, return X - N或return X^N即可。\n 1013. Pairs of Songs With Total Durations Divisible by 60\nclass Solution &#123;public:    int numPairsDivisibleBy60(vector&lt;int&gt;&amp; time) &#123;        vector&lt;int&gt; hashmap(60, 0);        int ret = 0;        for (const int &amp; t : time) &#123;            ret += hashmap[(60 - t + 60000) % 60];            hashmap[t % 60]++;        &#125;        return ret;    &#125;&#125;;\n与著名的two sum思路一样，考察hashmap的使用。\n为了将所有的值，包括负数，映射到60以内，我使用了(60 - t + 60000) % 60，其实更好的做法是(60 - t % 60) % 60。\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1014. Capacity To Ship Packages Within D Days\n一道典型的二分题，周末帮二师兄做头条笔试题的时候也遇到了。思路很清晰，写起来也很熟练。\nclass Solution &#123;    bool possible(vector&lt;int&gt;&amp; weights, int capacity, int D) &#123;        int day_count = 0;        int weight_index = 0;        for (; day_count &lt; D; day_count++) &#123;            int hasLoadedWeight = 0;            for (; weight_index &lt; weights.size() &amp;&amp; hasLoadedWeight + weights[weight_index] &lt;= capacity; weight_index++) &#123;                hasLoadedWeight += weights[weight_index];            &#125;        &#125;        return weight_index == weights.size();    &#125;public:    int shipWithinDays(vector&lt;int&gt;&amp; weights, int D) &#123;        // binary search，time complexity: 50000 * log(50000 * 500), Space: O(1)        int hi = 50000 * 500;        int lo = 0;        while (lo &lt; hi) &#123;            // loop invariant: possible(hi) == true            int mid = lo + (hi - lo) / 2;            if (possible(weights, mid, D))                hi = mid;            else                lo = mid + 1;        &#125;                return hi;    &#125;&#125;;\nTime complexity: 50000 * log(50000 * 500)，\nSpace: O(1)\n 1015. Numbers With 1 Repeated Digit\n花了一个小时，仍没有做出来。回头反思，正确的思路有：计算没有重复位的数的个数，将数集分为0、1～digit-1、digit。错误的想法有，没有使用permutation简化计算。对数字的模式分析的不够透彻，事实上只需要分为2类0~digit-1, digit即可。由于这些错误，虽然笔算可以算出数目，但代码实现过于复杂，长度也过长，很难直接写对。最后不得不放弃。\n参考了lee215和heqingy的解答。\nclass Solution &#123;    int permutation(int n, int m) &#123;        int ret = 1;        for (int i = 0; i &lt; n; i++) &#123;            ret *= m - i;        &#125;                return ret;    &#125;public:    int numDupDigitsAtMostN(int N) &#123;        vector&lt;int&gt; digits;        // transform N + 1 to list. Attention: have to be N + 1, not N        int tmp = N + 1;        while (tmp &gt; 0) &#123;            digits.push_back(tmp % 10);            tmp /= 10;        &#125;        reverse(digits.begin(), digits.end());        int len = digits.size();        int ret = 0;        // the first digit is 0        // take 3452 as an example        // len = 4        // compute ***, **, *        for (int i = 1; i &lt; len; i++) &#123;            ret += 9 * permutation(len - i - 1, 9);        &#125;        // the first digits is not 0        set&lt;int&gt; seen;        for (int i = 0; i &lt; len; i++) &#123;            // if i == 2            // compute 34**            for (int j = ((i == 0) ? 1 : 0); j &lt; digits[i]; j++) &#123;                // if j == 2                // compute 342*                if (seen.find(j) == seen.end()) &#123;                    ret += permutation(len - 1 - i, 10 - (i + 1));                &#125;            &#125;            // break if 344...            if (seen.find(digits[i]) != seen.end()) break;            seen.insert(digits[i]);        &#125;                return N - ret;    &#125;&#125;;\n时间复杂度：O(log n)，数字的长度。\n空间复杂度: O(1).\n 后记\n现在刷了279道题了，但愿刷到后来可以达到，遇到题目就有思路，有思路就能默写下来，bug-free的境界吧。这种境界需要多少题目呢？600？900？\n无论需要多少道题，都要做下去。\n之前刷题一直有个误区，速度不够，每天腾出来专心做题的时间不多。只有速度快才能称之为刷不是。\n再次明确自己的目标，用1年时间来准备面试需要的技能。数据结构与算法是其基础，剩下的语言、计算机组成、操作系统、设计模式、编译器、网络，也要慢慢补上来。明年这个时候就是真刀真枪地上战场的时候了。\n加油，Forest!\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 130","url":"/2019/03/31/LeetCode-weekly-contest-130/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (5)\nQ4 (5)\n\n\n\n\n258 / 5236\nYoungForest\n19\n0:57:19\n0:06:23\n0:25:41\n0:36:25\n0:52:19(1)\n\n\n\n本次contest比较简单，都是常规题。没有hard来区分水平，就看谁的实现的速度快了。50min内才能前200名。\n第二题耽误了些时间，最后一题刚开始思路秀逗了，走了些弯路。\n 1029. Binary Prefix Divisible By 5\nIntution:\nStright forward. 循环移位，判断除5的余数。需要注意current要取模，因为A的长度会很大。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;bool&gt; prefixesDivBy5(vector&lt;int&gt;&amp; A) &#123;        vector&lt;bool&gt; ret(A.size(), false);        uint32_t current = 0;        for (int i = 0; i &lt; A.size(); i++) &#123;            current = (current &lt;&lt; 1) % 10;            current += A[i];            if (current == 0 || current == 5)                ret[i] = true;        &#125;                return ret;    &#125;&#125;;\n 1028. Convert to Base -2\nIntution:\n类比2进制的解法。不断整除2.\nclass Solution &#123;public:    string baseNeg2(int N) &#123;        if (N == 0) return &quot;0&quot;;        string ret_reverse;        bool flag = true; // 正        while (N &gt; 0) &#123;            if (N % 2 == 1) &#123;                ret_reverse.push_back(&#x27;1&#x27;);                if (flag)                    N /= 2;                else                    N = (N + 1) / 2;    // 此处要加一，因为最后一位的权重此时是-1. N下一步的迭代要把其补上            &#125; else &#123;                ret_reverse.push_back(&#x27;0&#x27;);                N /= 2;            &#125;            flag = !flag;        &#125;                reverse(ret_reverse.begin(), ret_reverse.end());        return ret_reverse;    &#125;&#125;;\n 1030. Next Greater Node In Linked List\nIntution:\n单调栈。\n时间复杂度: O(N),\n空间复杂度: O(N).\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    vector&lt;int&gt; nextLargerNodes(ListNode* head) &#123;        // 单调栈        vector&lt;int&gt; ret;        stack&lt;pair&lt;int, int&gt;&gt; s; // index, value        int index = 0;        while (head) &#123;            while (!s.empty() &amp;&amp; head-&gt;val &gt; s.top().second) &#123;                auto current = s.top();                s.pop();                ret[current.first] = head-&gt;val;            &#125;            ret.push_back(0);            s.push(&#123;index, head-&gt;val&#125;);            index++;            head = head-&gt;next;        &#125;                return ret;    &#125;&#125;;\n 1031. Number of Enclaves\nIntution:\nDFS, 从边缘开始进行搜索。\n时间复杂度: O(N^2),\n空间复杂度: O(N^2).\nclass Solution &#123;    void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; A, int i, int j) &#123;        if (A[i][j] == 0 || A[i][j] == 2) return;        A[i][j] = 2;        vector&lt;int&gt; di &#123;0, 1, 0, -1&#125;;        vector&lt;int&gt; dj &#123;1, 0, -1, 0&#125;;        for (int k = 0; k &lt; 4; k++) &#123;            int new_i = di[k] + i;            int new_j = dj[k] + j;            if (new_i &gt;= 0 &amp;&amp; new_j &gt;= 0 &amp;&amp; new_i &lt; A.size() &amp;&amp; new_j &lt; A[0].size()) &#123;                dfs(A, new_i, new_j);            &#125;        &#125;    &#125;public:    int numEnclaves(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;        for (int j = 0; j &lt; A[0].size() - 1; j++) &#123;            dfs(A, 0, j);        &#125;        for (int i = 0; i &lt; A.size() - 1; i++) &#123;            dfs(A, i, A[0].size() - 1);        &#125;        for (int j = A[0].size() - 1; j &gt; 0; j--) &#123;            dfs(A, A.size() - 1, j);        &#125;        for (int i = A.size() - 1; i &gt; 0; i--) &#123;            dfs(A, i, 0);        &#125;                int ret = 0;        for (int i = 0; i &lt; A.size(); i++) &#123;            for (int j = 0; j &lt; A[0].size(); j++) &#123;                if (A[i][j] == 1)                    ret++;            &#125;        &#125;        return ret;    &#125;&#125;;\n 后记\n在LeetCode上刷了有319 / 969题了，算是到达一定瓶颈了。我目前是按照通过率刷的，正常情况下，也代表着从易到难。容易的题已经做完了，之后的题目会越来越难。刚开始10min能写一道题，看到题就知道怎么做，现在需要半个小时，每道题还需要思考一段时间。\n但这是好现象，只有做这种有一定难度，但又不超出自己能力范畴的题目，才能快速提高。\n加油，Forest！\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 129","url":"/2019/03/31/LeetCode-weekly-contest-129/","content":"上周末由于准备 Google的kick start round A，放弃了一次LeetCode weekly contest。但当天晚上还是把LeetCode的题补完了。4题不简单，但经过思考还是独立做出来了。算是给被kick start难到自闭的我一个安慰吧。\n 1020. Partition Array Into Three Parts With Equal Sum\nIntution:\nOne pass. Find the pivots which is 1/3 and 2/3.\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    bool canThreePartsEqualSum(vector&lt;int&gt;&amp; A) &#123;        int sum_all = accumulate(A.begin(), A.end(), 0);        if (sum_all %3 != 0) return false;        int sum_3 = sum_all / 3;        int sum_prefix = 0;        for (int i = 0; i &lt; A.size(); i++) &#123;            if (sum_prefix == sum_3 &amp;&amp; sum_3 != sum_all)                sum_3 += sum_all / 3;            sum_prefix += A[i];        &#125;        return sum_3 == sum_all;    &#125;&#125;;\n 1022. Smallest Integer Divisible by K\nIntution:\n模拟笔算过程。\n如果个位数不为1， 3， 7，9的话，直接范围-1. 代表找不到符合条件的N。\n之后用笔算的方法，一直凑最后一位为1，知道前面所有的位数也均为1.\n因为一定有解，所以循环一定会结束。\n时间复杂度: O(result.length),\n空间复杂度: O(1).\nclass Solution &#123;    bool all11(int i) &#123;        while (i &gt; 0) &#123;            if (i % 10 != 1) return false;            i /= 10;        &#125;        return true;    &#125;public:    int smallestRepunitDivByK(int K) &#123;        if (K % 10 != 1 &amp;&amp; K % 10 != 3 &amp;&amp; K % 10 != 7 &amp;&amp; K % 10 != 9) return -1;        vector&lt;int&gt; dictionary(10);        vector&lt;int&gt; gewei(10);        for (int i = 0; i &lt; dictionary.size(); i++) &#123;            dictionary[i] = K * i;            gewei[K * i % 10] = i;        &#125;        int ret = 0;        int remain = K;        while (!all11(remain)) &#123;            int last = remain % 10;            int new_value = 0;            new_value = gewei[(11 - last) % 10] * K;            ret++;            remain = (new_value + remain) / 10;        &#125;        while (remain &gt; 0) &#123;            if (remain % 10 != 1) return -1;            remain /= 10;            ret++;        &#125;                return ret;    &#125;&#125;;\n 1021. Best Sightseeing Pair\nIntution:\n动态规划。最有子结构为：\n以第i个元素结尾的pair的最大分数 为 max(i与i-1组成pair, i与 i-1的pair 组成pair)。\n时间复杂度: O(N), one pass.\n空间复杂度: O(1). 虽然我下面代码的实现为O(N)，但因为dp过程只用到dp[i-1]，所以可以进一步优化到O(1).\nclass Solution &#123;public:    int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123;        int n = A.size();        vector&lt;int&gt; dp(n, 0);        int ret = 0;        for (int i = 1; i &lt; n; i++) &#123;            dp[i] = max(A[i] + A[i - 1] - 1, dp[i - 1] - A[i - 1] + A[i] - 1);            ret = max(ret, dp[i]);        &#125;                return ret;    &#125;&#125;;\n 1023. Binary String With Substrings Representing 1 To N\nIntution:\n先打表，再查表。\n时间复杂度: O(max(S.length, N)),\n空间复杂度: O(N).\nclass Solution &#123;public:    bool queryString(string S, int N) &#123;        vector&lt;bool&gt; contain(N + 1);        for (size_t i = 0; i &lt; S.size(); i++) &#123;            int value = S[i] - &#x27;0&#x27;;            contain[value] = true;            for (size_t j = 1; j &lt; 31 &amp;&amp; i + j &lt; S.size(); j++) &#123;                value = (value &lt;&lt; 1) + S[i + j] - &#x27;0&#x27;;                if (value &lt;= N) contain[value] = true;            &#125;        &#125;                for (int i = 1; i &lt;= N; i++) &#123;            if (!contain[i]) return false;        &#125;        return true;    &#125;&#125;;\n 后记\nGoogle kick start round A的题目还没有整理。3个小时的比赛事实上对于我来说只有2个小时。我做出了签到题，第二题的small test。最后一个小时实在是毫无头绪，自知再给我多少时间也不会有突破了，便直接放弃了。排名600. 好像是比赛系统的bug, 最后25min无法提交，否则我的排名还会掉。因为很多人会在比赛结束前夕提交一波代码的。\nKick start是1月一次的，我想下次round B也继续参加，继续受虐。据 唐老师 说，中国Google校招的话，只看round D E。自己还差的远呢！仍需继续刷题，另外补充竞赛的知识，CS的知识。即使最后进不了Google，找工作的结果也不会差。\n加油，Forest！\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 131","url":"/2019/04/07/LeetCode-weekly-contest-131/","content":"本次比赛的题号吓了我一跳. LeetCode也是任性，直接从5000+开始出题了。看来题量上涨的空间已经超乎我的想象了。\n言归正传，本次contest也是以简单题拼速度为主。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (5)\nQ4 (5)\n\n\n\n\n323 / 4894\nYoungForest\n22\n0:59:58\n0:10:44\n0:19:06(2)\n0:30:57\n0:49:58\n\n\n也是大概需要50min内完成，才能进入200名内。\n\n\n\n\n\n\n\n\n\n\n 1021. Remove Outermost Parentheses\nIntution:\n括号匹配的问题。利用栈的思维，设置一个flag表示是否是Outermost。利用状态机的思维构造返回的字符串。\n时间复杂度: O(N)\n空间复杂度: O(1)\nclass Solution &#123;public:    string removeOuterParentheses(string S) &#123;        int flag = 0;        string ret;        for (char c : S) &#123;            if (c == &#x27;(&#x27;) &#123;                if (flag != 0)                    ret.push_back(c);                flag++;            &#125; else if (c == &#x27;)&#x27;) &#123;                if (flag != 1)                    ret.push_back(c);                flag--;            &#125;        &#125;                return ret;    &#125;&#125;;\n 1022. Sum of Root To Leaf Binary Numbers\nIntution:\nrecurse, 二进制表示的值用传值的方式进行传递。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    const static int mod = 1e9 + 7;    int ret = 0;    void dfs(TreeNode* root, int value) &#123;        int current_value = (value &lt;&lt; 1) % mod + root-&gt;val;        if (root-&gt;left) dfs(root-&gt;left, current_value);        if (root-&gt;right) dfs(root-&gt;right, current_value);        if (!root-&gt;left &amp;&amp; !root-&gt;right)            ret = (ret + current_value) % mod;    &#125;public:    int sumRootToLeaf(TreeNode* root) &#123;        dfs(root, 0);        return ret;    &#125;&#125;;\n需要注意的是取模的地方会有2个\n\n计算current_value\n累加ret\n\n时间复杂度: O(N)，所有节点都要遍历一次。\n空间复杂度: O(N)，树的深度，最差的情况是等于节点数。\n 1023. Camelcase Matching\nIntution:\n直接比较即可。借鉴状态机的思想，不同条件下，执行的操作不同(i, j的变化)。\nclass Solution &#123;    bool answer(const string&amp; query, const string&amp; pattern) &#123;        int i, j;        for (i = 0, j = 0; i &lt; pattern.size() &amp;&amp; j &lt; query.size();) &#123;            if (query[j] == pattern[i]) &#123;                i++;                j++;            &#125; else if (islower(query[j])) &#123;                j++;            &#125; else &#123;                return false;            &#125;        &#125;        if (i == pattern.size()) &#123;            for (; j &lt; query.size(); j++) &#123;                if (!islower(query[j]))                    return false;            &#125;        &#125; else &#123;            return false;        &#125;                return true;    &#125;public:    vector&lt;bool&gt; camelMatch(vector&lt;string&gt;&amp; queries, string pattern) &#123;        vector&lt;bool&gt; ret;        for (auto query : queries) &#123;            ret.push_back(answer(query, pattern));        &#125;        return ret;    &#125;&#125;;\n时间复杂度: O(N * M), queries的长度，和每个query的长度。\n空间复杂度: O(N).\n 1024. Video Stitching\nIntution:\n贪心。每次添加的clip都使得拼接完的视频最长。\nclass Solution &#123;public:    int videoStitching(vector&lt;vector&lt;int&gt;&gt;&amp; clips, int T) &#123;        // greedy        int ret = 0;        int current_interval_right = 0;        for (;current_interval_right &lt; T;) &#123;            int max_left = 0;            for (const auto&amp; clip : clips) &#123;                if (clip[0] &lt;= current_interval_right)                    max_left = max(clip[1], max_left);            &#125;            if (current_interval_right == max_left) &#123;                return -1;            &#125;            current_interval_right = max_left;            ret ++;        &#125;        return ret;    &#125;&#125;;\n时间复杂度: O(N ^ 2).\n空间复杂度: O(1).\n 后记\n最近参加了微软的summer intern的笔试题，过了签到题，第3题有个case超时了。后来在网上查了后，才知道有种叫做order statistic tree的数据结构，可以实现O(log n)的rank、删除任意节点、删除头节点。\n微软和Google的笔试题的难度都上升到ICPC(现在不能叫ACM了，因为ACM已经不赞助了。可能需要叫IBM-ICPC了。哈哈)了，LeetCode相比之下只能算是小弟弟。\n暑假抽时间把之前买的 挑战程序设计竞赛 和 算法竞赛入门经典 钻研一下，一定帮助很大。\n编程之美(甚至还是邹欣老师的亲笔签名版)到手也3年了，我竟然还没看完。\n要说大学期间我最后悔的事情: 一是没有早点想清楚自己毕业要干什么；二是没有抱住tls的大腿入门ACM。\n这周还干的一件挺有意义的事情是，报名参加Goolge的summer code。虽然入选的几率不大，但今年可以先试一试，为明年的在此申请做铺垫。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 132","url":"/2019/04/14/LeetCode-weekly-contest-132/","content":"本次比赛不难，但代码实现起来不易。不容易一次写到bug-free。考察的是用编程语言处理复杂的逻辑，和各种意外情况。比如 第3题，当前一个dp为0时，长度应该更新为2，除此之外，dp+1。第四题，在各种情况下寻找分隔符时，没有找到，应该如何处理。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (5)\nQ4 (5)\n\n\n\n\n388 / 4765\nYoungForest\n24\n1:21:20\n0:15:54\n0:30:16\n0:38:05\n1:21:20\n\n\n大概需要1个小时内做完，才能进入前200。\n\n\n\n\n\n\n\n\n\n\n第4题由于一些边界条件，我调试了不少时间。我分析花这么长时间的原因。还是写代码写的少，对变量更新的边界条件不敏感。比如string::find没有找到的时候，其他各个坐标该如何更新。我就是由于没找到的时候，返回了npos(-1), current_find_index此时应该等于end，而不是继续在-1上加分隔符的长度。\n 1025. Divisor Game\n一道找规律的题目。\nIntution:\ndp。 Solution(N) = true if any Solution(N’s divisor) is false, else false。\n时间复杂度: O(N^2),\n空间复杂度: O(N).\nclass Solution &#123;public:    bool divisorGame(int N) &#123;        // 1, false        // 2, 1 true        // 3, false        // 4, 1 true        // 5, 1 false        // 6. 3, true        // 7, 1, false        // 8, 1, true        // 9, false        vector&lt;bool&gt; dp(1001, false);        dp[1] = false;        for (int i = 2; i &lt;= N; i++) &#123;            for (int j = 1; j &lt; i; j++) &#123;                if (i % j == 0 &amp;&amp; dp[i - j] == false) &#123;                    dp[i] = true;                    break;                &#125;            &#125;        &#125;        return dp[N];    &#125;&#125;;\n把1～9的结果输出之后发现了了不得的规律。试了一下，一行代码就搞定了。\n用数学归纳法可以证明:\n前提:\nN 为奇数，false;\nN 为偶数，true。\n\n如果N为偶数，取x=1，N-1为false。则N为True.\n如果N为奇数，它所有的因子也必为奇数，即N-x一定为偶数，true. 则N为False。\n\n时间复杂度: O(1),\n空间复杂度: O(1).\nclass Solution &#123;public:    bool divisorGame(int N) &#123;        // 1, false        // 2, 1 true        // 3, false        // 4, 1 true        // 5, 1 false        // 6. 3, true        // 7, 1, false        // 8, 1, true        // 9, false        return N % 2 != 1;    &#125;&#125;;\n 1026. Maximum Difference Between Node and Ancestor\nIntution:\n递归。由于possible difference可能是| root-&gt;val - 左子树中的最小值 |或| root-&gt;val - 左子树中的最大值 |或 减去右子树中的最大最小值，或 左右子树中Maximun Difference中的较大者。\n所以递归函数返回3个值，分别是Maximun Different, 树中最小值，树中最大值。\n时间复杂度: O(N)，每个节点都会被递归调用一次。\n空间复杂度: O(N)，树的高度，平均情况O(log N), 最差O(N)。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    // max_different, max, min    tuple&lt;int, int, int&gt; dfs(TreeNode* root) &#123;        if (!root) &#123;            return &#123;0, -1, 100001&#125;;        &#125;        auto l = dfs(root-&gt;left);        auto r = dfs(root-&gt;right);        return &#123;            max(&#123;get&lt;0&gt;(l), get&lt;0&gt;(r), get&lt;1&gt;(l) == -1 ? -1 : abs(root-&gt;val - get&lt;1&gt;(l)), get&lt;1&gt;(r) == -1 ? -1 : abs(root-&gt;val - get&lt;1&gt;(r)), get&lt;2&gt;(l) == 100001 ? -1 : abs(root-&gt;val - get&lt;2&gt;(l)), get&lt;2&gt;(r) == 100001 ? -1 : abs(root-&gt;val - get&lt;2&gt;(r))&#125;),             max(&#123;root-&gt;val, get&lt;1&gt;(l), get&lt;1&gt;(r)&#125;),             min(&#123;root-&gt;val, get&lt;2&gt;(l), get&lt;2&gt;(r)&#125;)        &#125;;    &#125;public:    int maxAncestorDiff(TreeNode* root) &#123;        auto ret = dfs(root);        return get&lt;0&gt;(ret);    &#125;&#125;;\n 1027. Longest Arithmetic Sequence\nIntution:\nDP.\n最优子结构，其中dp[a][b]表示，以坐标a结尾，且差值为b的子序列的长度。\ndp[i][A[i] - A[j]] = dp[j][A[i] - A[j]] == 0 ? 2 : dp[j][A[i] - A[j]] + 1。\n时间复杂度: O(N ^ 2 log N), 用unordered_map的话可以进一步降为O(N^2).\n空间复杂度: O(N ^ 2). 最差情况下，两两差值均不同。\nclass Solution &#123;public:    int longestArithSeqLength(vector&lt;int&gt;&amp; A) &#123;        // n^2        int ret = 0;        vector&lt;map&lt;int, int&gt;&gt; dp(A.size()); // diff, length        for (int i = 0; i &lt; A.size(); ++i) &#123;            for (int j = 0; j &lt; i; ++j) &#123;                dp[i][A[i] - A[j]] = dp[j][A[i] - A[j]] == 0 ? 2 : dp[j][A[i] - A[j]] + 1;                ret = max(ret, dp[i][A[i] - A[j]]);            &#125;        &#125;                return ret;    &#125;&#125;;\n 1028. Recover a Tree From Preorder Traversal\nIntution:\n递归构造Tree。难点在于字符串的处理，如何迅速并bug-free地实现。\n时间复杂度：O(N * M), 每个节点最多遍历一次字符串；\n空间复杂度：O(N), 需要存储最后的树，递归深度最多为N，递归函数本身内存消耗O(1).\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    // [Begin, end)    TreeNode* dfs(string&amp; S, int begin, int end, int depth) &#123;        // cout &lt;&lt; begin &lt;&lt; &quot; &quot; &lt;&lt; end &lt;&lt; &quot; &quot; &lt;&lt; depth &lt;&lt; endl;        string delimiter(depth + 1, &#x27;-&#x27;);        int first_dash = S.find(&#x27;-&#x27;, begin);        int val_end_index = min(end, first_dash == string::npos ? numeric_limits&lt;int&gt;::max() : first_dash);        TreeNode* ret = new TreeNode(stoi(S.substr(begin, val_end_index - begin)));        // 找到左右子树的分界点        int left_begin = S.find(delimiter, begin);        if (left_begin == string::npos || left_begin &gt;= end) &#123;            return ret;        &#125;        int current_find_index = left_begin + delimiter.size();        // cout &lt;&lt; &quot;   &quot; &lt;&lt; current_find_index &lt;&lt; endl;        int left_end = S.find(delimiter, current_find_index);        // cout &lt;&lt; &quot;   &quot; &lt;&lt; left_end &lt;&lt; endl;        current_find_index = (left_end == string::npos) ? end : left_end + delimiter.size();        // cout &lt;&lt; &quot;   &quot; &lt;&lt; current_find_index &lt;&lt; endl;        while (left_end != string::npos &amp;&amp; left_end &lt; end &amp;&amp; S[current_find_index] == &#x27;-&#x27;) &#123;            while (S[current_find_index] == &#x27;-&#x27;) ++current_find_index;            // cout &lt;&lt; &quot;   &quot; &lt;&lt; current_find_index &lt;&lt; endl;            left_end = S.find(delimiter, current_find_index);            // cout &lt;&lt; &quot;   &quot; &lt;&lt; left_end &lt;&lt; endl;            current_find_index = (left_end == string::npos) ? end : left_end + delimiter.size();            // cout &lt;&lt; &quot;   &quot; &lt;&lt; current_find_index &lt;&lt; endl;        &#125;        ret-&gt;left = dfs(S, left_begin + delimiter.size(), left_end &lt; end &amp;&amp; left_end != string::npos ? left_end : end, depth + 1);        int right_begin = current_find_index;        if (right_begin &lt; end)            ret-&gt;right = dfs(S, right_begin, end, depth + 1);                return ret;    &#125;public:    TreeNode* recoverFromPreorder(string S) &#123;        return dfs(S, 0, S.size(), 0);    &#125;&#125;;\n由于自己的实现虽然想法简单，但实现不易，而且容易写错。我自己就调试了很长时间。\n于是去评论区找到了更 优的方案，Iterative Stack.\n时间复杂度: O(M), one pass.\n空间复杂度: O(N).\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* recoverFromPreorder(string S) &#123;        stack&lt;TreeNode*&gt; s;        int i = 0;        while (i &lt; S.size()) &#123;            int value = 0, level = 0;            while (i &lt; S.size() &amp;&amp; S[i] == &#x27;-&#x27;) &#123;                ++level;                ++i;            &#125;            while (i &lt; S.size() &amp;&amp; S[i] != &#x27;-&#x27;) &#123;                value = value * 10 + S[i] - &#x27;0&#x27;;                ++i;            &#125;            while (s.size() &gt; level) &#123;                s.pop();            &#125;            auto node = new TreeNode(value);            if (!s.empty() &amp;&amp; !s.top()-&gt;left) &#123;                s.top()-&gt;left = node;            &#125; else if (!s.empty()) &#123;                s.top()-&gt;right = node;            &#125;            s.push(node);        &#125;        TreeNode* ret;        while (!s.empty()) &#123;            ret = s.top();            s.pop();        &#125;        return ret;    &#125;&#125;;\n 后记\n每周在这里总结一下最近生活的进展吧。\n\nGoogle summer of code 的申请放弃了。理由是看了一些感兴趣的organization，发现proposal的要求很高。自己很多都达不到。另一方面，自己开源项目的经历确实不够。能拿出手的仅仅是去年在Apache/HAWQ上的一次Contribution。今年可以多参加一些开源活动，丰富简历。\n微软的summer intern的笔试的后续结果还没有。Action Center的最新的更新还处于3月31号。\n\n最近在读Lippman的《Essential C++》，侯捷老师在翻译的序里有这么一段话，送给大家。\n\n有些人的学习，自练一身铜筋铁骨，可以在热带丛林中披襟斩棘，在莽莽草原中追奔逐北。有些人的学习，既未习惯大部头书，也未习惯严谨格调，更未习惯自修勤学，是温室里的一朵花，没有自强自立的本钱。\n\n不知道大家怎么样。我反思自己学习的过程，常常“趋利避害”，喜欢简单的皮毛，面对需要花费大量时间钻研的技术即浅尝辄止。而我也知道，作为一名“程序员”，真正拉开与别人距离的都是需要沉下心去钻研的。放眼其他领域，其实也是这样。由于大家都是理智的人，拥有惰性的人，简单的好事一定是趋之若鹜的，做的人多了，供需平衡一打破，门槛一定也日渐提高。\n侯老师的话让我醍醐灌顶，自己也需每天反思自己的学习状态，即使纠正错误的思想和方法。这样才能走的更远，飞的更高。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 133","url":"/2019/04/21/LeetCode-weekly-contest-133/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (5)\nQ4 (5)\n\n\n\n\n864 / 4860\nYoungForest\n14\n1:10:35\n0:42:32\n0:54:38\n1:10:35\nnull\n\n\n\n本周的题目相比前几周质量有了不少提升，水题减少，考察的算法知识也更多。即使是前2题是easy题，也考察了足够的编程能力。本次比赛由于一开始肚子疼耽误了半个小时，所以开始的比较晚。最后一题其实差一点是可以AC的。总的方向是对的，即使用Trie单词树。但最后10min时提交后，TLE，也没时间改了。单词树的构造方向走反了，对于匹配问题，我们可以从前向后，也可以从后向前。这道题从后向前不仅实现起来更简单，时间上也会更好些(即使最坏情况的时间复杂度是一样的)。\n 1030. Matrix Cells in Distance Order\nIntuition:\n根据距离对所有格子进行排序。\n这里我是用了treemap，可以插入后保持有序。你也可以构造一个vector，然后再排序。\n时间复杂度：O(R * C * log (R*C)).\n空间复杂度：O(R * C).\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) &#123;        multimap&lt;int, pair&lt;int, int&gt;&gt; distance;        for (int i = 0; i &lt; R; ++i) &#123;            for (int j = 0; j &lt; C; ++j) &#123;                distance.insert(&#123;abs(r0 - i) + abs(c0 - j), &#123;i, j&#125;&#125;);            &#125;        &#125;        vector&lt;vector&lt;int&gt;&gt; ret;        for (const auto&amp; item : distance) &#123;            ret.push_back(vector&lt;int&gt; &#123; item.second.first, item.second.second&#125;);        &#125;        return ret;    &#125;&#125;;\n刚开始试图直接构造出结果，但发现不是很好写。果断放弃，不过还是耽误了些时间。\n看了discuss后，发现主流的解法还是从构造出发的。不过用了标准的BFS，会好写的多。\n 1029. Two City Scheduling\nIntuition:\n贪心。\n因为每个人肯定要被派到一个城市，而且结果是求最小花费和。\n所以以每个人的不同城市的花费之差为标准进行排序，前一半去A，后一半去B即可。\n时间复杂度: O(N log N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int twoCitySchedCost(vector&lt;vector&lt;int&gt;&gt;&amp; costs) &#123;        sort(costs.begin(), costs.end(), [](const vector&lt;int&gt;&amp; lhs, const vector&lt;int&gt;&amp; rhs) -&gt; bool &#123;            return lhs[1] - lhs[0] &gt; rhs[1] - rhs[0];        &#125;);        int N = costs.size() / 2;                int ret = 0;        for (int i = 0; i &lt; N; ++i) &#123;            ret += costs[i][0];        &#125;        for (int i = N; i &lt; 2*N; ++i) &#123;            ret += costs[i][1];        &#125;        return ret;    &#125;&#125;;\n 1031. Maximum Sum of Two Non-Overlapping Subarrays\nIntuition:\n稍微有些暴力，计算所有长度L和M的子数组的和，然后挑出不重合的最大的一对。\n时间复杂度: O(N ^ 2)\n空间复杂度: O(N)\nclass Solution &#123;public:    int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; A, int L, int M) &#123;        const int n = A.size();        vector&lt;int&gt; sum_l(n, 0);        vector&lt;int&gt; sum_m(n, 0);                int current_sum = accumulate(A.begin(), A.begin() + L, 0);        sum_l.at(0) = current_sum;        for (int i = 1; i &lt;= n - L; ++i) &#123;            current_sum += A[i + L - 1] - A[i - 1];            sum_l.at(i) = current_sum;        &#125;                current_sum = accumulate(A.begin(), A.begin() + M, 0);        sum_m.at(0) = current_sum;        for (int i = 1; i &lt;= n - M; ++i) &#123;            current_sum += A[i + M - 1] - A[i - 1];            sum_m.at(i) = current_sum;        &#125;                int ret = 0;        for (int i = 0; i &lt;= n - L; ++i) &#123;            for (int j = i + L; j &lt;= n - M; ++j) &#123;                ret = max(ret, sum_l.at(i) + sum_m.at(j));            &#125;        &#125;        for (int i = 0; i &lt;= n - M; ++i) &#123;            for (int j = i + M; j &lt;= n - L; ++j) &#123;                ret = max(ret, sum_m.at(i) + sum_l.at(j));            &#125;        &#125;                return ret;    &#125;&#125;;\nOne pass的解决方案，思想是 DP。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int maxSumTwoNoOverlap(vector&lt;int&gt;&amp; A, int L, int M) &#123;        for (int i = 1; i &lt; A.size(); ++i) &#123;            A[i] += A[i - 1];        &#125;        // Lmax: 从头到当前位置再向前跳M个元素的子数组中，长度为L的子数组的最大和        // Mmax: ... ... . .  .. . L ..   . . ..  . ..  .M.. ...        int ret = A[L + M - 1], Lmax = A[L - 1], Mmax = A[M - 1];        for (int i = L + M; i &lt; A.size(); ++i) &#123;            Lmax = max(Lmax, A[i - M] - A[i - M - L]);            Mmax = max(Mmax, A[i - L] - A[i - L - M]);            ret = max(&#123;ret, A[i] - A[i - M] + Lmax, A[i] - A[i - L] + Mmax&#125;);        &#125;                return ret;    &#125;&#125;;\n 1032. Stream of Characters\nIntuition:\n单词树可以很好的解决此类字符串匹配查询问题。\n从后向前匹配，更符合直觉，时间上也会好一点，实现起来也更简单。\n时间复杂度: 构造 O(words.length * word.length), 查询 O(word.length).\n空间复杂度: 最差 O(words.length * word.length).\nclass StreamChecker &#123;    // 单词树    struct Trie &#123;        vector&lt;shared_ptr&lt;Trie&gt;&gt; data = vector&lt;shared_ptr&lt;Trie&gt;&gt;(26);        bool value = false;    &#125;;    shared_ptr&lt;Trie&gt; root = make_shared&lt;Trie&gt;();    vector&lt;char&gt; history;public:    StreamChecker(vector&lt;string&gt;&amp; words) &#123;        for (const auto&amp; word : words) &#123;            shared_ptr&lt;Trie&gt; t = root;            for (int i = word.size() - 1; i &gt;= 0; --i) &#123;                char c = word[i];                if (t-&gt;data[c - &#x27;a&#x27;] == nullptr)                    t-&gt;data[c - &#x27;a&#x27;] = make_shared&lt;Trie&gt;();                t = t-&gt;data[c - &#x27;a&#x27;];            &#125;            t-&gt;value = true;        &#125;    &#125;        bool query(char letter) &#123;        history.push_back(letter);        shared_ptr&lt;Trie&gt; current = root;        if (current-&gt;value)            return true;        for (int i = history.size() - 1; i &gt;= 0; --i) &#123;            char c = history[i];            if (current-&gt;data[c - &#x27;a&#x27;] != nullptr) &#123;                current = current-&gt;data[c - &#x27;a&#x27;];            &#125; else &#123;                return false;            &#125;            if (current-&gt;value)                return true;        &#125;        return false;    &#125;&#125;;/** * Your StreamChecker object will be instantiated and called as such: * StreamChecker* obj = new StreamChecker(words); * bool param_1 = obj-&gt;query(letter); */\n 后记\n自从春节被快手师兄问C新特性后，已经过去2个半月了。这期间，我看了《C Primer》，正在看《Effective Modern C++》，《C++ Concurrency in Action》。自信对新特性有了更多的了解，也在尝试更多地参与C的项目，把C当作自己的主语言来发展。希望在明年找工作的时候能有所核心竞争力。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 134","url":"/2019/04/28/LeetCode-weekly-contest-134/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (5)\nQ4 (5)\n\n\n\n\n220 / 4136\nYoungForest\n17\n1:45:10\n0:14:52 (1)\n0:33:50(1)\nnull\n1:25:10 (2)\n\n\n\n本次比赛质量在上周的基础上继续提高。尤其是corner case，导致我有4次incorrect attempts, 也就是20min的罚时。不过我看leader board上，大家的战况也都差不多，错误尝试很多。\n本次比赛的重点在于作出所有的题目。恰好需要4道题，才能进入前200. 因为第三题的思路问题，即使再给我半个小时，我也难以做出来。所以我输的还算心服口服。\n 1033. Moving Stones Until Consecutive\nIntuition:\n最小移动步数只有3种情况：\n0: 3个坐标紧挨，\n1: 2个紧挨 或 2个中间空一个\n2: x, y y, z之间的间隔都大于1.\n最大移动步数一定是 z - x - 2, 此时每次移动都只向中间移一步。\n时间复杂度: O(1)\n空间复杂度: O(1)\nclass Solution &#123;public:    vector&lt;int&gt; numMovesStones(int a, int b, int c) &#123;        // greedy        int minimum_moves = 0, maximum_moves;        int x = min(&#123;a, b, c&#125;);        int z = max(&#123;a, b, c&#125;);        int y = a + b + c - x - z;        if (y - x == 1 &amp;&amp; z - y == 1)            minimum_moves = 0;        else if (y - x == 1 || z - y == 1 || y - x == 2 || z - y == 2)            minimum_moves = 1;        else            minimum_moves = 2;        maximum_moves = z - y - 1 + y - x - 1;        return &#123;minimum_moves, maximum_moves&#125;;    &#125;&#125;;\n 1034. Coloring A Border\nIntuition:\ndfs 染色。需要注意如何标注已经访问的节点，在这里我使用了负数来表示。\n时间复杂度: O(n*m),\n空间复杂度: O(1), in place.\nclass Solution &#123;    bool border(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r, int c) &#123;        vector&lt;int&gt; di = &#123;1, 0, -1, 0&#125;;        vector&lt;int&gt; dj = &#123;0, 1, 0, -1&#125;;        for (int k = 0; k &lt; 4; ++k) &#123;            int ni = r + di[k];            int nj = c + dj[k];            if (ni &lt; 0 || ni &gt;= grid.size() || nj &lt; 0 || nj &gt;= grid[0].size() || abs(grid[ni][nj]) != abs(grid[r][c]))                return true;        &#125;        return false;    &#125;    void dfs(vector&lt;vector&lt;int&gt;&gt; &amp;grid, int r, int c) &#123;        grid[r][c] = -grid[r][c];        vector&lt;int&gt; di = &#123;1, 0, -1, 0&#125;;        vector&lt;int&gt; dj = &#123;0, 1, 0, -1&#125;;        for (int k = 0; k &lt; 4; ++k) &#123;            int ni = r + di[k];            int nj = c + dj[k];            if (ni &gt;= 0 &amp;&amp; ni &lt; grid.size() &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; grid[0].size() &amp;&amp; grid[ni][nj] == abs(grid[r][c]))                dfs(grid, ni, nj);        &#125;        if (!border(grid, r, c))            grid[r][c] = -grid[r][c];    &#125;public:    vector&lt;vector&lt;int&gt;&gt; colorBorder(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int r0, int c0, int color) &#123;        // dfs        if (grid[r0][c0] == color) return grid;        int origin_color = grid[r0][c0];        dfs(grid, r0, c0);        for (auto&amp; r : grid) &#123;            for (auto &amp; item : r) &#123;                if (item &lt; 0)                    item = color;            &#125;        &#125;        return grid;    &#125;&#125;;\n 1035. Uncrossed Lines\nIntuition:\n第一直觉是将题目转化成 二分图求最大独立集的问题。把所有的连线当作node，连线相交表示node之间的edge。在网上找了些求解二分图的算法，但都不简单，短时间内无法写出来。遂放弃了该题目，先把第四题做出来了。实际上，先去做第四题的策略是对的。事实证明，本题我的思路是走偏了。应该转化成LCS(largest common subsequence), 用dp解决。而且第四题分数更高，所以此次比赛排名反而考前。\nLCS的dp实现起来也很简单。\n时间复杂度: O(NM).\n空间复杂度: O(NM).\nclass Solution &#123;public:    int maxUncrossedLines(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;        const int m = A.size(), n = B.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (n + 1, 0));        for (int i = 1; i &lt;= m; ++i) &#123;            for (int j = 1; j &lt;= n; ++j) &#123;                if (A[i - 1] == B[j - 1]) &#123;                    dp[i][j] = 1 + dp[i - 1][j - 1];                &#125; else &#123;                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);                                    &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;;\n空间复杂度可以优化到N, 因为dp的子问题只用到了上一行和本行的解。\nclass Solution &#123;public:    int maxUncrossedLines(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123;        const int m = A.size(), n = B.size();        vector&lt;int&gt; dp(n + 1, 0);        for (int i = 1; i &lt;= m; ++i) &#123;            for (int j = n; j &gt;= 1; --j) &#123;                if (A[i - 1] == B[j - 1]) &#123;                    dp[j] = 1 + dp[j - 1];                &#125;            &#125;            for (int j = 1; j &lt;= n; ++j) &#123;                dp[j] = max(dp[j], dp[j - 1]);            &#125;        &#125;        return dp[n];    &#125;&#125;;\n 1036. Escape a Large Maze\nIntuition:\ndfs: O(n ^ 2) 10 ^ 12 TLE.\nblocked.length 很小, 可以尝试从此做文章\nblocked把整个区域可以划分为几个region，判断source和target是否同region即可.\n由于blocked.length &lt;= 200, 可以算出最大的搜索空间为19900，当blocked cell与边界组成一个等腰直角三角形时。\n不过bound = 10000时，dfs就stack overflow了。5000时，可以通过所有的测试点。\n更好的实现是，使用迭代而不是递归，用栈实现dfs，或用队实现bfs都是不错的选择。\n时间复杂度: O(blocked.length ^ 2).\n空间复杂度: O(blocked.length ^ 2).\nclass Solution &#123;    const int bound = 5000;    const int border = 1e6;    int source_step = 0;    set&lt;pair&lt;int, int&gt;&gt; source_seen, target_seen, block_set;    bool find = false;    int target_step = 0;    void dfs(set&lt;pair&lt;int, int&gt;&gt;&amp; seen, int&amp; step, vector&lt;int&gt;&amp; target, int i, int j) &#123;        seen.insert(&#123;i, j&#125;);        ++step;        if (i == target[0] &amp;&amp; j == target[1]) &#123;            find = true;            return;        &#125;        if (step &gt; bound || find == true)            return;        vector&lt;int&gt; di = &#123;1, 0, -1, 0&#125;;        vector&lt;int&gt; dj = &#123;0, 1, 0, -1&#125;;        for (int k = 0; k &lt; 4; ++k) &#123;            int ni = i + di[k];            int nj = j + dj[k];            if (ni &gt;= 0 &amp;&amp; ni &lt; border &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; border &amp;&amp; seen.find(&#123;ni, nj&#125;) == seen.end() &amp;&amp; block_set.find(&#123;ni, nj&#125;) == block_set.end()) &#123;                dfs(seen, step, target, ni, nj);                if (step &gt; bound || find == true)                    return;            &#125;        &#125;        if (step &gt; bound || find == true)            return;    &#125;public:    bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) &#123;        for (const auto &amp; cell : blocked) &#123;            block_set.insert(&#123;cell[0], cell[1]&#125;);        &#125;        find = false;        dfs(source_seen, source_step, target, source[0], source[1]);        if (find) return true;        find = false;        dfs(target_seen, target_step, source, target[0], target[1]);        if (find) return true;        if (target_step &gt; bound &amp;&amp; source_step &gt; bound)            return true;        return false;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 135","url":"/2019/05/05/LeetCode-weekly-contest-135/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (5)\nQ4 (5)\n\n\n\n\n70 / 3635\nYoungForest\n15\n1:34:07\n0:07:28\n0:16:45\nnull\n1:29:07  (1)\n\n\n\n本周日是国内的工作日，参加LeetCode weekly contest的人直接少了1千，可见国内参与此比赛的热情。而且国人的实力一般也是排在世界前列的。所以我此次排名为70，首次进入前200，除了争分夺秒在结束前AC掉最后一题的功劳外，还有参赛大佬减少的原因。\n 5051. Valid Boomerang\nIntuition:\n分为判断distinct和not in a straight line两部分。\n3点共线可以用斜率直接判断。\n时间复杂度: O(1)\n空间复杂度: O(1)\nclass Solution &#123;    bool isSame(vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y) &#123;        return x[0] == y[0] &amp;&amp; x[1] == y[1];    &#125;public:    bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        return !isSame(points[0], points[1]) &amp;&amp; !isSame(points[1], points[2]) &amp;&amp; !isSame(points[2], points[0]) &amp;&amp; static_cast&lt;double&gt;(points[2][1] - points[1][1]) / static_cast&lt;double&gt;(points[2][0] - points[1][0]) != static_cast&lt;double&gt;(points[1][1] - points[0][1]) / static_cast&lt;double&gt;(points[1][0] - points[0][0]);    &#125;&#125;;\ndiscuss内发现的技巧：\n\n可以直接用面积是否为0同时判断 distinct和贡献，面积的公式用叉乘计算。\n判断斜率时，把除法转换成乘法会更好。此时也不需要提前判断distinct。\n\n我的解法会有除0的问题，\n但仍然能通过[[1,2],[1,1],[2,1]]这样的测试用例。\n仔细想想C++的浮点数除法，根据IEEE 754 标准，结果为+infinite。自然有不相等的结果。\n 1038. Binary Search Tree to Greater Sum Tree\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    int current = 0;    void recurse(TreeNode* root) &#123;        if (!root) return;        recurse(root-&gt;right);        current += root-&gt;val;        root-&gt;val = current;        recurse(root-&gt;left);    &#125;public:    TreeNode* bstToGst(TreeNode* root) &#123;        recurse(root);        return root;    &#125;&#125;;\n 1039. Minimum Score Triangulation of Polygon\n参考\nIntuition:\nDP.\n对于一个n边形，可以有一条直线，将其分为k, n - k 边形。\n这条直线肯定是三角形的一条边。\n再枚举另一个点的位置，更新最小值。\n时间复杂度：O(n ^ 3),\n空间复杂度：O(n ^ 2)\nclass Solution &#123;public:    int minScoreTriangulation(vector&lt;int&gt;&amp; A) &#123;        const int n = A.size();        vector&lt;vector&lt;int&gt;&gt; dp (n, vector&lt;int&gt; (n));        for (int d = 2; d &lt; n; ++d) &#123; // i, j 之间的距离            for (int i = 0; i + d&lt; n; ++i) &#123;   // 直线的一端                int j = i + d;  // 直线的另一端                dp[i][j] = numeric_limits&lt;int&gt;::max();                for (int k = i + 1; k &lt; j; ++k) &#123; // 三角形的另一个顶点                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[k] * A[j]);                &#125;            &#125;        &#125;                return dp[0][n-1];    &#125;&#125;;\n 1040. Moving Stones Until Consecutive II\n时间复杂度: O(n long n), 因为有个排序。\n空间复杂度: O(1)\nclass Solution &#123;public:    vector&lt;int&gt; numMovesStonesII(vector&lt;int&gt;&amp; stones) &#123;        // 贪心策略        // 最小：尽可能地收缩，答案一定小于size，连续的size内有多少石头，答案即为size-这个数目        // 特殊情况：这个区间涉及到头或尾，且补位的位置也是头尾，即 1 11这种情况，此时答案为2，而不是1        // 最大：先排个序，最小的跳到最大的左面，或 最大的额跳到最小的右面，剩下的每次收缩1        sort(stones.begin(), stones.end());        int size = stones.size();        int left = 0;        int minimum_moves = 0;        for(int i = 0; i &lt; size; ++i) &#123;            if (stones[i] &gt;= stones[left] + size) &#123;                while (stones[i] &gt;= stones[left] + size)                    ++left;            &#125;            minimum_moves = max(minimum_moves, i - left + 1);        &#125;        if (minimum_moves == size - 1 &amp;&amp; (stones[1] - stones[0] != 2 &amp;&amp; stones[size - 1] - stones[size - 2] != 2)) &#123;            minimum_moves = 2;        &#125; else &#123;            minimum_moves = size - minimum_moves;        &#125;                int maximum_moves = 0;        maximum_moves = max(stones[size - 2] - stones[0], stones[size - 1] - stones[1]) + 1 - size + 1;                return &#123;minimum_moves, maximum_moves&#125;;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 136","url":"/2019/05/12/LeetCode-weekly-contest-136/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (8)\n\n\n\n\n220 / 4109\nYoungForest\n15\n0:59:43\n0:17:07\n0:29:36\n0:54:43 (1)\nnull\n\n\n\n最近比赛的质量都还可以。即使是最简单的签到题，也是需要认真思考的。考察DP的题也是每次都有，DP算是那种你做很多，遇到新的题目还是可能写不出来的类型。\n本次恢复了原先的水平，跌到了200+。\n这次大概需要55分钟前3题，才能进入前200。我一是做题比较慢，二是 第3题DP有个下标问题搞错了，导致了一次罚时。所以遗憾地没有进入前200.\n 1041. Robot Bounded In Circle\nIntuition:\n执行instruction直到再此面朝北。因为只有4个方向，所以最多执行4次，也可能是2次或1次。\n如果此时不在原点，则继续走下去一定越走越远。否则就是一个circle.\n时间复杂度: O(instructions.length),\n空间复杂度: O(1)\nclass Solution &#123;    enum class Direction &#123;        north,        south,        west,        east    &#125;;public:    bool isRobotBounded(string instructions) &#123;        // 只要执行完一次instructions, 面朝北，同时不在原点，就没有圈。否则有圈        Direction direction = Direction::north;        int x = 0, y = 0;        do &#123;            for (char c : instructions) &#123;                if (c == &#x27;G&#x27;) &#123;                    switch (direction) &#123;                        case Direction::north:                            ++y;                            break;                        case Direction::south:                            --y;                            break;                        case Direction::west:                            --x;                            break;                        case Direction::east:                            ++x;                            break;                    &#125;                &#125; else if (c == &#x27;L&#x27;) &#123;                    switch (direction) &#123;                        case Direction::north:                            direction = Direction::west;                            break;                        case Direction::south:                            direction = Direction::east;                            break;                        case Direction::west:                            direction = Direction::south;                            break;                        case Direction::east:                            direction = Direction::north;                            break;                    &#125;                &#125; else if (c == &#x27;R&#x27;) &#123;                    switch (direction) &#123;                        case Direction::north:                            direction = Direction::east;                            break;                        case Direction::south:                            direction = Direction::west;                            break;                        case Direction::west:                            direction = Direction::north;                            break;                        case Direction::east:                            direction = Direction::south;                            break;                    &#125;                &#125;                // cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;int&gt;(direction) &lt;&lt; endl;            &#125;        &#125; while (direction != Direction::north);        return x == 0 &amp;&amp; y == 0;    &#125;&#125;;\n 1042. Flower Planting With No Adjacent\nIntuition:\n染色问题。因为一定存在解，所以可以基于贪心的思路。每次取可取颜色中的任意一个。\n时间复杂度: O(N),\n空间复杂度: O(N).\n有二维数组和2层循环，难道不是N^2嘛？事实上由于出入度 &lt;= 3, 颜色个数为4. 第二维的复杂度其实是个常数。\nclass Solution &#123;public:    vector&lt;int&gt; gardenNoAdj(int N, vector&lt;vector&lt;int&gt;&gt;&amp; paths) &#123;        vector&lt;int&gt; ret(N, 0);        vector&lt;vector&lt;int&gt;&gt; edges(N + 1);        vector&lt;set&lt;int&gt;&gt; remain_color(N + 1, &#123;1, 2, 3, 4&#125;);        for (const auto path : paths) &#123;            edges[path[0]].push_back(path[1]);            edges[path[1]].push_back(path[0]);        &#125;        for (int i = 1; i &lt;= N; ++i) &#123;            if (remain_color[i].begin() != remain_color[i].end()) &#123;                auto color = *(remain_color[i].begin());                ret[i - 1] = color;                for (auto j : edges[i]) &#123;                    remain_color[j].erase(color);                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;\n 1043. Partition Array for Maximum Sum\nIntuition:\n看到Array Maximum就可以想到动态规划了。\n动态规划，就要寻找递归子结构和最优表达式。\n回到本题，第i位的maxSumAfterPartitioning可以由前面的解得到。\n时间复杂度：O(A.size() * K)\n空间复杂度：O(A.size())\nclass Solution &#123;public:    int maxSumAfterPartitioning(vector&lt;int&gt;&amp; A, int K) &#123;        // dp        // dp[i] 表示以第i个元素结尾的数组的结果，i已经被划分到前一个子数组        int n = A.size();        vector&lt;int&gt; dp(n + 1, 0);        for (int i = 0; i &lt; n; ++i) &#123;            int max_value = A[i];            dp[i + 1] = max_value;            for (int j = 0; j &lt; K &amp;&amp; i - j &gt;= 0; ++j) &#123;                max_value = max(max_value, A[i - j]);                dp[i + 1] = max(dp[i + 1], dp[i - j] + (j + 1) * max_value);            &#125;            // cout &lt;&lt; dp[i+1] &lt;&lt; endl;        &#125;        return dp[n];    &#125;&#125;;\n 1044. Longest Duplicate Substring\n最后30min都在想本题，也尝试了明知会TLE的暴力解法。虽然心存侥幸，但果然超时了。\n暴力解法的思路很简单，每次把字符串向右平移一位，然后找相同的子字符串。\n时间复杂度: O(N ^ 2),\n空间复杂度: O(1).\n因为字符串的长度为10^5, n^2的算法一定超时。\nclass Solution &#123;public:    string longestDupSubstring(string S) &#123;        // 暴力解法，n^2. 肯定会超时        int global_max_begin = 0, global_max = 0;        for (int shift = 1; shift &lt; S.size(); ++shift) &#123;            int max_begin = 0, max_ = 0;            for (int i = shift; i &lt; S.size() &amp;&amp; i + global_max &lt; S.size(); ++i) &#123;                if (S[i] == S[i - shift]) &#123;                    ++max_;                    if (max_ &gt; global_max) &#123;                        global_max = max_;                        global_max_begin = max_begin + 1;                    &#125;                &#125; else &#123;                    max_ = 0;                    max_begin = i;                &#125;            &#125;        &#125;                return S.substr(global_max_begin, global_max);    &#125;&#125;;\n其实，这道题是经典题。什么是经典题呢？题目很明确，都是关键字，题面很短，没有一句废话。这类题目往往没有理解的困难和场景的包装，属于原始的题目。往往会就是会，不会就是不会。常常是之前做过就会，没做过就不会。\n解法1: suffix array + LCP(longest common prefix of the suffixes ) array\nkasais-algorithm\nclass Solution &#123;    // Structure to store information of a suffix     struct suffix     &#123;         int index; // To store original index         array&lt;int, 2&gt; rank; // To store ranks and next rank pair     &#125;;     // A comparison function used by sort() to compare two suffixes     // Compares two pairs, returns 1 if first pair is smaller     static constexpr auto cmp = [](const suffix&amp; a, const suffix&amp; b) -&gt; bool    &#123;         return (a.rank[0] == b.rank[0])? a.rank[1] &lt; b.rank[1]:             a.rank[0] &lt; b.rank[0];     &#125;;    // This is the main function that takes a string &#x27;txt&#x27; of size n as an     // argument, builds and return the suffix array for the given string     vector&lt;int&gt; buildSuffixArray(string txt)    &#123;         int n = txt.size();        // A structure to store suffixes and their indexes         struct suffix suffixes[n];         // Store suffixes and their indexes in an array of structures.         // The structure is needed to sort the suffixes alphabatically         // and maintain their old indexes while sorting         for (int i = 0; i &lt; n; i++)         &#123;             suffixes[i].index = i;             suffixes[i].rank[0] = txt[i] - &#x27;a&#x27;;             suffixes[i].rank[1] = ((i+1) &lt; n)? (txt[i + 1] - &#x27;a&#x27;): -1;         &#125;         // Sort the suffixes using the comparison function         // defined above.         sort(suffixes, suffixes+n, cmp);         // At his point, all suffixes are sorted according to first         // 2 characters. Let us sort suffixes according to first 4         // characters, then first 8 and so on         vector&lt;int&gt; ind(n); // This array is needed to get the index in suffixes[]         // from original index. This mapping is needed to get         // next suffix.         for (int k = 4; k &lt; 2*n; k = k*2)         &#123;             // Assigning rank and index values to first suffix             int rank = 0;             int prev_rank = suffixes[0].rank[0];             suffixes[0].rank[0] = rank;             ind[suffixes[0].index] = 0;             // Assigning rank to suffixes             for (int i = 1; i &lt; n; i++)             &#123;                 // If first rank and next ranks are same as that of previous                 // suffix in array, assign the same new rank to this suffix                 if (suffixes[i].rank[0] == prev_rank &amp;&amp;                         suffixes[i].rank[1] == suffixes[i-1].rank[1])                 &#123;                     prev_rank = suffixes[i].rank[0];                     suffixes[i].rank[0] = rank;                 &#125;                 else // Otherwise increment rank and assign                 &#123;                     prev_rank = suffixes[i].rank[0];                     suffixes[i].rank[0] = ++rank;                 &#125;                 ind[suffixes[i].index] = i;             &#125;             // Assign next rank to every suffix             for (int i = 0; i &lt; n; i++)             &#123;                 int nextindex = suffixes[i].index + k/2;                 suffixes[i].rank[1] = (nextindex &lt; n)?                                     suffixes[ind[nextindex]].rank[0]: -1;             &#125;             // Sort the suffixes according to first k characters             sort(suffixes, suffixes+n, cmp);         &#125;         // Store indexes of all sorted suffixes in the suffix array         vector&lt;int&gt;suffixArr;         for (int i = 0; i &lt; n; i++)             suffixArr.push_back(suffixes[i].index);         // Return the suffix array         return suffixArr;     &#125;     /* To construct and return LCP */    vector&lt;int&gt; kasai(string txt, vector&lt;int&gt; suffixArr)     &#123;         int n = suffixArr.size();         // To store LCP array         vector&lt;int&gt; lcp(n, 0);         // An auxiliary array to store inverse of suffix array         // elements. For example if suffixArr[0] is 5, the         // invSuff[5] would store 0. This is used to get next         // suffix string from suffix array.         vector&lt;int&gt; invSuff(n, 0);         // Fill values in invSuff[]         for (int i=0; i &lt; n; i++)             invSuff[suffixArr[i]] = i;         // Initialize length of previous LCP         int k = 0;         // Process all suffixes one by one starting from         // first suffix in txt[]         for (int i=0; i&lt;n; i++)         &#123;             /* If the current suffix is at n-1, then we don’t             have next substring to consider. So lcp is not             defined for this substring, we put zero. */            if (invSuff[i] == n-1)             &#123;                 k = 0;                 continue;             &#125;             /* j contains index of the next substring to             be considered to compare with the present             substring, i.e., next string in suffix array */            int j = suffixArr[invSuff[i]+1];             // Directly start matching from k&#x27;th index as             // at-least k-1 characters will match             while (i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; txt[i+k]==txt[j+k])                 k++;             lcp[invSuff[i]] = k; // lcp for the present suffix.             // Deleting the starting character from the string.             if (k&gt;0)                 k--;         &#125;         // return the constructed lcp array         return lcp;     &#125;public:    string longestDupSubstring(string S) &#123;        auto suffixArray = buildSuffixArray(S);        auto ret = kasai(S, suffixArray);        auto it = max_element(ret.begin(), ret.end());        if (*it == 0)            return &quot;&quot;;        return S.substr(*(suffixArray.begin() + distance(ret.begin(), it)), *it);    &#125;&#125;;\n时间复杂度: O(N log N), N = S.size().\n空间复杂度: O(N).\n另一种解法，使用了经典的二分搜索。trick的地方在于判断是否子字符串之前见过，使用了26进制编码的hashtable。\nclass Solution &#123;    string ret;    const int64_t prime = 288230376151711717;     bool compare(const string&amp; S, int first, int second, int len) &#123;        for (int i = 0; i &lt; len; ++i) &#123;            if (S[first + i] != S[second + i])                return false;        &#125;        return true;    &#125;    pair&lt;bool, int&gt; possible(const string&amp; S, int len) &#123;        // if the duplicate substring the length of which is len exist        unordered_map&lt;int64_t, vector&lt;int&gt;&gt; seen;        int64_t hash_code = 0;        int64_t highest_weight = 1;        for (int i = 0; i &lt; len; ++i) &#123;            hash_code = (hash_code * 26 + S[i] - &#x27;a&#x27;) % prime;            highest_weight = (highest_weight * 26) % prime;        &#125;        seen[hash_code].push_back(0);                for (int i = 1; i + len &lt;= S.size(); ++i) &#123;            hash_code = (hash_code * 26 + S[i + len - 1] - &#x27;a&#x27;) % prime;            hash_code = (hash_code + prime - (S[i - 1] - &#x27;a&#x27;)*highest_weight % prime) % prime;            if (seen.find(hash_code) != seen.end()) &#123;                for (auto begin_index : seen[hash_code]) &#123;                    if (compare(S, begin_index, i, len)) &#123;                        return &#123;true, i&#125;;                    &#125;                &#125;            &#125;            seen[hash_code].push_back(i);        &#125;        return &#123;false, -1&#125;;    &#125;public:    string longestDupSubstring(string S) &#123;        // true, true, true, ..., false        // lo, ...,                     hi        int lo = 0, hi = S.size();        while (lo &lt; hi) &#123;            int mid = lo + (hi - lo) / 2;            // cout &lt;&lt; mid &lt;&lt; &quot; &quot;;            auto r = possible(S, mid);            if (r.first) &#123;                // cout &lt;&lt; &quot;true&quot; &lt;&lt; endl;                lo = mid + 1;            &#125; else &#123;                // cout &lt;&lt; &quot;false&quot; &lt;&lt; endl;                hi = mid;            &#125;        &#125;        if (lo &lt;= 1) return &quot;&quot;;        auto r = possible(S, lo - 1);        // cout &lt;&lt; r.second &lt;&lt; &quot; &quot; &lt;&lt; lo - 1 &lt;&lt; &quot; &quot; &lt;&lt; S.size();        return S.substr(r.second, lo - 1);    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(N), hashtable + return value.\n第四题还是很难的。即使是我看discuss复现代码也用了半天时间。\nkasai算法基本上是复制的，要自己写还是很难写对。\n二分法，在26进制编码的时候踩了坑，忘记字符 - 'a'了。之后又在二分搜索的不变式上花了不少时间。正如 编程珠玑 所说，只有10%的程序员可以将二分查找一次写对，坑太多。推荐个别人的教程. 区间前闭后开，区间收缩时保持不变性，如何用lower_bound和upper_bound完成其他的二分任务，这些讲的都十分清楚。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 137","url":"/2019/05/19/LeetCode-weekly-contest-137/","content":"本周的题目要比以往的难，也可以说恰好考到我的知识盲区，DP问题。老实的说，我对DP问题没有过深入的研究。这次DP题目尤其多，尤其是第4题，更是可以可以用经典的背包问题求解。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (8)\n\n\n\n\n576 / 4091\nYoungForest\n13\n0:45:56\n0:09:24\n0:14:20\n0:35:56  2\nnull\n\n\n\n 1046. Last Stone Weight\nIntuition：\n本题解法不难。我首先想到了最暴力的模拟整个smash的过程的解法。因为是签到题，暴力解也够了。\n时间复杂度: O(n^2 log n)\n空间复杂度: O(1)\nclass Solution &#123;public:    int lastStoneWeight(vector&lt;int&gt;&amp; stones) &#123;        // 模拟smash        // sort        // pick two heaviest        // smash        // n^2 log n        while (stones.size() &gt; 1) &#123;            sort(stones.begin(), stones.end());            int n = stones.size();            stones[n - 2] = stones[n - 1] - stones[n - 2];            stones.pop_back();        &#125;        return stones[0];    &#125;&#125;;\n但事实上，同样是模拟smash的过程，找到最大的2个石头。我用的办法是sort，该操作的时间复杂度为O(n log n). 大佬们就能想到优先队列(Priority Queue), 找石头的时间复杂度为O(log n). 而且我的解法并没有专门处理x == y的情况，虽然不会出什么问题，但确实不符合模拟过程的初衷。\n Priority queue 版本\n时间复杂度：O(N log N)\n空间复杂度: O(1)\nclass Solution &#123;public:    int lastStoneWeight(vector&lt;int&gt;&amp; stones) &#123;        priority_queue&lt;int&gt; pq(stones.begin(), stones.end());        while (pq.size() &gt; 1) &#123;            int y = pq.top();            pq.pop();            int x = pq.top();            pq.pop();            if (y &gt; x)                pq.push(y - x);        &#125;        return pq.empty() ? 0 : pq.top();    &#125;&#125;;\n 1047. Remove All Adjacent Duplicates In String\nIntuition:\n用栈来保存之前的数，依次读取下一个数，视条件进行remove操作。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    string removeDuplicates(string S) &#123;        stack&lt;char&gt; s;        for (char c : S) &#123;            if (s.empty()) &#123;                s.push(c);            &#125; else if (s.top() == c) &#123;                s.pop();            &#125; else &#123;                s.push(c);            &#125;        &#125;        string ret;        while (!s.empty()) &#123;            ret.push_back(s.top());            s.pop();        &#125;        reverse(ret.begin(), ret.end());        return ret;    &#125;&#125;;\n使用 stack 应该是该题的标准解法，大佬们也基本上都用的同样的方法。\n 1048. Longest String Chain\nIntuition:\nDP. 对于每个单词，遍历一遍比它短1的所有单词，更新成最大的dp+1。\n时间复杂度: O(N^2 * word.length)\n空间复杂度: O(N).\n其中N为words.length.\nclass Solution &#123;    bool isPredecessor(const string&amp; last, const string&amp; current) &#123;        if (last.size() + 1 != current.size())            return false;        int flag = 0;        for (int i = 0; i &lt; last.size();) &#123;            if (last[i] == current[i + flag]) &#123;                ++i;                continue;            &#125;            if (flag == 0)                ++flag;            else                return false;        &#125;        return true;    &#125;public:    int longestStrChain(vector&lt;string&gt;&amp; words) &#123;        vector&lt;vector&lt;pair&lt;string, int&gt;&gt;&gt; dp(16);        for (const auto&amp; s : words) &#123;            dp[s.size() - 1].push_back(&#123;s, 1&#125;);        &#125;        // for (const auto&amp; i : dp) &#123;        //     for (const auto&amp; j : i) &#123;        //         cout &lt;&lt; j.first &lt;&lt; &quot; &quot;;        //     &#125;        //     cout &lt;&lt; endl;        // &#125;        int ret = 1;        for (int i = 1; i &lt; 16; ++i) &#123;            int last_length = i - 1;            const auto&amp; last_dp = dp[last_length];            auto&amp; current_dp = dp[i];            for (auto&amp; current : current_dp) &#123;                for (const auto&amp; last : last_dp) &#123;                    if (isPredecessor(last.first, current.first)) &#123;                        current.second = max(current.second, last.second + 1);                        ret = max(ret, current.second);                    &#125;                &#125;            &#125;        &#125;        // for (const auto&amp; i : dp) &#123;        //     for (const auto&amp; j : i) &#123;        //         cout &lt;&lt; &quot;(&quot; &lt;&lt; j.first &lt;&lt; &quot; &quot; &lt;&lt; j.second &lt;&lt; &quot;), &quot;;        //     &#125;        //     cout &lt;&lt; endl;        // &#125;        return ret;    &#125;&#125;;\nDiscuss总结：大概只有2种方法，DP(bottom-top)和DFS。DFS的复杂度会更高些，需要用memoization，其实也就是top-bottom的DP。\n 1049. Last Stone Weight II\nIntuition:\nbacktracking.\n时间复杂度：O(N!), N = 30. 所以肯定会超时。\n另外，我还尝试了Greedy的方法。\n但并没有找到正确的解并证明它，试了2次，都Wrong Answer了。\n正确的思路：\n考虑一个smash剩下的石头y - x，再次被smash，则有剩下的石头z - (y - x) = z - y + x。\n任何一个初始的石头，如果被smash的次数是奇数，则前面是 负号，反之，正号。\n所以，原始问题可以转化为 将所有石头分成2份，求2份石头差的绝对值的最小值。\n该问题是经典的背包问题之一“minimum knapsack partition”。\n Solution: DP for classic knapsack problem\nclass Solution &#123;public:    int lastStoneWeightII(vector&lt;int&gt;&amp; stones) &#123;        const int sum_bound = 1500;        bitset&lt;1500 + 1&gt; dp &#123;1&#125;; // present whether the sum of group is i is possible; initial true when i == 0          int sumOfStones = 0;        for (auto stone : stones) &#123;            sumOfStones += stone;            for (int i = sum_bound; i &gt;= stone; --i) &#123;  // reverse traversal is needed, for a stone can be used only once                dp[i] = dp[i] + dp[i - stone];            &#125;        &#125;        int ret = numeric_limits&lt;int&gt;::max();        for (int i = 0; i &lt;= sum_bound; ++i) &#123;            ret = min(ret, abs(sumOfStones - dp[i]*i*2));        &#125;        return ret;    &#125;&#125;;\n时间复杂度: O(sum_bound * stones.size())\n空间复杂度: O(sum_bound)\nC++ 中 Bitset 是内含bit 或 Boolean值且大小固定的array。对其不熟悉的同学，可以看看《C++ 标准库 第二版》（C++ Standard library)这本书。我最近也在看，目的是熟悉一下C++的标准库，学习其中的智慧和用法。\n除了使用Bitset外，直接使用set\n 后记\n周五剁手买了一年的LeetCode Premium, 花了159刀，大概1000元RMB。\n刷题走起！！！\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly conteset 138","url":"/2019/05/26/LeetCode-weekly-contest-138/","content":"本周比赛虽然题目质量还不错，但难度不高，是一场比拼速度的题目。\n因为第二题题目比较长，所以我做题的顺序是 1-&gt;3-&gt;4-&gt;2。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (8)\n\n\n\n\n247 / 4143\nYoungForest\n20\n0:57:43\n0:11:19\n0:52:43 (1)\n0:27:35\n0:36:44\n\n\n\n 1051. Height Checker\nIntuition:\n简单的排序，然后遍历比较一遍。\n时间复杂度: O(N log N)\n空间复杂度: O(N)\nclass Solution &#123;public:    int heightChecker(vector&lt;int&gt;&amp; heights) &#123;        auto copy = heights;        sort(copy.begin(), copy.end());        int ret = 0;        for (int i = 0; i &lt; heights.size(); ++i) &#123;            if (copy[i] != heights[i])                ++ret;        &#125;        return ret;    &#125;&#125;;\n 1052. Grumpy Bookstore Owner\n本题是最后做的，花费了不少时间。本次进不了前200的原因，首先是第一题读懂题目花了过长的时间，其次就是本题有些着急做，直接写代码，写错了思路，后来才改的。然后是本题还有一次罚时，是因为第一次忘记更新max_wanhui了。事实上，我刚开始是记得要更新的，但是写的时候就忘了。\n教训就是，先把题的算法想好，确定可行在写代码；另外，需要先写test case，尤其是corner case，再想算法，再下笔。这样可以有效验证算法和代码的正确性。\nIntuition:\n滑动窗口。不断更新最大的挽回损失的值。\n时间复杂度: O(N).\n空间复杂度: O(1).\nclass Solution &#123;public:    int maxSatisfied(vector&lt;int&gt;&amp; customers, vector&lt;int&gt;&amp; grumpy, int X) &#123;        int n = customers.size();        const int total_customers = accumulate(customers.cbegin(), customers.cend(), 0);        int sunshi = 0;        for (int i = 0; i &lt; n; ++i) &#123;            if (grumpy[i] == 1)                sunshi += customers[i];        &#125;        int max_wanhui = 0;        int wanhui = 0;        for (int i = 0; i &lt; X; ++i) &#123;            if (grumpy[i] == 1)                wanhui += customers[i];        &#125;        max_wanhui = max(max_wanhui, wanhui);                for (int i = X; i &lt; n; ++i) &#123;            if (grumpy[i] == 1)                wanhui += customers[i];            if (grumpy[i - X] == 1)                wanhui -= customers[i - X];            max_wanhui = max(max_wanhui, wanhui);        &#125;        // cout &lt;&lt; total_customers &lt;&lt; &quot; &quot; &lt;&lt; sunshi &lt;&lt; &quot; &quot; &lt;&lt; max_wanhui &lt;&lt; endl;        return total_customers - sunshi + max_wanhui;    &#125;&#125;;\n 1053. Previous Permutation With One Swap\nIntuition:\nGreedy. 我们想要找到一次交换产生的 最大的比当前小的枚举序列。\n首先，要使枚举序列变小，必需交换一个大值和一个小值。\n然后，为了使得交换后的序列尽可能大，大值需要尽可能靠后，小值也需尽可能靠后。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; prevPermOpt1(vector&lt;int&gt;&amp; A) &#123;        int larger_index = A.size() - 1;        while (larger_index &gt;= 1) &#123;            if (A[larger_index] &gt;= A[larger_index - 1]) &#123;                --larger_index;            &#125; else &#123;                break;            &#125;        &#125;        if (larger_index == 0)            return A;        --larger_index;        auto insert_it = lower_bound(A.cbegin() + larger_index + 1, A.cend(), A[larger_index]);        int swap_index = std::distance(A.cbegin(), insert_it) - 1;        swap(A[swap_index], A[larger_index]);                return A;    &#125;&#125;;\n 1054. Distant Barcodes\nIntuition:\nGreedy. 每次取频数最大的数，同时需要保证该数不是前一个数。\n用一个 优先队列 恰好可以方便地实现取频数最大的数的需求。\n时间复杂度: O(N log N), 优先队列的基本操作push的复杂度是O(log N). 如果对STL里的算法和container, adapter不熟的话，我再推荐一遍《C++ 标准库 第二版》（C++ Standard library)这本书。\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; rearrangeBarcodes(vector&lt;int&gt;&amp; barcodes) &#123;        map&lt;int, int&gt; count;        for (int barcode : barcodes) &#123;            ++count[barcode];        &#125;        priority_queue&lt;pair&lt;int, int&gt;&gt; pq;        for (const auto&amp; p : count) &#123;            pq.push(&#123;p.second, p.first&#125;);        &#125;        vector&lt;int&gt; ret;        pair&lt;int, int&gt; old_top;        while (!pq.empty()) &#123;            auto t = pq.top();            pq.pop();            ret.push_back(t.second);            --t.first;            if (old_top.first &gt; 0)                pq.push(old_top);            old_top = t;        &#125;        if (old_top.first &gt; 0)            ret.push_back(old_top.second);        return ret;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 139","url":"/2019/06/03/LeetCode-weekly-contest-139/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (8)\n\n\n\n\n855 / 3985\nYoungForest\n10\n1:03:50\n0:53:00\n1:03:50\n赛后做出来\nnull\n\n\n\n周日起来的时候已经11点多了，算是迟到40min才参加的比赛。顺利作出了前2题，第3题开始走了些弯路，赛后才做出来。如果时间够的话，第3题作出应该没意思。\n 1071. Greatest Common Divisor of Strings\nIntuition:\n此题相当于是找2个数的最大公约数。\nGreatest Common Divisor的长度一定等于最大公约数或0.\n简单的证明如下：\n设答案的长度为x, str1由x组成，所以x一定是str1.length的约数. 同样，也是str2.length。\n假设x不是最大公约数，可以组成str1和str2。那么最大公约数也一定可以组成str1和str2。\n时间复杂度: O(log N)\n空间复杂度: O(N)\nclass Solution &#123;    int gcd(int a, int b) &#123;        if (b &gt; a) &#123;            swap(a, b);        &#125;        while (b &gt; 0) &#123;            auto temp = b;            b = a % b;            a = temp;        &#125;        return a;    &#125;public:    string gcdOfStrings(string str1, string str2) &#123;        int len1 = str1.size();        int len2 = str2.size();        auto common_len = gcd(len1, len2);        auto t1 = str1.substr(0, common_len);        auto t2 = str2.substr(0, common_len);        return t1 == t2 ? t1 : &quot;&quot;;    &#125;&#125;;\n 1072. Flip Columns For Maximum Number of Equal Rows\nIntuition:\n寻找互补的行 的最大数量。\n时间复杂度: O(matrix.length * matrix[0].length)\n空间复杂度: O(matrix.length * matrix[0].length)\nclass Solution &#123;public:    int maxEqualRowsAfterFlips(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        unordered_map&lt;string, int&gt; count;        int ret = 0;        for (const auto&amp; row : matrix) &#123;            string right, complete;            for (int item : row) &#123;                right.push_back(item + &#x27;0&#x27;);                complete.push_back(((~item) &amp; 1) + &#x27;0&#x27;);            &#125;            ++count[right];            ++count[complete];            ret = max(&#123;ret, count[right], count[complete]&#125;);        &#125;        return ret;    &#125;&#125;;\n 1073. Adding Two Negabinary Numbers\nIntuition:\n模仿2进制。不同之处在于进位可能是-1，1，0。\n时间复杂度: O(max(arr.size(), arr.size()))\n共建复杂度: O(max(arr.size(), arr.size()))\nclass Solution &#123;    void update(int&amp; digit, int&amp; carry) &#123;        if (digit == -1) &#123;            digit = 1;            carry = 1;        &#125; else if (digit == 2) &#123;            carry = -1;            digit = 0;        &#125; else if (digit == 3) &#123;            carry = -1;            digit = 1;        &#125; else &#123;            carry = 0;        &#125;    &#125;public:    vector&lt;int&gt; addNegabinary(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123;        int carry = 0;        vector&lt;int&gt; ret;        int i, j;        for (i = arr1.size() - 1, j = arr2.size() - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; --i, --j) &#123;            int digit = arr1[i] + arr2[j] + carry;            update(digit, carry);            ret.push_back(digit);        &#125;        for (; i &gt;= 0; --i) &#123;            int digit = arr1[i] + carry;            update(digit, carry);            ret.push_back(digit);        &#125;        for (; j &gt;= 0; --j) &#123;            int digit = arr2[j] + carry;            update(digit, carry);            ret.push_back(digit);        &#125;        if (carry == 1)            ret.push_back(1);        else if (carry == -1) &#123;            ret.push_back(1);            ret.push_back(1);        &#125;        while(ret.size() &gt; 1 &amp;&amp; ret.back() == 0)            ret.pop_back();        reverse(ret.begin(), ret.end());                return ret;    &#125;&#125;;\n 1074. Number of Submatrices That Sum to Target\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 140","url":"/2019/06/09/LeetCode-weekly-contest-140/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (8)\n\n\n\n\n313 / 4046\nYoungForest\n16\n1:03:21\n0:21:32 (1)\n0:36:08\n0:53:21 (1)\nnull\n\n\n\n本次比赛难度适中，由于评测程序的问题，很多人被第三题坑了。赛后test case修改正确了。这已经不是LeetCode第一次出现事故了。\n 5083. Occurrences After Bigram\n思路：\n签到题，直接做。用一个状态机来记录当前的状态。\n时间复杂度: O(text.size()),\n空间复杂度: O(1). 我的实现中，为了方便将token存在一个vector中，其实是没必要的。\nclass Solution &#123;    enum class State &#123;        other,        first,        second    &#125;;public:    vector&lt;string&gt; findOcurrences(string text, string first, string second) &#123;        vector&lt;string&gt; ret;        istringstream iss(text);        vector&lt;string&gt; tokens&#123;istream_iterator&lt;string&gt;&#123;iss&#125;, &#123;&#125;&#125;;        State state = State::other;        for (const auto &amp; token : tokens) &#123;            if (state == State::second) &#123;                ret.push_back(token);                state = State::other;            &#125;            if (token == first) &#123;                state = State::first;            &#125; else if (token == second &amp;&amp; state == State::first) &#123;                state = State::second;            &#125; else &#123;                state = State::other;            &#125;        &#125;        return ret;    &#125;&#125;;\n 5087. Letter Tile Possibilities\n由于数据规模比较小，tiles.length &lt;= 7, 所以直接暴力枚举所有的可能即可。\n时间复杂度: O(N!),\n空间复杂度: O(N!).\nclass Solution &#123;    set&lt;string&gt; ret;    void backtracking(map&lt;char, int&gt;&amp; count, int size, int step, string&amp; current) &#123;        if (step == size) &#123;            ret.insert(current);            return;        &#125;        for (auto&amp; p : count) &#123;            char c = p.first;            if (count[c] &gt; 0) &#123;                --count[c];                current.push_back(c);                backtracking(count, size, step + 1, current);                current.pop_back();                ++count[c];            &#125;        &#125;     &#125;public:    int numTilePossibilities(string tiles) &#123;        map&lt;char, int&gt; count;        for (char tile : tiles) &#123;            ++count[tile];        &#125;        int s = tiles.size();        for (int len = 1; len &lt;= s; ++len) &#123;            string current;            backtracking(count, len, 0, current);        &#125;        // for (auto&amp; s : ret) &#123;        //     cout &lt;&lt; s &lt;&lt; &quot; &quot;;        // &#125;        return ret.size();    &#125;&#125;;\n 5084. Insufficient Nodes in Root to Leaf Paths\n典型的递归题目。根据题目描述删除结点即可，如果对树的递归比较熟悉的话，写起来很快。\n需要注意的是，叶子结点的定义是左右子树均为null，而不是左子树或又子树。\n时间复杂度: O(N), 树中每个结点要调用一次递归函数。\n空间复杂度: O(N), 树的深度。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    int limit = 0;    // return: 是否删除，子树从根到叶子最大的sum    // current: 从根到父节点的sum    pair&lt;TreeNode*, int&gt; recurse(TreeNode* root, int current) &#123;      if (root == nullptr) &#123;            return &#123;nullptr, 0&#125;;        &#125;        auto l = recurse(root-&gt;left, current + root-&gt;val);        auto r = recurse(root-&gt;right, current + root-&gt;val);        TreeNode* ret_ptr = nullptr;        int ret_int;        if (root-&gt;left != nullptr &amp;&amp; root-&gt;right != nullptr)            ret_int = max(l.second, r.second);        else if (root-&gt;left != nullptr)            ret_int = l.second;        else if (root-&gt;right)            ret_int = r.second;        else    // 叶子结点            ret_int = 0;        root-&gt;left = l.first;        root-&gt;right = r.first;        // cout &lt;&lt; root-&gt;val &lt;&lt; &quot; : &quot; &lt;&lt; ret_int &lt;&lt; endl;        if (ret_int + root-&gt;val + current &gt;= limit) &#123;            return &#123;root, ret_int + root-&gt;val&#125;;        &#125; else &#123;            return &#123;nullptr, ret_int + root-&gt;val&#125;;        &#125;    &#125;public:    TreeNode* sufficientSubset(TreeNode* root, int limit) &#123;        this-&gt;limit = limit;        auto ret = recurse(root, 0);        return ret.first;    &#125;&#125;;\n 5086. Smallest Subsequence of Distinct Characters\n这道题目在赛中没有做出来。我尝试用贪心的解法，每次添加一个字符。但这种贪心其实是错误的，无法处理形如\n“ddeeeccdce”\n这样的输入。\n当处理最后一个d时，&quot;ecd&quot;无法比&quot;dec&quot;大。\n// 错误的贪心思路// 时间复杂度: O(N^2)// 空间复杂度: O(N)class Solution &#123;public:    string smallestSubsequence(string text) &#123;        string current;        for (int i = 0; i &lt; text.size(); ++i) &#123;            char c = text.at(i);            auto index = current.find(c);            if (index == string::npos) &#123;                current.push_back(c);            &#125; else &#123;                string new_current = current.substr(0, index) + current.substr(index + 1);                new_current.push_back(c);                if (new_current &lt; current) &#123;                    current = std::move(new_current);                &#125;            &#125;        &#125;        return current;    &#125;&#125;;\n正确的思路:\n完全相同的题目 LeetCode 316.\n此题中的discuss中有很多高质量的回答。\n对于输入的字符串，我们尝试单调递增的结果字符串。如果输入字符小于结果字符串的最后一个，并且最后的这个字符之后还会出现，则 我们从结果字符串中移除掉这个字符。\n这其实也是贪心的思路。每次操作都会让字符串变得更小。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    string smallestSubsequence(string text) &#123;        unordered_map&lt;char, int&gt; used, count;        for (char c : text) &#123;            ++count[c];        &#125;        string ret;        for (char c : text) &#123;            --count[c];            if (used[c]++ &gt; 0) &#123;                continue;            &#125;            while (!ret.empty() &amp;&amp; ret.back() &gt; c &amp;&amp; count[ret.back()] &gt; 0) &#123;                used[ret.back()] = 0;                ret.pop_back();            &#125;            ret.push_back(c);        &#125;        return ret;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 141","url":"/2019/06/16/LeetCode-weekly-contest-141/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (8)\n\n\n\n\n234 / 4126\nYoungForest\n22\n1:18:45\n0:25:23  1\n0:36:29\n0:51:47\n1:13:45\n\n\n\n周一自然辩证法考试，周二矩阵考试，还是强行抽出时间参加contest。本身复习就不充分，平时的学习也没有十分扎实，我也是心大。\n200名的时间至少要在1:14:23以内。\n 1089. Duplicate Zeros\nIntuition:\n因为要求in-place, 一个自然的想法是从后向前更新值。\n2次遍历，第一次正向遍历，得到结果数组最后一位的原始坐标。\n第二次逆向遍历，更新结果数组。\nTime complexity: O(N),\nSpace complexity: O(1).\nclass Solution &#123;public:    void duplicateZeros(vector&lt;int&gt;&amp; arr) &#123;        int zeros = 0;        int i = 0;        for (i = 0; i &lt; arr.size() &amp;&amp; i + zeros &lt; arr.size(); ++i) &#123;            if (arr[i] == 0) &#123;                ++zeros;            &#125;        &#125;        --i;        for (int j = arr.size() - 1; j &gt;= 0; --j, --i) &#123;            arr[j] = arr[i];            if (arr[i] == 0 &amp;&amp; (i + zeros &lt; arr.size())) &#123;                --j;    // 多减一j                if (j &gt;= 0)                    arr[j] = 0;            &#125;        &#125;    &#125;&#125;;\n因为忽略 最后一个0如果位数不够的话，将不进行扩展。被罚时一次。\n测试用例:\n[0][0,0][0,0,0][0,0,1][8,4,5,0,0,0,0,7][8,4,5,0,0,0,0,0,7]\n 1090. Largest Values From Labels\nIntuition：\n贪心思路。总是试图加入value最大的item。\n具体实现为 先排序，并且用一个hashtable保证不违反 use_limit的限制。\nTime complexity: O(N log N),\nSpace complexity: O(N)\nclass Solution &#123;public:    int largestValsFromLabels(vector&lt;int&gt;&amp; values, vector&lt;int&gt;&amp; labels, int num_wanted, int use_limit) &#123;        vector&lt;pair&lt;int, int&gt;&gt; items;        for (int i = 0; i &lt; values.size(); ++i) &#123;            items.push_back(&#123;values.at(i), labels.at(i)&#125;);        &#125;        sort(items.begin(), items.end(), std::greater&lt;pair&lt;int, int&gt;&gt;());        unordered_map&lt;int, int&gt; used;        int num = 0;        int index = 0;        int ret = 0;        while (num &lt; num_wanted &amp;&amp; index &lt; items.size()) &#123;            const auto&amp; p = items.at(index);            if (used[p.second] &lt; use_limit) &#123;                ++used[p.second];                ++num;                ret += p.first;            &#125;            ++index;        &#125;        return ret;    &#125;&#125;;\n测试用例：\n[5,4,3,2,1][1,1,2,2,3]31[5,4,3,2,1][1,3,3,3,2]32[9,8,8,7,6][0,0,0,1,1]31[9,8,8,7,6][0,0,0,1,1]32\n 1091. Shortest Path in Binary Matrix\nIntuition:\n求最短路径，用DFS。\nTime complexity: O(N^2),\nSpace complexity: O(N^2).\nclass Solution &#123;public:    int shortestPathBinaryMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        // bfs        int n = grid.size();        set&lt;pair&lt;int, int&gt;&gt; visited;        queue&lt;pair&lt;int, int&gt;&gt; q;        if (grid[0][0] == 0)            q.push(&#123;0, 0&#125;);        int level = 1;        while (!q.empty()) &#123;            int s = q.size();            for (int i = 0; i &lt; s; ++i) &#123;                auto current = q.front();                q.pop();                if (current.first == n - 1 &amp;&amp; current.second == n - 1) &#123;                    return level;                &#125;                for (auto di : &#123;-1, 0, 1&#125;) &#123;                    for (auto dj : &#123;-1, 0, 1&#125;) &#123;                        int ni = current.first + di, nj = current.second + dj;                        if (ni == current.first &amp;&amp; nj == current.second)                            continue;                        if (visited.find(&#123;ni, nj&#125;) != visited.end())                            continue;                        if (ni &lt; 0 || ni &gt;= n || nj &lt; 0 || nj &gt;= n)                            continue;                        if (grid[ni][nj] == 1)                            continue;                        visited.insert(&#123;ni, nj&#125;);                        q.push(&#123;ni, nj&#125;);                    &#125;                &#125;            &#125;            ++level;        &#125;        return -1;    &#125;&#125;;\n我的测试用例：\n[[0,1],[1,0]][[0,0,0],[1,1,0],[1,1,0]][[0,0,0],[0,1,0],[0,1,0]][[0,0,0],[0,1,1],[0,1,0]][[0]][[1]][[0,1,0,0,0],[0,1,0,1,0],[0,1,0,1,0],[0,1,0,1,0],[0,0,0,1,0]][[0,1,0,0,0],[0,1,0,1,0],[0,1,1,1,0],[0,1,0,1,0],[0,0,0,1,0]]\n期望结果：\n244-11-113-1\n 1092. Shortest Common Supersequence\nIntuition:\n先求出 最长公共子序列(Longest Common Subsequence).\n然后补齐多余的字符。\n最长公共子序列的模版很重要，需要快速实现。\nTime Complexity: O(str1.size() * str2.size()),\nSpace Complexity: O(str1.size() * str2.size()).\nclass Solution &#123;    enum class Direction &#123;        left,        up,        left_up    &#125;;public:    string shortestCommonSupersequence(string str1, string str2) &#123;        vector&lt;vector&lt;pair&lt;int, Direction&gt;&gt;&gt; v(str1.size() + 1, vector&lt;pair&lt;int, Direction&gt;&gt;(str2.size() + 1));        v[0][0] = &#123;0, Direction::left_up&#125;;        for (int i = 1; i &lt; str1.size() + 1; ++i) &#123;            v[i][0] = &#123;0, Direction::up&#125;;        &#125;        for (int i = 1; i &lt; str2.size() + 1; ++i) &#123;            v[0][i] = &#123;0, Direction::left&#125;;        &#125;        for (int i = 1; i &lt; str1.size() + 1; ++i) &#123;            for (int j = 1; j &lt; str2.size() + 1; ++j) &#123;                if (str1.at(i - 1) == str2.at(j - 1)) &#123;                    v[i][j] = &#123;v[i-1][j-1].first + 1, Direction::left_up&#125;;                &#125; else if (v[i][j-1].first &gt; v[i-1][j].first) &#123;                    v[i][j] = &#123;v[i][j-1].first, Direction::left&#125;;                &#125; else &#123;                    v[i][j] = &#123;v[i-1][j].first, Direction::up&#125;;                &#125;            &#125;        &#125;        string ret;        int i = str1.size(), j = str2.size();        while (i &gt; 0 || j &gt; 0) &#123;            switch (v[i][j].second) &#123;                case Direction::left_up:                    ret.push_back(str1.at(i - 1));                    --i;                    --j;                    break;                case Direction::up:                    ret.push_back(str1.at(i - 1));                    --i;                    break;                case Direction::left:                    ret.push_back(str2.at(j - 1));                    --j;                    break;            &#125;        &#125;        reverse(ret.begin(), ret.end());        return ret;    &#125;&#125;;\n我的测试用例：\n&quot;abac&quot;&quot;cab&quot;&quot;geek&quot;&quot;eke&quot;&quot;AGGTAB&quot;&quot;GXTXAYB&quot;\n期望结果：\n&quot;cabac&quot;&quot;gekek&quot;&quot;AGXGTXAYB&quot;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 142","url":"/2019/06/23/LeetCode-weekly-contest-142/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (5)\nQ2 (5)\nQ3 (8)\nQ4 (8)\n\n\n\n\n851 / 4504\nYoungForest\n13\n1:39:38\nnull\n1:00:12 2\n1:19:38 2\nnull\n\n\n\n本次比赛的失误主要在于第二题sort中的cmp函数写错了，没有保证 严格有序。一直segment fault。即 a &lt; b, 必有 b !&lt; a.\n 1093. Statistics from a Large Sample\nIntution:\n熟悉C++和统计中的这5个统计值的意义即可。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    vector&lt;double&gt; sampleStats(vector&lt;int&gt;&amp; count) &#123;        double minimum = 255.0, maximum = 0.0, mean = 0.0, median = 0.0, mode = 0.0;        auto minimum_it = find_if(count.cbegin(), count.cend(), [](const auto &amp; a) -&gt; bool &#123;            return a &gt; 0;        &#125;);        minimum = minimum_it - count.cbegin();        auto max_it = find_if(count.crbegin(), count.crend(), [](const auto &amp; a) -&gt; bool &#123;            return a &gt; 0;        &#125;);        maximum = static_cast&lt;int&gt;(count.size()) - (max_it - count.crbegin()) - 1;                int num = 0;        for (int i = 0; i &lt; count.size(); ++i) &#123;            mean += i * count[i];            num += count[i];        &#125;        mean /= num;        int total = num;        num = 0;        for (int i = 0; i &lt; count.size(); ++i) &#123;            if (count[i] == 0)                continue;            num += count[i];            if (num * 2 &gt; total) &#123;                if (median &gt; 0) &#123;                    median = (median + i) / 2;                &#125; else &#123;                    median = i;                &#125;                break;            &#125; else if (num * 2 == total) &#123;                median = i;            &#125;        &#125;                auto mode_it = max_element(count.cbegin(), count.cend());        mode = mode_it - count.cbegin();                return &#123;minimum, maximum, mean, median, mode&#125;;    &#125;&#125;;\n 1094. Car Pooling\nIntuition:\n模拟整个上下车的过程。在每个站台判断是否超载。\n时间复杂度: O(N log N)\n空间复杂度: O(N)\nclass Solution &#123;public:    bool carPooling(vector&lt;vector&lt;int&gt;&gt; &amp;trips, int capacity) &#123;       map&lt;int, int&gt; stops;       for (const auto&amp; trip : trips) &#123;           stops[trip[1]] += trip[0];           stops[trip[2]] -= trip[0];       &#125;       int passengers = 0;       for (const auto&amp; stop : stops) &#123;           passengers += stop.second;           if (passengers &gt; capacity)               return false;       &#125;       return true;    &#125;&#125;;\n 1095. Find in Mountain Array\n本题算是一类新题型：交互式问题。\n3次 二分搜索搞定。\n时间复杂度: O(log N).\n空间复杂度: O(1).\n/** * // This is the MountainArray&#x27;s API interface. * // You should not implement it, or speculate about its implementation * class MountainArray &#123; *   public: *     int get(int index); *     int length(); * &#125;; */class Solution &#123;public:    int findInMountainArray(int target, MountainArray &amp;mountainArr) &#123;        int lo = 0, hi = mountainArr.length();        while (lo &lt; hi) &#123;            int mid = lo + (hi - lo) / 2;            if (mid == mountainArr.length() - 1) &#123;                hi = mid;                continue;            &#125;            if (mountainArr.get(mid) &lt; mountainArr.get(mid + 1))                lo = mid + 1;            else                 hi = mid;        &#125;                int mountain = lo;        // cout &lt;&lt; &quot;mountain: &quot; &lt;&lt; mountain &lt;&lt; endl;        lo = 0, hi = mountain + 1;        while (lo &lt; hi) &#123;            int mid = lo + (hi - lo) / 2;            if (mountainArr.get(mid) &lt; target)                lo = mid + 1;            else                 hi = mid;        &#125;        // cout &lt;&lt; &quot;first: &quot; &lt;&lt; lo &lt;&lt; endl;        if (mountainArr.get(lo) == target)            return lo;        lo = mountain, hi = mountainArr.length();        while (lo &lt; hi) &#123;            int mid = lo + (hi - lo) / 2;            if (mountainArr.get(mid) &gt; target)                lo = mid + 1;            else                 hi = mid;        &#125;        // cout &lt;&lt; &quot;second: &quot; &lt;&lt; lo &lt;&lt; endl;                if (lo &lt; mountainArr.length() &amp;&amp; mountainArr.get(lo) == target)            return lo;                return -1;    &#125;&#125;;\n 1096. Brace Expansion II\n参考的discuss\n作者用了语法分析的思路来解决这道题目。\n二个子程序parseRule2 和 parseRule3 分别处理 并集 和 笛卡尔积 的情况。\n时间复杂度: O(N^N), 因为 笛卡尔乘积。\nclass Solution &#123;    set&lt;string&gt; descarte(const set&lt;string&gt;&amp; s1, const set&lt;string&gt;&amp; s2) &#123;        set&lt;string&gt; ret;        for (const auto&amp; a : s1) &#123;            for (const auto&amp; b : s2) &#123;                ret.insert(a + b);            &#125;        &#125;        return ret;    &#125;    // &#123;a,b&#125;,a,&#123;a&#125;    set&lt;string&gt; parseRule2(const string&amp; s, int&amp; i) &#123;        set&lt;string&gt; ret = parseRule3(s, i);        while (i &lt; s.size()) &#123;            if (s[i] != &#x27;,&#x27;)                break;            ++i;    // skip &#x27;,&#x27;            auto temp = parseRule3(s, i);            ret.insert(std::make_move_iterator(temp.begin()), std::make_move_iterator(temp.end()));        &#125;        return ret;    &#125;    // &#123;a,b&#125;b&#123;a&#125;    set&lt;string&gt; parseRule3(const string&amp; s, int&amp; i) &#123;        set&lt;string&gt; ret;        ret.insert(&quot;&quot;);        while (i &lt; s.size()) &#123;            if (s[i] == &#x27;&#125;&#x27; || s[i] == &#x27;,&#x27;)                break;            if (s[i] == &#x27;&#123;&#x27;) &#123;                ++i;    // skip &#x27;&#123;&#x27;                auto temp = parseRule2(s, i);                ++i;    // skip &#x27;&#123;&#x27;                ret = descarte(ret, temp);            &#125; else &#123;                set&lt;string&gt; new_ret;                for (auto&amp; item : ret) &#123;                    new_ret.insert(item + s[i]);                &#125;                ret = std::move(new_ret);                ++i;            &#125;        &#125;        return ret;    &#125;            public:    vector&lt;string&gt; braceExpansionII(string expression) &#123;        int pos = 0;        auto ret = parseRule2(expression, pos);        ret.erase(&quot;&quot;);        return vector&lt;string&gt; (std::make_move_iterator(ret.begin()), std::make_move_iterator(ret.end()));    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 143","url":"/2019/07/01/LeetCode-weekly-contest-143/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (5)\nQ2 (5)\nQ3 (8)\nQ4 (8)\n\n\n\n\n396 / 4272\nYoungForest\n14\n1:01:14\n0:11:38\n0:28:38\n0:56:14 1\nnull\n\n\n\n 1103. Distribute Candies to People\nBrute force. 模拟整个分配过程。\n时间复杂度: O(sqrt(candies.size())). 因为1 + 2 + ... + n = n * (n + 1) / 2 = candies.size().\n空间复杂度: O(num_people).\nclass Solution &#123;public:    vector&lt;int&gt; distributeCandies(int candies, int num_people) &#123;        vector&lt;int&gt; ret(num_people, 0);        int row = 0;        while (candies &gt; 0) &#123;            for (int i = 0; i &lt; ret.size() &amp;&amp; candies &gt; 0; ++i) &#123;                ret[i] += min(candies, row * num_people + i + 1);                candies -= min(candies, row * num_people + i + 1);            &#125;            ++row;        &#125;        return ret;    &#125;&#125;;\n 1104. Path In Zigzag Labelled Binary Tree\n利用2个算法\n\n如果是顺序编号的话，父节点编号为 子节点编号 / 2 向下取整。\n反序编号，可以转成顺序编号。\n\n时间复杂度: O(log N),\n空间复杂度: O(1).\nclass Solution &#123;    int getLevel(int label) &#123;        int level = 0;        while (label &gt; 0) &#123;            label &gt;&gt;= 1;            ++level;        &#125;        return level - 1;    &#125;    int complete(int label, int level) &#123;        return (1&lt;&lt;(level + 1)) - 1 - label + (1&lt;&lt;level);    &#125;public:    vector&lt;int&gt; pathInZigZagTree(int label) &#123;        int n = getLevel(label);        const int level = n + 1;        // cout &lt;&lt; level &lt;&lt; endl;        vector&lt;int&gt; ret(level);        int true_label = label;        if (n % 2 == 1) &#123;            true_label = complete(label, n);        &#125;        ret[n] = true_label;        for (int i = n - 1; i &gt;= 0; --i) &#123;            ret[i] = ret[i + 1] / 2;        &#125;        // for (int i = 0; i &lt;= n; ++i) &#123;        //     cout &lt;&lt; ret[i] &lt;&lt; &quot; &quot;;        // &#125;        for (int i = 0; i &lt;= n; ++i) &#123;            if (i % 2 == 1)                ret[i] = complete(ret[i], i);        &#125;        return ret;    &#125;&#125;;\n 1105. Filling Bookcase Shelves\n回溯法 + 剪枝。\n时间复杂度: O(2^N), 实际上因为剪枝会小的多。\n空间复杂度: O(N).\nclass Solution &#123;    vector&lt;vector&lt;int&gt;&gt; local_min;    int global_min = numeric_limits&lt;int&gt;::max();    void backtracking(const vector&lt;vector&lt;int&gt;&gt;&amp; books, const int shelf_width, int i, int current_level_height, int height_before, int width) &#123;        if (i &gt;= books.size()) &#123;            global_min = min(global_min, current_level_height + height_before);            return;        &#125;        if (current_level_height + height_before &gt;= global_min)            return;        const int w = books[i][0];        const int h = books[i][1];        if (local_min.at(i).at(width) &lt;= height_before + max(current_level_height, h)) &#123;            return;        &#125;        local_min.at(i).at(width) = height_before + max(current_level_height, h);        if (w + width &lt;= shelf_width) &#123;            backtracking(books, shelf_width, i + 1, max(current_level_height, h), height_before, width + w);        &#125;        backtracking(books, shelf_width, i + 1, h, height_before + current_level_height, w);    &#125;public:    int minHeightShelves(vector&lt;vector&lt;int&gt;&gt;&amp; books, int shelf_width) &#123;        const int n = books.size();        local_min = vector&lt;vector&lt;int&gt;&gt; (n, vector&lt;int&gt; (shelf_width + 1, numeric_limits&lt;int&gt;::max()));        backtracking(books, shelf_width, 0, 0, 0, 0);                return global_min;    &#125;&#125;;\n实际上还可以通过DP解决该问题：Discuss\n 1106. Parsing A Boolean Expression\n词法分析。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;    // op: o not, 1 and, 2 or    bool parseNot(const string&amp; expression, int&amp; i) &#123;        // cout &lt;&lt; &quot;parseNot (&quot; &lt;&lt; i &lt;&lt; &quot;): &quot; &lt;&lt; expression.at(i) &lt;&lt; endl;        ++i; // skip &#x27;(&#x27;        bool ret = parse(expression, i);        ++i; // skip &#x27;)&#x27;        return !ret;    &#125;    bool parseAnd(const string&amp; expression, int&amp; i) &#123;        // cout &lt;&lt; &quot;parseAnd (&quot; &lt;&lt; i &lt;&lt; &quot;): &quot; &lt;&lt; expression.at(i) &lt;&lt; endl;        bool ret = true;        while (expression.at(i) != &#x27;)&#x27;) &#123;            ++i; // skip &#x27;,&#x27; or &#x27;(&#x27;            ret = parse(expression, i) &amp;&amp; ret;  // Warning: ret 必需写到后面，在比赛过程中，由于我写到前面了。忽略了逻辑短路问题，一直wrong answer。功亏一篑。        &#125;        ++i;    // skip &#x27;)&#x27;        return ret;    &#125;    bool parseOr(const string&amp; expression, int&amp; i) &#123;        // cout &lt;&lt; &quot;parseOr (&quot; &lt;&lt; i &lt;&lt; &quot;): &quot; &lt;&lt; expression.at(i) &lt;&lt; endl;        bool ret = false;        while (expression.at(i) != &#x27;)&#x27;) &#123;            ++i; // skip &#x27;,&#x27; or &#x27;(&#x27;            ret = parse(expression, i) || ret;        &#125;        ++i;    // skip &#x27;)&#x27;        return ret;    &#125;    bool parse(const string&amp; expression, int&amp; i) &#123;        // cout &lt;&lt; &quot;parse (&quot; &lt;&lt; i &lt;&lt; &quot;): &quot; &lt;&lt; expression.at(i) &lt;&lt; endl;        char head = expression.at(i);        switch (head) &#123;            case &#x27;t&#x27;:                ++i; // skip &#x27;t&#x27;                return true;            case &#x27;f&#x27;:                ++i;                return false;            case &#x27;!&#x27;:                ++i;                return parseNot(expression, i);            case &#x27;&amp;&#x27;:                ++i;                return parseAnd(expression, i);            case &#x27;|&#x27;:                ++i;                return parseOr(expression, i);            default:                cout &lt;&lt; &quot;error: &quot; &lt;&lt; head &lt;&lt; endl;                return false;        &#125;    &#125;public:    bool parseBoolExpr(string expression) &#123;        int pos = 0;        return parse(expression, pos);    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 144","url":"/2019/07/07/LeetCode-weekly-contest-144/","content":"今早由于参加托福考试，无法像往常一样参加周赛。赛后补题。\n 1108. Defanging an IP Address\nOne pass. 直接替换即可。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    string defangIPaddr(string address) &#123;        string ret;        for (char c : address) &#123;            if (c == &#x27;.&#x27;) &#123;                ret.push_back(&#x27;[&#x27;);                ret.push_back(&#x27;.&#x27;);                ret.push_back(&#x27;]&#x27;);            &#125; else &#123;                ret.push_back(c);            &#125;        &#125;        return ret;    &#125;&#125;;\n 1109. Corporate Flight Bookings\nBrute force. TLE.\n时间复杂度: O(N * bookings.length);\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) &#123;        vector&lt;int&gt; ret(n, 0);        for (const auto&amp; booking : bookings) &#123;            for (int i = booking.at(0); i &lt;= booking.at(1); ++i) &#123;                ret[i - 1] += booking.at(2);            &#125;        &#125;        return ret;    &#125;&#125;;\nOne pass. 前些天刚做过类似的题目。站点上下车的问题。\n时间复杂度: O(max(booking.length, N)).\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) &#123;        vector&lt;int&gt; stops(n + 1, 0);        vector&lt;int&gt; ret(n, 0);        for (const auto&amp; booking : bookings) &#123;            stops[booking[0] - 1] += booking[2];    // begin            stops[booking[1]] -= booking[2];    // end        &#125;        int total = 0;        for (int i = 0; i &lt; n; ++i) &#123;            total += stops[i];            ret[i] = total;        &#125;        return ret;    &#125;&#125;;\n 1110. Delete Nodes And Return Forest\n二叉树的通用解法：递归删除。\n时间复杂度: O(N), 每个结点被递归调用一次。\n空间复杂度: O(N). 最差情况下，返回的子树个数。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    vector&lt;TreeNode*&gt; ret;    TreeNode* recurse(TreeNode* root, const unordered_set&lt;int&gt;&amp; to_delete) &#123;        if (root == nullptr)            return nullptr;        TreeNode* ret = nullptr;        root-&gt;left = recurse(root-&gt;left, to_delete);        root-&gt;right = recurse(root-&gt;right, to_delete);        if (to_delete.find(root-&gt;val) == to_delete.end()) &#123;            ret = root;        &#125; else &#123;    // delete            if (root-&gt;left) &#123;                this-&gt;ret.push_back(root-&gt;left);            &#125;            if (root-&gt;right) &#123;                this-&gt;ret.push_back(root-&gt;right);            &#125;        &#125;        return ret;    &#125;public:    vector&lt;TreeNode*&gt; delNodes(TreeNode* root, vector&lt;int&gt;&amp; to_delete) &#123;        unordered_set&lt;int&gt; td(to_delete.begin(), to_delete.end());        auto r = recurse(root, td);        if (r) &#123;            ret.push_back(r);        &#125;        return ret;    &#125;&#125;;\n 1111. Maximum Nesting Depth of Two Valid Parentheses Strings\n理解题意时，需要注意A, B是seq的subsequence而不是subarray.\n首先尝试贪心的思路。在遇到左括号时，分配给深度较小的序列。遇到右括号时，分配给深度较大的序列。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; maxDepthAfterSplit(string seq) &#123;        int a = 0, b = 0;        vector&lt;int&gt; ret;        for (char c : seq) &#123;            if (c == &#x27;(&#x27;) &#123;                if (a &lt;= b) &#123;                    ++a;                    ret.push_back(0);                &#125; else &#123;                    ++b;                    ret.push_back(1);                &#125;            &#125; else &#123;                if (a &gt;= b) &#123;                    --a;                    ret.push_back(0);                &#125; else &#123;                    --b;                    ret.push_back(1);                &#125;            &#125;        &#125;        return ret;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 145","url":"/2019/07/15/LeetCode-weekly-contest-145/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (5)\nQ2 (5)\nQ3 (8)\nQ4 (8)\n\n\n\n\n451 / 4931\nYoungForest\n16\n1:24:26\n0:09:37\n0:17:39\n1:14:26 2\nnull\n\n\n\n 1122. Relative Sort Array\n定制排序规则。\n时间复杂度: O(N long N),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123;        unordered_map&lt;int, int&gt; location;        for (int i = 0; i &lt; arr2.size(); ++i) &#123;            location[arr2[i]] = i;        &#125;        sort(arr1.begin(), arr1.end(), [location](int lhs, int rhs) -&gt; bool &#123;            if (location.find(lhs) != location.end() &amp;&amp; location.find(rhs) != location.end()) &#123;                return location.at(lhs) &lt; location.at(rhs);            &#125; else if (location.find(lhs) == location.end() &amp;&amp; location.find(rhs) != location.end()) &#123;                return false;            &#125; else if (location.find(lhs) != location.end() &amp;&amp; location.find(rhs) == location.end()) &#123;                return true;            &#125; else &#123;                return lhs &lt; rhs;            &#125;        &#125;);        return arr1;    &#125;&#125;;\n 1123. Lowest Common Ancestor of Deepest Leaves\n树的问题递归解决。关注需要返回给父节点的信息和传递给子节点的信息。\n时间复杂度: O(N). 每个节点遍历一次。\n空间复杂度: O(N). 树的最深深度，即递归的深度。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    pair&lt;int, TreeNode*&gt; recurse(TreeNode* root, int depth) &#123;        if (root == nullptr) &#123;            return &#123;depth, nullptr&#125;;        &#125;        auto l = recurse(root-&gt;left, depth + 1);        auto r = recurse(root-&gt;right, depth + 1);        if (l.first &gt; r.first) &#123;            return l;        &#125; else if (l.first == r.first) &#123;            return &#123;l.first, root&#125;;        &#125; else &#123;            return r;        &#125;    &#125;public:    TreeNode* lcaDeepestLeaves(TreeNode* root) &#123;        auto ans = recurse(root, 0);        return ans.second;    &#125;&#125;;\n 1124. Longest Well-Performing Interval\n我们只关心元素的大小是否大于8，而不关心其绝对值。所以把大于8的元素变为1，小于等于8的元素变为0，可以将问题转化为，寻找1的个数大于0的最大子数组。\n为了快速求解子数组中1比0多的数目，我们可以通过前缀和得出。\n如：\n[9,9,6,0,6,6,9] -&gt;\n[1,1,0,0,0,0,1] -&gt; 前缀和\n[0,1,2,1,0,-1,-2,-3]\n子数组[i, j]的1比0多的数目即为prefix[j] - prefix[i - 1], 数组长度为j - i + 1.\n即 对于每个j, 我们想找到比prefix[j]小的最靠前的prefix[i-1]. 因为prefix是连续变化的，所以找恰好比prefix[j-1]小的，就更靠前。对于prefix[j] &gt; 0的，找0即可。\n另一种找*比prefix[j]小的最靠前的prefix[i-1]*的方法是，维护一个递减栈，记录prefix[i], i, 找的时候通过二分查找，寻找合适的prefix[i-1].\n很棒的题解: tiankonguse\n花花的视频讲解\nclass Solution &#123;public:    int longestWPI(vector&lt;int&gt;&amp; hours) &#123;        unordered_map&lt;int, int&gt; memo; // sum, index        int s = 0;        memo[0] = -1;        int ret = 0;        for (int i = 0; i &lt; hours.size(); ++i) &#123;            if (hours[i] &gt; 8) &#123;                ++s;            &#125; else &#123;                --s;            &#125;            if (memo.find(s) == memo.end()) &#123;                memo[s] = i;            &#125;            if (s - 1 &lt;= 0 &amp;&amp; memo.find(s - 1) != memo.end()) &#123;                ret = max(ret, i - memo[s - 1]);            &#125;            if (s - 1 &gt; 0) &#123;                ret = max(ret, i - memo[0]);            &#125;        &#125;        return ret;    &#125;&#125;;\n 1125. Smallest Sufficient Team\ndp + bitmast\n由于本题是NP问题。\n时间复杂度: O(2^(req_skills.size()) * people.size() * people[i].size())\n空间复杂度: O(2^(req_skills.size()))\nclass Solution &#123;public:    vector&lt;int&gt; smallestSufficientTeam(vector&lt;string&gt;&amp; req_skills, vector&lt;vector&lt;string&gt;&gt;&amp; people) &#123;        const int n = req_skills.size();        unordered_map&lt;string, int&gt; skill2bit;        for (int i = 0; i &lt; req_skills.size(); ++i) &#123;            skill2bit[req_skills[i]] = 1 &lt;&lt; i;        &#125;        map&lt;int, vector&lt;int&gt;&gt; res;        res[0] = &#123;&#125;;        for (int i = 0; i &lt; people.size(); ++i) &#123;            const auto&amp; p = people[i];            int p_skill = 0;            for (const auto&amp; skill : p) &#123;                p_skill |= skill2bit[skill];            &#125;            for (auto it = res.begin(); it != res.end(); ++it) &#123;                int combine = p_skill | it-&gt;first;                auto comb_it = res.find(combine);                if (comb_it == res.end() || it-&gt;second.size() + 1 &lt; comb_it-&gt;second.size()) &#123;                    res[combine] = it-&gt;second;                    res[combine].push_back(i);                &#125;            &#125;        &#125;        return res[(1 &lt;&lt; n) - 1];    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 146","url":"/2019/07/21/LeetCode-weekly-contest-146/","content":"今天由于高中同学xl来北京找我聊，和hcq一起吃了午饭和晚饭，并聊了一下午。上午的contest只匆匆做了签到题。第二题因为粗心，写错了red变化的时机，也没有时间调试。后2题干脆没有看。\n晚上回来9点才把题目补完，第二题的bug也调出来了。\n不过时间上应该是超时了。\n排名1800+。\n总体来讲，本次题目虽然不难，但是需要花时间思考才能做出来的。这样的题目也是我喜欢的。通过自己的思考，作出一道并不是一眼看上去就知道解答的题目，是很爽的。快感可比超神和三杀。\n 5130. Number of Equivalent Domino Pairs\n既然domino可以通过旋转相等，我们就把他们归一化(将2种domino映射成一种)。\n然后计算组合数即可。\n时间复杂度: O(N log N), 因为pair默认不是hashable，所以偷懒用了map。\n空间复杂度: O(N).\nclass Solution &#123;public:    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) &#123;        const int n = dominoes.size();        map&lt;pair&lt;int, int&gt;, int&gt; transform;        int ans = 0;        for (int i = 0; i &lt; n; ++i) &#123;            if (dominoes[i][0] &lt; dominoes[i][1]) &#123;                ++transform[make_pair(dominoes[i][0], dominoes[i][1])];              &#125; else &#123;                ++transform[make_pair(dominoes[i][1], dominoes[i][0])];            &#125;        &#125;        for (const auto&amp; p : transform) &#123;            ans += p.second * (p.second - 1) / 2;        &#125;        return ans;    &#125;&#125;;\n 1129. Shortest Path with Alternating Colors\n算最短路径，用BFS。由于需要颜色交替，代码略微有些麻烦，需要2套变量。\n时间复杂度: O(N), 每个节点最多遍历2次。\n空间复杂度: O(max(N, edges)).\nclass Solution &#123;public:    vector&lt;int&gt; shortestAlternatingPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; red_edges, vector&lt;vector&lt;int&gt;&gt;&amp; blue_edges) &#123;        unordered_map&lt;int, vector&lt;int&gt;&gt; red_to, blue_to;        for (const auto&amp; edge : red_edges) &#123;            red_to[edge[0]].push_back(edge[1]);        &#125;        for (const auto&amp; edge : blue_edges) &#123;            blue_to[edge[0]].push_back(edge[1]);        &#125;        vector&lt;int&gt; ret(n, numeric_limits&lt;int&gt;::max());        ret[0] = 0;        // bfs        for (bool red : &#123;true, false&#125;) &#123;            queue&lt;int&gt; q;            unordered_set&lt;int&gt; seen_red, seen_blue;            q.push(0);            seen_red.insert(0);            seen_blue.insert(0);            int level = 0;            while (!q.empty()) &#123;                int s = q.size();                ++level;                for (int i = 0; i &lt; s; ++i) &#123;                    int current = q.front();                    q.pop();                    vector&lt;int&gt;* edges = nullptr;                    unordered_set&lt;int&gt;* seen = nullptr;                    if (red) &#123;                        edges = &amp;red_to[current];                        seen = &amp;seen_red;                    &#125; else &#123;                        edges = &amp;blue_to[current];                        seen = &amp;seen_blue;                    &#125;                    for (int des : *edges) &#123;                        if (seen-&gt;find(des) == seen-&gt;end()) &#123;                            q.push(des);                            seen-&gt;insert(des);                            ret[des] = min(ret[des], level);                        &#125;                    &#125;                &#125;                            red = !red;            &#125;        &#125;        for (auto&amp; item : ret) &#123;            if (item == numeric_limits&lt;int&gt;::max())                item = -1;        &#125;        return ret;    &#125;&#125;;\n 5131. Minimum Cost Tree From Leaf Values\n本题是本次比赛中最难的题目。我也是思考了很长时间才摸索出来的。\n首先，观察有：\n\n层数和叶子数的关系。n层至少n个叶子，至多2^(n-1)个叶子。\n叶子数确定的话，非叶子节点数目也就确定了。\n观察小的树，可得贪心的解法。大的叶子尽量往上提，降低层数，使得影响的非叶子节点数更少，总和就最少。\n\n时间复杂度: O(n log n). 类似快排，把问题分解成2个子问题，然后还需要end - begin组合解。\n空间复杂度: O(n), n个叶子最多n层，也就是递归深度.\nclass Solution &#123;    int ret = 0;    // max_leaf    int recurse(const vector&lt;int&gt;&amp; arr, int begin, int end) &#123;        if (begin + 1 == end) &#123;            return arr[begin];        &#125;        int max_index = begin;        int max_value = arr[begin];        for (int i = begin + 1; i &lt; end; ++i) &#123;            if (arr[i] &gt;= max_value) &#123;                max_value = arr[i];                max_index = i;            &#125;        &#125;        int l, r;        if (max_index - begin + 2 &lt;= end - max_index) &#123; // 向后分            l = recurse(arr, begin, max_index + 1);            r = recurse(arr, max_index + 1, end);        &#125; else &#123;    // 向前分            l = recurse(arr, begin, max_index);            r = recurse(arr, max_index, end);        &#125;        ret += l * r;        return max(l, r);    &#125;public:    int mctFromLeafValues(vector&lt;int&gt;&amp; arr) &#123;        recurse(arr, 0, arr.size());        return ret;    &#125;&#125;;\n 1131. Maximum of Absolute Value Expression\n首先观察数据规模40000, 排除暴力解法的O(N^2)。\n寻找O(N) 或 O(N log N)的解法。\n实际上，由于绝对值的作用有2种：不变，取反。3个绝对值号，枚举2^3 = 8种组合即可。\n时间复杂度: O(8 * N)\n空间复杂度: O(N), 可以很轻易地缩减为O(1).\nclass Solution &#123;public:    int maxAbsValExpr(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123;        const int n = arr1.size();        int ans = numeric_limits&lt;int&gt;::min();        vector&lt;int&gt; tmp(n);        for (int i : &#123;-1, 1&#125;) &#123;            for (int j : &#123;-1, 1&#125;) &#123;                for (int k : &#123;-1, 1&#125;) &#123;                    for (int l = 0; l &lt; n; ++l) &#123;                        tmp[l] = arr1[l] * i + arr2[l] * j + l * k;                    &#125;                    auto r = minmax_element(tmp.begin(), tmp.end());                    ans = max(ans, *r.second - *r.first);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 147","url":"/2019/07/28/LeetCode-weekly-contest-147/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (2)\nQ2 (5)\nQ3 (7)\nQ4 (7)\n\n\n\n\n175 / 4906\nYoungForest\n21\n1:14:32\n0:08:18  1\n0:27:17  1\n0:41:32\n1:04:32\n\n\n\n昨天做了Biweekly contest，今天做了常规赛和 下午的Google Kick D.\n连续3场比赛，周末很充实。\n 1137. N-th Tribonacci Number\n和 Fibonacci 类似。相同的解法应该都可以用在这里。\n我采用了实现起来最方便的解法。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int tribonacci(int n) &#123;        vector&lt;int&gt; dp(max(n + 1, 3));        dp[0] = 0;        dp[1] = 1;        dp[2] = 1;        for (int i = 3; i &lt;= n; ++i) &#123;            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];        &#125;        return dp[n];    &#125;&#125;;\n 1138. Alphabet Boar\n也是straight forward的解法。因为移动距离就是2点之间的曼哈顿距离，所以贪心地移就好了。\n此处有坑，z的位置上不能向右移，uvwxy不能向下移。\n时间复杂度: O(N).\n空间复杂度: O(N).\nclass Solution &#123;public:    string alphabetBoardPath(string target) &#123;        vector&lt;pair&lt;int, int&gt;&gt; locations(26);        for (char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; ++c) &#123;            int index = c - &#x27;a&#x27;;            locations[index] = &#123;index / 5, index % 5&#125;;        &#125;        pair&lt;int,int&gt; current = &#123;0, 0&#125;;        string ans;        auto special = locations.back();        for (char c : target) &#123;            auto to = locations[c - &#x27;a&#x27;];            if (current != special) &#123;                if (to.second &gt; current.second) &#123;                    ans.append(to.second - current.second, &#x27;R&#x27;);                &#125; else &#123;                    ans.append(current.second - to.second, &#x27;L&#x27;);                &#125;                if (to.first &gt; current.first) &#123;                    ans.append(to.first - current.first, &#x27;D&#x27;);                &#125; else &#123;                    ans.append(current.first - to.first, &#x27;U&#x27;);                &#125;            &#125; else &#123;                if (to.first &gt; current.first) &#123;                    ans.append(to.first - current.first, &#x27;D&#x27;);                &#125; else &#123;                    ans.append(current.first - to.first, &#x27;U&#x27;);                &#125;                if (to.second &gt; current.second) &#123;                    ans.append(to.second - current.second, &#x27;R&#x27;);                &#125; else &#123;                    ans.append(current.second - to.second, &#x27;L&#x27;);                &#125;            &#125;            ans.push_back(&#x27;!&#x27;);            current = to;        &#125;        return ans;    &#125;&#125;;\n 1139. Largest 1-Bordered Square\n之前做过一道类似的题目，区别在于正方形是实心的。\n本题与之类似。枚举正方形所有的右下角，再枚举所有可能的左上角，判断是否可以组成正方形。\n时间复杂度: O(N ^ 3)\n空间复杂度: O(N ^ 2)\nclass Solution &#123;public:    int largest1BorderedSquare(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        auto up = grid, down = grid, left = grid, right = grid;        const int R = grid.size(), C = grid[0].size();        for (int i = 0; i &lt; R; ++i) &#123;            for (int j = 0; j &lt; C; ++j) &#123;                if (i == 0) &#123;                    up[i][j] = grid[i][j] == 1 ? 1 : 0;                &#125; else &#123;                    up[i][j] = grid[i][j] == 1 ? up[i-1][j] + 1 : 0;                &#125;                if (j == 0) &#123;                    left[i][j] = grid[i][j] == 1 ? 1 : 0;                &#125; else &#123;                    left[i][j] = grid[i][j] == 1 ? left[i][j-1] + 1 : 0;                &#125;            &#125;        &#125;        for (int i = R - 1; i &gt;= 0; --i) &#123;            for (int j = C - 1; j &gt;= 0; --j) &#123;                if (i == R - 1) &#123;                    down[i][j] = grid[i][j] == 1 ? 1 : 0;                &#125; else &#123;                    down[i][j] = grid[i][j] == 1 ? down[i+1][j] + 1 : 0;                &#125;                if (j == C - 1) &#123;                    right[i][j] = grid[i][j] == 1 ? 1 : 0;                &#125; else &#123;                    right[i][j] = grid[i][j] == 1 ? right[i][j+1] + 1 : 0;                &#125;            &#125;        &#125;        int ans = 0;        for (int i = 0; i &lt; R; ++i) &#123;            for (int j = 0; j &lt; C; ++j) &#123;                for (int k = min(up[i][j], left[i][j]); k &gt; ans; --k) &#123;                    int corner_i = i - k + 1;                    int corner_j = j - k + 1;                    if (down[corner_i][corner_j] &gt;= k &amp;&amp; right[corner_i][corner_j] &gt;= k) &#123;                        ans = k;                        break;                    &#125;                &#125;            &#125;        &#125;        return ans * ans;    &#125;&#125;;\n 1140. Stone Game II\n常规思路就是一个DP。这里采用了top-down的memorization的写法，实现起来更好实现。\n状态转移方程。\ndp[begin][M] = max(sum of prefix + sum of suffix - dp[begin + X][max(X, M)]), for X in [1, 2 * M].\n时间复杂度: O(N^2),\n空间复杂度: O(N^2).\nclass Solution &#123;    vector&lt;map&lt;pair&lt;int, int&gt;, int&gt;&gt; dp;    vector&lt;int&gt; s;    int recurse(const vector&lt;int&gt;&amp; piles, int begin, int M, int player) &#123;        if (begin &gt;= piles.size())            return 0;        if (dp[player].find(&#123;begin, M&#125;) != dp[player].end()) &#123;            return dp[player][&#123;begin, M&#125;];        &#125;        int add = 0;        for (int X = 1; X &lt;= 2 * M &amp;&amp; begin - 1 + X &lt; piles.size() ; ++X) &#123;            add += piles[begin - 1 + X];            dp[player][&#123;begin, M&#125;] = max(dp[player][&#123;begin, M&#125;], add + s[begin + X] - recurse(piles, begin + X, max(M, X), 1 - player));        &#125;        return dp[player][&#123;begin, M&#125;];    &#125;public:    int stoneGameII(vector&lt;int&gt;&amp; piles) &#123;        dp.resize(2);        s.resize(piles.size() + 1);        s.back() = 0;        for (int i = piles.size() - 1; i &gt;= 0; --i) &#123;            s[i] = piles[i] + s[i+1];        &#125;        return recurse(piles, 0, 1, 0);    &#125;&#125;;\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 148","url":"/2019/08/04/LeetCode-weekly-contest-148/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (8)\n\n\n\n\n77 / 5319\nYoungForest\n23\n0:56:45\n0:09:51\n0:24:02\n0:41:20\n0:56:45\n\n\n\n本次比赛是我时隔3个月再次进入前100名，也是连续2次进入前200名，还是有些小开心的。算是一扫上周kick start 翻车的阴郁。\n事实上，由于评测机的问题，我比赛刚结束时看到的排名是56名。后来官方有重新评测了最后一题，有些人的提交就可以过了，也没有罚时了。\n本次比赛也是质量蛮高，题目不是很难，但考察的知识点很全面，难度分布也比较合理。\n 1144. Decrease Elements To Make Array Zigzag\n因为只能减1嘛，所以是到Easy题目。如果题目改成加1或减1，会难的多。\n只需要比较2种情况，选择小的即可。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int movesToMakeZigzag(vector&lt;int&gt;&amp; nums) &#123;        int ans1 = 0;        for (int i = 0; i &lt; nums.size(); i += 2) &#123;            int neighbor = INF;            if (i &gt; 0) &#123;                neighbor = min(neighbor, nums[i - 1]);            &#125;            if (i &lt; nums.size() - 1) &#123;                neighbor = min(neighbor, nums[i + 1]);            &#125;            if (neighbor != INF &amp;&amp; neighbor &lt;= nums[i]) &#123;                ans1 += nums[i] - neighbor + 1;            &#125;        &#125;        int ans2 = 0;        for (int i = 1; i &lt; nums.size(); i += 2) &#123;            int neighbor = INF;            if (i &gt; 0) &#123;                neighbor = min(neighbor, nums[i - 1]);            &#125;            if (i &lt; nums.size() - 1) &#123;                neighbor = min(neighbor, nums[i + 1]);            &#125;            if (neighbor != INF &amp;&amp; neighbor &lt;= nums[i]) &#123;                ans2 += nums[i] - neighbor + 1;            &#125;        &#125;        return min(ans1, ans2);    &#125;&#125;;\n 1145. Binary Tree Coloring Game\n本题的难点在于理解题意。思路倒是十分直观，尽量选择最大的分支。如果大分支的数量大于一半，则必胜。\n树的问题用递归，模版还是一个DFS。\n时间复杂度: O(N), 遍历每个节点1次；\n空间复杂度: O(N). 树的深度，最差为N。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    int l, r;    // return the number of node in subtree    int dfs(TreeNode* root, int x) &#123;        if (root == nullptr)            return 0;        int left = dfs(root-&gt;left, x);        int right = dfs(root-&gt;right, x);        if (root-&gt;val == x) &#123;            l = left;            r = right;        &#125;        return left + right + 1;    &#125;public:    bool btreeGameWinningMove(TreeNode* root, int n, int x) &#123;        dfs(root, x);        if (n == l + r + 1) &#123;            return l != r;        &#125; else &#123;            int parent = n - l - r - 1;            return parent - 1 &gt; l + r || l - 1 &gt; r + parent || r - 1 &gt; l + parent;        &#125;    &#125;&#125;;\n 1146. Snapshot Array\n比较暴力的思路是每次snap，保存一次所有状态。snap函数的时间，空间上会比较大。\n另一个比较巧妙，但也不是很难想出来的思路是，每次保存变化的内容。我采用的是这种解法。\n时间复杂度:\n\nSnapshotArray: O(N)\nset: O(1)\nsnap:  O(1)\nget: O(log N)\n\nclass SnapshotArray &#123;    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; data;    int current_snap_id = 0;    const int INF = numeric_limits&lt;int&gt;::max();public:    SnapshotArray(int length) &#123;        data.resize(length, vector&lt;pair&lt;int, int&gt;&gt;(1, &#123;0, 0&#125;));    &#125;        void set(int index, int val) &#123;        data[index].push_back(&#123;current_snap_id, val&#125;);    &#125;        int snap() &#123;        return current_snap_id++;    &#125;        int get(int index, int snap_id) &#123;        auto&amp; target = data[index];        auto it = lower_bound(target.begin(), target.end(), make_pair(snap_id, INF));        --it;        return it-&gt;second;    &#125;&#125;;/** * Your SnapshotArray object will be instantiated and called as such: * SnapshotArray* obj = new SnapshotArray(length); * obj-&gt;set(index,val); * int param_2 = obj-&gt;snap(); * int param_3 = obj-&gt;get(index,snap_id); */\n 1147. Longest Chunked Palindrome Decomposition\nGreedy。每次贪心的寻找相等的头和尾。\n时间复杂度：O(n ^ 2),\n空间复杂度: O(N).\nclass Solution &#123;    bool equal(const string&amp; text, int begin1, int end1, int begin2, int end2) &#123;        if (end1 - begin1 != end2 - begin2) &#123;            return false;        &#125;        for (int i = 0; i &lt; end1 - begin1; ++i) &#123;            if (text[begin1 + i] != text[begin2 + i])                 return false;        &#125;        return true;    &#125;    int recurse(const string&amp; text, int begin, int end) &#123;        if (begin == end)            return 0;        for (int i = 1; begin + i &lt;= end - i; ++i) &#123;            if (equal(text, begin, begin + i, end - i, end)) &#123;                return recurse(text, begin + i, end - i) + 2;            &#125;        &#125;        return 1;    &#125;public:    int longestDecomposition(string text) &#123;        return recurse(text, 0, text.size());    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 149","url":"/2019/08/11/LeetCode-weekly-contest-149/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (6)\nQ4 (9)\n\n\n\n\n476 / 5091\nYoungForest\n15\n1:00:14\n0:10:21\n0:42:14\n1:00:14\nnull\n\n\n\n惭愧的排名又落到400+了。最后一题有半个小时可以解决，一直试图用线段树来做。像kick start round D一样，沉迷于线段树而翻车。获得的教训是，不要纠结与区间问题一定要用线段树做，常常还有其他更简单的做法。\n 1154. Day of the Year\n判断闰年，累加之前月份的日子。\n时间复杂度: O(1),\n空间复杂度: O(1).\nclass Solution &#123;    bool isLeap(int yy) &#123;        return (yy % 4 == 0 &amp;&amp; yy % 100 != 0) || yy % 400 == 0;    &#125;public:    int dayOfYear(string date) &#123;        auto yy = stoi(date.substr(0, 4));        auto mm = stoi(date.substr(5, 2));        auto dd = stoi(date.substr(8, 2));        vector&lt;int&gt; days = &#123;0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;        if (isLeap(yy)) &#123;            days[2] = 29;        &#125;        int ans = 0;        ans += accumulate(days.cbegin(), days.cbegin() + mm, 0);        ans += dd;        return ans;    &#125;&#125;;\n 1155. Number of Dice Rolls With Target Sum\n隔板插空，经典的排列组合问题。由于2个隔板之前的间隔不能大于骰子最大的数字，所以不能直接用数学公式求解。我采用了回溯法，使用了memorization，所以也算是DP。\n时间复杂度: O(N ^ 2),\n空间复杂度: O(d * bar).\nclass Solution &#123;    const int mod = 1e9 + 7;    int f;    map&lt;pair&lt;int, int&gt;, int&gt; memo;    // [begin, end), the index of insert bar    int backtracking(int begin, int end, int bar) &#123;        if (memo.find(&#123;begin, bar&#125;) != memo.end()) &#123;            return memo[&#123;begin, bar&#125;];        &#125;        if (bar == 0) &#123;            if (end - begin + 1 &lt;= f)                return 1;            else                return 0;        &#125;        int ans = 0;        for (int i = begin; i &lt; end &amp;&amp; i - begin + 1 &lt;= f; ++i) &#123;            // insert in i            ans += backtracking(i + 1, end, bar - 1);            ans %= mod;        &#125;        memo[&#123;begin, bar&#125;] = ans;        return ans;    &#125;public:    int numRollsToTarget(int d, int f, int target) &#123;        this-&gt;f = f;        int ans = backtracking(0, target - 1, d - 1);        return ans;    &#125;&#125;;\n 1156. Swap For Longest Repeated Character Substring\nOne pass, 更新可以获得的最长长度。\n需要观察到: 最长长度的获得和中间空的字母无关，而只和前后有无需要的字母有关。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int maxRepOpt1(string text) &#123;        vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; v(26);        char last = &#x27; &#x27;;        for (int i = 0; i &lt; text.size(); ++i) &#123;            if (text[i] == last) &#123;                v[text[i] - &#x27;a&#x27;].back().second = i + 1;            &#125; else &#123;                v[text[i] - &#x27;a&#x27;].push_back(&#123;i, i + 1&#125;);            &#125;            last = text[i];        &#125;        int ans = 0;        for (const auto&amp; row : v) &#123;            for (int i = 0; i &lt; row.size(); ++i) &#123;                if (i + 1 == row.size()) &#123;                    if (row.size() == 1)                        ans = max(ans, row[i].second - row[i].first);                    else                        ans = max(ans, row[i].second - row[i].first + 1);                &#125; else &#123;                    const auto&amp; a = row[i];                    const auto&amp; b = row[i + 1];                    if (a.second + 1 == b.first) &#123;                        if (row.size() &gt; 2) &#123;                            ans = max(ans, a.second - a.first + b.second - b.first + 1);                        &#125; else &#123;                            ans = max(ans, a.second - a.first + b.second - b.first);                        &#125;                    &#125; else &#123;                        ans = max(ans, a.second - a.first + 1);                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n 1157. Online Majority Element In Subarray\nrandom pick + binary search.\n时间复杂度: O(log N).\n空间复杂度: O(N).\nclass MajorityChecker &#123;    unordered_map&lt;int, vector&lt;int&gt;&gt; appear_index;    vector&lt;int&gt; arr;public:    MajorityChecker(vector&lt;int&gt;&amp; arr) &#123;        for (int i = 0; i &lt; arr.size(); ++i) &#123;            appear_index[arr[i]].push_back(i);        &#125;        this-&gt;arr = arr;    &#125;        int query(int left, int right, int threshold) &#123;        std::random_device dev;        std::mt19937 rng(dev());        std::uniform_int_distribution&lt;std::mt19937::result_type&gt; dist6(left,right); // distribution in range [left, right]        for (int i = 0; i &lt; 20; ++i) &#123;            int a = arr[dist6(rng)];            const auto&amp; index = appear_index[a];            auto l = lower_bound(index.cbegin(), index.cend(), left);            auto r = upper_bound(index.cbegin(), index.cend(), right);            if (r - l &gt;= threshold) &#123;                return a;            &#125;        &#125;        return -1;    &#125;&#125;;/** * Your MajorityChecker object will be instantiated and called as such: * MajorityChecker* obj = new MajorityChecker(arr); * int param_1 = obj-&gt;query(left,right,threshold); */\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 150","url":"/2019/08/19/LeetCode-weekly-contest-150/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n476 / 5091\nYoungForest\n19\n1:31:13\n0:03:52\n0:09:23\n1:16:13  2\n0:50:16  1\n\n\n\n本次比赛效果同样不佳，排名在400+。直接原因是第3题的搜索剪枝花费了太长时间，没有一步到位。根本原因是最近2周好不容易放假在家，放松了练习，刷题基本停止了，自然手上的功夫就荒废了。真应了那句“业精于勤荒于嬉”呀。上周的排名同样很差。\n 1160. Find Words That Can Be Formed by Characters\n常规的字母计数问题，用hashmap存储即可。需要注意的是，每次判断一个word的时候，需要获得一次拷贝。\n时间复杂度: O(chars.size() + words.size() * word.size()),\n空间复杂度: O(26)\nclass Solution &#123;public:    int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123;        int ans = 0;        vector&lt;int&gt; count(26);        for (char c : chars) &#123;            ++count[c - &#x27;a&#x27;];        &#125;        for (const auto&amp; s : words) &#123;            auto count_copy = count;            for (char c : s) &#123;                --count_copy[c - &#x27;a&#x27;];                if (count_copy[c - &#x27;a&#x27;] &lt; 0) &#123;                    goto next;                &#125;            &#125;            ans += s.size();            next:                ;        &#125;        return ans;    &#125;&#125;;\n 1161. Maximum Level Sum of a Binary Tree\n先获得每一层的和，再取得最大值。\n时间复杂度: O(N),\n空间复杂度: O(N).\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    vector&lt;int&gt; sum_of_level;    void dfs(TreeNode* root, int depth) &#123;        if (root == nullptr)            return;        if (depth &gt; sum_of_level.size()) &#123;            sum_of_level.push_back(0);        &#125;        sum_of_level[depth-1] += root-&gt;val;        dfs(root-&gt;left, depth + 1);        dfs(root-&gt;right, depth + 1);    &#125;public:    int maxLevelSum(TreeNode* root) &#123;        dfs(root, 1);        int ans = 0;        for (int i = 1; i &lt; sum_of_level.size(); ++i) &#123;            if (sum_of_level[i] &gt; sum_of_level[ans]) &#123;                ans = i;            &#125;        &#125;        return ans + 1;    &#125;&#125;;\n 1162. As Far from Land as Possible\n从陆地出发，进行DFS。\n剪枝条件比较复杂，需要注意：\n((src_i == i &amp;&amp; src_j == j) || (direct_i == di[k]) || (direct_j == dj[k]) || (direct_i == 0 &amp;&amp; dj[k] == 0) || (direct_j == 0 &amp;&amp; di[k] == 0)) &amp;&amp; grid[ni][nj] != 1。\n分别是\n\n搜索方向与之前的一直\n\n本次出发点就在原点\nrow方向一致\ncolumn方向一致\n之前没有在row方向走，现在往row方向走\n之前没有在column方向走，现在往column方向走\n\n\n不是陆地\n\n时间复杂度: O((rowcolumn) ^ 2),\n空间复杂度: O(rowcolumn).\n事实上，更好的算法是使用BFS。初始点为所有的陆地。BFS可以保证每个cell只被访问一次。\nclass Solution &#123;    void dfs(const vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; distance, int i, int j, int depth, int src_i, int src_j) &#123;        if (distance[i][j] != -1 &amp;&amp; depth &gt;= distance[i][j]) &#123;            return;        &#125;        distance[i][j] = depth;        vector&lt;int&gt; di = &#123;1, 0, -1, 0&#125;;        vector&lt;int&gt; dj = &#123;0, 1, 0, -1&#125;;        for (int k = 0; k &lt; 4; ++k) &#123;            int ni = di[k] + i;            int nj = dj[k] + j;            int direct_i = (i - src_i) == 0 ? 0 : (i - src_i) / abs(i - src_i);            int direct_j = (j - src_j) == 0 ? 0 : (j - src_j) / abs(j - src_j);            if (ni &gt;= 0 &amp;&amp; ni &lt; grid.size() &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; grid[0].size() &amp;&amp; ((src_i == i &amp;&amp; src_j == j) || (direct_i == di[k]) || (direct_j == dj[k]) || (direct_i == 0 &amp;&amp; dj[k] == 0) || (direct_j == 0 &amp;&amp; di[k] == 0)) &amp;&amp; grid[ni][nj] != 1) &#123;                dfs(grid, distance, ni, nj, depth + 1, src_i, src_j);            &#125;        &#125;    &#125;public:    int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        auto distance = grid;        for (int i = 0; i &lt; distance.size(); ++i) &#123;            std::fill(distance[i].begin(), distance[i].end(), -1);        &#125;        for (int i = 0; i &lt; grid.size(); ++i) &#123;            for (int j = 0; j &lt; grid[0].size(); ++j) &#123;                if (grid[i][j] == 1) &#123;                    dfs(grid, distance, i, j, 0, i, j);                &#125;            &#125;        &#125;        int ans = -1;        for (int i = 0; i &lt; distance.size(); ++i) &#123;            for (int j = 0; j &lt; distance[0].size(); ++j) &#123;                if (grid[i][j] == 0) &#123;                    ans = max(ans, distance[i][j]);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n 1163. Last Substring in Lexicographical Order\n答案可能是从某个字母出发，然后到字符串末尾的。\n首字母肯定是最大的字母。\n每次挑选出来最大的字母，然后再挑选第二个字母，依次向后找，直到剩下一个候选。\n有剪枝的情况是’zzzz’这种情况。大家都是最大的字母，此时候选者只有第一个最大字母。\n时间复杂度：O(N). 由于有剪枝条件，所以候选者的数量为N + N / 2 + N / 4 + ... + 1 = 2 * N.\n空间复杂度: O(N).\nclass Solution &#123;    /**    find the first maximum char, then compare next char    */public:    string lastSubstring(string s) &#123;        vector&lt;pair&lt;int, int&gt;&gt; q; // begin index, compare length        char maximum_char = &#x27;a&#x27;;        for(int i = 0; i &lt; s.size(); ++i) &#123;            if (s[i] &gt; maximum_char) &#123;                maximum_char = s[i];            &#125;        &#125;        for(int i = 0; i &lt; s.size(); ++i) &#123;            if (s[i] == maximum_char) &#123;                q.push_back(&#123;i, 1&#125;);            &#125;        &#125;        while (q.size() &gt; 1) &#123;            char mc = &#x27;a&#x27;;            vector&lt;pair&lt;int, int&gt;&gt; nq;            for(const auto&amp; p : q) &#123;                if (p.first + p.second &lt; s.size() &amp;&amp; s[p.first + p.second] &gt; mc) &#123;                    mc = s[p.first + p.second];                &#125;            &#125;            for(const auto&amp; p : q) &#123;                if (p.first + p.second &lt; s.size() &amp;&amp; s[p.first + p.second] == mc) &#123;                    if (mc == maximum_char &amp;&amp; p.first &gt; 0 &amp;&amp; s[p.first  - 1] == mc) &#123;                        continue;                    &#125;                    nq.push_back(&#123;p.first, p.second + 1&#125;);                &#125;            &#125;            std::swap(q, nq);        &#125;        return s.substr(q.back().first);    &#125;&#125;;\n 后记\n曾经在知乎上写过一个很用心的答案大家都是如何刷 LeetCode 的。这几个月来不断有同学关注我，甚至评论说会进一步关注我的动向。我本不应让他们失望，收拾起慵懒的心情，以一个奋斗逼的心态去迎接新的学期吧！\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 151","url":"/2019/08/31/LeetCode-weekly-contest-151/","content":"这周去字节跳动参加夏令营了，周日还需要上课，所以就鸽了周赛。那你怎么能参加kick start呢？毕竟本月的round E是所谓的黄金轮次，对面试获取名额很重要，所以我选择翘掉夏令营。\n夏令营结束后，按约补题。不得不说，LeetCode比Kick start的难度还是要低不少的。感觉Kick start的签到题难度是Medium，后2题是Hard。\n 1169. Invalid Transactions\n考察字符串处理。由于transactions.lenght &lt; 1000, 所以及时是暴力方法也是可以的。事实上，我实现的优化方法在最坏情况下，并没有变好。\n时间复杂度: O(N^2).\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;string&gt; invalidTransactions(vector&lt;string&gt;&amp; transactions) &#123;        unordered_map&lt;string, vector&lt;tuple&lt;int, int, string&gt;&gt;&gt; name_trasactions;        for (const auto&amp; s : transactions) &#123;            stringstream ss(s);            string tmp;            vector&lt;string&gt; v;            while (getline(ss, tmp, &#x27;,&#x27;)) &#123;                v.push_back(tmp);            &#125;            name_trasactions[v[0]].push_back(&#123;stoi(v[1]), stoi(v[2]), v[3]&#125;);        &#125;        unordered_set&lt;string&gt; ans;        for (auto&amp; p : name_trasactions) &#123;            sort(p.second.begin(), p.second.end());            int l = 0, r = 0;            for (; r &lt; p.second.size(); ++r) &#123;                if (get&lt;1&gt;(p.second[r]) &gt; 1000) &#123;                    ans.insert(p.first + &quot;,&quot; + to_string(get&lt;0&gt;(p.second[r])) + &quot;,&quot; + to_string(get&lt;1&gt;(p.second[r]))+ &quot;,&quot; + get&lt;2&gt;(p.second[r]));                &#125;                while (get&lt;0&gt;(p.second[r]) - get&lt;0&gt;(p.second[l]) &gt; 60) &#123;                    ++l;                &#125;                for (int i = l; i &lt; r; ++i) &#123;                    if (get&lt;2&gt;(p.second[r]) != get&lt;2&gt;(p.second[i])) &#123;                        ans.insert(p.first + &quot;,&quot; + to_string(get&lt;0&gt;(p.second[r])) + &quot;,&quot; + to_string(get&lt;1&gt;(p.second[r]))+ &quot;,&quot; + get&lt;2&gt;(p.second[r]));                        ans.insert(p.first + &quot;,&quot; + to_string(get&lt;0&gt;(p.second[i])) + &quot;,&quot; + to_string(get&lt;1&gt;(p.second[i]))+ &quot;,&quot; + get&lt;2&gt;(p.second[i]));                    &#125;                &#125;            &#125;        &#125;        return vector&lt;string&gt;(ans.begin(), ans.end());    &#125;&#125;;\n 1170. Compare Strings by Frequency of the Smallest Character\n简单的二分查找。\n时间复杂度: O(queries.length * queries[i].length * log words.length),\n空间复杂度: O(queries.length + words.length).\nclass Solution &#123;    int f(const string&amp; s) &#123;        char mi = &#x27;z&#x27; + 1;        int count = 0;        for (char c : s) &#123;            if (c == mi) &#123;                ++count;            &#125; else if (c &lt; mi) &#123;                mi = c;                count = 1;            &#125;        &#125;        return count;    &#125;public:    vector&lt;int&gt; numSmallerByFrequency(vector&lt;string&gt;&amp; queries, vector&lt;string&gt;&amp; words) &#123;        vector&lt;int&gt; a;        for (const auto&amp; w : words) &#123;            a.push_back(f(w));        &#125;        sort(a.begin(), a.end());        vector&lt;int&gt; ans;        for (const auto&amp; q : queries) &#123;            int c = f(q);            auto it = upper_bound(a.begin(), a.end(), c);            ans.push_back(distance(it, a.end()));        &#125;        return ans;    &#125;&#125;;\n 1171. Remove Zero Sum Consecutive Nodes from Linked List\n考察链表操作。为了快速找到对应元素和删除元素，我们需要使用一个hash table来存储前缀和和节点的映射关系。\n时间复杂度: O(N),\n空间复杂度: O(N).\n/** * Definition for singly-linked list. * struct ListNode &#123; *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    ListNode* removeZeroSumSublists(ListNode* head) &#123;        ListNode dummy(0);        dummy.next = head;        ListNode* current = head;        unordered_map&lt;int, ListNode*&gt; m;        int sum = 0;        m[0] = &amp;dummy;        while (current) &#123;            sum += current-&gt;val;            if (m.find(sum) != m.end()) &#123;                auto delete_head = m[sum]-&gt;next;                m[sum]-&gt;next = current-&gt;next;                current-&gt;next = nullptr;                int delete_sum = sum;                while (delete_head) &#123;                    auto tmp = delete_head;                    delete_sum += tmp-&gt;val;                    if (delete_sum != sum)                        m.erase(delete_sum);                    delete_head = delete_head-&gt;next;                    delete tmp;                &#125;                current = m[sum]-&gt;next;            &#125; else &#123;                m[sum] = current;                current = current-&gt;next;            &#125;                    &#125;        return dummy.next;    &#125;&#125;;\n 1172. Dinner Plate Stacks\n用多个栈来模拟一个栈。\n实现不复杂，但是需要考虑比较多的边界条件。每个函数如何使栈的状态发生改变。\n时间复杂度: O(1).\n空间复杂度: O(N).\nclass DinnerPlates &#123;    vector&lt;stack&lt;int&gt;&gt; stacks;    set&lt;int&gt; condidates;    int capacity;public:    DinnerPlates(int capacity_) : capacity(capacity_) &#123;    &#125;        void push(int val) &#123;        if (condidates.empty()) &#123;            condidates.insert(stacks.size());            stacks.push_back(stack&lt;int&gt;());        &#125;        int target = *condidates.begin();        stacks[target].push(val);        if (stacks[target].size() == capacity) &#123;            condidates.erase(target);        &#125;    &#125;        int pop() &#123;        if (stacks.empty())            return -1;        int ret = stacks.back().top();        stacks.back().pop();        while (!stacks.empty() &amp;&amp; stacks.back().empty()) &#123;            stacks.pop_back();            condidates.erase(stacks.size());        &#125;        if (!stacks.empty() &amp;&amp; stacks.back().size() &lt; capacity) &#123;            condidates.insert(stacks.size() - 1);        &#125;        return ret;    &#125;        int popAtStack(int index) &#123;        if (index &gt;= stacks.size())            return -1;        if (stacks[index].empty())            return -1;        if (index == stacks.size() - 1)            return pop();        int ret = stacks[index].top();        stacks[index].pop();        condidates.insert(index);        return ret;    &#125;&#125;;/** * Your DinnerPlates object will be instantiated and called as such: * DinnerPlates* obj = new DinnerPlates(capacity); * obj-&gt;push(val); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;popAtStack(index); */\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 152","url":"/2019/09/01/LeetCode-weekly-contest-152/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n111 / 5333\nYoungForest\n18\n1:11:49\n0:11:56  1\n0:21:44  1\n0:37:27\n1:01:49\n\n\n\n本期比赛由于粗心，第一题忘记考虑corner case，0的排列是1；第二题干脆upper lower写反了。获得2次罚时。否则应该可以进入前100的。题目比较简单，都是常规题目，之前的原题改改就行。\n 1175. Prime Arrangements\n筛法求素数 + 排列组合。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;    using ll = long long;    const int modulo = 1e9 + 7;    unordered_map&lt;int, ll&gt; memo;    ll A(int x) &#123;        if (x == 0)            return 1;        if (x == 1)            return 1;        if (memo.find(x) == memo.end()) &#123;            memo[x] = (x * A(x - 1)) % modulo;        &#125;        return memo[x];    &#125;public:    int numPrimeArrangements(int n) &#123;        vector&lt;bool&gt; a(n + 1, true);        int count = 0;        for (int i = 2; i &lt; n + 1; ++i) &#123;            if (a[i]) &#123;                ++count;                for (int j = 2; j * i &lt; n + 1; ++j) &#123;                    a[j * i] = false;                &#125;            &#125;        &#125;        return (A(count) * A(n - count)) % modulo;    &#125;&#125;;\n 1176. Diet Plan Performance\n简单的滑动窗口。竟然因为粗心错了一次。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int dietPlanPerformance(vector&lt;int&gt;&amp; calories, int k, int lower, int upper) &#123;        if (k &gt; calories.size())            return 0;        int sum = accumulate(calories.begin(), calories.begin() + k, 0);        int ans = 0;        if (sum &gt; upper)            ++ans;        else if (sum &lt; lower)            --ans;        for (int i = k; i &lt; calories.size(); ++i) &#123;            sum = sum + calories[i] - calories[i - k];            if (sum &gt; upper)                ++ans;            else if (sum &lt; lower)                --ans;        &#125;        return ans;    &#125;&#125;;\n 5175. Can Make Palindrome from Substring\n对回文字符串要敏感。观察有：回文串只允许一个字母的数量是奇数，没多一个替换，多2个允许的单数。\n时间复杂度：O(max(s.size(), queries.size()).\n空间复杂度: O(max(s.size(), queries.size()).\nclass Solution &#123;public:    vector&lt;bool&gt; canMakePaliQueries(string s, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        vector&lt;int&gt; count(26, 0);        vector&lt;vector&lt;int&gt;&gt; prefix(s.size() + 1);        prefix[0] = count;        for (int i = 1; i &lt; s.size() + 1; ++i) &#123;            ++count[s[i - 1] - &#x27;a&#x27;];            prefix[i] = count;        &#125;        vector&lt;bool&gt; ans(queries.size());        for (int j = 0; j &lt; queries.size(); ++j) &#123;            const auto&amp; query = queries[j];            const auto&amp; l = prefix[query[0]];            const auto&amp; r = prefix[query[1] + 1];            int odd = 0;            for (int i = 0; i &lt; 26; ++i) &#123;                // cout &lt;&lt; r[i] &lt;&lt; &quot;, &quot; &lt;&lt; l[i] &lt;&lt; endl;                int sub = r[i] - l[i];                if (sub % 2 == 1) &#123;                    ++odd;                &#125;            &#125;            ans[j] = odd &lt;= 1 + 2 * query[2];        &#125;        return ans;    &#125;&#125;;\n 1178. Number of Valid Words for Each Puzzle\n字典树的变种。\n首先起码想到暴力解法，每个puzzle和每个word去匹配。时间复杂度为 O(words.length * puzzles.length), 肯定会超时。\n优化方向是，整合word的信息，字典树是一个很好的数据结构。\n时间复杂度: O(2^puzzles[i].length * puzzles.length, words.length * words[i].length).\n空间复杂度: O(puzzles.length + min(2 ^ 26, words.length)).\nclass Solution &#123;    struct Trie &#123;        shared_ptr&lt;Trie&gt; zero, one;        int value = 0;    &#125;;    shared_ptr&lt;Trie&gt; root;    int dfs(const vector&lt;bool&gt;&amp; appear, int begin, shared_ptr&lt;Trie&gt; current, int special) &#123;        if (current == nullptr)            return 0;        if (special == begin) &#123;            return dfs(appear, begin + 1, current-&gt;one, special) + current-&gt;value;        &#125;        if (appear[begin]) &#123;            return dfs(appear, begin + 1, current-&gt;zero, special) + dfs(appear, begin + 1, current-&gt;one, special) + current-&gt;value;        &#125; else &#123;            return dfs(appear, begin + 1, current-&gt;zero, special) + current-&gt;value;        &#125;    &#125;public:    vector&lt;int&gt; findNumOfValidWords(vector&lt;string&gt;&amp; words, vector&lt;string&gt;&amp; puzzles) &#123;        root = make_shared&lt;Trie&gt;();        for (const string&amp; w : words) &#123;            vector&lt;bool&gt; appear(26, false);            for (char c : w) &#123;                appear[c - &#x27;a&#x27;] = true;            &#125;            auto current = root;            for (bool b : appear) &#123;                if (b) &#123;                    if (current-&gt;one == nullptr) &#123;                        current-&gt;one = make_shared&lt;Trie&gt;();                    &#125;                    current = current-&gt;one;                &#125; else &#123;                    if (current-&gt;zero == nullptr) &#123;                        current-&gt;zero = make_shared&lt;Trie&gt;();                    &#125;                    current = current-&gt;zero;                &#125;            &#125;            ++current-&gt;value;        &#125;        vector&lt;int&gt; ans(puzzles.size());        for (int i = 0; i &lt; puzzles.size(); ++i) &#123;            const auto&amp; puzzle = puzzles[i];            auto current = root;            vector&lt;bool&gt; appear(26, false);            for (char c : puzzle) &#123;                appear[c - &#x27;a&#x27;] = true;            &#125;            ans[i] = dfs(appear, 0, root, puzzle[0] - &#x27;a&#x27;);        &#125;        return ans;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 153","url":"/2019/09/15/LeetCode-weekly-contest-153/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n392 / 6212\nYoungForest\n12\n0:41:42\n0:06:46  1\n0:16:11\n0:36:42\nnull\n\n\n\n本次比赛是我在国内的最后一场了。由于比利时这边时差的原因，每周的周赛是周日的早上4点半到6点。所以我并没有条件参加，只能每周日早上起来补题了。\n 1184. Distance Between Bus Stops\nTwo pass。正着走一遍，总共走一遍，然后总的路程减去正的路程就是反的路程。\n这里要注意start必须在destination之前，否则要换一下位置。\nclass Solution &#123;public:    int distanceBetweenBusStops(vector&lt;int&gt;&amp; distance, int start, int destination) &#123;        int total = accumulate(distance.begin(), distance.end(), 0);        if (start &gt; destination)            swap(start, destination);        int clockwise = accumulate(distance.begin() + start, distance.begin() + destination, 0);        int counterclockwise = total - clockwise;        return min(clockwise, counterclockwise);    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1185. Day of the Week\n经典的日历问题。需要注意的点是 闰年 的处理。\n时间复杂度: O(year * month),\n空间复杂度: O(1).\nclass Solution &#123;    bool isLeap(int year) &#123;        return (year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0);    &#125;public:    string dayOfTheWeek(int day, int month, int year) &#123;        vector&lt;string&gt; v = &#123;&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;&#125;;        vector&lt;int&gt; monthes = &#123;0, 31, 28, 31, 30, 31,30, 31, 31, 30,31,30,31&#125;;        int count = 4;        for (int i = 1971; i &lt; year; ++i) &#123;            if (isLeap(i)) &#123;                count += 366;            &#125; else &#123;                count += 365;            &#125;        &#125;        if (isLeap(year)) &#123;            monthes[2] += 1;        &#125;        count += accumulate(monthes.begin(), monthes.begin() + month, 0);        count += day;        count %= 7;        return v[count];    &#125;&#125;;\n 1186. Maximum Subarray Sum with One Deletion\n动态规划。\n第i位的结果可以由第i - 1位的结果获得。\n因为最多删除一个，所以DP需要维护2个最小值，一个是删了一个的，另一个是每删的。另外需要维护可以删除的最小值。\nclass Solution &#123;public:    int maximumSum(vector&lt;int&gt;&amp; arr) &#123;        const int n = arr.size();        vector&lt;int&gt; dp_delete(n + 1, 0), dp_nodelete(n + 1, 0), dp_which_min(n + 1, 0);        int ret = arr[0];        for (int i = 1; i &lt; n + 1; ++i) &#123;            if (dp_nodelete[i - 1] + arr[i - 1] &gt;= arr[i - 1]) &#123;                dp_which_min[i] = min(dp_which_min[i - 1], arr[i - 1]);            &#125; else &#123;                dp_which_min[i] = arr[i - 1];            &#125;            dp_nodelete[i] = max(dp_nodelete[i - 1] + arr[i - 1], arr[i - 1]);            dp_delete[i] = max(dp_delete[i - 1] + arr[i - 1], dp_nodelete[i - 1] + arr[i - 1] - dp_which_min[i - 1]);            ret = max(&#123;ret, dp_nodelete[i], dp_delete[i]&#125;);        &#125;        return ret;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N). 可以优化为 O(1).\n 1187. Make Array Strictly Increasing\n比较暴力的方法，DFS + memorization.\n每次向下一位搜索时有替换和不替换2种选择，配合剪枝和memorization加速。\n可以发现，最坏情况下搜索的空间只是n * m而已，因为memo。\n时间复杂度: O(n * m * log m)，\n空间复杂度: O(n * m)\nclass Solution &#123;    const int FAIL = 3000;    unordered_map&lt;int, unordered_map&lt;int, int&gt;&gt; memo;    int dfs(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2, int i, int prev) &#123;        if (i == arr1.size()) &#123;            return 0;        &#125;        if (memo.find(i) != memo.end() &amp;&amp; memo[i].find(prev) != memo[i].end()) &#123;            return memo[i][prev];        &#125;        // pickarr2        auto it = upper_bound(arr2.begin(), arr2.end(), prev);        if (arr1[i] &gt; prev) &#123;            if (it != arr2.end() &amp;&amp; *it &lt; arr1[i])                return memo[i][prev] = min(dfs(arr1, arr2, i + 1, arr1[i]), dfs(arr1, arr2, i + 1, *it) + 1);            else                return memo[i][prev] = dfs(arr1, arr2, i + 1, arr1[i]);        &#125; else &#123;            if (it == arr2.end()) &#123;                return memo[i][prev] = FAIL;            &#125; else &#123;                return memo[i][prev] = dfs(arr1, arr2, i + 1, *it) + 1;            &#125;        &#125;    &#125;public:    int makeArrayIncreasing(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123;        sort(arr2.begin(), arr2.end());        auto ans = dfs(arr1, arr2, 0, -1);        if (ans &gt;= FAIL) &#123;            return -1;        &#125; else &#123;            return ans;        &#125;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 154","url":"/2019/09/18/LeetCode-weekly-contest-154/","content":"上周末在比利时，比赛时间是凌晨的4点半到6点，时间不合适，所以就没有参加。发现只有双周赛的时间是周六的下午4点半到6点，稍微合适些。ranking 2000的目标今年怕是要鸽了。最好的情况下，参与比赛的数目也只有国内的1/3.\n 1189. Maximum Number of Balloons\n统计每个字母的频数即可。需要注意的是，l和o 需要2次才能组成一个ballon。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int maxNumberOfBalloons(string text) &#123;        const string once = &quot;ban&quot;;        const string twice = &quot;lo&quot;;        vector&lt;int&gt; count(26, 0);        for (char c : text) &#123;            ++count[c - &#x27;a&#x27;];        &#125;        int ans = numeric_limits&lt;int&gt;::max();        for (char c : once) &#123;            ans = min(ans, count[c - &#x27;a&#x27;]);        &#125;        for (char c : twice) &#123;            ans = min(ans, count[c - &#x27;a&#x27;] / 2);        &#125;        return ans;    &#125;&#125;;\n 1190. Reverse Substrings Between Each Pair of Parentheses\n因为字符串的最大长度为2000，使用暴力法即可。用一个栈来进行括号匹配。\n时间复杂度: O(N ^ 2),\n空间负责度: O(N).\nclass Solution &#123;public:    string reverseParentheses(string s) &#123;        stack&lt;int&gt; st;        for (int i = 0; i &lt; s.size(); ++i) &#123;            auto&amp; c = s[i];            if (c == &#x27;)&#x27;) &#123;                int begin = st.top();                st.pop();                reverse(s.begin() + begin, s.begin() + i);            &#125; else if (c == &#x27;(&#x27;) &#123;                st.push(i);            &#125;        &#125;        string ans;        for (char c : s) &#123;            if (c != &#x27;)&#x27; &amp;&amp; c != &#x27;(&#x27;) &#123;                ans.push_back(c);            &#125;        &#125;        return ans;    &#125;&#125;;\n看过discuss之后，发现时间复杂度为O(N)的Solution。\n第一遍找到所有匹配的括号，第二遍构造结果字符串。每一个括号像一道传送门一样，改变前进方向的同时，跳到对应的括号那里。\nstring reverseParentheses(string s) &#123;    int n = s.length();    vector&lt;int&gt; opened, pair(n);    for (int i = 0; i &lt; n; ++i) &#123;        if (s[i] == &#x27;(&#x27;)            opened.push_back(i);        if (s[i] == &#x27;)&#x27;) &#123;            int j = opened.back();            opened.pop_back();            pair[i] = j;            pair[j] = i;        &#125;    &#125;    string res;    for (int i = 0, d = 1; i &lt; n; i += d) &#123;        if (s[i] == &#x27;(&#x27; || s[i] == &#x27;)&#x27;)            i = pair[i], d = -d;        else            res += s[i];    &#125;    return res;&#125;\n 1191. K-Concatenation Maximum Sum\n子数组最大和问题。该题目的特殊之处在于数组可以重复k次。\n仔细观察可以发现，当整个数组的和小于等于0时,根据贪心的思路，最后答案必定是数组重复2次组成的答案，即 本身的子数组，或 最大的前缀和 + 最大的后缀和。\n当整个数组的和大于0时，答案为k-2个数组和 + 最大的前缀和 + 最大的后缀和\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;    using ll = long long;    const ll mod = 1e9 + 7;public:    int kConcatenationMaxSum(vector&lt;int&gt;&amp; arr, int k) &#123;        ll head = 0, tail = 0;        ll global_max = 0, local_max = 0;        ll prefix = 0, total_sum = 0;        for (ll i = 0; i &lt; arr.size(); ++i) &#123;            if (arr[i] + prefix &lt; 0) &#123;                prefix = 0;            &#125; else &#123;                prefix = arr[i] + prefix;                local_max = max(local_max, prefix);            &#125;            total_sum += arr[i];            head = max(head, total_sum);            tail = min(tail, total_sum);        &#125;        tail = total_sum - tail;        tail = prefix;        if (total_sum &gt; 0) &#123;            global_max = tail + head + total_sum * (k - 2);        &#125; else &#123;            global_max = head + tail;        &#125;                global_max = max(global_max, local_max);        return global_max % mod;    &#125;&#125;;\n 1192. Critical Connections in a Network\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 156","url":"/2019/10/04/LeetCode-weekly-contest-156/","content":"赛后补题。\n 1207. Unique Number of Occurrences\nRecord the number of occurrences of each value by unordered_map.\nCheck the unique using unordered_set.\nTime complexity: O(N),\nSpace complexity: O(N).\nclass Solution &#123;public:    bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123;        unordered_set&lt;int&gt; count;        unordered_map&lt;int, int&gt; seen;        for (int i : arr) &#123;            ++seen[i];        &#125;        for (const auto&amp; p : seen) &#123;            if (count.find(p.second) != count.end()) &#123;                return false;            &#125; else &#123;                count.insert(p.second);            &#125;        &#125;        return true;    &#125;&#125;;\n 1208. Get Equal Substrings Within Budget\nSliding window.\nUse a sliding window to represent the available substring.\nTime complexity: O(N),\nspace complexity: O(1).\nclass Solution &#123;public:    int equalSubstring(string s, string t, const int maxCost) &#123;        int left = 0, right = 0;        // window: [left, right), length = right - left        int cost = 0;        int ans = 0;        while (left &lt; s.size()) &#123;            while (right &lt; s.size() &amp;&amp; cost + std::abs(s[right] - t[right]) &lt;= maxCost) &#123;                cost += std::abs(s[right] - t[right]);                ++right;                ans = max(ans, right - left);            &#125;            cost -= std::abs(s[left] - t[left]);            ++left;        &#125;        return ans;    &#125;&#125;;\n 1209. Remove All Adjacent Duplicates in String II\nOne pass scan  and remove duplicates.\nclass Solution &#123;public:    string removeDuplicates(string s, int k) &#123;        string ans;        vector&lt;int&gt; accu; // accumulate        for (char c : s) &#123;            int new_accu;            if (!ans.empty() &amp;&amp; c == ans.back()) &#123;                new_accu = accu.back() + 1;            &#125; else &#123;                new_accu = 1;            &#125;            if (new_accu &gt;= k) &#123;                for (int i = 0; i &lt; new_accu - 1; ++i) &#123;                    ans.pop_back();                    accu.pop_back();                &#125;            &#125; else &#123;                ans.push_back(c);                accu.push_back(new_accu);            &#125;        &#125;        return ans;    &#125;&#125;;\n 1210. Minimum Moves to Reach Target with Rotations\n最小步数，而且n的大小在100以内，所以 可以用BFS解决。\n本题的思路并不难，难点在于实现。由于不是直接的 BFS，实现 过程中 有 很多需要注意的点。\n时间复杂度: O(N ^ 2),\n空间复杂度: O(N ^ 2).\n因为最近尝鲜学习了Rust这门新兴的语言，所以接下来的一些题目都会用rust而不是C++。目的是可以让自己有机会练习和熟悉这门新的语言。有时间和心情的同学也可以学一下这门新语言，如果之前的主语言是C++的话，学RUST真的很痛快。\nuse std::collections::HashSet;use std::collections::VecDeque;impl Solution &#123;    pub fn minimum_moves(grid: Vec&lt;Vec&lt;i32&gt;&gt;) -&gt; i32 &#123;        // bfs        let n = grid.len() as i32;        assert_eq!(n &gt;= 2, true);        let m = grid[0].len() as i32;        assert_eq!(n, m);        let mut q = VecDeque::new();        let mut seen = HashSet::new();        let mut level = 1;        q.push_back(((0, 0), (0, 1)));        seen.insert(((0, 0), (0, 1)));        while !q.is_empty() &#123;            let size = q.len();            for _ in 0..size &#123;                let current = q.pop_front();                match current &#123;                    Some(value) =&gt; &#123;                        let next_step: [((i32, i32), (i32, i32)); 4] = [                            ((0, 1), (0, 1)),                            ((1, 0), (1, 0)),                            ((0, 0), (1, -1)),                            ((0, 0), (-1, 1)),                        ];                        for i in 0..4 &#123;                            let m = next_step[i];                            let new_tail = (value.0 .0 + m.0 .0, value.0 .1 + m.0 .1);                            let new_head = (value.1 .0 + m.1 .0, value.1 .1 + m.1 .1);                            if new_tail.0 &lt; n                                &amp;&amp; new_tail.1 &lt; n                                &amp;&amp; new_head.0 &lt; n                                &amp;&amp; new_head.1 &lt; n                                &amp;&amp; new_tail.0 &gt;= 0                                &amp;&amp; new_tail.1 &gt;= 0                                &amp;&amp; new_head.0 &gt;= 0                                &amp;&amp; new_head.1 &gt;= 0                                &amp;&amp; grid[new_tail.0 as usize][new_tail.1 as usize] == 0                                &amp;&amp; grid[new_head.0 as usize][new_head.1 as usize] == 0                                &amp;&amp; !seen.contains(&amp;(new_tail, new_head))                            &#123;                                if i == 0                                    || i == 1                                    || (value.0 .0 + 1 &gt;= 0 // old_tail + 1 is in range                                        &amp;&amp; value.0 .0 + 1 &lt; n                                        &amp;&amp; value.0 .1 + 1 &gt;= 0                                        &amp;&amp; value.0 .1 + 1 &lt; n                                        &amp;&amp; grid[(value.0 .0 + 1) as usize]  // old_tail + 1 is unblock                                            [(value.0 .1 + 1) as usize]                                            == 0                                        &amp;&amp; ((i == 2 &amp;&amp; value.0 .0 == value.1 .0)                                            || (i == 3 &amp;&amp; value.0 .1 == value.1 .1)))                                &#123;                                    if new_tail == (n - 1, n - 2) &amp;&amp; new_head == (n - 1, n - 1) &#123;                                        return level;                                    &#125;                                    q.push_back((new_tail, new_head));                                    seen.insert((new_tail, new_head));                                &#125;                            &#125;                        &#125;                    &#125;                    None =&gt; (),                &#125;;            &#125;            level += 1;        &#125;        return -1;    &#125;&#125;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly  contest 158","url":"/2019/10/14/LeetCode-weekly-contest-158/","content":" 1221. Split a String in Balanced Strings\n理解balanced的定义，发现只需要找到 L 和 R 出现个数相等的位置即可。\nTime complexity: O(N),\nSpace complexity: O(1).\nimpl Solution &#123;    pub fn balanced_string_split(s: String) -&gt; i32 &#123;        let mut ans = 0;        let mut l = 0;        let mut r = 0;        for c in s.chars() &#123;            match c &#123;                &#x27;L&#x27; =&gt; &#123; l += 1&#125;,                &#x27;R&#x27; =&gt; &#123; r += 1&#125;,                _ =&gt; (),            &#125;            if l == r &#123;                ans += 1;            &#125;        &#125;        ans    &#125;&#125;\n 1222. Queens That Can Attack the King\n虽然理解题目稍微复杂些，但算法其实很直接，从King往外找，而不是从queue开始找。\n时间复杂度: O(queens.len() + chessboard.len()),\n空间复杂度: O(queens.len()).\npub fn queens_attackthe_king(queens: Vec&lt;Vec&lt;i32&gt;&gt;, king: Vec&lt;i32&gt;) -&gt; Vec&lt;Vec&lt;i32&gt;&gt; &#123;    let mut qs: HashSet&lt;(i32, i32)&gt; = HashSet::new();    for queen in queens.iter() &#123;        qs.insert((queen[0], queen[1]));    &#125;    let mut ans: Vec&lt;Vec&lt;i32&gt;&gt; = Vec::new();    let direction = vec![        (0, 1),        (1, 1),        (1, 0),        (1, -1),        (0, -1),        (-1, -1),        (-1, 0),        (-1, 1),    ];    let k = (king[0], king[1]);    for (x, y) in direction.iter() &#123;        let mut target: (i32, i32) = k;        loop &#123;            target.0 += x;            target.1 += y;            if target.0 &gt;= 0 &amp;&amp; target.0 &lt; 8 &amp;&amp; target.1 &gt;= 0 &amp;&amp; target.1 &lt; 8 &#123;                if qs.contains(&amp;target) &#123;                    ans.push(vec![target.0, target.1]);                    break;                &#125;            &#125; else &#123;                break;            &#125;        &#125;    &#125;    ans&#125;\n 1223. Dice Roll Simulation\n有memoization的dfs。\n通过分析memo的最多可能，可知\n时间复杂度: O(6 * N ^ 2),\n空间复杂度: O(6 * N ^ 2).\nuse std::collections::HashMap;impl Solution &#123;    const MOD_NUMBER: i32 = 1000000007;    pub fn answer(        mut memo: &amp;mut HashMap&lt;(i32, usize, i32), i32&gt;,        roll_max: &amp;Vec&lt;i32&gt;,        n: i32,        previous_number: usize,        previous_consecutive: i32,    ) -&gt; i32 &#123;        if n == 0 &#123;            return 1;        &#125;        match memo.get(&amp;(n, previous_number, previous_consecutive)) &#123;            Some(value) =&gt; &#123;                return *value;            &#125;            None =&gt; &#123;                let mut ans = 0;                for i in 0..6 &#123;                    if i == previous_number &#123;                        if previous_consecutive == roll_max[previous_number] &#123;                            continue;                        &#125; else &#123;                            ans = (ans                                + Solution::answer(&amp;mut memo, &amp;roll_max, n - 1, i, previous_consecutive + 1))                                % Solution::MOD_NUMBER;                        &#125;                    &#125; else &#123;                        ans = (ans + Solution::answer(&amp;mut memo, &amp;roll_max, n - 1, i, 1)) % Solution::MOD_NUMBER;                    &#125;                &#125;                memo.insert((n, previous_number, previous_consecutive), ans);                return ans;            &#125;        &#125;    &#125;    pub fn die_simulator(n: i32, roll_max: Vec&lt;i32&gt;) -&gt; i32 &#123;        let mut memo: HashMap&lt;(i32, usize, i32), i32&gt; = HashMap::new();        Solution::answer(&amp;mut memo, &amp;roll_max, n, 0, 0)    &#125;&#125;\n 1224. Maximum Equal Frequency\n首先明确 an array prefix of nums的意义，即前缀数组。\n再看到加粗的exactly one，可知符合要求的前缀数组有2种情况：\n\n出现次数最多的数的数目 - 1 = 所有其他数的出现次数的数目\n有一个数出现次数为 1，其他数出现的次数相同\n最后看数据规模10^5，基本上可以确定必须要O(N * log N) 或 O(N)的算法了。\n\n算法其实已经呼之欲出了，很自然地想到用 散列表 记录不同数的出现次数，用 TreeSet对出现次数进行存储，可以快速更新出现次数。然后One Pass即可。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int maxEqualFreq(vector&lt;int&gt;&amp; nums) &#123;        unordered_map&lt;int, int&gt; count;        multiset&lt;int&gt; order;        int ans = 0;        for (int x = 0; x &lt; nums.size(); ++x) &#123;            int i = nums[x];            if (count[i] != 0) &#123;                auto it = order.find(count[i]);                order.erase(it);            &#125;            ++count[i];            order.insert(count[i]);            // detemiate            auto it1 = order.begin();            auto it2 = order.end();            --it2;            int n = order.size() - 1;            int length = x + 1;            if (it1 == it2) &#123;                ans = x + 1;            &#125; else &#123;                if ((*it2) == (*it1) + 1) &#123;                    if ( (*it2) * 1 + (*it1) * (n) == length) &#123;                        ans = x + 1;                    &#125;                &#125;                if (*it1 == 1) &#123;                    if (*it2 * n == length - 1) &#123;                        ans = x + 1;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 159","url":"/2019/10/21/LeetCode-weekly-contest-159/","content":" 1232. Check If It Is a Straight Line\n依次检查3个点是否共线。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;    bool right(const vector&lt;int&gt;&amp; p1, const vector&lt;int&gt;&amp; p2, const vector&lt;int&gt;&amp; p3) &#123;        return (p1[0] - p2[0]) * (p2[1] -  p3[1]) == (p1[1] - p2[1]) * (p2[0] - p3[0]);    &#125;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        for (int i =   0; i + 2 &lt; coordinates.size(); ++i) &#123;            if (!right(coordinates[i], coordinates[i + 1], coordinates[i + 2])) &#123;                return  false;            &#125;        &#125;        return true;    &#125;&#125;;\n 1233. Remove Sub-Folders from the Filesystem\n用一个HashSet记录出现过的路径，再遍历所有路径，依次分解每层的父目录，判断是否再记录中即可。\n时间复杂度: O(folder.size() * string.size()),\n空间复杂度: O(folder.size() * string.size()).\nclass Solution &#123;public:    vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) &#123;        unordered_set&lt;string&gt; memo;        for (auto&amp; f : folder) &#123;            memo.insert(f);        &#125;        vector&lt;string&gt; ans;        for (auto&amp; f : folder) &#123;            int i = f.size() - 1;            bool appear = false;            while (i &gt;= 0) &#123;                while (i &gt;= 0 &amp;&amp; f[i] != &#x27;/&#x27;) &#123;                    --i;                &#125;                auto head = f.substr(0, i);                if (memo.find(head) != memo.end()) &#123;                    appear = true;                    break;                &#125;                --i;            &#125;            if (!appear) &#123;                ans.push_back(f);            &#125;        &#125;        return ans;    &#125;&#125;;\n 1234. Replace the Substring for Balanced String\n滑动窗口。\n记录所有多的字母，然后设置一个窗口使得多的字母出现字数多于多的次数。然后移动该窗口，保持窗口的特性(多的字母出现字数多于多的次数)不变。记录 窗口的最小长度。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;    using ll = long long;public:    int balancedString(string s) &#123;        auto charaters = &#123;&#x27;Q&#x27;, &#x27;W&#x27;, &#x27;E&#x27;, &#x27;R&#x27;&#125;;        unordered_map&lt;char, ll&gt; count;        for (char c : s) &#123;            ++count[c];        &#125;        ll target = s.size() / 4;        ll window_size = 0;        unordered_set&lt;char&gt; one;        for (const auto&amp; p : count) &#123;            // cout &lt;&lt; p.first &lt;&lt; &quot;, &quot; &lt;&lt; p.second &lt;&lt; endl;            if (p.second &gt; target) &#123;                window_size += p.second - target;                one.insert(p.first);            &#125;        &#125;        if (window_size == 0)            return 0;        ll i = 0;        unordered_map&lt;char, ll&gt; one_amount;        while (i &lt; s.size()) &#123;            if (all_of(one.begin(), one.end(), [&amp;](const auto&amp; p) -&gt; bool &#123;                return one_amount[p] &gt;= count[p] - target;            &#125;)) &#123;                break;            &#125;            if (one.find(s[i]) != one.end()) &#123;                ++one_amount[s[i]];            &#125;            ++i;        &#125;        ll left = 0;        while (left &lt; s.size() &amp;&amp; (one.find(s[left]) != one.end() &amp;&amp; one_amount[s[left]] &gt; count[s[left]] - target) || (one.find(s[left]) == one.end())) &#123;            --one_amount[s[left]];            ++left;        &#125;        ll ret = i - left;        for (; i &lt; s.size(); ++i) &#123;            if (one.find(s[i]) != one.end()) &#123;                ++one_amount[s[i]];                while (left &lt; s.size() &amp;&amp; (one.find(s[left]) != one.end() &amp;&amp; one_amount[s[left]] &gt; count[s[left]] - target) || (one.find(s[left]) == one.end())) &#123;                    --one_amount[s[left]];                    ++left;                &#125;            &#125;            ret = min(ret, i - left + 1);        &#125;        return ret;    &#125;&#125;;\n 1235. Maximum Profit in Job Scheduling\n类似背包问题。\n先把job按照endTime排序，遍历每个job，加入或不加入，更新总的profit。\n更新策略为：根据job的start_time 二分查找符合条件的 end_time，得到加入该job的最大收益。如果最大收益大于之前 end_time的最大收益（因为 事先已经根据end_time排好序了，所以可以保证job的end_time是获得最大收益的end_time，则更新profit。\n最后返回最大的end_time的profit。\n时间 复杂度: O(N log N),\n空间 复杂度: O(N).\nclass Solution &#123;public:    int jobScheduling(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, vector&lt;int&gt;&amp; profit) &#123;        map&lt;int, int&gt; dp;        dp[0] = 0;        const int n = startTime.size();        vector&lt;tuple&lt;int, int, int&gt;&gt; jobs(n);        for (int i = 0; i &lt; n; ++i) &#123;            jobs[i] = &#123;endTime[i], startTime[i], profit[i]&#125;;        &#125;        sort(jobs.begin(), jobs.end());        for (const auto&amp; job : jobs) &#123;            int cur = prev(dp.upper_bound(get&lt;1&gt;(job)))-&gt;second + get&lt;2&gt;(job);            if (cur &gt; dp.rbegin()-&gt;second) &#123;                dp[get&lt;0&gt;(job)] = cur;            &#125;        &#125;        return dp.rbegin()-&gt;second;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 174","url":"/2020/02/03/LeetCode-weekly-contest-174/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n459 / 6997\nYoungForest\n18\n1:04:52\n0:15:31\n0:21:58\n0:41:22  2\n0:54:52\n\n\n\n终于回到亲爱的祖国啦。可以周日早上起来打LeetCode的比赛了。不得不承认，4个月没打，手生了很多。从比赛名次上就可以看出。\n这次比赛是完全的手速场，而手速是很看状态和熟练度的。因此排名掉了我心服口服。也恰好可以督促自己投入更多的精力准备接下来谷歌的面试。\n 1341. The K Weakest Rows in a Matrix\n二分搜索 查找每行的士兵数，排序找到前K个最少的行。\n时间复杂度: O(m log m * log n)\n空间复杂度: O(m)\nclass Solution &#123;    bool decide(const vector&lt;int&gt;&amp; row, int x) &#123;        return row[x] == 1;    &#125;    int number(const vector&lt;int&gt;&amp; row) &#123;        int lo = 0, hi = row.size();        while (lo &lt; hi) &#123;            int mid = lo + (hi - lo) / 2;            if (decide(row, mid)) &#123;                lo = mid + 1;            &#125; else &#123;                hi = mid;            &#125;        &#125;        return lo;    &#125;public:    vector&lt;int&gt; kWeakestRows(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) &#123;        vector&lt;pair&lt;int, int&gt;&gt; q;        for (int i = 0; i &lt; mat.size(); ++i) &#123;            q.push_back(&#123;number(mat[i]), i&#125;);        &#125;        // for (auto a : q) &#123;        //     cout &lt;&lt; a.first &lt;&lt; &quot; &quot; &lt;&lt; a.second &lt;&lt; endl;        // &#125;        sort(q.begin(), q.end(), [](auto a, auto b) -&gt; bool &#123;            if (a.first == b.first) &#123;                return a.second &lt; b.second;                            &#125; else &#123;                return a.first &lt; b.first;            &#125;        &#125;);        // for (auto a : q) &#123;        //     cout &lt;&lt; a.first &lt;&lt; &quot; &quot; &lt;&lt; a.second &lt;&lt; endl;        // &#125;        vector&lt;int&gt; ans;        for (int i = 0; i &lt; k; ++i) &#123;            ans.push_back(q[i].second);        &#125;        return ans;    &#125;&#125;;\n 1342. Reduce Array Size to The Half\n贪心策略。每次删除出现次数最多的数。\n时间复杂度: O(N log N).\n空间复杂度: O(N).\nclass Solution &#123;public:    int minSetSize(vector&lt;int&gt;&amp; arr) &#123;        unordered_map&lt;int, int&gt; count;        for (int i : arr) &#123;            ++count[i];        &#125;        vector&lt;int&gt; v;        for (auto p : count) &#123;            v.push_back(p.second);        &#125;        sort(v.begin(), v.end(), greater&lt;int&gt;());        int ans = 0, target = (arr.size() + 1) / 2, accu = 0;        while (accu &lt; target) &#123;            accu += v[ans];            ++ans;        &#125;        return ans;    &#125;&#125;;\n 1343. Maximum Product of Splitted Binary Tree\n枚举搜索即可。尝试所有的子树组合，寻找乘积最大的。\n在这里要注意，modulo 10^9 + 7的操作，我在此WA了2此。我使用unsigned long long，最后才mod。\n时间复杂度: O(N),\n空间复杂度: O(N).\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;    using ll = unsigned long long;    const ll mod = 1e9 + 7;    ll ans = 0;    ll sumOfSubtree(TreeNode* root, const ll total) &#123;        if (root == nullptr) &#123;            return 0;        &#125; else &#123;            ll l = sumOfSubtree(root-&gt;left, total);            ll r = sumOfSubtree(root-&gt;right, total);            if (root-&gt;left != nullptr) &#123;                ans = max(ans, l * (total - l));            &#125;            if (root-&gt;right != nullptr) &#123;                ans = max(ans, r * (total - r));            &#125;            return root-&gt;val + l + r;        &#125;    &#125;    ll sum(TreeNode* root) &#123;        if (root) &#123;            return root-&gt;val + sum(root-&gt;left) + sum(root-&gt;right);        &#125; else &#123;            return 0;        &#125;    &#125;public:    int maxProduct(TreeNode* root) &#123;        ll total = sum(root);        sumOfSubtree(root, total);        return ans % mod;    &#125;&#125;;\n 1344. Jump Game V\n自顶向下的动态规划思想。从每个index尝试向左右跳，直到遇到高度更大的。\n时间复杂度: O(N ^ 2).\n空间复杂度: O(N).\nclass Solution &#123;    int dp(const vector&lt;int&gt;&amp; arr, const int d, unordered_map&lt;int, int&gt;&amp; memo, int x) &#123;        if (x &lt; 0 || x &gt;= arr.size()) &#123;            return 0;        &#125; else if (memo.find(x) != memo.end()) &#123;            return memo[x];        &#125;        else &#123;            int ans = 1;            for (int i = x + 1; i &lt; arr.size() &amp;&amp; i &lt;= x + d &amp;&amp; arr[i] &lt; arr[x]; ++i) &#123;                ans = max(ans, dp(arr, d, memo, i) + 1);            &#125;            for (int i = x - 1; i &gt;= 0 &amp;&amp; i &gt;= x - d &amp;&amp; arr[i] &lt; arr[x]; --i) &#123;                ans = max(ans, dp(arr, d, memo, i) + 1);            &#125;            return memo[x] = ans;        &#125;    &#125;public:    int maxJumps(vector&lt;int&gt;&amp; arr, int d) &#123;        int ans = 0;        unordered_map&lt;int, int&gt; memo;        for (int i = 0; i &lt; arr.size(); ++i) &#123;            ans = max(ans, dp(arr, d, memo, i));        &#125;        return ans;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 175","url":"/2020/02/09/LeetCode-weekly-contest-175/","content":"本周由于眼镜坏掉了，不在状态。在家吃饭也晚，所以题目并没有做完。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n1378 / 7826\nYoungForest\n7\n0:11:41\n0:06:51\n0:11:41\nnull\nnull\n\n\n\n 1346. Check If N and Its Double Exist\n使用一个hashmap存储之前见到过的数即可。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    bool checkIfExist(vector&lt;int&gt;&amp; arr) &#123;        unordered_set&lt;int&gt; s;        for (int i : arr) &#123;            if (s.find(i * 2) != s.end() || (i % 2 == 0 &amp;&amp; s.find(i / 2) != s.end()))                return true;            s.insert(i);        &#125;        return false;    &#125;&#125;;\n 1347. Minimum Number of Steps to Make Two Strings Anagram\n根据Anagram的定义，我们统计2个字符串中各个字符出现频数之差就可以了。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;    vector&lt;int&gt; convert(const string&amp; s) &#123;        vector&lt;int&gt; ans(26);        for (char c : s) &#123;            ++ans[c - &#x27;a&#x27;];        &#125;        return ans;    &#125;public:    int minSteps(string s, string t) &#123;        auto count_s = convert(s);        auto count_t = convert(t);        int ans = 0;        for (int i = 0; i &lt; 26; ++i) &#123;            if (count_s[i] &gt; count_t[i]) &#123;                ans += count_s[i] - count_t[i];            &#125;                    &#125;        return ans;    &#125;&#125;;\n 1348. Tweet Counts Per Frequency\n使用TreeMap记录Tweet即可。\n需要注意记录区间分割的点，根据这些分割点寻找里面的Tweet。\n时间复杂度:\n\nrecordTweet: O(log N)\ngetTweetCountsPerFrequency: O(N * log N * (endTime - startTime) / interval)\n空间复杂度:\nO(N)\n\nclass TweetCounts &#123;    unordered_map&lt;string, map&lt;int, int&gt;&gt; string_map;public:    TweetCounts() &#123;            &#125;    void recordTweet(string tweetName, int time) &#123;        ++string_map[tweetName][time];    &#125;        vector&lt;int&gt; getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) &#123;        int interval = 0;        if (freq == &quot;hour&quot;) &#123;            interval = 3600;        &#125; else if (freq == &quot;day&quot;) &#123;            interval =  3600 * 24;        &#125; else &#123;            interval = 60;        &#125;        const auto&amp; m = string_map[tweetName];        vector&lt;int&gt; ans;        int st = startTime;        auto start_it = m.lower_bound(st);        auto end_it = m.upper_bound(endTime);        auto it = start_it;        while (st &lt;= endTime) &#123;            auto next_it = m.lower_bound(st + interval);            int accu = 0;            for (; it != next_it &amp;&amp; it != end_it; ++it) &#123;                accu += it-&gt;second;            &#125;            ans.push_back(accu);            st += interval;        &#125;                return ans;    &#125;&#125;;/** * Your TweetCounts object will be instantiated and called as such: * TweetCounts* obj = new TweetCounts(); * obj-&gt;recordTweet(tweetName,time); * vector&lt;int&gt; param_2 = obj-&gt;getTweetCountsPerFrequency(freq,tweetName,startTime,endTime); */\n 1349. Maximum Students Taking Exam\n一道还挺难的题目，看了花花酱的视频后才学会正确的解法，在这里友情打一波广告。\n动态规划 和 状态压缩。\n这里有几个bitmask的技巧:\n\n左右不能有学生: (x &amp; (x &gt;&gt; 1)) == 0\n左上不能有学生: (a &amp; (b &gt;&gt; 1)) == 0\n根据座椅枚举所有的状态: state_enum = state &amp; (state_enum - 1)\n\n时间复杂度: O(m * 2 ^ n * 2 ^ n),\n空间复杂度: O(m * 2 ^ n) -&gt; O(2 ^ n).\nclass Solution &#123;    bool left_and_right(int a) &#123;        return (a &amp; (a &gt;&gt; 1)) == 0;    &#125;    bool ok(int a, int b) &#123;        return left_and_right(b) &amp;&amp; left_and_right(b) &amp;&amp; (a &amp; (b &gt;&gt; 1)) == 0 &amp;&amp; (b &amp; (a &gt;&gt; 1)) == 0;    &#125;public:    int maxStudents(vector&lt;vector&lt;char&gt;&gt;&amp; seats) &#123;        const int m = seats.size();        const int n = seats[0].size();                vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (1 &lt;&lt; n));        int last_state = 0;                for (int row = 0; row &lt; m; ++row) &#123;            auto&amp; last_row = dp[row];            auto&amp; current_row = dp[row + 1];            int state = 0;            for (int col = 0; col &lt; n; ++col) &#123;                state |= seats[row][col] == &#x27;.&#x27; ? (1 &lt;&lt; col) : 0;            &#125;            for (int last_state_enum = last_state; ; last_state_enum = last_state &amp; (last_state_enum - 1)) &#123;                for (int state_enum = state; ; state_enum = state &amp; (state_enum - 1)) &#123;                    if (ok(last_state_enum, state_enum)) &#123;                        current_row[state_enum] = max(current_row[state_enum], last_row[last_state_enum] +  __builtin_popcount(state_enum));                    &#125;                    if (state_enum == 0) &#123;                        break;                    &#125;                &#125;                if (last_state_enum == 0) &#123;                    break;                &#125;            &#125;                        last_state = state;        &#125;                return *max_element(begin(dp[m]), end(dp[m]));    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 176","url":"/2020/02/16/LeetCode-weekly-contest-176/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n306 / 8105\nYoungForest\n19\n1:36:07\n0:02:47\n0:23:09\n0:54:53  1\n1:26:07  1\n\n\n\n本次比赛在最后关头终于AC，也是极其的惊现刺激。自从加入中国区的同学之后，我周赛的排名都很难进入前200了。比如本次就从229掉到了306。不得不承认，我国内卷之严重呀。\n排名落后的主要原因在于第3题花费了很多时间调试和试，差点最后一题都没时间实现了。最近缺少练习也导致debug能力和一遍bug-free的能力急剧下降。\n 1351. Count Negative Numbers in a Sorted Matrix\n利用横竖都是有序的条件，可以实现O(m + n)的计数。\n和search-a-2d-matrix-ii类似。\n时间复杂度: O(m + n),\n空间复杂度: O(1).\nclass Solution &#123;public:    int countNegatives(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans = 0;        const int m = grid.size();        const int n = grid[0].size();        int row = 0, col = n - 1;        while (row &lt; m &amp;&amp; col &gt;= 0) &#123;            if (grid[row][col] &lt; 0) &#123;                ans += m - row;                --col;            &#125; else &#123;                ++row;            &#125;        &#125;        return ans;    &#125;&#125;;\n 1352. Product of the Last K Numbers\n记录最后0的位置和累计的乘积。判断最后K个数中是否有0，如果没有的话，借助最后的乘积除以倒数第k + 1个乘积即可。\n时间复杂度:\n\nadd: O(1)\ngetProduct: O(1)\n空间复杂度: O(N)\n\nclass ProductOfNumbers &#123;    vector&lt;int&gt; product;    int zeros = 0;    int index = 1;public:    ProductOfNumbers() &#123;        product.push_back(1);    &#125;        void add(int num) &#123;        if (num == 0) &#123;            product.push_back(1);            zeros = index;        &#125;        else            product.push_back(num * product.back());        ++index;    &#125;        int getProduct(int k) &#123;        int b = index - k;        int e = index; // [b, e)        if (zeros &lt; b) &#123;            return product.back() / product[product.size() - k - 1];        &#125; else &#123;            return 0;        &#125;    &#125;&#125;;/** * Your ProductOfNumbers object will be instantiated and called as such: * ProductOfNumbers* obj = new ProductOfNumbers(); * obj-&gt;add(num); * int param_2 = obj-&gt;getProduct(k); */\n 1353. Maximum Number of Events That Can Be Attended\n贪心策略。\n每次都做结束时间最早的事件。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int maxEvents(vector&lt;vector&lt;int&gt;&gt;&amp; events) &#123;        int ans = 0;        int current_day = 1;        multiset&lt;int&gt; q;        int i = 0;        sort(begin(events), end(events), [](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            if (a[0] != b[0]) &#123;                return a[0] &lt; b[0];            &#125; else &#123;                return a[1] &lt; b[1];            &#125;        &#125;);        while (i &lt; events.size() || !q.empty()) &#123;            while (i &lt; events.size() &amp;&amp; events[i][0] &lt;= current_day) &#123;                q.insert(events[i][1]);                ++i;            &#125;            while (!q.empty() &amp;&amp; *q.begin() &lt; current_day) &#123;                q.erase(q.begin());            &#125;            if (!q.empty() &amp;&amp; *q.begin() &gt;= current_day) &#123;                ++ans;                // cout &lt;&lt; *q.begin() &lt;&lt; endl;                q.erase(q.begin());            &#125;            ++current_day;        &#125;        return ans;    &#125;&#125;;\n 1354. Construct Target Array With Multiple Sums\n貌似很难的题目，但一旦发现：每次replace的结果都是替换成最大的数，就可以从最后的数组倒推回初始数组。\n时间复杂度: O(N log N max_number)\n空间复杂度: O(N).\nclass Solution &#123;    using ll = long long;public:    bool isPossible(vector&lt;int&gt;&amp; target) &#123;        multimap&lt;ll, ll&gt; m;        ll s = 0;        for (int i = 0; i &lt; target.size(); ++i) &#123;            m.insert(&#123;target[i], i&#125;);            s += target[i];        &#125;        function&lt;bool()&gt; recurse = [&amp;]() -&gt; bool &#123;            if (s == target.size())                return true;            auto max_item = m.end();            --max_item;            ll left = max_item-&gt;first;            ll index = max_item-&gt;second;            ll others = s - left;            ll x = left - others;            // cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; others &lt;&lt; &quot; &quot; &lt;&lt; x &lt;&lt; endl;            if (x &lt; 1)                return false;            s = left;            m.erase(max_item);            m.insert(&#123;x, index&#125;);            target[index] = x;            return recurse();        &#125;;        return recurse();    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 177","url":"/2020/02/23/LeetCode-weekly-contest-177/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n333 / 6106\nYoungForest\n20\n1:04:22\n0:25:00\n0:33:40\n0:43:21\n0:59:22  1\n\n\n\n手速和bug-free的场。\n 1360. Number of Days Between Two Dates\n计算2个日期间的差值。本来想着手算来着，但写起来太复杂了。后来果断放弃，投机取巧用了Python日期处理的库函数。\n时间复杂度: O(1),\n空间复杂度: O(1).\nfrom datetime import dateclass Solution:    def daysBetweenDates(self, date1: str, date2: str) -&gt; int:        delta = date.fromisoformat(date1) - date.fromisoformat(date2)        return abs(delta.days)\n 1361. Validate Binary Tree Nodes\n观察有，合法的二叉树为：\n\n有且仅有一个节点没有父节点\n剩下节点均只有一个父节点\n没有孤儿，既没有父亲、也没有child（在节点数大于1的情况下）\n\n第3个要求比较难想到，甚至是OJ一开始也是错的。我也就将错就错通过了。感谢votrubac的提示。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    bool validateBinaryTreeNodes(int n, vector&lt;int&gt;&amp; leftChild, vector&lt;int&gt;&amp; rightChild) &#123;        if (n &lt; 2)            return true;        vector&lt;int&gt; parents(n, -1);        vector&lt;bool&gt; hasChild(n, false);        auto fillParents = [&amp;](int index, int parent) -&gt; bool &#123;            if (parents[index] != -1)                return false;            parents[index] = parent;            return true;        &#125;;        for (int i = 0; i &lt; n; ++i) &#123;            for (int child : &#123;leftChild[i], rightChild[i]&#125;) &#123;                if (child != -1) &#123;                    if(fillParents(child, i) == false)                        return false;                &#125;            &#125;            hasChild[i] = leftChild[i] != -1 || rightChild[i] != -1;        &#125;        int count = 0;        for (int i : parents) &#123;            if (i == -1) &#123;                if (hasChild[i] == false)                    return false;                ++count;            &#125;        &#125;        return count == 1;    &#125;&#125;;\n 1362. Closest Divisors\n使用贪心的策略。从sqrt(n)开始进行枚举，此时差就是最小的。\n时间复杂度: O(sqrt(n)),\n空间复杂度: O(1).\nclass Solution &#123;    pair&lt;int, int&gt; current(int n) &#123;        for (int i = floor(sqrt(n)); i &gt;= 1; --i) &#123;            if (n % i == 0) &#123;                return &#123;i, n / i&#125;;            &#125;        &#125;        return &#123;0, 0&#125;;    &#125;public:    vector&lt;int&gt; closestDivisors(int num) &#123;        auto p1 = current(num + 1);        auto p2 = current(num + 2);        if (abs(p1.first - p1.second) &lt; abs(p2.second - p2.first)) &#123;            return &#123;p1.first, p1.second&#125;;        &#125; else &#123;            return &#123;p2.first, p2.second&#125;;        &#125;    &#125;&#125;;\n 1363. Largest Multiple of Three\n总体上是一个贪心的思路。\n首先考虑一个更简单的问题：\n如何组成最大的数组-&gt;最大的放前面。\n在加入被3整除这一约束条件后，\n我们有观察，剩下的数字越多越好，其次是删掉的数越小越好。\n此时，就有了如下算法。\n因为错将multiset用作set，导致了一次Wrong Answer. 这不是第一次犯类似的错误了。以后考虑使用set时，需要提前想想允不允许重复。\n时间复杂度: O(n log n),\n空间复杂度: O(n).\nclass Solution &#123;    // n log npublic:    string largestMultipleOfThree(vector&lt;int&gt;&amp; digits) &#123;        vector&lt;multiset&lt;int&gt;&gt; remind(3);        int all = 0;        for (int i : digits) &#123;            remind[i % 3].insert(i);            all += i;        &#125;        auto remove = [&amp;](int one, int two) -&gt; bool &#123;            if (remind[one].empty()) &#123;                if (remind[two].size() &gt;= 2) &#123;                    remind[two].erase(remind[two].begin());                    remind[two].erase(remind[two].begin());                &#125; else &#123;                    return false;                &#125;            &#125; else &#123;                remind[one].erase(remind[one].begin());            &#125;            return true;        &#125;;        if (all % 3 == 0) &#123;                    &#125; else if (all % 3 == 1) &#123;            if (remove(1, 2) == false)                return &quot;&quot;;        &#125; else &#123;            if (remove(2, 1) == false)                return &quot;&quot;;        &#125;        vector&lt;int&gt; v;        for (const auto&amp; s : remind) &#123;            for (int i : s) &#123;                v.push_back(i);            &#125;        &#125;        sort(v.begin(), v.end(), greater&lt;int&gt;());        string ans;        for (int i : v) &#123;            ans += to_string(i);        &#125;        if (ans[0] == &#x27;0&#x27;)            return &quot;0&quot;;        else            return ans;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 179","url":"/2020/03/08/LeetCode-weekly-contest-179/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n539 / 6242\nYoungForest\n18\n1:09:53\n0:05:43\n0:13:09\n0:24:01\n1:04:53  1\n\n\n\n 1374. Generate a String With Characters That Have Odd Counts\n如果n为偶数，则一个a，剩下都为b；\n如果n为奇数，则全为a.\n时间复杂度: O(n),\n空间复杂度: O(n).\n之前写代码从来不过重注意输入的合法性检查。因为Leetcode本身对输入有限制。但是现实面试的时候，面试官有时会关注你对输入的预设和检查，毕竟实际生产过程中的输入永远是无法预料的。\nclass Solution &#123;public:    string generateTheString(int n) &#123;        if (n &lt;= 0) return &quot;&quot;;        string ans;        if (n % 2 == 1) &#123;            ans.append(n, &#x27;a&#x27;);        &#125; else &#123;            ans.push_back(&#x27;a&#x27;);            ans.append(n - 1, &#x27;b&#x27;);        &#125;        return  ans;    &#125;&#125;;\n 1375. Bulb Switcher III\n观察有：蓝色灯永远是前连续个，意味着蓝色灯的状态可以用index最高的灯表示，同时这个index是单调非递减的。所以只需要比较它和最大亮着的灯的下标是否相同即可。且每次亮灯都试图增大这个blue_index。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int numTimesAllBlue(vector&lt;int&gt;&amp; light) &#123;        int max_turn_on_index = -1;        int blue_index = -1;        const int n = light.size();        vector&lt;bool&gt; turn_on(n);        int ans = 0;        for (int i : light) &#123;            turn_on[i - 1] = true;            max_turn_on_index = max(max_turn_on_index, i - 1);            while (blue_index + 1 &lt; n &amp;&amp; turn_on[blue_index +  1] == true) &#123;                ++blue_index;            &#125;            if (blue_index == max_turn_on_index)                ++ans;        &#125;        return ans;    &#125;&#125;;\n 1376. Time Needed to Inform All Employees\n典型的dfs，每次寻找最长时间通知完的下属。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123;        unordered_map&lt;int, vector&lt;int&gt;&gt; graphs;        for (int i = 0; i &lt; manager.size(); ++i) &#123;            graphs[manager[i]].push_back(i);        &#125;        if (graphs[-1].empty()) return 0;        int head = graphs[-1][0];        function&lt;int(int)&gt; dfs = [&amp;](int index) -&gt; int &#123;            if (graphs[index].empty())                return 0;            else &#123;                int ans = 0;                for (int subordinate : graphs[index]) &#123;                    ans = max(ans, dfs(subordinate));                &#125;                return ans + informTime[index];            &#125;        &#125;;                return dfs(head);    &#125;&#125;;\n 1377. Frog Position After T Seconds\n同样是DFS, 需要注意的是，我们要寻找的是经过t秒后的位置。所以有可能跳过target，概率为0。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    double frogPosition(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, int t, int target) &#123;        unordered_map&lt;int, set&lt;int&gt;&gt; graphs;        for (const auto&amp; e : edges) &#123;            graphs[e[0]].insert(e[1]);            graphs[e[1]].insert(e[0]);        &#125;        graphs[1].insert(0);        int ans = 0;        unordered_set&lt;int&gt; visited;        visited.insert(0);        function&lt;bool(int,int,int)&gt; dfs = [&amp;](int index, int probability, int time) -&gt; bool &#123;            visited.insert(index);            if (time &gt; t)                return false;            if (index == target) &#123;                if (time == t)                    ans = probability;                else &#123;                    if (graphs[index].size() &lt;= 1)                        ans = probability;                    else                        ans = 0;                    // cout &lt;&lt; ans &lt;&lt; &quot; &quot; &lt;&lt; probability &lt;&lt; endl;                &#125;                return true;            &#125; else &#123;                for (int neighbor : graphs[index]) &#123;                    if (visited.find(neighbor) == visited.end())                        if (dfs(neighbor, probability * (graphs[index].size() - 1), time + 1))                            return true;                &#125;                return false;            &#125;        &#125;;        dfs(1, 1, 0);        // cout &lt;&lt; ans &lt;&lt; endl;        return ans &gt; 0 ? 1.0 / ans : 0;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 180","url":"/2020/03/15/LeetCode-weekly-contest-180/","content":"自从LeetCode更新了周赛rating算法后，结果下我一跳。Rating直接涨到2171，全球排名608/81184, 完成比赛53场。记得上周我还在期望可以近几周突破2000分的，已经1990+了。更新后的算法显示去年8月份就已经2000了。\n本周日会村里看望奶奶，由于疫情原因，之前一家人一直未能团聚。今天好不容易，几乎所有人都到场了。周赛也是回老家参加的。由于环境不适合思考，所以结果也差强人意。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (4)\nQ4 (6)\n\n\n\n\n1300 / 10047\nYoungForest\n11\n0:29:31\n0:12:20\n0:18:26\n0:29:31\nnull\n\n\n\n 1380. Lucky Numbers in a Matrix\n统计每行的最小值所在的列数和每列最大值所在的行数，判断是否有相等的。\n时间复杂度: O(m * n),\n空间复杂度: O(m + n).\nclass Solution &#123;public:    vector&lt;int&gt; luckyNumbers (vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        const int m =  matrix.size();        if (m == 0) return &#123;&#125;;        const  int n = matrix[0].size();        vector&lt;int&gt; row_min_index(m, -1);        vector&lt;int&gt; col_max_index(n, -1);        for (int i = 0; i &lt; m; ++i) &#123;            for (int j = 0; j &lt; n; ++j) &#123;                if (row_min_index[i] == -1 || matrix[i][row_min_index[i]] &gt; matrix[i][j]) &#123;                    row_min_index[i] = j;                &#125;                if (col_max_index[j] == -1 || matrix[col_max_index[j]][j] &lt; matrix[i][j]) &#123;                    col_max_index[j] = i;                &#125;            &#125;        &#125;        vector&lt;int&gt; ans;        for (int row = 0; row &lt; m; ++row) &#123;            if (col_max_index[row_min_index[row]] == row) &#123;                ans.push_back(matrix[row][row_min_index[row]]);            &#125;        &#125;        return ans;    &#125;&#125;;\n 1381. Design a Stack With Increment Operation\n用数组实现栈即可。\n时间复杂度:\n\nConstructor: O(1)\npush: O(1)\npop: O(1)\nincrement: O(k)\n空间复杂度: O(maxSize)\n\n还有一种Lazy Increment的算法，increment时，只做一个标记，只有到pop的时候才真的增加。可以实现increment的O(1).\nclass CustomStack &#123;    vector&lt;int&gt; data;    int index;    int max_size;public:    CustomStack(int maxSize) &#123;        data.resize(maxSize);        index = 0;        max_size = maxSize;    &#125;        void push(int x) &#123;        if (index &lt; max_size) &#123;            data[index++] = x;        &#125;    &#125;        int pop() &#123;        if (index &gt; 0) &#123;            return data[--index];        &#125; else &#123;            return -1;        &#125;    &#125;        void increment(int k, int val) &#123;        for (int i = 0; i &lt; k &amp;&amp; i &lt; index; ++i) &#123;            data[i] += val;        &#125;    &#125;&#125;;/** * Your CustomStack object will be instantiated and called as such: * CustomStack* obj = new CustomStack(maxSize); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * obj-&gt;increment(k,val); */\n 1382. Balance a Binary Search Tree\n先用中序遍历将数据排序，然后再使用二分法重新建树。\n时间复杂度: O(N),\n空间复杂度: O(height).\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:    TreeNode* balanceBST(TreeNode* root) &#123;        if (!root) return nullptr;        vector&lt;int&gt; element;        function&lt;void(TreeNode*)&gt; store = [&amp;](TreeNode* root) -&gt; void &#123;            if (!root) &#123;                return;            &#125; else &#123;                store(root-&gt;left);                element.push_back(root-&gt;val);                store(root-&gt;right);            &#125;        &#125;;        store(root);        function&lt;TreeNode*(int, int)&gt; build = [&amp;](int begin, int end) -&gt; TreeNode* &#123;            if (begin &gt; end) return nullptr;            else if (begin == end) return new TreeNode(element[begin]);            else &#123;                int mid = begin + (end - begin) / 2;                auto ret = new TreeNode(element[mid]);                ret-&gt;left = build(begin, mid - 1);                ret-&gt;right = build(mid + 1, end);                return ret;            &#125;        &#125;;        return build(0, element.size() - 1);    &#125;&#125;;\n 1383. Maximum Performance of a Team\n贪心的算法。先按照efficiency从大到小排序，挑选效率最高的k个人，然后再遍历效率稍低的人，尝试把他们加入队伍(剔除掉speed最小的), 更新可能的Maximum performance.\n时间复杂度: O(N log N + N log K),\n空间复杂度: O(N + K).\n相似的题目: LeetCode 857.\nclass Solution &#123;    using ll = long long;    const ll MOD = 1e9 + 7;    const ll INF = 0x3f3f3f3f;public:    int maxPerformance(int n, vector&lt;int&gt;&amp; speed, vector&lt;int&gt;&amp; efficiency, int k) &#123;        ll ans = 0;        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;        vector&lt;pair&lt;int, int&gt;&gt; workers;        for (int i = 0; i &lt; n; ++i) &#123;            workers.push_back(&#123;efficiency[i], speed[i]&#125;);        &#125;        sort(workers.begin(), workers.end(), greater&lt;pair&lt;int, int&gt;&gt;());        ll sum_speed = 0;        ll min_efficiency = INF;        for (int i = 0; i &lt; k; ++i) &#123;            sum_speed += workers[i].second;            min_efficiency = workers[i].first;            pq.push(workers[i].second);            ans = max(sum_speed * min_efficiency, ans);        &#125;        for (int i = k; i &lt; n; ++i) &#123;            min_efficiency = workers[i].first;            if (workers[i].second &gt; pq.top()) &#123;                auto t = pq.top();                pq.pop();                sum_speed = sum_speed - t + workers[i].second;                pq.push(workers[i].second);                ans = max(ans, sum_speed * min_efficiency);            &#125;        &#125;        return ans % MOD;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode  weekly contest 181","url":"/2020/03/22/LeetCode-weekly-contest-181/","content":"自从LeetCode rating算法更新后，我的rating到达了顶峰，之后就一直向下掉。不过也是因为自己菜，每次都打的大好几百名，偶尔还上千。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n839 / 10930\nYoungForest\n18\n1:31:13\n0:04:53\n0:14:43  1\n0:45:27  1\n1:16:13  1\n\n\n\n 1389. Create Target Array in the Given Order\n签到题。使用vector的insert接口，缺点是效率有问题，不过对于签到题足够了。\n时间复杂度: O(n ^ 2), 最坏情况是 每次都插到首位。\n空间复杂度: O(n).\nclass Solution &#123;public:    vector&lt;int&gt; createTargetArray(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; index) &#123;        vector&lt;int&gt; ans;        const int n = nums.size();        for (int i = 0; i &lt; n ; ++ i) &#123;            if (index[i] &lt; ans.size())                 ans.insert(ans.begin() + index[i], nums[i]);            else                ans.push_back(nums[i]);        &#125;        return ans;    &#125;&#125;;\n 1390. Four Divisors\nBrute force. 计算每个数的因数。\n时间复杂度: O(sqrt(nums[i]) * nums.length),\n空间复杂的: O(nums.length) -&gt; O(1) without memo.\nclass Solution &#123;    unordered_map&lt;int, int&gt; memo;    unordered_map&lt;int, int&gt; sumDivisors;    int divisors(int x) &#123;        if (x == 1)            return 1;        else &#123;            if (memo.find(x) == memo.end()) &#123;                int ans = 2;                int sum = 1 + x;                for (int i = 2; i * i &lt;= x; ++i) &#123;                    if (x % i == 0) &#123;                        ans += (i * i == x) ? 1 : 2;                        sum += (i * i == x) ? i : i + x / i;                    &#125;                    if (ans &gt; 4)                        break;                &#125;                if (ans == 4) &#123;                    sumDivisors[x] = sum;                &#125;                return memo[x] = ans;            &#125; else &#123;                return memo[x];            &#125;        &#125;    &#125;public:    int sumFourDivisors(vector&lt;int&gt;&amp; nums) &#123;        int ans = 0;        for (int i : nums) &#123;            if (divisors(i) == 4)                ans += sumDivisors[i];        &#125;        return ans;    &#125;&#125;;\n 1391. Check if There is a Valid Path in a Grid\n算法不是很难的一道题目，一遍搜索即可。难点在于实现，对复杂问题进行抽象。我在这里使用了多个hashmap来解决方位的抽象。\n时间复杂度: O(row * col),\n空间复杂度: O(1).\n本题也可以用 &quot;并查集&quot;解决，实现起来更简单些。\nclass Solution &#123;public:    bool hasValidPath(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        unordered_map&lt;string, pair&lt;int, int&gt;&gt; directions = &#123;            &#123;&quot;up&quot;, &#123;-1, 0&#125;&#125;,            &#123;&quot;down&quot;, &#123;1, 0&#125;&#125;,            &#123;&quot;left&quot;, &#123;0, -1&#125;&#125;,            &#123;&quot;right&quot;, &#123;0, 1&#125;&#125;        &#125;;        unordered_map&lt;int, unordered_map&lt;string, string&gt;&gt; mm = &#123;            &#123;1, &#123;&#123;&quot;left&quot;, &quot;right&quot;&#125;, &#123;&quot;right&quot;, &quot;left&quot;&#125;&#125;&#125;,            &#123;2, &#123;&#123;&quot;up&quot;, &quot;down&quot;&#125;, &#123;&quot;down&quot;, &quot;up&quot;&#125;&#125;&#125;,            &#123;3, &#123;&#123;&quot;left&quot;, &quot;down&quot;&#125;, &#123;&quot;down&quot;, &quot;left&quot;&#125;&#125;&#125;,            &#123;4, &#123;&#123;&quot;down&quot;, &quot;right&quot;&#125;, &#123;&quot;right&quot;, &quot;down&quot;&#125;&#125;&#125;,            &#123;5, &#123;&#123;&quot;left&quot;, &quot;up&quot;&#125;, &#123;&quot;up&quot;, &quot;left&quot;&#125;&#125;&#125;,            &#123;6, &#123;&#123;&quot;up&quot;, &quot;right&quot;&#125;, &#123;&quot;right&quot;, &quot;up&quot;&#125;&#125;&#125;        &#125;;        unordered_map&lt;string, string&gt; reversed = &#123;            &#123;&quot;left&quot;, &quot;right&quot;&#125;,            &#123;&quot;right&quot;, &quot;left&quot;&#125;,            &#123;&quot;up&quot;, &quot;down&quot;&#125;,            &#123;&quot;down&quot;, &quot;up&quot;&#125;        &#125;;        unordered_map&lt;int, vector&lt;string&gt;&gt; start_direction = &#123;            &#123;1, &#123;&quot;left&quot;&#125;&#125;,            &#123;2, &#123;&quot;up&quot;&#125;&#125;,            &#123;3, &#123;&quot;left&quot;&#125;&#125;,            &#123;4, &#123;&quot;down&quot;, &quot;right&quot;&#125;&#125;,            &#123;5, &#123;&#125;&#125;,            &#123;6, &#123;&quot;up&quot;&#125;&#125;        &#125;;        const int m = grid.size();        const int n = grid[0].size();        if (m == 1 &amp;&amp; n == 1)            return true;        for (string d : start_direction[grid[0][0]]) &#123;            int row = 0, col = 0;            while (true) &#123;                d = mm[grid[row][col]][d];                row += directions[d].first;                col += directions[d].second;                d = reversed[d];                if (row &lt; 0 || row &gt;= m || col &lt; 0 || col &gt;= n || mm[grid[row][col]].find(d) == mm[grid[row][col]].end()) &#123;                    break;                &#125; else if (row == m - 1 &amp;&amp; col == n - 1)                    return true;            &#125;        &#125;        return false;    &#125;&#125;;\n 1392. Longest Happy Prefix\n参考的是geekforgeek上的代码，并不难找，Google &quot;longest prefix suffix&quot;就能出来。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    string longestPrefix(string s) &#123;        int n = s.size();           vector&lt;int&gt; lps(n);         lps[0] = 0; // lps[0] is always 0         // length of the previous         // longest prefix suffix         int len = 0;         // the loop calculates lps[i]         // for i = 1 to n-1         int i = 1;         while (i &lt; n)         &#123;             if (s[i] == s[len])             &#123;                 len++;                 lps[i] = len;                 i++;             &#125;             else // (pat[i] != pat[len])             &#123;                 if (len != 0)                 &#123;                     len = lps[len-1];                 &#125;                 else // if (len == 0)                 &#123;                     lps[i] = 0;                     i++;                 &#125;             &#125;         &#125;         int res = lps[n-1];         return s.substr(0, res);     &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 182","url":"/2020/03/29/LeetCode-weekly-contest-182/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (8)\n\n\n\n\n727 / 11694\nYoungForest\n12\n0:22:50\n0:03:13\n0:14:04\n0:22:50\nnull\n\n\n\n这周一加了一个LeetCode每日打卡和周赛群。每周出排名，末位发红包；每天做道指定题目，连续2天没做发红包，极其惊现刺激。赛事排行榜。\n本次比赛是入群以来的第一次，由于第四题太难了，总共也就一百人做出来。群里也只有5个人AC\n 1394. Find Lucky Integer in an Array\n签到题。注意数据范围，统计frequency即可。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int findLucky(vector&lt;int&gt;&amp; arr) &#123;        vector&lt;int&gt; count(501, 0);        for (int i : arr) &#123;            ++count[i];        &#125;        for (int i = 500; i &gt;= 1; --i) &#123;            if (count[i] == i)                return i;        &#125;        return -1;    &#125;&#125;;\n 1395. Count Number of Teams\n由于数据规模很小，所以即使是枚举所有3元组的N^3的解法也能过。\n在这里，我使用了DP, N^2复杂度的解法。如果使用order statistic tree的话，可以近一步降为N log N.\n时间复杂度: O(N ^ 2),\n空间复杂度: O(N).\nclass Solution &#123;public:    int numTeams(vector&lt;int&gt;&amp; rating) &#123;        auto f = [&amp;](function&lt;bool(int,int)&gt; op) -&gt; int &#123;            const int n = rating.size();            vector&lt;vector&lt;int&gt;&gt; large(3, vector&lt;int&gt;(n, 1));            int ans;            for (int echo = 1; echo &lt;= 2; ++echo) &#123;                ans = 0;                for (int i = 0; i &lt; n; ++i) &#123;                    large[echo][i] = 0;                    for (int j = 0; j &lt; i; ++j) &#123;                        if (op(rating[i], rating[j])) &#123;                            large[echo][i] += large[echo-1][j];                        &#125;                    &#125;                    ans += large[echo][i];                &#125;            &#125;            return ans;        &#125;;        return f(greater&lt;int&gt;()) + f(less&lt;int&gt;());    &#125;&#125;;\n 1396. Design Underground System\nstraight forward.\n用map记录每个站对的进出站总时间和人数。\n时间复杂度：\n\ncheckIn: O(1),\ncheckOut: O(1 + log N),\ngetAverageTime: O(log N).\n空间复杂度: O(user.size() + station.size() ^ 2).\n\nclass UndergroundSystem &#123;    unordered_map&lt;int, pair&lt;string, int&gt;&gt; user_checkin_time;    // 记录进站信息    map&lt;pair&lt;string, string&gt;, pair&lt;int, int&gt;&gt; interval_total_time_person_count; // 记录2站之间流量的信息，总时间、人数public:    UndergroundSystem() &#123;            &#125;        void checkIn(int id, string stationName, int t) &#123;        user_checkin_time[id] = &#123;stationName, t&#125;;    &#125;        void checkOut(int id, string stationName, int t) &#123;        auto in = user_checkin_time[id];        auto&amp; interval = interval_total_time_person_count[&#123;in.first, stationName&#125;];        interval.first += t - in.second;        ++interval.second;        user_checkin_time.erase(id);    &#125;        double getAverageTime(string startStation, string endStation) &#123;        auto it = interval_total_time_person_count.find(&#123;startStation, endStation&#125;);        if (it == interval_total_time_person_count.end())            return -1;        else            return static_cast&lt;double&gt;(it-&gt;second.first) / it-&gt;second.second;    &#125;&#125;;/** * Your UndergroundSystem object will be instantiated and called as such: * UndergroundSystem* obj = new UndergroundSystem(); * obj-&gt;checkIn(id,stationName,t); * obj-&gt;checkOut(id,stationName,t); * double param_3 = obj-&gt;getAverageTime(startStation,endStation); */\n 1397. Find All Good Strings\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 183","url":"/2020/04/07/LeetCode-weekly-contest-183/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (4)\nQ3 (6)\nQ4 (7)\n\n\n\n\n91 / 12542\nYoungForest\n21\n0:39:07\n0:09:24\n0:15:33\n0:29:53\n0:39:07\n\n\n\n本周又是手速场，足足有800人AK。可能是由于疫情的原因，程序员都wfh（work from home），每次周赛的参加人数都稳步上涨，比我刚回国的时候已经增加一个一倍了。rating掉了有一个月了，这周终于涨上来了，2187，恢复到了最高点。\n 1403. Minimum Subsequence in Non-Increasing Order\n贪心。先排序，试图选大的值，直到累计和超过一半。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; minSubsequence(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end(), greater&lt;int&gt;());        int sumAll = accumulate(nums.begin(), nums.end(), 0);        vector&lt;int&gt; ans;        int sumCurrent = 0;        for (int i : nums) &#123;            ans.push_back(i);            sumCurrent += i;            if (sumCurrent &gt; sumAll / 2) &#123;                return ans;            &#125;        &#125;        return ans;    &#125;&#125;;\n 1404. Number of Steps to Reduce a Number in Binary Representation to One\n用字符串模拟“加一”操作，直到为1.\n这里我用了一个list来存字符，以方便进位操作。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int numSteps(string s) &#123;        list&lt;char&gt; l(s.begin(), s.end());        int ans = 0;        while (l.size() &gt; 1) &#123;            if (l.back() == &#x27;1&#x27;) &#123;                auto it = l.rbegin();                for (;it != l.rend(); ++it) &#123;                    if (*it == &#x27;0&#x27;) &#123;                        *it = &#x27;1&#x27;;                        goto endIf;                    &#125; else &#123;                        *it = &#x27;0&#x27;;                    &#125;                &#125;                l.push_front(&#x27;1&#x27;);                endIf: ;            &#125; else &#123;                l.pop_back();            &#125;            ++ans;        &#125;        return ans;    &#125;&#125;;\n 1405. Longest Happy String\n贪心。每次试图用剩余最多的字符。\n时间复杂度: O(a + b + c),\n空间复杂度: O(a + b + c).\nclass Solution &#123;public:    string longestDiverseString(int a, int b, int c) &#123;        // greedy        string ans;        vector&lt;int&gt; count = &#123;a, b, c&#125;;        auto maxChar = [&amp;](const vector&lt;int&gt;&amp; mask) -&gt; int &#123;            int ans = -1;            for (int i = 0; i &lt; count.size(); ++i) &#123;                if (mask[i] == 0 &amp;&amp; (ans == -1 || count[i] &gt; count[ans])) &#123;                    ans = i;                &#125;            &#125;            return ans;        &#125;;        while (count[0] &gt; 0 || count[1] &gt; 0 || count[2] &gt; 0) &#123;            int nextChar = -1;            vector&lt;int&gt; mask(3, 0);            if (ans.size() &gt;= 2 &amp;&amp; ans[ans.size() - 1] == ans[ans.size() - 2]) &#123;                mask[ans[ans.size() - 1] - &#x27;a&#x27;] = 1;                nextChar = maxChar(mask);            &#125; else &#123;                nextChar = maxChar(mask);            &#125;            if (count[nextChar] == 0) &#123;                return ans;            &#125;            ans.push_back(&#x27;a&#x27; + nextChar);            --count[nextChar];        &#125;        return ans;    &#125;&#125;;\n 1406. Stone Game III\nDP。\nf(x): 以x开头，先手最优情况下获得的分数。\n因为2个人都以最优策略执行, 所以\nf(x) = max(剩余所有和 - f(x + 1),剩余所有和 - f(x + 2),剩余所有和 - f(x + 3)).\nAlice获得的最大分数为f(0).\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution:    def stoneGameIII(self, stoneValue: List[int]) -&gt; str:        @lru_cache(None)        def suffixFunction(x: int) -&gt; int:            if x == len(stoneValue):                return 0            else:                return stoneValue[x] + suffixFunction(x + 1)                    @lru_cache(None)        def f(x: int) -&gt; int:            if x &gt;= len(stoneValue):                return 0            else:                suffix = suffixFunction(x)                return max(suffix - f(x + 1), suffix - f(x + 2), suffix - f(x + 3))        alice = f(0)        bob = suffixFunction(0) - alice        if alice == bob:            return &#x27;Tie&#x27;        elif alice &gt; bob:            return &#x27;Alice&#x27;        else:            return &#x27;Bob&#x27;\n 后记\n今天翻到很久之前写的contest的博客，大概一年多前准备Google电话面试的时候。当时还是很菜的，一般能做出2题就差不多了。谷歌的面试也挂在了第一轮，就问了个加油站问题 和 最近公共祖先问题。都答的不是很好。现在看来都是不难的题目。遗憾当时准备不足，水平也有限。一年过后，同样面对Google的面试，虽回答的不完美，但也通过了第一轮面试。我从18年底开始大量刷题，现在做了有900+道了，contest也参加了50+，算法水平还是有可见的进步的。虽然离大佬的差距依旧很大。\n不过由于疫情的原因，application并没有继续进行下去。HR只说是招聘流程有变化。和残酷刷题群的群友交流，美国那边很多New Graduate和intern的招聘都停了，原来发的offer很多也收回了，或者work from home。谷歌中国不会也这样吧。\n之前只知道就业形势一年不如一年，没想到今年这么糟糕呀。实习、毕业都成问题。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 184","url":"/2020/04/12/LeetCode-weekly-contest-184/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (4)\nQ3 (6)\nQ4 (7)\n\n\n\n\n589 / 9816\nYoungForest\n19\n0:55:30\n0:07:04\n0:15:05\n0:37:18  1\n0:50:30\n\n\n\n今天又是一轮手速场。Python告诉我们，“人生苦短，我用Python”。我有2题用Python实现，1和4。事实上，对于第3题，直接调用Python Str API更是如鱼得水，不过我当时选择了用Trie+自动机的方式实现，也活该名次掉下来。\n 1408. String Matching in an Array\n签到题。使用Python Str的find函数确定是否是子字符串即可。\n时间复杂度: O(words.length ^ 2 * words[i].length),\n空间复杂度: O(words.length * words[i].length).\nclass Solution:    def stringMatching(self, words: List[str]) -&gt; List[str]:        ans = set()        n = len(words)        for i in range(n):            for j in range(i + 1, n):                if words[i].find(words[j]) != -1:                    ans.add(words[j])                if words[j].find(words[i]) != -1:                    ans.add(words[i])        return [i for i in ans]\n 1409. Queries on a Permutation With Key\n用List模拟Permutation的变化。\n寻找位置时使用顺序查找。\n时间复杂度: O(m + queries.length * m),\n空间复杂度: O(m + queries.length).\nclass Solution &#123;public:    vector&lt;int&gt; processQueries(vector&lt;int&gt;&amp; queries, int m) &#123;        list&lt;int&gt; P;        for (int i = 1; i &lt;= m; ++i) &#123;            P.push_back(i);        &#125;        vector&lt;int&gt; ans(queries.size());        for (int i = 0; i &lt; queries.size(); ++i) &#123;            auto it = P.begin();            int position = 0;            while (it != P.end() &amp;&amp; *it != queries[i]) &#123;                ++it;                ++position;            &#125;            ans[i] = position;            P.push_front(*it);            P.erase(it);        &#125;        return ans;    &#125;&#125;;\nDiscuss中提供了一种Fenwick Tree的解法，时间复杂度: O(queries.length * log m + m * log m).\n 1410. HTML Entity Parser\n自动机，用Trie维护自动机的状态转移。\n时间复杂度: O(text.length),\n空间复杂度: O(text.length + 1).\nclass Solution &#123;    struct Trie &#123;        unordered_map&lt;char, shared_ptr&lt;Trie&gt;&gt; children;        char replace;        bool valid = false;        void add(const string&amp; s, char c, int index = 1) &#123;            if (index == s.size()) &#123;                valid = true;                replace = c;                return;            &#125;            if (children[s[index]] == nullptr) &#123;                children[s[index]] = make_shared&lt;Trie&gt;();            &#125;            children[s[index]]-&gt;add(s, c, index + 1);        &#125;    &#125;;public:    string entityParser(string text) &#123;        shared_ptr&lt;Trie&gt; root = make_shared&lt;Trie&gt;();        root-&gt;add(&quot;&amp;quot;&quot;, &#x27;&quot;&#x27;);        root-&gt;add(&quot;&amp;apos;&quot;, &#x27;\\&#x27;&#x27;);        root-&gt;add(&quot;&amp;amp;&quot;, &#x27;&amp;&#x27;);        root-&gt;add(&quot;&amp;gt;&quot;, &#x27;&gt;&#x27;);        root-&gt;add(&quot;&amp;lt;&quot;, &#x27;&lt;&#x27;);        root-&gt;add(&quot;&amp;frasl;&quot;, &#x27;/&#x27;);        string ans;        int  i = 0;        while (i &lt; text.size())  &#123;            if (text[i] == &#x27;&amp;&#x27;) &#123;                int j = i + 1;                auto current = root;                while (j &lt; text.size() &amp;&amp; current-&gt;children[text[j]] != nullptr) &#123;                    current = current-&gt;children[text[j++]];                &#125;                if (current-&gt;valid) &#123;                    ans.push_back(current-&gt;replace);                    i = j;                &#125; else &#123;                    ans.push_back(text[i++]);                &#125;            &#125; else &#123;                ans.push_back(text[i++]);            &#125;        &#125;        return  ans;    &#125;&#125;;\n 1411. Number of Ways to Paint N × 3 Grid\n递归解法，一行一行地确定Paint数目。明确本行可行和上行兼容的表示方法即可。\n时间复杂度: O(n),\n空间复杂度: O(n) -&gt; O(1). 最多只需要保存2行的状态即可。\nclass Solution:    def numOfWays(self, n: int) -&gt; int:        import functools        @functools.lru_cache(None)        def unzip(x: int) -&gt; List[int]:            a = x // (3*3)            b = (x // (3)) % 3            c = x % 3            return [a, b, c]        @functools.lru_cache(None)        def row_not_valid(state: int) -&gt; bool:            a, b, c = unzip(state)            return a == b or b == c        @functools.lru_cache(None)        def between_row_valid(a: int, b: int) -&gt; bool:            al = unzip(a)            bl = unzip(b)            return all(al[i] != bl[i] for i in range(3))                    @functools.lru_cache(None)        def dp(n: int, state: int) -&gt; int:            if row_not_valid(state):                return 0            else:                if n == 0:                    return 1                else:                    ans = 0                    for i in range(3**3):                        if not row_not_valid(i) and between_row_valid(state, i):                            ans += dp(n-1, i)                    return ans                ans = 0        for i in range(3**3):            if not row_not_valid(i):                ans += dp(n-1, i)        return ans % (1000000000 + 7)","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 185","url":"/2020/04/20/LeetCode-weekly-contest-185/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (4)\nQ3 (6)\nQ4 (7)\n\n\n\n\n703 / 9206\nYoungForest\n12\n0:36:35\n0:10:24\n0:22:03\n0:31:35  1\nnull\n\n\n\n 1417. Reformat The String\n分别统计数字和字母的个数。如果相差个数不大于1，则可以reformat。\n先选多的那类。\n时间复杂度: O(N),\n空间复杂度: O(N). 可以用双指针的方法，节省存储数字和字母的string的空间。\nclass Solution &#123;    string compose(const string&amp; a, const string&amp; b) &#123;        string ans;        int ai = 0, bi = 0;        if (a.size() &gt; b.size())            ans.push_back(a[ai++]);        while (ai &lt; a.size()) &#123;            ans.push_back(b[bi++]);            ans.push_back(a[ai++]);        &#125;        return ans;    &#125;public:    string reformat(string s) &#123;        string digit, alpha;        for (char c : s) &#123;            if (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123;                digit.push_back(c);            &#125; else &#123;                alpha.push_back(c);            &#125;        &#125;        if (digit.size() == alpha.size() || digit.size() + 1 == alpha.size() || alpha.size() + 1 == digit.size()) &#123;            if (digit.size() &gt;= alpha.size()) &#123;                return compose(digit, alpha);            &#125; else &#123;                return compose(alpha, digit);            &#125;        &#125; else &#123;            return &quot;&quot;;        &#125;    &#125;&#125;;\n 1418. Display Table of Food Orders in a Restaurant\n考察数据结构的使用。遍历orders，将其转换成dish-&gt;table的hashmap，同时用set存储table编号。\n时间复杂度: O(orders.length * orders[i].length),\n空间复杂度: O(tables.length * dishes.length).\nclass Solution &#123;public:    vector&lt;vector&lt;string&gt;&gt; displayTable(vector&lt;vector&lt;string&gt;&gt;&amp; orders) &#123;        set&lt;int&gt; tables;        map&lt;string, unordered_map&lt;int, int&gt;&gt; count;        for (const auto&amp; p : orders) &#123;            const int table_number = stoi(p[1]);            const auto&amp; dish = p[2];            ++count[dish][table_number];            tables.insert(table_number);        &#125;        vector&lt;vector&lt;string&gt;&gt; ans;        vector&lt;string&gt; first_row = &#123;&quot;Table&quot;&#125;;        for (const auto&amp; p : count) &#123;            first_row.push_back(p.first);        &#125;        ans.push_back(move(first_row));        for (int i : tables) &#123;            vector&lt;string&gt; row;            row.push_back(to_string(i));            for (auto&amp; p : count) &#123;                row.push_back(to_string(p.second[i]));            &#125;            ans.push_back(move(row));        &#125;        return ans;    &#125;&#125;;\n 1419. Minimum Number of Frogs Croaking\n有限状态机，记录处于不同位置青蛙的个数。模拟整个叫声。\n时间复杂度: O(croakOfFrogs.length),\n时间复杂度: O(croak.length).\nclass Solution &#123;public:    int minNumberOfFrogs(string croakOfFrogs) &#123;        vector&lt;int&gt; state_count(5, 0);        unordered_map&lt;char, int&gt; position = &#123;            &#123;&#x27;c&#x27;, 0&#125;,            &#123;&#x27;r&#x27;, 1&#125;,            &#123;&#x27;o&#x27;, 2&#125;,            &#123;&#x27;a&#x27;, 3&#125;,            &#123;&#x27;k&#x27;, 4&#125;        &#125;;        for (char c : croakOfFrogs) &#123;            if (position[c] == 0) &#123;                if (state_count[4] &gt; 0) &#123;                    --state_count[4];                &#125;                ++state_count[position[c]];            &#125; else &#123;                ++state_count[position[c]];                if (state_count[position[c]-1] &lt;= 0)                    return -1;                --state_count[position[c]-1];            &#125;        &#125;        if (all_of(state_count.begin(), state_count.begin() + 4, [](const auto&amp; a) -&gt; bool &#123;            return a == 0;        &#125;))            return state_count[4];        else            return -1;    &#125;&#125;;\n 1420. Build Array Where You Can Find The Maximum Exactly K Comparisons\n最近做DP的题目虽然做了很多，但遇到新的问题还是不一定能做出来。遇到的困难主要有：\n\n确定dp的定义。一般情况下照搬目标就可以了，但有些题目不是。\n确定边界条件。递归退出的条件。\n状态转移方程，和dp的定义紧密相连。\n\n本题中dp[i][currentMaxValue][cost]表示长度为i的数组，且数组中最大值为currentMaxValue, 递增子序列长度为cost 的数组个数。\n状态转移方程 有2类：\n一是i-1数组的最大值已经是currentMaxValue了。这时，我们可以在第i个位置加上[1, currentMaxValue], 而cost不变。\n二是i-1数组的最大值小于currentMaxValue。此时，第i个位置必须是currentMaxValue。且之前的cost为cost-1. 需要注意的是，前面的最大值最小是cost-1，递增序列为1, …, cost-1.\n时间复杂度: O(n * m * k * (m - k)),\n空间复杂度: O(n * m * k).\nclass Solution:    def numOfArrays(self, n: int, m: int, k: int) -&gt; int:        mod = 10**9 + 7        @lru_cache(None)        def dp(i, currentMaxValue, cost):            if cost == 1:                return currentMaxValue**i            ans = 0            # arr[i] &lt;= currentMaxValue            if i + 1 &gt; cost:                ans += dp(i-1, currentMaxValue, cost) * currentMaxValue            # arr[i] == currentMaxValue            ans += sum(dp(i-1, x, cost - 1) for x in range(cost - 1, currentMaxValue))            return ans        return sum(dp(n - 1, x, k) for x in range(k, m+1)) % mod        # return sum(dp(length, k, x) * (x ** (n - length)) for x in range(1, m + 1) for length in range(1, n+1))\n 美团笔试中的一道DP题目\n周四参加美团暑期实习招聘的笔试，最后一道也是DP，但当时没做出来, 其实也就那么回事。\n\n给2个字符串S, T. 求S的子串等于T的子序列的个数。注意，即使子串相同，但位置不同，算2种。\nS，T的长度最大为5000.\n\n时间复杂度: (len(S) * (len(T) ^ 2)),\n空间复杂度: (len(S) * len(T)).\nimport functoolsS = input()T = input()@functools.lru_cache(None)def dp(i, j):    # S[x:i], 以s[i]结尾的子串，T[:j]中子串匹配到的数目    if i == 0:        return sum(1 if S[i] == T[x] else 0 for x in range(0, j + 1))    if j == 0:        return 1 if S[i] == T[0] else 0    ans = 0    if T[0] == S[i]:        ans = 1    for x in range(1, j+1):        if T[x] == S[i]:            ans += dp(i-1, x-1) + 1    return ansmod = 1000000000 + 7ans = sum(dp(x, len(T)-1) for x in range(0, len(S))) % modprint(ans)","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weeekly contest 186","url":"/2020/04/26/LeetCode-weekly-contest-186/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (4)\nQ2 (4)\nQ3 (6)\nQ4 (7)\n\n\n\n\n113 / 11684\nYoungForest\n18\n0:34:17\n0:04:32\n0:10:54\n0:18:49\n0:34:17\n\n\n\n手速场。换成Python后，手速场很轻松。真的是人生苦短，我用Python。不过在用Python刷题的过程中，我也发现了一些问题。\n\nAPI不熟悉。比如sorted会返回一个排好序的list，而不是in-place sort.\n数据结构不全。如没有treemap，priority_queue只能用heap，代替。最小堆需要把所有数*-1，使用这种丑陋的实现方式。\nruntime error。在一些手误情况下，会有错误的提交。这时候很考验你的测试用例了，是否覆盖所有的情况和边界条件。\n\n 1422. Maximum Score After Splitting a String\nbrute-force. 2 &lt;= s.length &lt;= 500.\n时间复杂度: O(N ^ 2),\n空间复杂度: O(1).\n另外，如果采取Presum的方式的话，时间复杂度可以降为O(N)。\nclass Solution:    def maxScore(self, s: str) -&gt; int:        def count(s, c):            ans = 0            for i in s:                if i == c:                    ans += 1            return ans        return max(count(s[:x], &#x27;0&#x27;) + count(s[x:], &#x27;1&#x27;) for x in range(1,len(s)))\n 1423. Maximum Points You Can Obtain from Cards\n问题可以转化为：从头取x个，从尾取k-x个 和最大。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution:    def maxScore(self, cardPoints: List[int], k: int) -&gt; int:        n = len(cardPoints)        presum = [0] * (n + 1)        suffixsum = [0] * (n + 1)        for i in range(1, n+1):            presum[i] = presum[i-1] + cardPoints[i-1]            suffixsum[i] = suffixsum[i-1] + cardPoints[n-i]                return max(presum[x] + suffixsum[k-x] for x in range(k+1)) # take x from head, k - x from tail\n评论区还有一种主流方法。将问题转化为 寻找和最小的大小为num.size()-k的子数组。使用滑动窗口的方法，时间复杂度: O(N), 空间复杂度: O(1).\n 1424. Diagonal Traverse II\n遍历一遍，把元素放入适当的对角线上。对角线用一个dict存储，每条对角线是个list.\n需要注意的是，python中dict是hashmap，3.7后保证遍历时的顺序和插入的顺序一致。所以在这里我们可以直接遍历对角线字典。\n时间复杂度: O(the number of elements),\n空间复杂度: O(the number of elements).\nclass Solution:    def findDiagonalOrder(self, nums: List[List[int]]) -&gt; List[int]:        line = defaultdict(list)        for start in range(len(nums)):            for i in range(len(nums[start])):                line[start + i].append(nums[start][i])        ans = []        for i in line:            while line[i]:                ans.append(line[i].pop())        return ans\n 1425. Constrained Subset Sum\n动态规划。dp[i]表示以第i个元素结尾，的最大子集和。\ndp[i] = max(dp[j] + nums[i] for i - j &gt;= k).\n观察有，当遇到非负数时，可以提前跳出。因为子集中肯定尽量加正数（非负数）。\n时间复杂度: O(n * k),\n空间复杂度: O(n).\nclass Solution:    def constrainedSubsetSum(self, nums: List[int], k: int) -&gt; int:        n = len(nums)        dp = nums[:]        ans = float(&#x27;-inf&#x27;)        for i in range(n):            for j in range(k):                index = i - 1 - j                if index &lt; 0:                    break                dp[i] = max(dp[i], dp[index] + nums[i])                if nums[index] &gt;= 0:                    break            ans = max(ans, dp[i])        return ans\n评论区中有正确的O(N)的解法。利用单调递减deque，可以在O(1)的时间里维护max(dp[j] + nums[i] for i - j &gt;= k).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 187","url":"/2020/05/04/LeetCode-weekly-contest-187/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n301 / 12353\nYoungForest\n19\n1:03:24\n0:06:34\n0:03:07\n0:17:30\n1:03:24\n\n\n\n 1436. Destination City\n遍历每条边，统计各个点的出度。\n时间复杂度: O(path.length * city[i].length),\n空间复杂度: O(city.length * city[i].length).\nclass Solution &#123;public:    string destCity(vector&lt;vector&lt;string&gt;&gt;&amp; paths) &#123;        unordered_map&lt;string, int&gt; outgoing;        unordered_set&lt;string&gt; seen;        for (const auto&amp; v : paths) &#123;            ++outgoing[v[0]];            seen.insert(v[0]);            seen.insert(v[1]);        &#125;        for (const auto&amp; s : seen) &#123;            if (outgoing[s] == 0)                return s;        &#125;        return &quot;&quot;;    &#125;&#125;;\n 1437. Check If All 1’s Are at Least Length K Places Away\nOne pass. 记录上一个1出现的位置。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    bool kLengthApart(vector&lt;int&gt;&amp; nums, int k) &#123;        int last_one = -INF;        for (int i = 0; i &lt; nums.size(); ++i) &#123;            if (nums[i] == 1) &#123;                if (i - last_one - 1 &gt;= k) &#123;                    last_one = i;                &#125; else &#123;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;&#125;;\n 1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit\n双指针，用一个multiset维护子数组中的元素，由于treemap的特点，可以快速地锁定子数组中的最大最小值。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\nclass Solution &#123;public:    int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) &#123;        multiset&lt;int&gt; subarray;        size_t ans = 0;        for (int r = 0, l = 0; r &lt; nums.size(); ++r) &#123;            while (!subarray.empty() &amp;&amp; nums[r] - *subarray.begin() &gt; limit) &#123;                auto it = subarray.find(nums[l++]);                subarray.erase(it);            &#125;            while (!subarray.empty() &amp;&amp; *subarray.rbegin() - nums[r] &gt; limit) &#123;                auto it = subarray.find(nums[l++]);                subarray.erase(it);            &#125;            subarray.insert(nums[r]);            ans = max(ans, subarray.size());        &#125;        return ans;    &#125;&#125;;\n 1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows\n优先队列记录所有的候选者，从中选出sum最小的组合，并将变化后的可能加入优先队列。\n需要注意的是，相同的候选者可能从不同的状态产生（如 001, 010 -&gt; 011)，这里我用了一个set和字符串变化以去重。\n时间复杂度: O(k * m * m * log (nm)),\n空间复杂度: O(n * m * m).\nclass Solution &#123;    string encode(const vector&lt;int&gt;&amp; v) &#123;        string ans;        for (int i : v) &#123;            ans.push_back(&#x27;a&#x27; + i);        &#125;        return ans;    &#125;public:    int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int k) &#123;        const int m = mat.size();        const int n = mat[0].size();        int rank = 0;        priority_queue&lt;pair&lt;int, vector&lt;int&gt;&gt;,std::vector&lt;pair&lt;int,vector&lt;int&gt;&gt;&gt;, std::greater&lt;pair&lt;int,vector&lt;int&gt;&gt;&gt;&gt; pq; // difference, row_index        unordered_set&lt;string&gt; seen;        int current_sum = 0;        for (int i = 0; i &lt; m; ++i) &#123;            current_sum += mat[i][0];        &#125;        &#123;            vector&lt;int&gt; index(m, 0);            pq.push(&#123;current_sum, index&#125;);            seen.insert(encode(index));        &#125;                while (rank &lt; k &amp;&amp; !pq.empty()) &#123;            auto t = pq.top();            pq.pop();            current_sum = t.first;            for (int i = 0; i &lt; m; ++i) &#123;                ++t.second[i];                string x = encode(t.second);                if (t.second[i] &lt; n &amp;&amp; seen.find(x) == seen.end()) &#123;                    pq.push(&#123;current_sum + mat[i][t.second[i]] - mat[i][t.second[i]-1], t.second&#125;);                    seen.insert(x);                &#125;                --t.second[i];            &#125;            ++rank;        &#125;        return current_sum;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 188","url":"/2020/05/10/LeetCode-weekly-contest-188/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n445 / 12715\nYoungForest\n19\n1:14:29\n0:07:04\n0:17:33\n0:56:49\n1:14:29\n\n\n\nRating 稳定在2200+2周了，虽然本周的rating还没有更新，但根据排名应该是会继续升的。争取早日到达2300+的分数线。最近刷题遇到了瓶颈，很多hard的题目还是不会做，也没有总结出自己刷题的模版和类别。我发现很多大佬之所以很强，是因为看到题目描述，可以很快地发现该题目属于具体的哪类，迅速和之前做过的题目建立联系，才能又快又bug free的AC。\n 1441. Build an Array With Stack Operations\nOne pass. 2个下标分别指向target的位置和n中的位置。\n时间复杂度: O(max(N, target.size())),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;string&gt; buildArray(vector&lt;int&gt;&amp; target, int n) &#123;        int i = 1;        int index = 0;        vector&lt;string&gt; ans;        for (; i &lt;= n &amp;&amp; index &lt; target.size(); ++i) &#123;            if (target[index] == i) &#123;                ans.push_back(&quot;Push&quot;);                ++index;            &#125; else &#123;                ans.push_back(&quot;Push&quot;);                ans.push_back(&quot;Pop&quot;);            &#125;        &#125;        return ans;    &#125;&#125;;\n 1442. Count Triplets That Can Form Two Arrays of Equal XOR\n本题需要利用 异或 的一个性质。a ^ a = 0, a ^ b = b ^ a, (a ^ b) ^ c = a ^ (b ^ c). 即 自反律，交换律，结合律。\n所以可以根据类似 presum 的操作在O(1)的时间里算出整个区间的异或值。\n然后枚举 所有三元组，找到符合条件的。\n时间复杂度: O(N ^ 3),\n空间复杂度: O(N).\nclass Solution &#123;public:    int countTriplets(vector&lt;int&gt;&amp; arr) &#123;        // Time: O(n ^ 3)        vector&lt;int&gt; prexor(arr.size() + 1);        prexor[0] = 0;        // prexor[i]: arr[0] ^ ... ^ arr[i-1]        for (int i = 0; i &lt; arr.size(); ++i) &#123;            prexor[i+1] = prexor[i] ^ arr[i];         &#125;        // [i, j)        auto xorquick = [&amp;](int i, int j) -&gt; int &#123;            return prexor[j] ^ prexor[i];        &#125;;        int ans = 0;        for (int i = 0; i &lt; arr.size(); ++i) &#123;            for (int j = i + 1; j &lt; arr.size(); ++j) &#123;                for (int k = j; k &lt; arr.size(); ++k) &#123;                    if (xorquick(i, j) == xorquick(j, k + 1)) &#123;                        ++ans;                        // cout &lt;&lt; &quot;(&quot; &lt;&lt; i &lt;a&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;,&quot; &lt;&lt; k &lt;&lt; &quot;)&quot; &lt;&lt; endl;                    &#125;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\nDiscuss里有寒神给出的\nO(N^2)的算法和O(N)的算法.\n 1443. Minimum Time to Collect All Apples in a Tree\n树状DP。首先，递归搜索所有子树是否有苹果。然后，递归收集子树重的苹果。\n时间复杂度: O(N),\n空间复杂度: O(N).\n一开始看错了题目，忽略了还必须回到根节点，所以写了更复杂度的树状DP。增加了一个条件，是否需要回来。耽误了半个小时，否则我的本次周赛的排名还可以再提高点。\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int minTime(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;bool&gt;&amp; hasApple) &#123;        vector&lt;vector&lt;int&gt;&gt; children(n);        for (const auto&amp; v : edges) &#123;            children[v[0]].push_back(v[1]);            children[v[1]].push_back(v[0]);        &#125;        children[0].push_back(-1);        vector&lt;bool&gt; hasAppleInChildTree(n);        function&lt;int(int, int)&gt; recurse = [&amp;](int root, int parent) -&gt; int &#123;            bool ans = hasApple[root];            for (int child : children[root]) &#123;                if (child != parent) &#123;                    if (recurse(child, root)) &#123;                        ans = true;                    &#125;                &#125;            &#125;            return hasAppleInChildTree[root] = ans;        &#125;;        recurse(0, -1);        function&lt;int(int,int)&gt; dp = [&amp;](int root, int parent) -&gt; int &#123;           // return step need to collect all apple int subtree root            if (children[root].size() == 1) return 0;            int ans = 0;            for (int child : children[root]) &#123;                if (child != parent &amp;&amp; hasAppleInChildTree[child] == true) &#123;                    ans += dp(child, root) + 2;                &#125;            &#125;            return ans;        &#125;;        return dp(0, -1);    &#125;&#125;;\n 1444. Number of Ways of Cutting a Pizza\n一道典型的DP问题。\n每步DP切一刀。\n时间复杂度: O(rows * cols * k * (rows + cols)^2),\n空间复杂度: O(rows * cols * k).\nclass Solution &#123;    const int MOD = 1e9 + 7;    using ll = long long;public:    int ways(vector&lt;string&gt;&amp; pizza, int k) &#123;        const int rows = pizza.size();        const int cols = pizza[0].size();        auto containApple = [&amp;](int x, int y, int r, int c) -&gt; bool &#123;            for (int i = x; i &lt; x + r; ++i) &#123;                for (int j = y; j &lt; y + c; ++j) &#123;                    if (pizza[i][j] == &#x27;A&#x27;) &#123;                        return true;                    &#125;                &#125;            &#125;            return false;        &#125;;        map&lt;tuple&lt;int,int,int&gt;, int&gt; memo;        // time: rows * cols * k * (rows + cols)^2        function&lt;ll(int, int, int)&gt; dp = [&amp;](int x, int y, int remainCut) -&gt; ll &#123;            auto it = memo.find(&#123;x, y, remainCut&#125;);            if (it != memo.end()) return it-&gt;second;            else &#123;                ll ans = 0;                if (remainCut == 0) &#123;                    ans = containApple(x, y, rows - x, cols - y) ? 1 : 0;                &#125; else &#123;                    for (int cutx = x + 1; cutx &lt; rows; ++cutx) &#123;                        if (containApple(x, y, cutx - x, cols - y)) &#123;                            ans += dp(cutx, y, remainCut - 1);                            ans %= MOD;                        &#125;                    &#125;                    for (int cuty = y + 1; cuty &lt; cols; ++cuty) &#123;                        if (containApple(x, y, rows - x, cuty - y)) &#123;                            ans += dp(x, cuty, remainCut - 1);                            ans %= MOD;                        &#125;                    &#125;                &#125;                return memo[&#123;x, y, remainCut&#125;] = ans;            &#125;        &#125;;        return dp(0, 0, k-1);    &#125;&#125;;\n 后记\n在残酷刷题群的这一个半月里，我跟随每日打卡，做了很多比较难的DP问题。周赛的进步也是明显的。群排名也从刚开始的30，进步为15. 我入群时人数170，现在只有146了。所以我怀疑是有很多大佬退群，我的群排名才更好看了。不过群友和群主都鼓励我说，“是你变强了”。我觉得确实有这部分因素。\n纵观自己的研究生生涯，科研每做好，题倒是刷了不少。这周正式突破1000+题了。\n遥想我当年看到LeetCode的题目超过1000时还很感叹，怎么可能做的完。现在LeetCode有1400+题目，我也做了1000+。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 189","url":"/2020/05/17/LeetCode-weekly-contest-189/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n484 / 13036\nYoungForest\n19\n1:27:45\n0:11:20\n0:19:20  1\n0:08:48\n1:22:45\n\n\n\n本周的最后一题是一个经典的计算几何问题，并不好写。不过通过率还是很高的，可能是test case比较弱的原因。\n在残酷群的排名降到了32名，跌幅达100%。之前感觉自己变强了错觉，是由于3周前的186周赛取得了113的好成绩，所以按照群排名算法，之后3周的排名都比较高。最好的一次成绩过去后，排名就恢复了本来的水平。30左右。并不是自己变强了，而是运气好而已。而且186正好用的python，python确实对手速场有优势。\n 1450. Number of Students Doing Homework at a Given Time\n签到题，One Pass.\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int busyStudent(vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime, int queryTime) &#123;        int ans = 0;        for (int i = 0; i &lt; startTime.size(); ++i) &#123;            if (startTime[i] &lt;= queryTime &amp;&amp; queryTime &lt;= endTime[i]) ++ans;        &#125;        return ans;    &#125;&#125;;\n 1451. Rearrange Words in a Sentence\n利用C++ STL提供的排序函数。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\nclass Solution &#123;    vector&lt;pair&lt;string,int&gt;&gt; splitSentence(const string&amp; text) &#123;        string tmp;        vector&lt;pair&lt;string,int&gt;&gt; stk;        stringstream ss(text);        int position = 0;        while(getline(ss,tmp,&#x27; &#x27;)) &#123;            if (!islower(tmp[0])) tmp[0] = tolower(tmp[0]);            stk.push_back(&#123;tmp, position&#125;);            ++position;        &#125;        return stk;    &#125;public:    string arrangeWords(string text) &#123;        auto split = splitSentence(text);        sort(split.begin(), split.end(), [](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            if (a.first.size() == b.first.size()) &#123;                return a.second &lt; b.second;            &#125; else &#123;                return a.first.size() &lt; b.first.size();            &#125;        &#125;);        string ans;        for (const auto&amp; word : split) &#123;            ans += word.first;            ans.push_back(&#x27; &#x27;);        &#125;        ans.pop_back();        ans[0] = toupper(ans[0]);        return ans;    &#125;&#125;;\n 1452. People Whose List of Favorite Companies Is Not a Subset of Another List\nbrute force. 对于每个人，判断是否被另外一个人所包含。N^2.\n判断包含时，可以将公司先排序，再顺序比较。O(m * log m + m).\nN为人数，M为公司数。\n时间复杂度: O(N^2 * M log M),\n空间复杂度: O(N).\n其中，利用了STL algorithm里的includes函数，可以判断2个排序区间是否包含。\nclass Solution &#123;public:    vector&lt;int&gt; peopleIndexes(vector&lt;vector&lt;string&gt;&gt;&amp; favoriteCompanies) &#123;        for (auto&amp; v : favoriteCompanies) &#123;            sort(v.begin(), v.end());        &#125;        const int n = favoriteCompanies.size();        vector&lt;int&gt; ans;        for (int i = 0; i &lt; n; ++i) &#123;            bool remove = false;            for (int j = 0; j &lt; n; ++j) &#123;                if (i == j) continue;                if (includes(favoriteCompanies[j].begin(), favoriteCompanies[j].end(), favoriteCompanies[i].begin(), favoriteCompanies[i].end())) &#123;                    remove = true;                    break;                &#125;            &#125;            if (!remove) &#123;                ans.push_back(i);            &#125;        &#125;        return ans;    &#125;&#125;;\n 1453. Maximum Number of Darts Inside of a Circular Dartboard\n一道经典的题目：disk partial covering problem。\n在网上随便一搜就有，原理参考geekforgeek, discuss, 即著名的augular sweep.\n时间复杂度: O(n^2 log n)\n空间复杂度: O(n ^ 2).\nclass Solution &#123;    using Point = complex&lt;double&gt;;    // angular sweep    int getPointsInside(const vector&lt;Point&gt;&amp; arr, const vector&lt;vector&lt;double&gt;&gt;&amp; dis, int i, double r, int n)     &#123;         vector&lt;pair&lt;double, bool&gt; &gt; angles;         for (int j=0; j&lt;n; j++)         &#123;             if (i != j &amp;&amp; dis[i][j] &lt;= 2*r)             &#123;                 double B =  acos(dis[i][j]/(2*r));                 double A = arg(arr[j]-arr[i]);                 double alpha = A-B;                 double beta = A+B;                 angles.push_back(make_pair(alpha, false));                 angles.push_back(make_pair(beta, true));             &#125;         &#125;         sort(angles.begin(), angles.end());         int count = 1, res = 1;         vector&lt;pair&lt;double, bool&gt; &gt;::iterator it;         for (it=angles.begin(); it!=angles.end(); ++it)         &#123;             if (!(*it).second)                 count++;             else                count--;             if (count &gt; res)                 res = count;         &#125;         return res;     &#125; public:    int numPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int r) &#123;        const int n = points.size();        vector&lt;Point&gt; arr;        arr.reserve(n);        for (const auto&amp; p : points) &#123;            arr.emplace_back(p[0], p[1]);        &#125;        vector&lt;vector&lt;double&gt;&gt; dis(n, vector&lt;double&gt;(n, 0));        for (int i=0; i&lt;n-1; i++)             for (int j=i+1; j&lt;n; j++)                 dis[i][j] = dis[j][i] = abs(arr[i]-arr[j]);         int ans = 0;         for (int i=0; i&lt;n; i++)             ans = max(ans, getPointsInside(arr, dis, i, r, n));        return ans;     &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 190","url":"/2020/05/24/LeetCode-weekly-contest-190/","content":"昨晚老爸帮我掏耳朵，一不小心掏出了血。今天一大早就去地区医院检查，还好并无大碍，只损伤了外耳道，休息一周，自然痊愈就好了。只要不感染，就没问题。开了些阿姆西林吃了。\n所以鸽了周赛，赛后补题。\n 1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence\nC++没有自带的切割字符串的方法，不过可以用自己的模版。通过stringstream实现分割，O(N)的复杂度.\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;    vector&lt;string&gt; splitSentence(const string&amp; text) &#123;        string tmp;        vector&lt;string&gt; stk;        stringstream ss(text);        while(getline(ss,tmp,&#x27; &#x27;)) &#123;            stk.push_back(tmp);        &#125;        return stk;    &#125;public:    int isPrefixOfWord(string sentence, string searchWord) &#123;        auto words = splitSentence(sentence);        for (int i = 0; i &lt; words.size(); ++i) &#123;            if (words[i].find(searchWord) == 0) return i + 1;        &#125;        return -1;    &#125;&#125;;\n 1456. Maximum Number of Vowels in a Substring of Given Length\n滑动窗口。窗口大小为k，统计窗口内的vowels。\n时间复杂度: O(N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int maxVowels(string s, int k) &#123;        int count = 0;        unordered_set&lt;int&gt; vowels = &#123;            &#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;        &#125;;        for (int i = 0; i &lt; k; ++i) &#123;            if (vowels.find(s[i]) != vowels.end()) &#123;                ++count;            &#125;        &#125;        int ans = count;        for (int i = k; i &lt; s.size(); ++i) &#123;            if (vowels.find(s[i]) != vowels.end()) &#123;                ++count;            &#125;            if (vowels.find(s[i-k]) != vowels.end()) &#123;                --count;            &#125;            ans = max(ans, count);        &#125;        return ans;    &#125;&#125;;\n 1457. Pseudo-Palindromic Paths in a Binary Tree\n根据字母出现频数为奇数的字母个数是否 &lt;= 判断是否回文。\n采用dfs搜索路径。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;    bool isPalindromicPath(const unordered_map&lt;int, int&gt;&amp; count) &#123;        int odd = 0;        for (const auto&amp; p : count) &#123;            if (p.second % 2 == 1) &#123;                ++odd;            &#125;        &#125;        return odd &lt;= 1;    &#125;public:    int pseudoPalindromicPaths (TreeNode* root) &#123;        unordered_map&lt;int, int&gt; path;        int ans = 0;        function&lt;void(TreeNode*)&gt; dfs = [&amp;](TreeNode* root) -&gt; void &#123;            if (root) &#123;                ++path[root-&gt;val];                if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; // leaf                    if (isPalindromicPath(path)) &#123;                        ++ans;                    &#125;                &#125;                dfs(root-&gt;left);                dfs(root-&gt;right);                --path[root-&gt;val];            &#125;        &#125;;        dfs(root);        return ans;    &#125;&#125;;\n 1458. Max Dot Product of Two Subsequences\nDP。dp[i][j] 表示nums1[:i+1], nums2[:j+1]的max dot product.\ndp[i][j] = max(&#123;dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i]*nums2[j], nums1[i]*nums2[j]&#125;);\n需要注意的是，并不允许空的subsequence。\n时间复杂度: O(nums1.size() * nums2.size()),\n空间复杂度: O(nums1.size() * nums2.size()).\nclass Solution &#123;public:    int maxDotProduct(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        const int m = nums1.size();        const int n = nums2.size();        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0));        // nums[i], nums[j], max dot product        for (int i = 0; i &lt; m; ++i) &#123;            for (int j = 0; j &lt; n; ++j) &#123;                if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;                    dp[i][j] = max(&#123;dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + nums1[i]*nums2[j], nums1[i]*nums2[j]&#125;);                &#125; else if (i == 0 &amp;&amp; j == 0) &#123;                    dp[i][j] = nums1[i]*nums2[j];                &#125; else if (i == 0) &#123;                    dp[i][j] = max(&#123;dp[i][j-1], nums1[i]*nums2[j]&#125;);                &#125; else &#123;                    dp[i][j] = max(&#123;dp[i-1][j], nums1[i]*nums2[j]&#125;);                &#125;            &#125;        &#125;        return dp[m-1][n-1];    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 191","url":"/2020/05/31/LeetCode-weekly-contest-191/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n765 / 13283\nYoungForest\n12\n0:27:19\n0:02:16\n0:12:53\n0:27:19\nnull\n\n\n\n本周最后一题着实比较难，涉及概率和组合数学等知识。恰好触及到我的知识盲区，所以没有做出来。对于数学好的同学应该会好很多。\n 1464. Maximum Product of Two Elements in an Array\n签到题。由于nums.size()比较小，所以暴力即可。\n时间复杂度: O(N^2),\n空间复杂度: O(1).\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int maxProduct(vector&lt;int&gt;&amp; nums) &#123;        int ans = -INF;        for (int i = 0; i &lt; nums.size(); ++i) &#123;            for (int j = i+1; j &lt; nums.size(); ++j) &#123;                ans = max(ans, (nums[i] - 1) * (nums[j] - 1));            &#125;        &#125;        return ans;    &#125;&#125;;\n 1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts\n分别找出最大的horizontal和vertical间隔，相乘即可。需要注意，把边界也当作cut处理。\n数据类型最好使用long long，因为会有int32的溢出问题。\n时间复杂度: O(horizontalCuts.size() * log + verticalCuts.size() * log),\n空间复杂度: O(1).\nclass Solution &#123;    using ll = long long;    const ll MOD = 1e9 + 7;public:    int maxArea(int h, int w, vector&lt;int&gt;&amp; horizontalCuts, vector&lt;int&gt;&amp; verticalCuts) &#123;        horizontalCuts.insert(horizontalCuts.begin(), 0);        horizontalCuts.push_back(h);        verticalCuts.insert(verticalCuts.begin(), 0);        verticalCuts.push_back(w);        sort (begin(horizontalCuts), end(horizontalCuts));        sort (begin(verticalCuts), end(verticalCuts));        int maxH = 0, maxW = 0;        for (int i = 1; i &lt; horizontalCuts.size(); ++i) &#123;            maxH = max(maxH, horizontalCuts[i] - horizontalCuts[i-1]);        &#125;        for (int j = 1; j &lt; verticalCuts.size(); ++j) &#123;            maxW = max(maxW, verticalCuts[j] - verticalCuts[j-1]);        &#125;        ll mxh = maxH;        ll mxw = maxW;        return (mxh * mxw) % MOD;    &#125;&#125;;\n 1466. Reorder Routes to Make All Paths Lead to the City Zero\n由于无向图本身是一棵树，每个节点通向0的路径有且仅有一条。所以用dfs从0搜索一遍，把反向的边调整过来即可。\n时间复杂度: O(N),\n空间复杂度: O(N) -&gt; 通过记录父节点，可以不用seen，将空间降到O(1).\nclass Solution &#123;public:    int minReorder(int n, vector&lt;vector&lt;int&gt;&gt;&amp; connections) &#123;        int ans = 0;        unordered_map&lt;int, vector&lt;int&gt;&gt; in, out;        vector&lt;bool&gt; seen(n, false);        for (const auto&amp; v : connections) &#123;            in[v[1]].push_back(v[0]);            out[v[0]].push_back(v[1]);        &#125;        function&lt;void(int)&gt; dfs = [&amp;](int root) -&gt; void &#123;            if (seen[root]) return;            seen[root] = true;            for (int neighbor : in[root]) &#123;                dfs(neighbor);            &#125;            for (int neighbor : out[root]) &#123;                if (!seen[neighbor]) &#123;                    ++ans;                    dfs(neighbor);                &#125;            &#125;        &#125;;        dfs(0);        return ans;    &#125;&#125;;\n 1467. Probability of a Two Boxes Having The Same Number of Distinct Balls\n概率问题。由于数据范围比较小，可以用回溯法枚举每个颜色的球在2个盒子里的数目。终点时，需要判断合法的permutation的数目，即 2个盒子中的球的数目相等。然后，如果颜色数量相等，也需要记录。\n这里需要些组合数学的知识，x个球，然后每种颜色的数目为A_i.\n则permutation的数目为:\nx!/∑Aix! / \\sum{A_i} \nx!/∑Ai​\n时间复杂度: O(balls[i]^balls.size() * balls.size() * sum_balls) = O(6 ^ 8 * 8 * 48) = O(644972544).\n空间复杂度: O(balls.size()).\nclass Solution:    def getProbability(self, balls: List[int]) -&gt; float:        self.all = 0        self.good = 0        self.firstHalf = defaultdict(int)        self.secondHalf = defaultdict(int)        def validKeys(m):            ans = 0            for i in m:                if m[i] &gt; 0: ans += 1            return ans        def permutationUnder(count):            under = 1            for k in count.values():                under *= math.factorial(k)            return under        def dfs(i):            if i == len(balls):                s1 = sum(self.firstHalf.values())                s2 = sum(self.secondHalf.values())                if s1 != s2: return                add = math.factorial(s1) * math.factorial(s2) / (permutationUnder(self.firstHalf) * permutationUnder(self.secondHalf))                self.all += add                if validKeys(self.firstHalf) == validKeys(self.secondHalf): self.good += add            else:                for x in range(0, balls[i] + 1):                    self.firstHalf[i] = x                    self.secondHalf[i] = balls[i] - x                    dfs(i+1)        dfs(0)        return self.good / self.all\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 192","url":"/2020/06/07/LeetCode-weekly-contest-192/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n374 / 13805\nYoungForest\n18\n0:53:48\n0:07:19\n0:07:35\n0:15:00\n0:43:48 2\n\n\n\n本周的题目不算难，3456手速场，最后1k人AK。\n前3题自己手速还算快，最后一题花了比较长的时间，还因为实现问题TLE了2发。本来觉得自己做的还不错，后来看到排名才发现，大家都很强。还需继续努力呀。争取rating进入世界前500.\n 1470. Shuffle the Array\n使用辅助数组，straight forward.\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; shuffle(vector&lt;int&gt;&amp; nums, int n) &#123;        vector&lt;int&gt; ans(2 * n);        for (int i = 0; i &lt; n; ++i) &#123;            ans[i*2] = nums[i];            ans[i*2 + 1] = nums[n + i];        &#125;        return ans;    &#125;&#125;;\n 1471. The k Strongest Values in an Array\n把stronger作为排序函数，对整个arr进行排序即可。\n时间复杂度: O(N log N),\n空间复杂度: O(1).\nclass Solution &#123;public:    vector&lt;int&gt; getStrongest(vector&lt;int&gt;&amp; arr, int k) &#123;        sort(arr.begin(), arr.end());        const int n = arr.size();        int m = arr[((n - 1) / 2)];        sort(arr.begin(), arr.end(), [&amp;](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            if (abs(a - m) == abs(b - m)) &#123;                return a &gt; b;            &#125; else &#123;                return abs(a - m) &gt; abs(b - m);            &#125;        &#125;);        arr.erase(arr.begin() + k, arr.end());        return arr;    &#125;&#125;;\n 1472. Design Browser History\n模拟整个过程。用一个数组存history，2个下标表示当前位置和最新的位置。\n时间复杂度: O(1),\n空间复杂度: O(N).\nclass BrowserHistory &#123;    vector&lt;string&gt; history;    int index;    int last;public:    BrowserHistory(string homepage) &#123;        history.resize(5000);        index = 0;        last = 0;        history[0] = move(homepage);    &#125;        void visit(string url) &#123;        ++index;        history[index] = url;        last = index;    &#125;        string back(int steps) &#123;        if (index &gt;= steps) &#123;            index = index - steps;        &#125; else &#123;            index = 0;        &#125;        return history[index];    &#125;        string forward(int steps) &#123;        if (index + steps &lt;= last) &#123;            index = index + steps;        &#125; else &#123;            index = last;        &#125;        return history[index];    &#125;&#125;;/** * Your BrowserHistory object will be instantiated and called as such: * BrowserHistory* obj = new BrowserHistory(homepage); * obj-&gt;visit(url); * string param_2 = obj-&gt;back(steps); * string param_3 = obj-&gt;forward(steps); */\n 1473. Paint House III\nDP.\ndp[i][t][lastColor]: paint [1:] 的房子，把他们分成t个group，而且前一个颜色是lastColor（避免同颜色，合并group）所需的最小的cost.\n状态转移方程: dp[i][t][lastColor] = min(paint cost [i:j) use color + dp[j][t-1][color]) for j in range(i,m+1) for color in range(1,n+1).\n需要注意一些剪枝和paint函数的有效实现，因为此TLE2发。\n时间复杂度: O(m * target * n * m * n),\n空间复杂度: O(m * target * n).\nclass Solution:    def minCost(self, houses: List[int], cost: List[List[int]], m: int, n: int, target: int) -&gt; int:        @lru_cache(None)        def paint(i, j, color):            if i == j:                return 0            else:                if houses[i] == color:                    return paint(i+1, j, color)                elif houses[i] == 0:                    return paint(i+1, j, color) + cost[i][color-1]                else:                    return float(&#x27;inf&#x27;)                    @lru_cache(None)        def dp(i: int, t: int, lastColor: int) -&gt; int:            if t == 1:                ans = float(&#x27;inf&#x27;)                for color in range(1, n + 1):                    if color == lastColor: continue                    pre = paint(i, m, color)                    ans = min(ans, pre)                return ans            else:                ans = float(&#x27;inf&#x27;)                seenColors = 0                for j in range(i + 1, m):                    if houses[j-1] != 0:                        if seenColors != 0 and seenColors != houses[j-1]:                            return ans                        seenColors = houses[j-1]                    if seenColors == 0:                        for color in range(1, n + 1):                            if color == lastColor: continue                            pre = paint(i, j, color)                            if pre &lt; ans:                                ans = min(ans, pre + dp(j, t-1, color))                    else:                        color = seenColors                        if color != lastColor:                             pre = paint(i, j, color)                            if pre &lt; ans:                                ans = min(ans, pre + dp(j, t-1, color))                return ans                ans = dp(0, target, -1)        return ans if ans &lt; float(&#x27;inf&#x27;) else -1","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 208","url":"/2020/09/30/LeetCode-weekly-contest-208/","content":"距上次写周赛总结已经过去3个半月了。坚持了半年的写周赛题解中断确实挺可惜的，但却是当时的不得已之举。7月份一直在忙小论文的事儿，8月份接着就是开题和中期，9月份正式开学，并且从7月初就在Amazon开始了暑期实习。任务确实比之前要多，当时因为事务压身，感觉精力不足以把所有事都做好。因为每次周赛写题解都要花大半天的时间，再加上打周赛，基本1天时间。打比赛和写题解对精力的损耗也是不言而喻的。虽然这3个月题解断更了，但比赛还是在照常的打，毕竟加入了残酷刷题群，有更多的人一起打周赛，每周打比赛的反馈和热爱也更强了。\n这3个月，我残酷群的排名也是起起落落落落落…最好时有15名，最差已经90名了。总的感觉是，自己更擅长常规不难的题目。遇到之前没见过或做的不多的就很容易最后一题做不出来。\n昨天和Amazon的manager确认了转正事宜，之后基本上只用走流程了。有了理想offer后，秋招不知所措的弦终于可以放松下来了。有心情花时间做自己想做的事情了，读几本之前一直想看的书，认真打几场比赛，恢复写题解的习惯。当然实习和毕设大论文才是当前的主要任务，需要投入大部分时间。但终于有精力happy了。\n这3个月来，因为国服赞助商礼物比较丰富，我比赛已经从美服转战国服了。效果还不错，除了coins奖励更容易拿到外，实体奖励也是很香的。有幸2次进入前50名，拿到一个帆布包和一个小米无线鼠标。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n392 / 11499\nYoungForest\n18\n1:04:46\n0:28:38\n0:40:28\n1:04:46\n0:55:59\n\n\n\n事实上，由于要处理突发的培养方案问题，我还迟到了25min，否则成绩会更好看。\n本次比赛被大家吐槽为阅读理解，读题难、题目描述迷惑。确实如此。\n 1598. Crawler Log Folder\n签到题。只需要关心向下一层和向上一层即可。可以用一个变量维护，在比赛中，我是用了一个栈去做，实际上是大材小用了。\nclass Solution &#123;public:    int minOperations(vector&lt;string&gt;&amp; logs) &#123;        stack&lt;string&gt; st;        for (auto&amp; s : logs) &#123;            if (s == &quot;../&quot;) &#123;                if (!st.empty()) &#123;                    st.pop();                &#125;            &#125; else if (s == &quot;./&quot;) &#123;                continue;            &#125; else &#123;                s.pop_back();                st.push(s);            &#125;        &#125;        return st.size();    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1599. Maximum Profit of Operating a Centennial Wheel\nStraight forward. 千万不要多想，直接模拟，一下一下地转，得到最大收益。特别需要注意的是，当你停止运行后，之后再转就不需要cost了。\nclass Solution &#123;public:    int minOperationsMaxProfit(vector&lt;int&gt;&amp; customers, int boardingCost, int runningCost) &#123;        int waitCustomer = 0;        int getBoard = 0;        int maxProfit = 0;        int ans = 0;        for (int i = 0; i &lt; customers.size() || waitCustomer &gt; 0; ++i) &#123;            if (i &lt; customers.size()) &#123;                waitCustomer += customers[i];            &#125;            if (waitCustomer &gt;= 4) &#123;                waitCustomer -= 4;                getBoard += 4;            &#125; else &#123;                getBoard += waitCustomer;                waitCustomer = 0;            &#125;            const int profit = getBoard * boardingCost - runningCost * (i + 1);            // cout &lt;&lt; profit &lt;&lt; endl;            if (profit &gt; maxProfit) &#123;                maxProfit = profit;                ans = i + 1;            &#125;        &#125;        if (maxProfit &lt;= 0) return -1;        else return ans;    &#125;&#125;;\n时间复杂度: O(customers.size() + sum(customers) / 4),\n空间复杂度: O(1).\n 1600. Throne Inheritance\n别看描述的这么复杂，其实就是一个深度优先搜索/前序遍历。前面的问题描述，尤其是Successor函数的定义会让人十分迷惑，其实就是嫡长子继承制。直接看example会更好理解。我也是做完第四题才返回来看的第三题，确实太难理解题意了。\nclass ThroneInheritance &#123;    unordered_set&lt;string&gt; dead;    unordered_map&lt;string, vector&lt;string&gt;&gt; children;    string root;    // dfspublic:    ThroneInheritance(string kingName) &#123;        root = kingName;    &#125;        void birth(string parentName, string childName) &#123;        children[parentName].push_back(childName);    &#125;        void death(string name) &#123;        dead.insert(name);    &#125;        vector&lt;string&gt; getInheritanceOrder() &#123;        vector&lt;string&gt; ans;        function&lt;void(const string&amp;)&gt; dfs = [&amp;](const string&amp; r) -&gt; void &#123;            if (dead.find(r) == dead.end()) &#123;                ans.push_back(r);            &#125;            for (const string&amp; child : children[r]) &#123;                dfs(child);            &#125;        &#125;;        dfs(root);        return ans;    &#125;&#125;;/** * Your ThroneInheritance object will be instantiated and called as such: * ThroneInheritance* obj = new ThroneInheritance(kingName); * obj-&gt;birth(parentName,childName); * obj-&gt;death(name); * vector&lt;string&gt; param_3 = obj-&gt;getInheritanceOrder(); */\n 1601. Maximum Number of Achievable Transfer Requests\n题目相比二三题好理解的多。由于request.length本身比较小，所以我们可以直接暴力解法，枚举所有requests的子集，判断是否合法(每个building入度出度相等)，找到最大的。\nclass Solution &#123;public:    int maximumRequests(int n, vector&lt;vector&lt;int&gt;&gt;&amp; requests) &#123;        // 2 ^ 16 * 16        const int rl = requests.size();        int ans = 0;        auto verify  = [&amp;](const int mask) -&gt; bool &#123;            vector&lt;int&gt; in(n, 0);            vector&lt;int&gt; out(n, 0);            for (int i = 0; i &lt; rl; ++i) &#123;                if ((mask &amp; (1 &lt;&lt; i)) != 0) &#123;                    ++in[requests[i][1]];                    ++out[requests[i][0]];                &#125;            &#125;            for (int i = 0; i &lt; n; ++i) &#123;                if (in[i] != out[i]) return false;            &#125;            return true;        &#125;;        for (int i = (1 &lt;&lt; rl) - 1; i &gt;= 0; --i) &#123;            if (verify(i)) &#123;                ans = max(ans, __builtin_popcount(i));            &#125;        &#125;        return ans;    &#125;&#125;;\nm: requests.length,\n时间复杂度: O(2 ^ m * (m + n)),\n空间复杂度: O(n).\n当然也有多项式时间复杂度的解法：O((n+m)m).\n用到了费用流，这已经超出我的知识范围了，有兴趣的同学可以学习下。\n 后记\n经过3年的准备，我的秋招基本结束了。已经决定留在亚马逊了，再过3个月就要成为社畜了。算是比较理想的offer了。\n最理想的Dream company当然是Google，无奈好不容易通过了实习一面，谷歌今年的实习项目因为疫情原因取消了。秋招也相比往年晚了很多，最近才有一些推送的消息。本身HC也十分稀少，机会难得。\n其他心仪的外企 Hulu 通过一面，在等待二面；微软找zenian内推却一直没有笔试或面试的消息，应该是由于投的北京的STCA，HC少而且基本上都被实习生占了，之前还收到是否同意可能调剂到苏州的问卷，难呀；Intel基本上是稳了，不过那边薪资待遇比起亚麻都要差很多，已经不考虑了；还投了小厂HotStar，有口头的offer，但本身就是我用来拿个大package再和大厂compete的，基本上不考虑去。\n国内互联网企业这边，拿了蚂蚁金服和猿辅导的offer，评级还都不错，蚂蚁还是A+。蚂蚁那边由于运气好，笔试拿了满分，师兄和lead还一直挺想让我去的。提前批6月份投了vivo，本身就是去试水的。结果因为overqualify被拒了，明明笔试全A，面试谈笑风声，有不要太优秀的要求就直说，别浪费的大家的时间。8月份还投了京东，面试很水，offer薪资也极其没诚意，属于劝退，我直接给拒了。百度提前批面完了，说是会给我offer，但一直没有消息。腾讯实习生面伤了，本身在北京也没好的岗位，秋招就没投。没想到还是被捞起来面了一次，后续无消息。字节一直被拒，反复捞起反复拒，真是八字不合。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 193","url":"/2020/06/15/LeetCode-weekly-contest-193/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n1854 / 13794\nYoungForest\n12\n1:18:35\n0:15:31\n0:12:31\n1:18:35\nnull\n\n\n\n最近比赛能力有所下降，昨晚的双周赛也是有一道第3题没做出来，现在更是最后一题没做出来。对Q4的树上倍增算法不了解。\n 1480. Running Sum of 1d Array\n签到题，一遍presum求和。\n也可以使用STL 中的partial_sum，达到相同的效果。\n时间复杂度: O(N),\n空间复杂度: O(N).\nclass Solution &#123;public:    vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; presum;        presum.reserve(nums.size() + 1);        presum.push_back(0);        for (int i : nums) &#123;            presum.push_back(presum.back() + i);        &#125;        presum.erase(presum.begin());        return presum;    &#125;&#125;;\n 1481. Least Number of Unique Integers after K Removals\n贪心。\n按照频数从小到大排序，先删除小的。\n时间复杂度: O(N + N log N + K),\n空间复杂度: O(N).\nclass Solution &#123;public:    int findLeastNumOfUniqueInts(vector&lt;int&gt;&amp; arr, int k) &#123;        unordered_map&lt;int,int&gt; count;        for (int i : arr) &#123;            ++count[i];        &#125;        vector&lt;int&gt; frequence;        frequence.reserve(count.size());        for (const auto&amp; p : count) &#123;            frequence.push_back(p.second);        &#125;        sort(frequence.begin(), frequence.end());        int i = 0;        const int n = frequence.size();        if (i == k) return n;        for (int j = 0; j &lt; frequence.size(); ++j) &#123;            i += frequence[j];            if (i == k) &#123;                return n - j - 1;            &#125; else if (i &gt; k) &#123;                return n - j;            &#125;        &#125;        return 0;    &#125;&#125;;\n 1482. Minimum Number of Days to Make m Bouquets\n将最优化问题转换成二分判定问题。\n寻找一个临界点，临界点前判定问题均为false, 之后均为true.\n时间复杂度: O(log 1e9 * N),\n空间复杂度: O(1).\nclass Solution &#123;public:    int minDays(vector&lt;int&gt;&amp; bloomDay, int m, int k) &#123;        auto determine = [&amp;](int x) -&gt; bool &#123;            int sub = 0;            int ans = 0;            for (int i : bloomDay) &#123;                if (i &lt;= x) &#123;                    ++sub;                &#125; else &#123;                    ans += sub / k;                    sub = 0;                &#125;            &#125;            ans += sub / k;            return ans &gt;= m;        &#125;;        int lo = 1, hi = 1e9 + 1;        while (lo &lt; hi) &#123;            int mid = lo + (hi - lo) / 2;            if (determine(mid)) &#123;                hi = mid;            &#125; else &#123;                lo = mid + 1;            &#125;        &#125;        return lo &gt; 1e9 ? -1 : lo;    &#125;&#125;;\n 1483. Kth Ancestor of a Tree Node\n类似树上倍增 LCA问题。用时间换空间。\n时间复杂度: O(N * log N),\n空间复杂度: O(N * log N).\nclass TreeAncestor &#123;    vector&lt;vector&lt;int&gt;&gt; ancestors;public:    TreeAncestor(int n, vector&lt;int&gt;&amp; parent) &#123;        // time: N * log N        vector&lt;vector&lt;int&gt;&gt; children(n);        for (int i = 1; i &lt; n; ++i) &#123;            children[parent[i]].push_back(i);        &#125;        ancestors.resize(n);        function&lt;void(int,vector&lt;int&gt;&amp;)&gt; dfs = [&amp;](int root, vector&lt;int&gt;&amp; path) -&gt; void &#123;            int depth = path.size();            for (int i = 0; depth - (1 &lt;&lt; i) &gt;= 0; ++i) &#123;                ancestors[root].push_back(path[depth - (1 &lt;&lt; i)]);            &#125;            path.push_back(root);            for (int child : children[root]) &#123;                dfs(child, path);            &#125;            path.pop_back();        &#125;;        vector&lt;int&gt; path;        path.push_back(-1);        dfs(0, path);    &#125;        int getKthAncestor(int node, int k) &#123;        // time: log K        int i = 20;        while (k &gt; 0 &amp;&amp; node != -1) &#123;            if ((k &amp; (1 &lt;&lt; i)) != 0) &#123;                if (i &lt; ancestors[node].size())                    node = ancestors[node][i];                else                    node = -1;                k -= (1 &lt;&lt; i);            &#125;            --i;        &#125;        return node;    &#125;&#125;;/** * Your TreeAncestor object will be instantiated and called as such: * TreeAncestor* obj = new TreeAncestor(n, parent); * int param_1 = obj-&gt;getKthAncestor(node,k); */","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 209","url":"/2020/10/07/LeetCode-weekly-contest-209/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n522 / 12138\nYoungForest\n12\n0:49:07\n0:05:12\n0:11:28\n0:39:07 2\nnull\n\n\n\n 1608. Special Array With X Elements Greater Than or Equal X\n签到题。从小到大枚举可能的答案，进行检查。\nclass Solution &#123;public:    int specialArray(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end());        const int n = nums.size();        auto check = [&amp;](const int i) -&gt; bool &#123;            auto it = lower_bound(nums.begin(), nums.end(), i);            const int d = distance(nums.begin(), it);            const int le = n - d;            return le == i;        &#125;;        for (int i = 1; i &lt;= 100; ++i) &#123;            if (check(i)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;;\n时间复杂度: O(N * log N),\n 1609. Even Odd Tree\n二叉树的层序遍历。使用广度优先搜索（BFS），记录层数和前一个元素即可。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public:    bool isEvenOddTree(TreeNode* root) &#123;        // bfs        queue&lt;TreeNode*&gt; q;        int level = 0;        if (root) q.push(root);        while (!q.empty()) &#123;            const int s = q.size();            int last;            if (level % 2 == 0) last = -1;            else last = 1&#x27;000&#x27;006;            for (int i = 0; i &lt; s; ++i) &#123;                auto current = q.front();                q.pop();                if (level % 2 == 0) &#123;                    if (current-&gt;val % 2 == 0) return false;                    if (current-&gt;val &lt;= last) return false;                &#125; else &#123;                    if (current-&gt;val % 2 == 1) return false;                    if (current-&gt;val &gt;= last) return false;                &#125;                last = current-&gt;val;                if (current-&gt;left) q.push(current-&gt;left);                if (current-&gt;right) q.push(current-&gt;right);            &#125;            ++level;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1610. Maximum Number of Visible Points\n滑动窗口。这里有2个技巧：\n\n使用复数及其方法处理几何问题。可以快速计算向量的夹角。\n把所有点 + 360度 遍历2次。以处理跨0问题。\n\n还有一个需要注意的点是：当点和观察点重合时需要特殊处理。\ntemplate &lt;typename T&gt;ostream&amp; operator &lt;&lt;(ostream&amp; out, const vector&lt;T&gt;&amp; a) &#123;  out &lt;&lt; &quot;[&quot;; bool first = true;  for (auto&amp; v : a) &#123; out &lt;&lt; (first ? &quot;&quot; : &quot;, &quot;); out &lt;&lt; v; first = 0;&#125; out &lt;&lt; &quot;]&quot;;  return out;&#125;class Solution &#123;    using Point = complex&lt;double&gt;;public:    int visiblePoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int a, vector&lt;int&gt;&amp; location) &#123;        double angle = a;        const int n = points.size();        Point me &#123;static_cast&lt;double&gt;(location[0]), static_cast&lt;double&gt;(location[1])&#125;;        vector&lt;double&gt; ps;        ps.reserve(2 * points.size());        int same = 0;        for (const auto &amp; v : points) &#123;            if (v == location) &#123;                ++same;                continue;            &#125;            Point x &#123;static_cast&lt;double&gt;(v[0]), static_cast&lt;double&gt;(v[1])&#125;;            ps.push_back(arg(x - me)*(180/M_PI));        &#125;        const int s = ps.size();        for (int i = 0; i &lt; s; ++i) &#123;            ps.push_back(ps[i] + 360);        &#125;        sort(ps.begin(), ps.end());        // cout &lt;&lt; ps &lt;&lt; endl;        const double error = 1e-8;        int l = 0, r = 0;        int ans = 0;        for (; r &lt; ps.size(); ++r) &#123;            if (ps[r] - ps[l] &gt; angle + error) &#123;                ++l;            &#125;            ans = max(ans, r - l + 1);            // cout &lt;&lt; r &lt;&lt; &quot; &quot; &lt;&lt; l &lt;&lt; endl;        &#125;        return min(ans, n) + same;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n 1611. Minimum One Bit Operations to Make Integers Zero\n参考群主的视频写的代码。比赛时没做出来，赛后看lee215的discuss也是讲的比较简单和跳跃。还是群主的视频好，把你当傻逼一样讲，速度还慢。虽然时长挺长的，但对于这种比较难的题目还是十分有效的。\nclass Solution &#123;    int largestBit (const int n) &#123;        int b = 1;        while (b &lt;= n) &#123;            b = (b &lt;&lt; 1);        &#125;        b = (b &gt;&gt; 1);        return b;    &#125;    int helper(const int n, const int b) &#123;        if (n == 0) return 1;        // xxxx -&gt; 1000        if ((n &amp; b) != 0) &#123;            // 1xxx -&gt; 1000            return minimumOneBitOperations(n ^ b);        &#125; else &#123;            // 0xxx -&gt; 0100 -&gt; 1100 -&gt; 1000            return helper(n, b &gt;&gt; 1) + 1 + minimumOneBitOperations(b &gt;&gt; 1);        &#125;    &#125;public:    int minimumOneBitOperations(int n) &#123;        if (n == 0) return 0;        else if (n == 1) return 1;        if (__builtin_popcount(n) == 1) &#123;            return (n &lt;&lt; 1) - 1;        &#125; else &#123;            const int b = largestBit(n);            return helper(b ^ n, b &gt;&gt; 1) + 1 + minimumOneBitOperations(b &gt;&gt; 1);        &#125;            &#125;&#125;;\n时间复杂度: O(log N),\n空间复杂度: O(log N).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 210","url":"/2020/10/11/LeetCode-weekly-contest-210/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n94 / 11792\nYoungForest\n18\n0:51:30\n0:03:13\n0:08:36\n0:21:59\n0:51:30\n\n\n\n本场比赛都是常规题目，我没有遇到困难，久违地进入了前100名。太难了，残酷群排名也因此上升到25名。\n 5535. Maximum Nesting Depth of the Parentheses\n签到题。括号嵌套层数，用栈的思路即可。左括号入栈，右括号出栈。\nclass Solution &#123;public:    int maxDepth(string s) &#123;        int left = 0;        int ans = 0;        for (char c : s) &#123;            if (c == &#x27;(&#x27;) &#123;                ++left;            &#125; else if (c == &#x27;)&#x27;) &#123;                --left;            &#125;            ans = max(ans, left);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 5536. Maximal Network Rank\n暴力法。枚举所有的城市对，计算network rank。有个技巧是先统计单个城市的度，如果2城市间存在道路则减一。\nclass Solution &#123;public:    int maximalNetworkRank(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123;        using pii = pair&lt;int, int&gt;;        set&lt;pii&gt; roadmap;        vector&lt;int&gt; cnt(n);        for (const auto&amp; r : roads) &#123;            roadmap.insert(&#123;r[0], r[1]&#125;);            ++cnt[r[0]];            ++cnt[r[1]];        &#125;        int ans = 0;        for (int i = 0; i &lt; n; ++i) &#123;            for (int j = i + 1; j &lt; n; ++j) &#123;                int sub = 0;                if (roadmap.find(&#123;i, j&#125;) != roadmap.end() || roadmap.find(&#123;j, i&#125;) != roadmap.end()) &#123;                    ++sub;                &#125;                ans = max(ans, cnt[i] + cnt[j] - sub);            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n^2 * log m + m log m),\n空间复杂度: O(n + m).\n评论区中有一神 O(n + m) 的解法，太强了。大意是，只需要知道度最大的城市和第二大的即可。\n 1616. Split Two Strings to Make Palindrome\n观察有，答案只有可能2中：\na_prefix + a_mid + b_suffix,\na_prefix + b_mid + b_suffix,\nb_prefix + a_mid + a_suffix,\nb_prefix + b_mid + a_suffix.\n计算a_prefix与b_suffix匹配的最长长度，和a_mid/b_mid的最长长度，看是否相交。\n同理，b_prefix 与 a_suffix匹配的最长长度。\nclass Solution &#123;    int head1 = 0;    int head2 = 0;    bool check(const string&amp; a, const string&amp; b) &#123;        const int n = a.size();        int left, right;        if (n % 2 == 0) &#123;            left = (n - 1)  / 2;            right = n / 2;        &#125; else &#123;            const int mid = n / 2;            left = mid - 1;            right = mid + 1;        &#125;        while (left &gt;= 0 &amp;&amp; right &lt; n &amp;&amp; a[left] == a[right]) &#123;            --left;            ++right;        &#125;        const int length = right - left - 1;        return head1 &gt; left || head2 &gt; left;    &#125;public:    bool checkPalindromeFormation(string a, string b) &#123;        const int n = a.size();        while (head1 &lt; n &amp;&amp; a[head1] == b[n - 1 - head1]) &#123;            ++head1;        &#125;        while (head2 &lt; n &amp;&amp; b[head2] == a[n - 1 - head2]) &#123;            ++head2;        &#125;        return check(a, b) || check(b, a);    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 5538. Count Subtrees With Max Distance Between Cities\n暴力法，写了近100行代码。先枚举所有的点组合，判断是否是subtree，如果是的话，计算最大距离。\n判断是否subtree，我使用了用 并查集 判断是否全部联通的方法。\n最大距离d，我采用了多次DFS的方式，时间复杂度 n^2. 赛后得知有O(n) 2次dfs的方法计算树的直径。\nclass Solution &#123;    struct UF &#123;        vector&lt;int&gt; parent;        int count;        UF(int n) : parent(n), count(n) &#123;            iota(parent.begin(), parent.end(), 0);        &#125;        // A utility function to find the subset of an element i          int find(int x)          &#123;              return x == parent[x] ? x : parent[x] = find(parent[x]);        &#125;          // A utility function to do union of two subsets          void unite(int x, int y)          &#123;              int xset = find(x);              int yset = find(y);              if(xset != yset)             &#123;                  parent[xset] = yset;                --count;            &#125;          &#125;        &#125;;public:    vector&lt;int&gt; countSubgraphsForEachDiameter(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        // time: (n ^ 2 * 2 ^ n)        vector&lt;unordered_set&lt;int&gt;&gt; graph(n);        for (const auto&amp; v : edges) &#123;            const int a = v[0] - 1;            const int b = v[1] - 1;            graph[a].insert(b);            graph[b].insert(a);        &#125;        vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n));        function&lt;void(const int, const int, const int, const int)&gt; dfs = [&amp;](const int root, const int current, const int parent, const int depth) -&gt; void &#123;            dist[root][current] = depth;            for (int child : graph[current]) &#123;                if (child == parent) continue;                dfs(root, child, current, depth + 1);            &#125;                        &#125;;        for (int i = 0; i &lt; n; ++i) &#123;            dfs(i, i, -1, 0);        &#125;        auto getnodes = [&amp;](const int mask) -&gt; vector&lt;int&gt; &#123;            vector&lt;int&gt; ans;            for (int i = 0; i &lt; n; ++i) &#123;                if ((mask &amp; (1 &lt;&lt; i)) != 0) &#123;                    ans.push_back(i);                &#125;            &#125;            return ans;        &#125;;        auto checksubtree = [&amp;](const vector&lt;int&gt;&amp; nodes) -&gt; bool &#123;            if (nodes.empty() || nodes.size() == 1) return false;            UF uf(n);            for (int i = 0; i &lt; nodes.size(); ++i) &#123;                for (int j = i + 1; j &lt; nodes.size(); ++j) &#123;                    const int a = nodes[i], b = nodes[j];                    if (graph[a].find(b) != graph[a].end()) &#123;                        uf.unite(a, b);                    &#125;                &#125;            &#125;            int root = -1;            for (int a : nodes) &#123;                if (root == -1) &#123;                    root = uf.find(a);                &#125; else &#123;                    if (root != uf.find(a)) return false;                &#125;            &#125;            return true;        &#125;;        auto distance = [&amp;](const vector&lt;int&gt;&amp; nodes) -&gt; int &#123;            int ans = 0;            for (int i = 0; i &lt; nodes.size(); ++i) &#123;                for (int j = i + 1; j &lt; nodes.size(); ++j) &#123;                    const int a = nodes[i], b = nodes[j];                    ans = max(ans, dist[a][b]);                &#125;            &#125;            return ans;        &#125;;        // d = 1...n-1                vector&lt;int&gt; ans (n - 1, 0);        const int upper = (1 &lt;&lt; n);        for (int mask = 0; mask &lt; upper; ++mask) &#123;            auto nodes = getnodes(mask);            if (!checksubtree(nodes)) continue;            ++ans[distance(nodes) - 1];        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n ^ 2 * 2 ^ n),\n空间复杂度: O(n ^ 2).\n由于n &lt;= 15, 所以指数级的还是可以过的。\n评论区也有 O(n ^ 5)的解法。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 211","url":"/2020/10/19/LeetCode-weekly-contest-211/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n224 / 11960\nYoungForest\n18\n1:23:45\n0:03:19\n0:31:37\n1:00:04\n1:18:45 1\n\n\n\n本周题目质量还不错，而且自己排名也不错。提前10分钟AC，就是喜欢这种紧张刺激感。而像上周那样提前40minAC反而没今天这么开心。\n因为连续2次周赛排名都很靠前，我残酷群的排名也上升到15名了。久违的最高位置，继续保持。\n 1624. Largest Substring Between Two Equal Characters\n签到题。记录每个字符的首次出现下标和最后出现下标，遍历做差即可。\nclass Solution &#123;public:    int maxLengthBetweenEqualCharacters(string s) &#123;        using pii = pair&lt;int, int&gt;;        vector&lt;pii&gt; index(26, &#123;-1, -1&#125;);        for (int i = 0; i &lt; s.size(); ++i) &#123;            const int idx = s[i] - &#x27;a&#x27;;            if (index[idx].first == -1) &#123;                index[idx].first = i;            &#125;            index[idx].second = i;        &#125;        int ans = -1;        for (auto p : index) &#123;            ans = max(ans, p.second - p.first - 1);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(s.size()),\n空间复杂度: O(1).\n 1625. Lexicographically Smallest String After Applying Operations\n第二题挺恶心，暴力就行，但实现起来还是比较复杂度的。写了50行代码，没成想竟然一次bug-free。\n因为数据规模很小，100，brute force搞起.\n先找到所有通过shift可以作为开头的下标。shift最为一个子问题也是LeetCode的原题，通过3次reverse可以方便的实现。\n然后就不需要考虑shift操作了，只需要考虑增加操作。贪心即可。这时根据b是奇偶，可能有2或1位要增加。\n最后找到所有下标可以达到的最小值即可。\nclass Solution &#123;public:    string findLexSmallestString(string s, int a, int b) &#123;        const int n = s.size();        vector&lt;int&gt; head;        bool first = true;        for (int i = 0; ; ++i) &#123;            const int condidate = ((n - i * b) % n + n) % n;            if (condidate == 0) &#123;                if (!first) break;                first = false;            &#125;            head.push_back(condidate);        &#125;        string ans(n, &#x27;9&#x27;);        auto shiftK = [&amp;](string&amp; a, const int k) -&gt; void &#123;            // shift left k unit            reverse(a.begin(), a.end());            auto it = a.begin() + k;            reverse(a.begin(), it);            reverse(it, a.end());        &#125;;        auto minIncrease = [&amp;](const int x) -&gt; int &#123;            map&lt;int, int&gt; reach;            int i = x;            int ans = 0;            while (reach.find(i) == reach.end()) &#123;                reach[i] = ans;                i = (i + a) % 10;                ans += a;            &#125;            return reach.begin()-&gt;second;        &#125;;        auto fixHead = [&amp;](const int d) -&gt; string &#123;            string ans = s;            shiftK(ans, d);            if (b % 2 != 0) &#123;                const int increase = minIncrease(ans[0] - &#x27;0&#x27;);                for (int i = 0; i &lt; n; i += 2) &#123;                    ans[i] = &#x27;0&#x27; + ((ans[i] - &#x27;0&#x27; + increase) % 10);                &#125;            &#125;            const int increase = minIncrease(ans[1] - &#x27;0&#x27;);            for (int i = 1; i &lt; n; i += 2) &#123;                ans[i] = &#x27;0&#x27; + ((ans[i] - &#x27;0&#x27; + increase) % 10);            &#125;            return ans;        &#125;;        for (const int d : head) &#123;            const string x = fixHead(d);            if (x &lt; ans) &#123;                ans = x;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n * n * 10),\n空间复杂度: O(n).\n 1626. Best Team With No Conflicts\n动态规划。\n先按年龄和分数排序。\ndp[i][j] = max(dp[i-1][x] for x &lt;= j)\n其中，i表示年龄位置，j表示当前最高分数。\nclass Solution &#123;public:    int bestTeamScore(vector&lt;int&gt;&amp; scores, vector&lt;int&gt;&amp; ages) &#123;        map&lt;int, multiset&lt;int&gt;&gt; players;        const int n = scores.size();        for (int i = 0; i &lt; n; ++i) &#123;            players[ages[i]].insert(scores[i]);        &#125;        map&lt;int, int&gt; m;    // maxScore, max_sum_score        m[0] = 0;        for (const auto&amp; p : players) &#123;            auto it = m.begin();            int maxScore = it-&gt;second;            for (int x : p.second) &#123;                while (it != m.end() &amp;&amp; it-&gt;first &lt;= x) &#123;                    maxScore = max(maxScore, it-&gt;second);                    ++it;                &#125;                m[x] = maxScore + x;                maxScore += x;            &#125;        &#125;        int ans = 0;        for (const auto&amp;  p : m) &#123;            ans = max(ans, p.second);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N ^ 2),\n空间复杂度: O(N).\n 1627. Graph Connectivity With Threshold\n被国服的翻译坑了。query是询问2个节点是否联通，而不是直接相连。国服一开始翻译成直接相连了，还专门强调一下子。我每次打比赛的习惯是一开始就打开所有的题目。之后除了遇到难题会刷新看提交和通过人数外，几乎不会刷新。所以当题目有问题时，及时之后更新了，我也不知道。力扣并没有类似codeforces的通知机制。幸亏残酷群里有同学也遇到相同的问题，WA了，但就是不明白expected answer怎么对。\n本题只有6分，名副其实，属于我恰好能做出来的Hard题目。\n联通用并查集可以快速实现，模版拿来。\n然后就是最大公因数联通。最笨的方法是两两判断，用gcd。时间复杂度是N^N，肯定TLE了。\n比较取巧的方法是枚举公因数（这里并不需要最大），然后连接公因数和倍数就可以了。这里并没有实现题目中的直接相连这一概念，而是间接相连。直接相连并不需要，因为我们最后需要的也是间接相连。\n这里时间复杂度不容易判断，需要一个知识:\n1 + 1/2 + 1/3 + … + 1/n ~ log n.\n即调和级数求和复杂度约等于对数。\nclass Solution &#123;    struct UF &#123;        vector&lt;int&gt; parent;        int count;        UF(int n) : parent(n), count(n) &#123;            iota(parent.begin(), parent.end(), 0);        &#125;        // A utility function to find the subset of an element i          int find(int x)          &#123;              return x == parent[x] ? x : parent[x] = find(parent[x]);        &#125;          // A utility function to do union of two subsets          void unite(int x, int y)          &#123;              int xset = find(x);              int yset = find(y);              if(xset != yset)             &#123;                  parent[xset] = yset;                --count;            &#125;          &#125;        &#125;;public:    vector&lt;bool&gt; areConnected(int n, int threshold, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        // n * log n + queries.size();        const int q = queries.size();        vector&lt;bool&gt; ans;        ans.reserve(q);        UF uf(n + 1);        for (int i = threshold + 1; i &lt;= n; ++i) &#123;            for (int j = i + i; j &lt;= n; j += i) &#123;                uf.unite(i, j);            &#125;        &#125;        auto check = [&amp;](const int a, const int b) -&gt; bool &#123;            return uf.find(a) == uf.find(b);        &#125;;        for (const auto&amp; x : queries) &#123;            ans.push_back(check(x[0], x[1]));        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n log n + queries.length),\n空间复杂度: O(n).\n 后记\n本周忙于实习转正需要发的CR和UT，以及28号就要交的大论文初稿。连续加班，估计需要2周时间，一周后交了论文才有机会休息。加油，YoungForest!\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 211","url":"/2020/10/26/LeetCode-weekly-contest-212/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n103 / 10984\nYoungForest\n19\n1:19:51\n0:06:36\n0:12:02\n0:39:44 2\n1:09:51\n\n\n\n本周周赛继续高歌猛进，排名也很靠前。加上上周的名次，我在残酷群里的排名也上升到了新高，第11名。\n 1629. Slowest Key\n一次遍历。使用一个变量维护上次按键的时刻。\nclass Solution &#123;public:    char slowestKey(vector&lt;int&gt;&amp; releaseTimes, string keysPressed) &#123;        const int n =  releaseTimes.size();        int last = 0;        int maxDuration = 0;        char ans = &#x27; &#x27;;        for (int i = 0; i &lt; n; ++i) &#123;            const int duration = releaseTimes[i] - last;            if (duration &gt; maxDuration || (duration == maxDuration &amp;&amp; keysPressed[i] &gt; ans)) &#123;                maxDuration = duration;                ans = keysPressed[i];            &#125;            last = releaseTimes[i];        &#125;        return ans;    &#125;&#125;;\n空间复杂度: O(1),\n时间复杂度: O(n).\n 1630. Arithmetic Subarrays\n对于每个子数组，排序判断是否为等差数列。\nclass Solution &#123;    bool check(const vector&lt;int&gt;&amp; x) &#123;        if (x.size() &lt; 2) return false;        const int diff = x[1] - x[0];        for (int i = 2; i &lt; x.size(); ++i) &#123;            if (x[i] - x[i - 1] != diff) return false;        &#125;        return true;    &#125;public:    vector&lt;bool&gt; checkArithmeticSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; l, vector&lt;int&gt;&amp; r) &#123;        // time: m * n * n log n        const int m = l.size();        const int n = nums.size();        vector&lt;bool&gt; ans(m);        for (int i = 0; i &lt; m; ++i) &#123;            vector&lt;int&gt; cp;            cp.reserve(r[i] - l[i] + 1);            for (int j = l[i]; j &lt;= r[i]; ++j) &#123;                cp.push_back(nums[j]);            &#125;            sort(cp.begin(), cp.end());            ans[i] = check(cp);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(m * n * n log n),\n空间复杂度: O(m).\n 1631. Path With Minimum Effort\nBFS。从头开始搜索，用dp进行剪枝。\nclass Solution &#123;    const int INF = 0x3f3f3f3f;    using pii = pair&lt;int, int&gt;;public:    int minimumEffortPath(vector&lt;vector&lt;int&gt;&gt;&amp; heights) &#123;        const int rows = heights.size();        const int cols = heights[0].size();        vector&lt;vector&lt;int&gt;&gt; dp(rows, vector&lt;int&gt;(cols, INF));        dp[0][0] = 0;        const vector&lt;pii&gt; neighbor = &#123;            &#123;1, 0&#125;,            &#123;0, 1&#125;,            &#123;-1, 0&#125;,            &#123;0, -1&#125;        &#125;;        queue&lt;pii&gt; q;        q.push(&#123;0, 0&#125;);        while (!q.empty()) &#123;            auto [i, j] = q.front();            q.pop();            for (auto [di, dj] : neighbor) &#123;                const int ni = i + di, nj = j + dj;                if (ni &gt;= 0 &amp;&amp; ni &lt; rows &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; cols &amp;&amp; dp[ni][nj] &gt; max(dp[i][j], abs(heights[i][j] - heights[ni][nj]))) &#123;                    dp[ni][nj] = max(dp[i][j], abs(heights[i][j] - heights[ni][nj]));                    q.push(&#123;ni, nj&#125;);                &#125;            &#125;        &#125;        return dp[rows - 1][cols - 1];    &#125;&#125;;\n时间复杂度: O(rows * cols),\n空间复杂度: O(rows * cols).\n 1632. Rank Transform of a Matrix\n从小到大处理数字，每次处理相同的数字。\n相同的数字需要根据行列判断联通（使用并查集），同一联通图中的数字需要取最大的rank，这时才满足answer最小。\nclass Solution &#123;        struct UF &#123;        vector&lt;int&gt; parent;        int count;        UF(int n) : parent(n), count(n) &#123;            iota(parent.begin(), parent.end(), 0);        &#125;        // A utility function to find the subset of an element i          int find(int x)          &#123;              return x == parent[x] ? x : parent[x] = find(parent[x]);        &#125;          // A utility function to do union of two subsets          void unite(int x, int y)          &#123;              int xset = find(x);              int yset = find(y);              if(xset != yset)             &#123;                  parent[xset] = yset;                --count;            &#125;          &#125;        &#125;;public:    vector&lt;vector&lt;int&gt;&gt; matrixRankTransform(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123;        const int m = matrix.size();        const int n = matrix[0].size();        vector&lt;int&gt; rowsRank(m, 0);        vector&lt;int&gt; colsRank(n, 0);        vector&lt;vector&lt;int&gt;&gt; ans(m, vector&lt;int&gt;(n, 0));        using pii = pair&lt;int, int&gt;;        map&lt;int, vector&lt;pii&gt;&gt; arr;        for (int i = 0; i &lt; m; ++i) &#123;            for (int j = 0; j &lt; n; ++j) &#123;                arr[matrix[i][j]].emplace_back(i, j);            &#125;        &#125;        for (const auto &amp; p : arr) &#123;            const auto &amp; v = p.second;            const int vsize = v.size();            UF uf(vsize);            vector&lt;int&gt; rowsIndex(m, -1);            vector&lt;int&gt; colsIndex(n, -1);            for (int i = 0; i &lt; vsize; ++i) &#123;                auto [x, y] = v[i];                if (rowsIndex[x] == -1 &amp;&amp; colsIndex[y] == -1) &#123;                    rowsIndex[x] = i;                    colsIndex[y] = i;                &#125; else if (rowsIndex[x] == -1) &#123;                    rowsIndex[x] = i;                    uf.unite(i, colsIndex[y]);                &#125; else if (colsIndex[y] == -1) &#123;                    colsIndex[y] = i;                    uf.unite(i, rowsIndex[x]);                &#125; else &#123;                    uf.unite(i, rowsIndex[x]);                    uf.unite(i, colsIndex[y]);                &#125;            &#125;            unordered_map&lt;int, vector&lt;int&gt;&gt; cluster;            for (int i = 0; i &lt; vsize; ++i) &#123;                cluster[uf.find(i)].push_back(i);            &#125;            for (const auto&amp; p : cluster) &#123;                const auto&amp; vec = p.second;                int maxRank = numeric_limits&lt;int&gt;::min();                for (int i : vec) &#123;                    maxRank = max(rowsRank[v[i].first] + 1, maxRank);                    maxRank = max(colsRank[v[i].second] + 1, maxRank);                &#125;                for (int i : vec) &#123;                    rowsRank[v[i].first] = maxRank;                    colsRank[v[i].second] = maxRank;                    ans[v[i].first][v[i].second] = maxRank;                &#125;            &#125;        &#125;               return ans;    &#125;&#125;;\n时间复杂度: O(m * n * log mn),\n空间复杂度: O(m * n).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 213","url":"/2020/11/01/LeetCode-weekly-contest-213/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n139 / 10630\nYoungForest\n18\n0:39:13\n0:06:26\n0:14:56\n0:22:59\n0:39:13\n\n\n\n周赛已经连续4周表现良好了，开心。群排名也稳定在了15名，终究还是无法进入前10.不过我已经满意了。\n 5554. Check Array Formation Through Concatenation\n签到题。需要注意arr和pieces都是 distinct （互不相同）的。\n所以，我们只需要记录pieces的开头元素对应的数组就可以了，直接找，然后匹配。\nclass Solution &#123;public:    bool canFormArray(vector&lt;int&gt;&amp; arr, vector&lt;vector&lt;int&gt;&gt;&amp; pieces) &#123;        unordered_map&lt;int, int&gt; num2indexInPieces;        for (int i = 0; i &lt; pieces.size(); ++i) &#123;            const auto&amp; v = pieces[i];            num2indexInPieces[v[0]] = i;        &#125;        for (int i = 0; i &lt; arr.size(); ) &#123;            auto it = num2indexInPieces.find(arr[i]);            if (it == num2indexInPieces.end()) return false;            const int j = it-&gt;second;            const int oldi = i;            for (; i &lt; arr.size() &amp;&amp; i - oldi &lt; pieces[j].size(); ++i) &#123;                if (arr[i] != pieces[j][i - oldi]) return false;            &#125;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O(arr.size() + pieces.size()),\n空间复杂度: O(pieces.size()).\n 5555. Count Sorted Vowel Strings\nDP. 定义dp(n, i)为长度为n，开头是第i大的字母所对应的字符串的数量。\ndp(n, i) = sum(dp(n-1, j) for j in range(i, 0, -1)).\nclass Solution:    def countVowelStrings(self, n: int) -&gt; int:        @lru_cache(None)        def dp(n, i):            if n == 1:                return i            else:                return sum(dp(n-1, j) for j in range(i, 0, -1))        return dp(n, 5)\n时间复杂度: O(n * 5 * 5),\n空间复杂度: O(n * 5).\n当然，评论区里还有零神的O(1)解法. tql，反正我是没看懂。\n 5556. Furthest Building You Can Reach\n贪心。尽量把梯子用到高度差最大的地方。\n这里需要用priority_queue来维护之前最大的高度差。\nclass Solution &#123;public:    int furthestBuilding(vector&lt;int&gt;&amp; heights, int bricks, int ladders) &#123;        std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; q;        int lasth = heights[0];        int i = 1;        for (; i &lt; heights.size(); ++i) &#123;            if (heights[i] &gt; lasth) &#123;                const int diff = heights[i] - lasth;                q.push(diff);                if (q.size() &gt; ladders) &#123;                    int t = q.top();                    q.pop();                    bricks -= t;                    if (bricks &lt; 0) return i - 1;                &#125;            &#125;            lasth = heights[i];        &#125;        return heights.size() - 1;    &#125;&#125;;\n 5600. Kth Smallest Instructions\n上上周hulu面试刚问了一个找二叉搜索数中第k大的数的算法，而这又是我最早在《算法第4版》中看到的一个实现。在平时解题时，也经常用到需要这种带rank的数据结构。\n这道题和求rank的思路十分相似，都是维护一个子树的size，然后根据“左子树（向右走）”的size和rank的相对大小，选择走的决策。不同的是，本题中子树的size是总共可以走的路径的方案数，也就是一个组合数。\n本题中用到了零神用杨辉三角求组合数的方法，相比阶乘算法，可以支持取模。也防止了溢出。\nclass Solution &#123;    using ll = unsigned long long;    const ll MOD = 1e18 + 7;    vector&lt;vector&lt;ll&gt;&gt; c;    ll C(ll m, ll n) &#123;        return c[m][n];    &#125;public:    string kthSmallestPath(vector&lt;int&gt;&amp; destination, int k) &#123;        const int rows = destination[0];        const int cols = destination[1];        const  int n = rows + cols + 1;        c.resize(n + 1, vector&lt;ll&gt;(n + 1));        c[0][0] = 1;        for (int i = 1; i &lt;= n; ++i) &#123;            c[i][0] = 1;            for (int j = 1; j &lt;= i; ++j) &#123;                c[i][j] = c[i - 1][j - 1] + c[i - 1][j];                if (c[i][j] &gt;= MOD) &#123;                    c[i][j] -= MOD;                &#125;            &#125;        &#125;        string ans;        using pii = pair&lt;int, int&gt;;        pii start = &#123;0, 0&#125;;        int r = rows, c = cols;        while (ans.size() &lt; rows + cols) &#123;            if (r == 0) &#123;                ans.push_back(&#x27;H&#x27;);                --c;            &#125; else if (c == 0) &#123;                ans.push_back(&#x27;V&#x27;);                --r;            &#125; else &#123;                const ll right = C(r + c - 1, c - 1);                if (right &gt;= k) &#123;                    ans.push_back(&#x27;H&#x27;);                    --c;                &#125; else &#123;                    ans.push_back(&#x27;V&#x27;);                    --r;                    k -= right;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度：O((rows + cols) * cols),\n空间复杂度: O((rows + cols) * cols).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 214","url":"/2020/11/08/LeetCode-weekly-contest-214/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n393 / 9769\nYoungForest\n18\n1:36:40\n0:05:13\n0:11:24\n0:44:59\n1:26:40  2\n\n\n\n残酷群排名维持在14名了，看来这就是我的水平收敛的位置了。最近由于写毕业大论文比较忙，另一方面秋招也结束了，打卡题都没打了。11月才恢复开始打美服和国服每日一题，拿积分换衣服。残酷群由于基本可以免打卡，就一个月都没打了。\n 5561. Get Maximum in Generated Array\n签到题。按照递推公式填写每一个元素。\nclass Solution &#123;public:    int getMaximumGenerated(int n) &#123;        vector&lt;int&gt; nums(n + 1);        int ans = 0;        nums[0] = 0;        if (nums.size() &lt;= 1) return 0;        nums[1] = 1;        ans = 1;        for (int i = 2; i &lt;= n; ++i) &#123;            if (i % 2 == 0) &#123;                nums[i] = nums[i / 2];            &#125; else &#123;                nums[i] = nums[i / 2] + nums[i / 2 + 1];            &#125;            ans = max(ans, nums[i]);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 5562. Minimum Deletions to Make Character Frequencies Unique\n贪心。不断删除字符，直到有空缺的位置。\nclass Solution &#123;public:    int minDeletions(string s) &#123;        vector&lt;int&gt; cnt(26, 0);        for (char c : s) &#123;            ++cnt[c - &#x27;a&#x27;];        &#125;        set&lt;int&gt; count;        int ans = 0;        for (int a : cnt) &#123;            if (a != 0) &#123;                while (a != 0 &amp;&amp; count.find(a) != count.end()) &#123;                    ++ans;                    --a;                &#125;                count.insert(a);            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(26).\n 5563. Sell Diminishing-Valued Colored Balls\n贪心。每次都试图先拿球数最多的颜色。拿的过程中并不是要一个一个拿，而是可以一次拿尽可能多的。\n用一个优先队列维护最多的颜色数目，用等差数列求和求解拿的cost。\nclass Solution &#123;    using ll = long long;    const ll MOD = 1e9 + 7;    using pii = pair&lt;int, int&gt;;public:    int maxProfit(vector&lt;int&gt;&amp; inventory, int o) &#123;        ll orders = o;        // greedy        ll ans = 0;        map&lt;ll, ll, greater&lt;ll&gt;&gt; cnt;        for (ll i : inventory) &#123;            ++cnt[i];        &#125;        cnt[0] = 0;        while (orders &gt; 0) &#123;            auto first = *cnt.begin();            if (first.first == 0) return -1;            auto second = *next(cnt.begin());            cnt.erase(cnt.begin());            cnt.erase(cnt.begin());            ll balls = (first.first - second.first) * first.second;            pii newSecond = &#123;second.first, second.second + first.second&#125;;            ll reduce = min(orders, balls);            orders -= reduce;            // cout &lt;&lt; first.first &lt;&lt; &quot; &quot; &lt;&lt; first.second &lt;&lt; &quot; &quot; &lt;&lt; reduce &lt;&lt; endl;            const ll batch = reduce / first.second;            const ll remain = reduce % first.second;            ans = (ans + (first.first * batch - batch*(batch-1) / 2) * first.second) % MOD;            ans = (ans + (first.first - batch) * remain) % MOD;            // for (int i = 0; i * first.second &lt; reduce; ++i) &#123;            //     // cout &lt;&lt;  min(first.second, reduce - i) &lt;&lt; &quot; &quot; &lt;&lt;  (first.first - i) &lt;&lt; endl;            //     ans = (ans + min(first.second, reduce - i * first.second) * (first.first - i)) % MOD;            // &#125;            // cout &lt;&lt; ans &lt;&lt; endl;            cnt.insert(newSecond);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N), N = inventory.size()\n空间复杂度: O(N).\n时间复杂度并不是那么明显，可以考虑cnt的size每次减一这个事实。所以while循环最多被执行N次。\n 5564. Create Sorted Array through Instructions\n核心在于需要这样一个数据结构，可以求解一定范围的元素的数量。可以使用 线段树、树状数组（BIT）、rank tree 等。比赛时我首先使用了GNU pbds实现的rank tree的板子，但是超时了。按理说复杂度是没问题的。\n然后，其实国服前一天的每日一题也用到同样的数据结构，去抄了treap的板子。由于不了解接口，光调试就花了半个小时。所幸最后5分钟AC了，这周又可以不用打卡残酷群了（已经一个月没打了）。\n需要注意板子接口中rank是1开头索引的。\nclass BalancedTree &#123;private:    struct BalancedNode &#123;        long long val;        long long seed;        int count;        int size;        BalancedNode* left;        BalancedNode* right;        BalancedNode(long long _val, long long _seed): val(_val), seed(_seed), count(1), size(1), left(nullptr), right(nullptr) &#123;&#125;        BalancedNode* left_rotate() &#123;            int prev_size = size;            int curr_size = (left ? left-&gt;size : 0) + (right-&gt;left ? right-&gt;left-&gt;size : 0) + count;            BalancedNode* root = right;            right = root-&gt;left;            root-&gt;left = this;            root-&gt;size = prev_size;            size = curr_size;            return root;        &#125;        BalancedNode* right_rotate() &#123;            int prev_size = size;            int curr_size = (right ? right-&gt;size : 0) + (left-&gt;right ? left-&gt;right-&gt;size : 0) + count;            BalancedNode* root = left;            left = root-&gt;right;            root-&gt;right = this;            root-&gt;size = prev_size;            size = curr_size;            return root;        &#125;    &#125;;private:    BalancedNode* root;    int size;    mt19937 gen;    uniform_int_distribution&lt;long long&gt; dis;private:    BalancedNode* insert(BalancedNode* node, long long x) &#123;        if (!node) &#123;            return new BalancedNode(x, dis(gen));        &#125;        ++node-&gt;size;        if (x &lt; node-&gt;val) &#123;            node-&gt;left = insert(node-&gt;left, x);            if (node-&gt;left-&gt;seed &gt; node-&gt;seed) &#123;                node = node-&gt;right_rotate();            &#125;        &#125;        else if (x &gt; node-&gt;val) &#123;            node-&gt;right = insert(node-&gt;right, x);            if (node-&gt;right-&gt;seed &gt; node-&gt;seed) &#123;                node = node-&gt;left_rotate();            &#125;        &#125;        else &#123;            ++node-&gt;count;        &#125;        return node;    &#125;public:    BalancedTree(): root(nullptr), size(0), gen(random_device&#123;&#125;()), dis(LLONG_MIN, LLONG_MAX) &#123;&#125;    long long get_size() const &#123;        return size;    &#125;    void insert(long long x) &#123;        ++size;        root = insert(root, x);    &#125;    long long lower_bound(long long x) const &#123;        BalancedNode* node = root;        long long ans = LLONG_MAX;        while (node) &#123;            if (x == node-&gt;val) &#123;                return x;            &#125;            if (x &lt; node-&gt;val) &#123;                ans = node-&gt;val;                node = node-&gt;left;            &#125;            else &#123;                node = node-&gt;right;            &#125;        &#125;        return ans;    &#125;    long long upper_bound(long long x) const &#123;        BalancedNode* node = root;        long long ans = LLONG_MAX;        while (node) &#123;            if (x &lt; node-&gt;val) &#123;                ans = node-&gt;val;                node = node-&gt;left;            &#125;            else &#123;                node = node-&gt;right;            &#125;        &#125;        return ans;    &#125;    pair&lt;int, int&gt; rank(long long x) const &#123;        BalancedNode* node = root;        int ans = 0;        while (node) &#123;            if (x &lt; node-&gt;val) &#123;                node = node-&gt;left;            &#125;            else &#123;                ans += (node-&gt;left ? node-&gt;left-&gt;size : 0) + node-&gt;count;                if (x == node-&gt;val) &#123;                    return &#123;ans - node-&gt;count + 1, ans&#125;;                &#125;                node = node-&gt;right;            &#125;        &#125;        return &#123;INT_MIN, INT_MAX&#125;;    &#125;&#125;;class Solution &#123;    const int MOD = 1e9 + 7;    using ll = long long;public:    int createSortedArray(vector&lt;int&gt;&amp; instructions) &#123;        BalancedTree* treap = new BalancedTree();        int ret = 0;        for (long long i: instructions) &#123;            // numLeft is the smallest &gt;= i            long long numLeft = treap-&gt;lower_bound(i);            // cout &lt;&lt; &quot;numLeft: &quot; &lt;&lt; numLeft &lt;&lt; endl;            // rankLeft is the rank of numLeft, starting from 0            ll rankLeft = (numLeft == LLONG_MAX ? treap-&gt;get_size(): treap-&gt;rank(numLeft).first - 1);            // numRight is the smallest &gt; i            long long numRight = treap-&gt;upper_bound(i);            // cout &lt;&lt; &quot;numRight: &quot; &lt;&lt; numRight &lt;&lt; endl;            // rankLeft is the rank of numLeft, starting from 0            ll rankRight = (numRight == LLONG_MAX ? treap-&gt;get_size(): treap-&gt;rank(numRight).first - 1);            // cout &lt;&lt; rankLeft - 1 &lt;&lt; &quot; &quot; &lt;&lt; treap-&gt;get_size() - rankRight &lt;&lt; endl;            ret = (ret + min(treap-&gt;get_size() - rankRight, rankLeft)) % MOD;            treap-&gt;insert(i);        &#125;        return ret;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 215","url":"/2020/11/15/LeetCode-weekly-contest-215/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n362 / 9683\nYoungForest\n12\n0:35:02\n0:04:21\n0:13:42\n0:30:02  1\nnull\n\n\n\n 5601. Design an Ordered Stream\n签到题。按照题目要求，用一个数组和指针实现接口。\nclass OrderedStream &#123;    vector&lt;string&gt; data;    int ptr;    int n;public:    OrderedStream(int _n) &#123;        data.resize(_n);        ptr = 1;        n = _n;    &#125;        vector&lt;string&gt; insert(int id, string value) &#123;        data[id-1] = move(value);        vector&lt;string&gt; ans;        while (ptr &lt;= n &amp;&amp; !data[ptr-1].empty()) &#123;            ans.push_back(data[ptr-1]);            ++ptr;        &#125;        return ans;    &#125;&#125;;/** * Your OrderedStream object will be instantiated and called as such: * OrderedStream* obj = new OrderedStream(n); * vector&lt;string&gt; param_1 = obj-&gt;insert(id,value); */\n时间复杂度: O(n),\n空间复杂度: O(n).\n 5603. Determine if Two Strings Are Close\n观察2个字符串接近的操作，发现其充分必要条件为：\n组成字符相同，字符的个数排列相同。\nclass Solution &#123;    vector&lt;int&gt; cnt(const string &amp;a) &#123;        vector&lt;int&gt; ans(26, 0);        for (char c : a) &#123;            ++ans[c - &#x27;a&#x27;];        &#125;        return ans;    &#125;    string appear(const vector&lt;int&gt;&amp; a) &#123;        string ans;        for (int i = 0; i &lt; 26; ++i) &#123;            if (a[i] != 0) ans.push_back(&#x27;a&#x27; + i);        &#125;        return ans;    &#125;    vector&lt;int&gt; frequency(const vector&lt;int&gt;&amp; a) &#123;        vector&lt;int&gt; ans;        for (int i = 0; i &lt; 26; ++i) &#123;            if (a[i] != 0) ans.push_back(a[i]);        &#125;        sort(ans.begin(), ans.end());        return ans;    &#125;public:    bool closeStrings(string word1, string word2) &#123;        if (word1.size() != word2.size()) return false;        auto cnt1 = cnt(word1);        auto cnt2 = cnt(word2);        return appear(cnt1) == appear(cnt2) &amp;&amp; frequency(cnt1) == frequency(cnt2);    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 5602. Minimum Operations to Reduce X to Zero\n观察：\n\n取头和取尾操作，其实是和顺序无关的，只和头尾各多少有关。\n头尾相加为x，可以转换成中间剩特定的值，找到最长的中间。\n\n所以我们枚举每个中间的尾部即可。\nclass Solution &#123;public:    int minOperations(vector&lt;int&gt;&amp; nums, int x) &#123;        const int n = nums.size();        unordered_map&lt;int, int&gt; presum;        presum[0] = -1;        int s = 0;        int maxJSubI = -1;        int total = accumulate(nums.begin(), nums.end(), 0);        int i = 0;        for (; i &lt; n; ++i) &#123;            s += nums[i];                        if (presum.find(s) == presum.end())  &#123;                presum[s] = i;            &#125;            auto it = presum.find(s - (total - x));            // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; s - (total - x) &lt;&lt; endl;;            if (it != presum.end()) &#123;                const int current = i - it-&gt;second;                // cout &lt;&lt; it-&gt;second &lt;&lt; endl;                maxJSubI = max(maxJSubI, current);            &#125;        &#125;        if (maxJSubI == -1) return -1;        else return n - maxJSubI;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 5604. Maximize Grid Happiness\n轮廓线DP。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 216","url":"/2020/11/22/LeetCode-weekly-contest-216/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n862 / 9573\nYoungForest\n18\n0:58:34\n0:12:47\n0:23:33\n0:33:14\n0:58:34\n\n\n\n之前连续5周免残酷群打卡，着实爽了一个月。上周虽然在前500，但只做出3题。本周虽然做出了4题，但出了前500. 又要打一周卡了。残酷群排名也降到了38名，不再15名的巅峰时光了。\n自从秋招结束后，再加上实习/大论文特别忙，就没时间刷题了。甚至之前交大论文形式审查最忙的时候，一道题都不刷。11月份以来，恢复了刷国服/美服每日一题的习惯。主要是这2题一般比较简单，花的时间少。另外是想打卡赚积分，争取毕业前可以换2套衣服。\n3道打卡题的难度基本上是 残酷 &gt; 国服 &gt;= 美服。\n 1662. Check If Two String Arrays are Equivalent\n签到题。把列表字符串拼接起来然后再比较即可。\nclass Solution &#123;    string concat(vector&lt;string&gt;&amp; w) &#123;        string ans;        for (auto&amp; s : w) &#123;            ans += move(s);        &#125;        return ans;    &#125;public:    bool arrayStringsAreEqual(vector&lt;string&gt;&amp; word1, vector&lt;string&gt;&amp; word2) &#123;        return concat(word1) == concat(word2);    &#125;&#125;;\n时间复杂度: O(sum(word1[i].length) + sum(word2[i].length)),\n空间复杂度: O(sum(word1[i].length) + sum(word2[i].length)).\n 1663. Smallest String With A Given Numeric Value\n贪心。每次都尽量增加最后一位数。\nclass Solution &#123;public:    string getSmallestString(int n, int k) &#123;        string ans(n, &#x27;a&#x27;);        k -= n;        for (int i = n - 1; i &gt;= 0 &amp;&amp; k &gt; 0; --i) &#123;            const int thisDigit = min(k, 25);            ans[i] += thisDigit;            k -= thisDigit;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1664. Ways to Make a Fair Array\n使用类似 前缀和数组 的 前缀偶数和 和 前缀奇数和，同样 后缀偶数和 和 后缀奇数和。\n然后就可以快速计算删掉某个位置后的 奇数下标元素的和与偶数下标元素的和。\nclass Solution &#123;public:    int waysToMakeFair(vector&lt;int&gt;&amp; nums) &#123;        const int n = nums.size();        int ans = 0;        vector&lt;int&gt; leftOdd(n, 0);        vector&lt;int&gt; leftEven(n, 0);        vector&lt;int&gt; rightOdd(n, 0);        vector&lt;int&gt; rightEven(n, 0);        leftEven[0] = nums[0];        for (int i = 1; i &lt; nums.size(); ++i) &#123;            if (i % 2 == 1) &#123;                leftOdd[i] = leftOdd[i - 1] + nums[i];                leftEven[i] = leftEven[i - 1];            &#125; else &#123;                leftEven[i] = leftEven[i - 1] + nums[i];                leftOdd[i] = leftOdd[i - 1];            &#125;        &#125;        if ((n - 1) % 2 == 0) &#123;            rightEven[n-1] = nums[n-1];        &#125; else &#123;            rightOdd[n-1] = nums[n-1];        &#125;        for (int i = n - 2; i &gt;= 0; --i) &#123;            if (i % 2 == 1) &#123;                rightOdd[i] = rightOdd[i + 1] + nums[i];                rightEven[i] = rightEven[i + 1];            &#125; else &#123;                rightEven[i] = rightEven[i + 1] + nums[i];                rightOdd[i] = rightOdd[i + 1];            &#125;        &#125;        for (int i = 0; i &lt; nums.size(); ++i) &#123;            int odd = 0, even = 0;            odd += i &gt; 0 ? leftOdd[i - 1] : 0;            even += i &gt; 0 ? leftEven[i - 1] : 0;            odd += i &lt; n - 1 ? rightEven[i + 1] : 0;            even += i &lt; n - 1 ? rightOdd[i + 1] : 0;            if (odd == even) ++ans;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1665. Minimum Initial Energy to Finish Tasks\n参见零神的帖子。\n本题我在比赛时用了不正确地贪心也过了。即找到最小的差值|minimum_i - actual_i|，作为剩下的值；比较这个值和最大的minimum_i。\n正确的解法对于6分题实在是太难了，应该7/8分。很多人即使猜对了，也不会证明正确性。\nclass Solution &#123;public:    int minimumEffort(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) &#123;        sort(tasks.begin(), tasks.end(), [](const auto&amp; u, const auto&amp; v) &#123;            return u[0] - u[1] &lt; v[0] - v[1];        &#125;);        int p = 0;        int suma = 0;        for (const auto&amp; task: tasks) &#123;            p = max(p, suma + task[1]);            suma += task[0];        &#125;        return p;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(1).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 217","url":"/2020/11/29/LeetCode-weekly-contest-217/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (6)\nQ4 (7)\n\n\n\n\n356 / 9462\nYoungForest\n13\n1:24:07\n0:03:55\n0:20:14\n1:09:07  3\nnull\n\n\n\n 1672. Richest Customer Wealth\n签到题。数组求和, C++ accumulate 一行搞定。\nclass Solution &#123;public:    int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) &#123;        int ans = 0;        for (const auto &amp; v : accounts) &#123;            ans = max(ans, accumulate(v.begin(), v.end(), 0));        &#125;        return ans;    &#125;&#125;;\n 1673. Find the Most Competitive Subsequence\n类似 402. Remove K Digits，采用贪心的思路，尽量删除大的数。标准做法是使用单调栈。\n比赛时我采用的是 优先队列维护要删除的最大数。\nclass Solution &#123;public:    vector&lt;int&gt; mostCompetitive(vector&lt;int&gt;&amp; nums, int k) &#123;        using pii = pair&lt;int, int&gt;;        auto cmp = [](pii a, pii b) -&gt; bool &#123;            if (a.first != b.first) &#123;                return a.first &gt; b.first;            &#125; else &#123;                return a.second &gt; b.second;            &#125;        &#125;;        priority_queue&lt;pii, vector&lt;pii&gt;, decltype(cmp)&gt; m(cmp);                for (int i = 0; i + k - 1 &lt; nums.size(); ++i) &#123;            m.push(&#123;nums[i], i&#125;);        &#125;        int begin = 0;        vector&lt;int&gt; ans;        while (k &gt; 0) &#123;            auto p = m.top();            m.pop();            while (p.second &lt; begin &amp;&amp; !m.empty()) &#123;                p = m.top();                m.pop();            &#125;            begin = p.second;            ans.push_back(p.first);            --k;            if (k == 0) break;            m.push(&#123;nums[nums.size() - k], nums.size() - k&#125;);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n 1674. Minimum Moves to Make Array Complementary\n我在注释中记录了我比赛时的思路。最后灵感乍现，确定每组数一次变化的范围，然后枚举每个可能的目标数，可以快速O(log N)计算出需要的变数。\nclass Solution &#123;    static const int MAX = 1e5 + 5;    int open[MAX], close[MAX], dot[MAX];public:    int minMoves(vector&lt;int&gt;&amp; nums, int limit) &#123;        // 统计和的最大众数，变其他。但是有的需要大于limit (x)        // 二分，快速求判定问题？        // 暴力，枚举互补数，遍历一遍再。O(n * n)        // a + b = 互补数，0        // a + b 变 互补数： 1， 2        // 0次变 是一个数        // 一次变最大，一次变最小 是一个范围        // 出了范围就需要2次变        // 确定互补数，可以遍历一遍确定变数        // 确定变数呢？        // ｜  .  ｜        // open - close: in range        // close + total - open: out range        // dtop: 0        const int n = nums.size();        for (int i = 0; i &lt; n - 1 - i; ++i) &#123;            int a = nums[i];            int b = nums[n - 1 - i];            if (a &gt; b) swap(a, b);            // a &lt;= b            int lower = a + 1;            int upper = b + limit;            dot[i] = a + b;            open[i] = lower;            close[i] = upper;        &#125;        const int size = n / 2;        auto openEnd = begin(open) + size;        auto closeEnd = begin(close) + size;        auto dotEnd = begin(dot) + size;        sort(begin(open), openEnd);        sort(begin(close), closeEnd);        sort(begin(dot), dotEnd);                auto need = [&amp;](const int line) -&gt; int &#123;            auto itOpen = upper_bound(begin(open), openEnd, line);            auto itClose = lower_bound(begin(close), closeEnd, line);            auto itDot = lower_bound(begin(dot), dotEnd, line);            auto itDot2 = upper_bound(itDot, dotEnd, line);            int dotNumber = distance(itDot, itDot2);            int outRange = 0;            outRange += distance(begin(close), itClose);            outRange += distance(itOpen, openEnd);            int inRange = n / 2 - dotNumber - outRange;            return inRange + 2 * outRange;        &#125;;        int ans = n;        for (int line = 2; line &lt;= limit * 2; ++line) &#123;            const int condidate = need(line);            // cout &lt;&lt; line &lt;&lt; &quot;: &quot; &lt;&lt; condidate &lt;&lt; endl;            ans = min(ans, condidate);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(limit * log N),\n空间复杂度: O(N).\n在比赛时，C++ 被卡常数了。需要讲数组改成全局数组才能AC。\n我本身平时更习惯使用局部vector，可读性和可维护性都更高。\n使用差分数组可以避免二分搜索，具体见零神的题解. 我也是头一次接触差分数组这一概念。\n 1675. Minimize Deviation in Array\n基于2个操作，可以将问题很轻松地转为LC之前地一个题：\n632. Smallest Range Covering Elements from K Lists。\n然后使用优先队列或Tree解决。\nclass Solution &#123;public:    int minimumDeviation(vector&lt;int&gt;&amp; nums) &#123;        multiset&lt;int&gt; ms;        for (int i : nums) &#123;            if (i % 2 == 0) ms.insert(i);            else ms.insert(i * 2);        &#125;        int ret = numeric_limits&lt;int&gt;::max();        while (true) &#123;            ret = min(ret, *ms.rbegin() - *ms.begin());            const int maxValue = *ms.rbegin();            ms.erase(prev(ms.end()));            if (maxValue % 2 != 0) break;            ms.insert(maxValue / 2);        &#125;        return ret;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 218","url":"/2020/12/06/LeetCode-weekly-contest-218/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n71 / 9827\nYoungForest\n18\n0:48:21\n0:03:32\n0:05:23\n0:12:14\n0:43:21  1\n\n\n\n 1678. Goal Parser Interpretation\n签到题。字符串解释，通用的做法是先做词法分析得到token，然后在依次翻译。由于本题的token比较少，设定也简单，所以可以一次遍历，向前看以确定token。\nclass Solution &#123;public:    string interpret(string command) &#123;        string ans;        for (int i = 0; i &lt; command.size(); ++i) &#123;            if (command[i] == &#x27;G&#x27;) &#123;                ans.push_back(&#x27;G&#x27;);            &#125; else &#123;                if (command[i + 1] == &#x27;)&#x27;) &#123;                    ans.push_back(&#x27;o&#x27;);                    ++i;                &#125; else &#123;                    ans.push_back(&#x27;a&#x27;);                    ans.push_back(&#x27;l&#x27;);                    i += 3;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n据说Python 选手都是一行代码搞定。\n 1679. Max Number of K-Sum Pairs\n贪心。对于每个数，找到它对应的数，然后remove掉即可。使用一个哈希表存储之前见到的数，然后找的花费就是O(1)了。\nclass Solution &#123;public:    int maxOperations(vector&lt;int&gt;&amp; nums, int k) &#123;        sort(nums.begin(), nums.end());        int ans = 0;        unordered_map&lt;int, int&gt; count;        for (int i : nums) &#123;            if (count[k - i] &gt; 0) &#123;                ++ans;                --count[k - i];            &#125; else &#123;                ++count[i];            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N), 代码中的排序其实是不需要的，比赛时没注意就先排序了。\n空间复杂度: O(N).\n 1680. Concatenation of Consecutive Binary Numbers\nStraight forward。用乘法和加法模拟拼接操作。\n需要注意的是，左移操作是否可以直接取模。答案是可以的，加减乘都可以直接取模，但除法不行。\n左移相当于是乘法。\nclass Solution &#123;    using ll = long long;    const ll MOD = 1e9 + 7;    ll bits(ll x) &#123;        ll ans = 0;        while (x &gt; 0) &#123;            x = x &gt;&gt; 1;            ++ans;        &#125;        return ans;    &#125;public:    int concatenatedBinary(int n) &#123;        ll ans = 0;        for (ll i = 1; i &lt;= n; ++i) &#123;            ans = ((ans &lt;&lt; bits(i)) + i) % MOD;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N * log N),\n空间复杂度: O(1).\n 1681. Minimum Incompatibility\n本题标的是medium，但有6分，确实不大容易。\n正确的做法是状态压缩DP，详见评论区。但比赛中还是有很多人AC了，包括我，都使用的是暴力的backtracking解法。因为回溯+剪枝的时间复杂度往往不好分析，所以即使通过了，心里也是没有底的。\n尤其是LeetCode周赛最近加了rejudge的机制，比赛时通过并不意味着成功，所以更心虚。\n我首先使用一个贪心的思路（每次都试图找最小的数加入集合）得到一个可能的解。\n此时，这个解不一定是最小解，但可以用来后面的剪枝。\n之后会有回溯搜索所有的解空间，构建解集合，得到最小解。\nclass Solution &#123;public:    int minimumIncompatibility(vector&lt;int&gt;&amp; nums, int k) &#123;        const int n = nums.size();        const int s = n / k;                unordered_map&lt;int, int&gt; count;        for (int i : nums) &#123;            ++count[i];            if (count[i] &gt; k) return -1;        &#125;        auto greedy = [&amp;]() -&gt; int &#123;            int ans = 0;            multiset&lt;int&gt; s(nums.begin(), nums.end());            const int n = nums.size();            for (int setIdx = 0; setIdx &lt; k; ++setIdx) &#123;                int minValue = *s.begin();                int maxValue = minValue;                int current = minValue;                s.erase(s.begin());                int i = 1;                while (i &lt; n / k) &#123;                    auto it = s.upper_bound(current);                    if (it == s.end()) return numeric_limits&lt;int&gt;::max();                    current = *it;                    s.erase(it);                    maxValue = current;                    ++i;                &#125;                ans += maxValue - minValue;            &#125;            return ans;        &#125;;        int ans = greedy();        // if (ans != -1) return ans;        vector&lt;set&lt;int&gt;&gt; results(k);        vector&lt;int&gt; uncomp(k, 0);        function&lt;void(const int, const int)&gt; backtracking = [&amp;](const int i, const int condidate) -&gt; void &#123;            if (condidate &gt; ans) return;            if (i == nums.size()) &#123;                ans = min(ans, condidate);            &#125; else &#123;                const int x = nums[i];                for (int j = 0; j &lt; k; ++j) &#123;                    if (results[j].size() &lt; s) &#123;                        if (j - 1 &gt;= 0 &amp;&amp; results[j - 1].size() == 0) break;                        if (results[j].find(x) == results[j].end()) &#123;                            const int tmpuncomp = uncomp[j];                            results[j].insert(x);                            uncomp[j] = *results[j].rbegin() - *results[j].begin();                            backtracking(i + 1, condidate + uncomp[j] - tmpuncomp);                            results[j].erase(x);                            uncomp[j] = tmpuncomp;                        &#125;                    &#125;                &#125;            &#125;        &#125;;        backtracking(0, 0);        if (ans == numeric_limits&lt;int&gt;::max()) return -1;        else return ans;    &#125;&#125;;\n时间复杂度: O((k * log (n / k)) ^ N), 因为剪枝的存在，实际上运行会快些，但真正的时间复杂度不好分析。\n空间复杂度: O(N).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 221","url":"/2020/12/27/LeetCode-weekly-contest-221/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n231 / 8838\nYoungForest\n18\n1:24:39\n0:03:55\n0:21:00\n0:30:16\n1:09:39  3\n\n\n\n 5637. Determine if String Halves Are Alike\n签到题。使用set记录元音，然后挨个统计即可。\nclass Solution &#123;public:    bool halvesAreAlike(string s) &#123;        unordered_set&lt;char&gt; yuan = &#123;&#x27;a&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;o&#x27;, &#x27;u&#x27;,                                    &#x27;A&#x27;, &#x27;E&#x27;, &#x27;I&#x27;, &#x27;O&#x27;, &#x27;U&#x27;&#125;;        const int n = s.size();        int first = 0;        for (int i = 0; i &lt; n / 2; ++i) &#123;            if (yuan.find(s[i]) != yuan.end()) ++first;        &#125;        int last = 0;        for (int i = n / 2; i &lt; n; ++i) &#123;            if (yuan.find(s[i]) != yuan.end()) ++last;        &#125;        return first == last;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 5638. Maximum Number of Eaten Apples\n贪心。先吃快过期的苹果。\n使用TreeMap维护过期时间，二分搜索寻找过期时间最近的苹果。\nclass Solution &#123;public:    int eatenApples(vector&lt;int&gt;&amp; apples, vector&lt;int&gt;&amp; days) &#123;        const int n = apples.size();        int maxDay = n;        for (int i = 0; i &lt; n; ++i) &#123;            maxDay = max(maxDay, i + days[i]);        &#125;        map&lt;int, int&gt; rust;        int ans = 0;        // cout &lt;&lt; &quot;maxDay: &quot; &lt;&lt; maxDay &lt;&lt; endl;        for (int i = 0; i &lt; maxDay; ++i) &#123;            if (i &lt; n &amp;&amp; apples[i] &gt; 0) &#123;                rust[i + days[i] - 1] += apples[i];            &#125;            auto it = rust.lower_bound(i);            if (it != rust.end()) &#123;                // cout &lt;&lt; i &lt;&lt; endl;                ++ans;                --it-&gt;second;                if (it-&gt;second == 0) &#123;                    rust.erase(it);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1706. Where Will the Ball Fall\n由于m, n规模较小，所以可以尝试暴力的dfs解法。\nclass Solution &#123;public:    vector&lt;int&gt; findBall(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        const int m = grid.size();        const int n = grid[0].size();        function&lt;int(const int, const int)&gt; dfs = [&amp;](const int row, const int col) -&gt; int &#123;            if (row == m) &#123;                return col;            &#125; else &#123;                if (grid[row][col] == 1) &#123;                    if (col == n - 1 || grid[row][col + 1] == -1) &#123;                        return -1;                    &#125;                    return dfs(row + 1, col + 1);                &#125; else &#123;                    if (col == 0 || grid[row][col - 1] == 1) &#123;                        return -1;                    &#125;                    return dfs(row + 1, col - 1);                &#125;            &#125;        &#125;;        vector&lt;int&gt; ans(n);        for (int i = 0; i &lt; n; ++i) &#123;            ans[i] = dfs(0, i);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n * m).\n 5640. Maximum XOR With an Element From Array\n经典0-1 Trie。\n最后一题被智能指针shared_ptr坑了 3次TLE，换成裸指针就过了。虽然智能指针花费较小，但shared_ptr也不是zero-overhead的。即使这样，被LeetCode卡常数还是好气呀！\nclass Solution &#123;    struct TrieNode &#123;        TrieNode* zero = nullptr;        TrieNode* one = nullptr;        int count = 0;        int minValue = numeric_limits&lt;int&gt;::max();    &#125;;    void insert(TrieNode* root, const int i, const int num) &#123;        ++root-&gt;count;        root-&gt;minValue = min(root-&gt;minValue, num);        if (i &gt;= 0) &#123;            if (num &amp; (1 &lt;&lt; i)) &#123;                if (root-&gt;one == nullptr) root-&gt;one = new TrieNode();                insert(root-&gt;one, i - 1, num);            &#125; else &#123;                if (root-&gt;zero == nullptr) root-&gt;zero = new TrieNode();                insert(root-&gt;zero, i - 1, num);            &#125;        &#125;    &#125;    int recurseQuery(TrieNode* root, const int x, const int limit, const int i, const int ans) &#123;        // cout &lt;&lt; &quot;level: &quot; &lt;&lt; i &lt;&lt; &quot; &quot;;        if (i &lt; 0) return ans;        if (x &amp; (1 &lt;&lt; i)) &#123; // 1            if (root-&gt;zero &amp;&amp; root-&gt;zero-&gt;count &gt; 0) &#123;                // cout &lt;&lt; &quot;zero&quot; &lt;&lt; endl;                return recurseQuery(root-&gt;zero, x, limit, i - 1, ans | (1 &lt;&lt; i));            &#125; else if (root-&gt;one &amp;&amp; root-&gt;one-&gt;count &gt; 0) &#123;                // cout &lt;&lt; &quot;one&quot; &lt;&lt; endl;                return recurseQuery(root-&gt;one, x, limit, i - 1, ans);            &#125; else &#123;                return -1;            &#125;        &#125; else &#123; // 0            if (root-&gt;one &amp;&amp; root-&gt;one-&gt;count &gt; 0 &amp;&amp; root-&gt;one-&gt;minValue &lt;= limit) &#123;                // cout &lt;&lt; &quot;root-&gt;one-&gt;minValue &quot; &lt;&lt; root-&gt;one-&gt;minValue &lt;&lt; &quot; &quot; &lt;&lt; limit &lt;&lt; &quot; &quot;;                // cout &lt;&lt; &quot;one&quot; &lt;&lt; endl;                return recurseQuery(root-&gt;one, x, limit, i - 1, ans | (1 &lt;&lt; i));            &#125; else if (root-&gt;zero &amp;&amp; root-&gt;zero-&gt;count &gt; 0) &#123;                // cout &lt;&lt; &quot;zero&quot; &lt;&lt; endl;                return recurseQuery(root-&gt;zero, x, limit, i - 1, ans);            &#125; else &#123;                return -1;            &#125;        &#125;    &#125;public:    vector&lt;int&gt; maximizeXor(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        const int maxDigit = 29;        TrieNode* root = new TrieNode();        for (int i : nums) &#123;            insert(root, maxDigit, i);        &#125;        const int q = queries.size();        vector&lt;int&gt; ans(q, -1);        for (int i = 0; i &lt; q; ++i) &#123;            const int x = queries[i][0];            const int m = queries[i][1];            if (root-&gt;minValue &gt; m) &#123;                ans[i] = -1;            &#125; else &#123;                ans[i] = recurseQuery(root, x, m, maxDigit, 0);            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(29 * N),\n空间复杂度: O(29 * N).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 222","url":"/2021/01/03/LeetCode-weekly-contest-222/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n331 / 9692\nYoungForest\n18\n2:02:29\n0:05:32\n0:13:55  2\n0:54:53  2\n1:17:29  5\n\n\n\n 5641. Maximum Units on a Truck\n贪心。按盒子容量从大到小排序后先用大的盒子。\nclass Solution &#123;public:    int maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) &#123;        // greedy, put larger boxes first        sort(boxTypes.begin(), boxTypes.end(), [](const auto&amp; a, const auto&amp; b) -&gt; bool &#123;            if (a[1] != b[1]) return a[1] &gt; b[1];            else return a[0] &gt; b[0];        &#125;);        int ans = 0;        int i = 0;        while (truckSize &gt; 0 &amp;&amp; i &lt; boxTypes.size()) &#123;            const int put = min(truckSize, boxTypes[i][0]);            truckSize -= put;            ans += boxTypes[i][1] * put;            ++i;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n log n), n = boxTypes.size()\n空间复杂度: O(log n). 快排内部的递归消耗。\n 5642. Count Good Meals\n类似two-sum。使用hashtable维护之前见过的数，只是target数目编程了22.\n从2^0 到 最大的2^21.\nclass Solution &#123;    using ll = int;    const int maxBit = 22;    const int MOD = 1e9 + 7;public:    int countPairs(vector&lt;int&gt;&amp; deliciousness) &#123;        vector&lt;ll&gt; target(maxBit);        target[0] = 1;        for (int i = 1; i &lt; maxBit; ++i) &#123;            target[i] = target[i-1] * 2;        &#125;        unordered_map&lt;ll, int&gt; count;        int ans = 0;        for (ll i : deliciousness) &#123;            for (int j = 0; j &lt; maxBit; ++j) &#123;                auto it = count.find(target[j] - i);                if (it != count.end()) &#123;                    ans = (ans + it-&gt;second) % MOD;                &#125;            &#125;            ++count[i];        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(22n),\n空间复杂度: O(n).\n比赛过程中，由于错误估计了最大的幂数。2^20 + 2^20 = 2^21, 错估计成了2^40。导致2次超时罚时。\n 5643. Ways to Split Array Into Three Subarrays\n枚举每个左子数组。然后利用前缀和和二分确定中间数组的大小。\nclass Solution &#123;    const int MOD = 1e9 + 7;public:    int waysToSplit(vector&lt;int&gt;&amp; nums) &#123;        const int n = nums.size();        vector&lt;int&gt; presum(n + 1);        presum[0] = 0;        for (int i = 0; i &lt; n; ++i) &#123;            presum[i+1] = presum[i] + nums[i];        &#125;        auto binarySearchRightLessThanMid = [&amp;](int lo, int hi) -&gt; int &#123;            // [lo, hi)            const int begin = lo;            while (lo &lt; hi) &#123;                // [begin, mid), [mid, end)                const int mid = lo + (hi - lo) / 2;                const int rightSum = presum[n] - presum[mid];                const int midSum = presum[mid] - presum[begin];                if (rightSum &lt; midSum) &#123;                    hi = mid;                &#125; else &#123; // rightSum &gt;= midSum                    lo = mid + 1;                &#125;            &#125;            return lo;        &#125;;        auto binarySearchFirstLargeEqualThan = [&amp;](int lo, int hi, const int leftSum) -&gt; int &#123;            // [lo, hi)            const int begin = lo;            while (lo &lt; hi) &#123;                // [begin, mid)                const int mid = lo + (hi - lo) / 2;                const int midSum = presum[mid] - presum[begin];                if (midSum &gt;= leftSum) &#123;                    hi = mid;                &#125; else &#123; // rightSum &lt; midSum                    lo = mid + 1;                &#125;            &#125;            return lo;        &#125;;        int ans = 0;        for (int left = 1; left &lt;= n - 2; ++left) &#123;            // [0, left)            const int leftSum = presum[left];            // [left, mid)            int midLeft = binarySearchFirstLargeEqualThan(left, n, leftSum);            if (midLeft == left) midLeft = left + 1;            const int midRight = binarySearchRightLessThanMid(left, n);            // cout &lt;&lt; left &lt;&lt; &quot; &quot; &lt;&lt; leftSum &lt;&lt; &quot; &quot; &lt;&lt; midLeft &lt;&lt; &quot; &quot; &lt;&lt; midRight &lt;&lt; endl;            if (midRight &gt; midLeft)                ans = (ans + (midRight - midLeft)) % MOD;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n log n),\n空间复杂度: O(n).\n比赛中因为边界问题（corner case）WA了2次。\n\n左数组和是0时，此时中数组需不为空。\n数组全为9时，此时右数组不为空。\n\n事实上，由于midRight和midleft是单调递增的，可以采用三指针的方法进一步将时间复杂度降到O(n).\n 5644. Minimum Operations to Make a Subsequence\n本题大家都是比赛现场学，现场抄的。之所以这样讲，是因为本题可以转化成其他经典题目。\n首先，观察有，arr中不出现在target中的数是没用的，可以直接删掉。\n删掉后的arr是一个target的组合（也不完全是，区别在于arr中有些可能是重复的数）。\n我们只需要求2者的最长公共子序列(Longest Common Subquence, LCS)的长度，然后补齐其余即可。\n然而LCS的时间复杂度是O(mn)的，显然超时。\n此时就需要利用组合这一条件了，我谷歌全排列 最长公共子序列。在第三条找到了解法最长公共子序列 和其变形.\n具体而言，对于这种组合的LCS的特例，可以将其转化成最长上升子序列（Longest Increasing Subsequence, LIS)的问题。LIS又有巧妙的O(n log n)的解法。\nclass Solution &#123;    int nums[100005];    int lengthOfLIS(int n) &#123;        vector&lt;int&gt; res;        for(int i=0; i&lt;n; i++) &#123;            auto it = std::lower_bound(res.begin(), res.end(), nums[i]);            if(it==res.end()) res.push_back(nums[i]);            else *it = nums[i];        &#125;        return res.size();    &#125;public:    int minOperations(vector&lt;int&gt;&amp; target, vector&lt;int&gt;&amp; arr) &#123;        // n log n        int cnt = 0;        unordered_map&lt;int, int&gt; m;        for (int i : target) &#123;            m[i] = cnt;            ++cnt;        &#125;        int x = 0;        for (int i : arr) &#123;            auto it = m.find(i);            if (it != m.end()) &#123;                nums[x++] = it-&gt;second;            &#125;        &#125;        int lcs = lengthOfLIS(x);        return target.size() - lcs;    &#125;&#125;;\n时间复杂度: O(n log n), n = target.size()\n空间复杂度: O(target.size()).\n因为抄错LIS的模版，TLE了3次。因为一开始只用了朴素的LCS的O(mn)解法又TLE了2次。\n 后记\n今天是2021年的第一场周赛，比往常的更难一些。\n北京的冬天真是太冷了，起床已经变的十分困难了，对生活的热情也十分不足，状态有些消极和悲伤。\n我想要重新振作和积极起来，开始奋斗的Forest。\n打工人，打工魂，打工才是人上人。\n加油Forest！\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 225","url":"/2021/01/24/LeetCode-weekly-contest-225/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n299 / 11282\nYoungForest\n18\n1:16:19\n0:05:09\n0:18:06\n0:29:04\n1:11:19  1\n\n\n\n 1736. Latest Time by Replacing Hidden Digits\n贪心。分析每位的情况，if-else解决。\nclass Solution &#123;public:    string maximumTime(string time) &#123;        if (time[4] == &#x27;?&#x27;) &#123;            time[4] = &#x27;9&#x27;;        &#125;        if (time[3] == &#x27;?&#x27;) &#123;            time[3] = &#x27;5&#x27;;        &#125;        if (time[1] == &#x27;?&#x27;) &#123;            if (time[0] == &#x27;?&#x27;) &#123;                time[0] = &#x27;2&#x27;;                time[1] = &#x27;3&#x27;;            &#125; else if (time[0] == &#x27;2&#x27;) &#123;                time[1] = &#x27;3&#x27;;            &#125; else &#123;                time[1] = &#x27;9&#x27;;            &#125;        &#125; else &#123;            if (time[0] == &#x27;?&#x27;) &#123;                if (time[1] &lt; &#x27;4&#x27;) &#123;                    time[0] = &#x27;2&#x27;;                &#125; else &#123;                    time[0] = &#x27;1&#x27;;                &#125;            &#125;        &#125;        return time;    &#125;&#125;;\n时间复杂度: O(1),\n空间复杂度: O(1).\n 1737. Change Minimum Characters to Satisfy One of Three Conditions\n计算每种目标情况。\n1，2: 枚举分割点，变换超过分割点的不合适字符。\n3: 找到众数即可。\nclass Solution &#123;public:    int minCharacters(string a, string b) &#123;        int ans = a.size() + b.size();        auto calculatePresum = [&amp;](const string&amp; x) -&gt; vector&lt;int&gt; &#123;            vector&lt;int&gt; ans(26, 0);            for (char c : x) &#123;                ++ans[c - &#x27;a&#x27;];            &#125;            for (int i = 1; i &lt; 26; ++i) &#123;                ans[i] += ans[i - 1];            &#125;            return ans;        &#125;;        auto op12 = [&amp;](const string&amp; a, const string&amp; b) -&gt; void &#123;            // 26 * (a.size() + b.size())            auto presumA = calculatePresum(a);            auto presumB = calculatePresum(b);            // b &gt;= splitPoint, a &lt; splitPoint            for (int splitPoint = 1; splitPoint &lt; 26; ++splitPoint) &#123;                int need = 0;                // a need                need += a.size() - presumA[splitPoint - 1];                // b need                need += presumB[splitPoint - 1];                ans = min(ans, need);            &#125;        &#125;;        // 1, 2        op12(a, b);        op12(b, a);                // 3        // size 和 - 众数        &#123;            unordered_map&lt;char, int&gt; cnt;            for (char c : a) &#123;                ++cnt[c];            &#125;            for (char c : b) &#123;                ++cnt[c];            &#125;            int maxCnt = 0;            for (auto p : cnt) &#123;                maxCnt = max(maxCnt, p.second);            &#125;            ans = min(ans, static_cast&lt;int&gt;(a.size() + b.size()) - maxCnt);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n + 26),\n空间复杂度: O(26).\n 1738. Find Kth Largest XOR Coordinate Value\n动态规划。\n事实上，比赛时算复杂了。用了3个DP数组，分别表示矩形异或值，行异或值，列异或值。\n不过根据异或的性质，交换律和抵消律，只需要维护一个矩形异或值就可以了。\nclass Solution &#123;public:    int kthLargestValue(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123;        const int m = matrix.size();        const int n = matrix[0].size();        auto rows = matrix;        auto cols = matrix;        vector&lt;int&gt; nums;        nums.reserve(m * n);        nums.push_back(matrix[0][0]);        for (int i = 1; i &lt; m; ++i) &#123;            cols[i][0] = cols[i-1][0] ^ matrix[i][0];            matrix[i][0] ^= matrix[i-1][0];            nums.push_back(matrix[i][0]);        &#125;        for (int j = 1; j &lt; n; ++j) &#123;            rows[0][j] = rows[0][j-1] ^ matrix[0][j];            matrix[0][j] ^= matrix[0][j-1];            nums.push_back(matrix[0][j]);        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            for (int j = 1; j &lt; n; ++j) &#123;                rows[i][j] = rows[i][j-1] ^ matrix[i][j];                cols[i][j] = cols[i-1][j] ^ matrix[i][j];                matrix[i][j] ^= matrix[i-1][j-1] ^ rows[i][j-1] ^ cols[i-1][j];                nums.push_back(matrix[i][j]);            &#125;        &#125;        sort(nums.begin(), nums.end(), greater&lt;int&gt;());        return nums[k-1];    &#125;&#125;;\n时间复杂度: O(m * n),\n空间复杂度: O(1), 不需要rows, cols如果复用matrix的话。\n 1739. Building Boxes\n二分查找。\n确定最下一层盒子数，计算其最多可以摆多少盒子。\n根据贪心的思路，每一层都要尽量挤到角角上，是一个等差数列。\nclass Solution &#123;    using ll = long long;public:    int minimumBoxes(int n) &#123;        // time: log n * log n * log n        // 1 + 3 + 6        // level(x) = level(x-1) + x, level(1) = 1        // level(2) = 3        // level(3) = 6        // binary_search        // maxBoxesCount(x) =         const ll MAX = n + 1;        auto binary = [&amp;](ll lo, ll hi, function&lt;bool(const ll)&gt; predicate) -&gt; int &#123;            while (lo &lt; hi) &#123;                ll mid = lo + (hi - lo) / 2;                if (predicate(mid)) &#123;                    hi = mid;                &#125; else &#123;                    lo = mid + 1;                &#125;            &#125;            return lo;        &#125;;        function&lt;ll(const ll)&gt; maxBoxesCouldHoldByLastLevel = [&amp;](const ll x) -&gt; ll &#123;            if (x &lt;= 0) return 0;            ll k = binary(0, MAX, [&amp;](const ll k) -&gt; bool &#123;                return k * (k + 1) / 2 &gt; x;            &#125;) - 1;            // if (x &lt; 5) cout &lt;&lt; &quot;maxBoxesCouldHoldByLastLevel: &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; k &lt;&lt; endl;            const ll y = x - (k * (k + 1) / 2);            const ll couldNotPut = y + (k) - (y == 0 ? y : (y - 1));            const ll nextLevel = x - couldNotPut;            return x + maxBoxesCouldHoldByLastLevel(nextLevel);        &#125;;        return binary(0, MAX, [&amp;](const ll x) -&gt; bool &#123;            return maxBoxesCouldHoldByLastLevel(x) &gt;= n;        &#125;);    &#125;&#125;;\n时间复杂度: O(log n * log n * sqrt n), sqrt n 为 maxBoxesCouldHoldByLastLevel的递归层数，\n空间复杂度: O(sqrt n).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 230","url":"/2021/03/01/LeetCode-weekly-contest-230/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n314 / 11654\nYoungForest\n12\n0:27:36\n0:04:00\n0:14:38\n0:27:36\nnull\n\n\n\n自从秋招结束后，刷题和比赛的热情与日俱减。\n之前每日三题（国服、美服、残酷），现在每日0题。当然偶尔因为周赛成绩不足以免打卡，也需每日一题。\n相反，比赛的反馈还是挺强的。长期有rating和排名的增长激励，短期有残酷排名和每次排名的激励，还有额外积分的奖励。另外每周比赛完还可以在残酷群里领红包，给自己加个鸡腿。\n 1773. Count Items Matching a Rule\n签到题。按照题目描述便利一遍即可。\nclass Solution &#123;public:    int countMatches(vector&lt;vector&lt;string&gt;&gt;&amp; items, string ruleKey, string ruleValue) &#123;        int index = -1;        if (ruleKey == &quot;type&quot;) &#123;            index = 0;        &#125; else if (ruleKey == &quot;color&quot;) &#123;            index = 1;        &#125; else &#123;            index = 2;        &#125;        int ans = 0;        for (const auto&amp; v : items) &#123;            if (v[index] == ruleValue) &#123;                ++ans;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1774. Closest Dessert Cost\nBrute force 暴力枚举即可。观察题目的数据规模，n 和 m都比较小，指数级的暴力搜索就可以过。\n可以只用回溯(backtracking)，也可以使用3进制bitmask做枚举。\n我比赛时采用了回溯。\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int closestCost(vector&lt;int&gt;&amp; baseCosts, vector&lt;int&gt;&amp; toppingCosts, int target) &#123;        // time: n * (3 ^ m)        // 10 * 3 ^ 10 59049        // max: 10^4 + 2 * 10 * 10^4        vector&lt;int&gt; candidates;        const int m = toppingCosts.size();        function&lt;void(const int, const int)&gt; backtracking = [&amp;](const int i, const int now) -&gt; void &#123;            if (i == m) &#123;                candidates.push_back(now);            &#125; else &#123;                for (int j = 0; j &lt;= 2; ++j) &#123;                    backtracking(i + 1, now + toppingCosts[i] * j);                &#125;            &#125;        &#125;;        for (int base : baseCosts) &#123;            backtracking(0, base);        &#125;        int ans = -1, diff = INF;        for (int i : candidates) &#123;            const int diffI = abs(i - target);            if (diffI &lt; diff) &#123;                ans = i;                diff = diffI;            &#125; else if (diffI == diff &amp;&amp; i &lt; ans) &#123;                ans = i;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n * 3 ^ m),\n空间复杂度: O(n * 3 ^ m).\n 1775. Equal Sum Arrays With Minimum Number of Operations\n贪心。优先进行变化最大的操作。\nclass Solution &#123;    struct Content &#123;        int sumOfAll = 0;        vector&lt;int&gt; nums;        Content() &#123;            nums.resize(7, 0);        &#125;    &#125;;    Content preprocess(const vector&lt;int&gt;&amp; arr) &#123;        Content ans;        for (int i : arr) &#123;            ans.sumOfAll += i;            ++ans.nums[i];        &#125;        return ans;    &#125;public:    int minOperations(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        // 1 -&gt; 6 6 -&gt; 1 5        // 2 -&gt; 6 5 -&gt; 1 4        // 3        auto c1 = preprocess(nums1);        auto c2 = preprocess(nums2);        if (c1.sumOfAll &gt; c2.sumOfAll) &#123;            swap(c1, c2);        &#125;        // c1 &lt; c2        int ans = 0;        for (int i = 1; i &lt;= 5; ++i) &#123;            const int j = 7 - i;            const int cost = 6 - i;            const int need = c2.sumOfAll - c1.sumOfAll;            const int needStep = need / cost + ((need % cost == 0) ? 0 : 1);            // 3 2 -&gt; 2            // 4 2 -&gt; 2            // 2 2 -&gt; 1            if (needStep &lt;= c1.nums[i] + c2.nums[j]) &#123;                return ans + needStep;            &#125;            c1.sumOfAll += c1.nums[i] * cost;            c2.sumOfAll -= c2.nums[j] * cost;            ans += c1.nums[i] + c2.nums[j];        &#125;        return -1;    &#125;&#125;;\n时间复杂度: O(nums1.size() + nums2.size()),\n空间复杂度: O(1).\n 1776. Car Fleet II\n比较难的一道题目。比赛时没做出来，但是有一定的想法。可以先判断最后会分成几个车队。从后向前通过判断是否可以追上not meeting: speed[i] &gt; min of speed [i+1:]，把问题先分成若干个子问题。然后在每个子问题中，通过维护一个碰撞时间的优先队列，更新汽车的状态和新的碰撞事件。时间复杂度为 O(N log N).\n后来证明这个想法实现过于繁琐和容易出错。\n虽然用优先队列记录碰撞事件可以做，但实现起来，尤其是更新碰撞特别繁琐。\n优雅的做法是单调栈。详情参考群主的视频.\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 231","url":"/2021/03/07/LeetCode-weekly-contest-231/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n221 / 12900\nYoungForest\n13\n0:26:48\n0:03:30\n0:08:23  1\n0:21:48\nnull\n\n\n\n3题选手, again。sad.\n\n 1784. Check if Binary String Has at Most One Segment of Ones\n签到题。有限状态机。\nclass Solution &#123;public:    bool checkOnesSegment(string s) &#123;        int state = 0;        // 0: not see 1        // 1: see 1 and now 1        // 2: see 1 but now 0        for (char c : s) &#123;            if (c == &#x27;0&#x27;) &#123;                if (state == 0) &#123;                    state = 0;                &#125; else if (state == 1) &#123;                    state = 2;                &#125; else &#123;                    state = 2;                &#125;            &#125; else &#123; // c == &#x27;1&#x27;                if (state == 0) &#123;                    state = 1;                &#125; else if (state == 1) &#123;                    state = 1;                &#125; else &#123;                    return false;                &#125;            &#125;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1785. Minimum Elements to Add to Form a Given Sum\n贪心。每次都加减limit/-limit，以最大步长，以得到最小步数。\n注意: 这里题目数据范围故意挖了坑，用int求和nums会溢出。当然Python没有这种问题。\nclass Solution &#123;    using ll = long long;public:    int minElements(vector&lt;int&gt;&amp; nums, ll limit, ll goal) &#123;        const ll current = accumulate(nums.begin(), nums.end(), 0L);        if (current &gt; goal) &#123;            return (current - goal) / limit + (((current - goal) % limit == 0) ? 0 : 1);        &#125; else if (current == goal) &#123;            return 0;        &#125; else &#123;            return (goal - current) / limit + (((goal - current) % limit == 0) ? 0 : 1);        &#125;    &#125;&#125;;\n 1786. Number of Restricted Paths From First to Last Node\n题目比较难理解，但其实不难。\n用Dijistra求解distanceToLastNode(x)，然后记忆化dfs就OK了。\nclass Solution &#123;    using pii = pair&lt;int, int&gt;;    const int MOD = 1e9 + 7;public:    int countRestrictedPaths(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        // dijistra: E log E + V        vector&lt;vector&lt;pii&gt;&gt; neighbors(n+1);        for (const auto&amp; e : edges) &#123;            neighbors[e[0]].push_back(&#123;e[1], e[2]&#125;);            neighbors[e[1]].push_back(&#123;e[0], e[2]&#125;);        &#125;                vector&lt;int&gt; distance(n + 1, 0);        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq;        vector&lt;bool&gt; visited(n + 1, false);        pq.push(&#123;0, n&#125;);        while (!pq.empty()) &#123;            auto [d, current] = pq.top();            pq.pop();            if (!visited[current]) &#123;                visited[current] = true;                distance[current] = d;                for (auto neighbor : neighbors[current]) &#123;                    pq.push(&#123;d + neighbor.second, neighbor.first&#125;);                &#125;            &#125;        &#125;                vector&lt;int&gt; memo(n + 1, -1);        function&lt;int(const int)&gt; dfs = [&amp;](const int current) -&gt; int &#123;            if (current == n) &#123;                return memo[current] = 1;            &#125; else &#123;                if (memo[current] != -1) return memo[current];                int ans = 0;                for (auto neighbor : neighbors[current]) &#123;                    const int node = neighbor.first;                    if (distance[node] &lt; distance[current]) &#123;                        ans = (ans + dfs(node)) % MOD;                    &#125;                &#125;                return memo[current] = ans;            &#125;        &#125;;                return dfs(1);    &#125;&#125;;\n时间复杂度: O(E log E + V + E),\n空间复杂度: O(V + E).\n 1787. Make the XOR of All Segments Equal to Zero 中文\n说实话本题想了半天没思路，我还去Google了半天，感觉可能会是一道原题。然而没找到。\n赛后群友发出来链接，果然是原题：\n原题链接。\n看来搜题也是一门技术呀。有的人能搜到抄代码也算是他的本事。\n我是参考群主的题解。\n首先可以观察到 最后的状态中，每k个数是重复出现的。所以可以判定，我们只需要计算头k个数XOR为0即可。当然，算cost时，需要考虑后面的。\n然后根据数据返回，猜测是时间复杂度为O(1024*n)的DP。然后再构造状态转移方程。\nclass Solution &#123;    const int MAX_NUMS = 1 &lt;&lt; 10;public:    int minChanges(vector&lt;int&gt;&amp; nums, int k) &#123;        const int n = nums.size();                // the total size of Set[i]        vector&lt;int&gt; totalCost(k);        // cnt[i][j]: the count of j in Set[i]        vector&lt;unordered_map&lt;int, int&gt;&gt; cnt(k);                for (int i = 0; i &lt; n; ++i) &#123;            ++totalCost[i % k];            ++cnt[i%k][nums[i]];        &#125;                // the cost to set Set[i] to v        auto cost = [&amp;](const int i, const int v) -&gt; int &#123;            return totalCost[i] - cnt[i][v];        &#125;;                // dp[i][d]: the minimum cost to make first i XOR equal to d        vector&lt;vector&lt;int&gt;&gt; dp(k, vector&lt;int&gt; (MAX_NUMS, numeric_limits&lt;int&gt;::max()));        int minLastDp = numeric_limits&lt;int&gt;::max();        for (int d = 0; d &lt; MAX_NUMS; ++d) &#123;            dp[0][d] = totalCost[0] - cnt[0][d];            minLastDp = min(minLastDp, dp[0][d]);        &#125;        for (int i = 1; i &lt; k; ++i) &#123;            int minDp = numeric_limits&lt;int&gt;::max();             for (int d = 0; d &lt; MAX_NUMS; ++d) &#123;                dp[i][d] = minLastDp + totalCost[i];                for (int j = i; j &lt; n; j += k) &#123;                    dp[i][d] = min(dp[i][d],                                   dp[i-1][d^nums[j]] + cost(i, nums[j]));                &#125;                minDp = min(minDp, dp[i][d]);            &#125;            minLastDp = minDp;        &#125;        return dp[k-1][0];    &#125;&#125;;\n时间复杂度: O(k * 1024 * n / k) = O(1024 * n),\n空间复杂度: O(k * 1024).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 232","url":"/2021/03/14/LeetCode-weekly-contest-232/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n807 / 12541\nYoungForest\n17\n1:06:39\n0:03:24\n0:06:02\n0:38:44\n1:01:39  1\n\n\n\n昨天出去修Mac，因为屏幕一直闪。果然卖Apple的产品Apple Care是必须的。上次修了键盘，这次修屏幕，4个面都换新的了。在外面跑了一天，特别累。今早起来晚，一起来就开始比赛了，一口水一口饭都没吃。\n继连续2周3题后，终于4题了。一开始我还挺得意，觉得这周应该不用打卡了。后来发现小丑竟然是我自己。其他选手竟然认为本场是手速场。我T3 T4想复杂了，速度慢了些，没进前500. 残酷名次也从10+退到了40+。下周rating要掉了。没想到3题涨分，4题掉分。\n\n 1790. Check if One String Swap Can Make Strings Equal\n签到题。完全相等特殊判断，枚举所有的交换看是否可行。\nclass Solution &#123;public:    bool areAlmostEqual(string s1, string s2) &#123;        if (s1 == s2) return true;        for (int i = 0; i &lt; s1.size(); ++i) &#123;            for (int j = i + 1; j &lt; s1.size(); ++j) &#123;                swap(s1[i], s1[j]);                if (s1 == s2) return true;                swap(s1[i], s1[j]);            &#125;        &#125;        return false;    &#125;&#125;;\n时间复杂度: O(N^2),\n空间复杂度: O(1).\n当然，本题也有O(N)的做法。比如，可以找到2个字符串不一样的2个位置，再交换。\n由于题目数据范围较小，比赛时重点比拼手速，所以我选择了复杂度更高，但想起来和写起来更简单的解法。\n 1791. Find Center of Star Graph\n计算所有节点的度。度为n-1的节电即为中心节点。\nclass Solution &#123;public:    int findCenter(vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123;        const int n = edges.size() + 1;        vector&lt;int&gt; degree(n + 1, 0);        for (const auto&amp; e : edges) &#123;            ++degree[e[0]];            ++degree[e[1]];        &#125;        for (int i = 0; i &lt;= n; ++i) &#123;            if (degree[i] == n - 1) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n当然，本题也有时间和空间复杂度 O(1)的解法。比如，前2个边的共同节点即为中心节点。\n 1792. Maximum Average Pass Ratio\n贪心 + 优先队列。\n每个聪明学生都优先被加入到可以使得通过率增加最多的班级。\n用优先队列维护这种贪心思想。pair&lt;double, int&gt; 表示 增加的通过率 和 对应的班级编号。\n具体贪心正确性的证明可参考零神的题解.\nclass Solution &#123;    double div(const double a, const double b) &#123;        return a / b;    &#125;public:    double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) &#123;        using pii = pair&lt;double, int&gt;;        const int n = classes.size();        priority_queue&lt;pii&gt; pq;        auto change = [&amp;](const int i, const int more) -&gt; double &#123;            double next = div(classes[i][0] + more, classes[i][1] + more);            double now = div(classes[i][0], classes[i][1]);            return next - now;        &#125;;        double ans = 0;                for (int i = 0; i &lt; n; ++i) &#123;            pq.push(&#123;change(i, 1), i&#125;);            ans += div(classes[i][0], classes[i][1]);        &#125;                        for (int i = 0; i &lt; extraStudents; ++i) &#123;            auto [c, index] = pq.top();            pq.pop();            ans += c;            classes[index][0] += 1;            classes[index][1] += 1;            pq.push(&#123;change(index, 1), index&#125;);        &#125;                return div(ans, n);    &#125;&#125;;\n时间复杂度: O(n * log n),\n空间复杂度: O(n).\n 1793. Maximum Score of a Good Subarray\n根据数据规模，解法的时间复杂度很可能是O(N)的双指针 或是 O(N log N)的最优化问题转判定问题的二分.\n再看i 和 j 的变化趋势，基本可以判定是采用双指针解法。两边看谁变的更大，就变它。同时，还需维护单调减的性质，即略过那些会变大的数。\n在比赛中我的实现是，先用单调减性计算出变化的位置：construct.\n再在变化位置上移动双指针。\nclass Solution &#123;    using pii = pair&lt;int, int&gt;;    template &lt;typename T&gt;    vector&lt;pii&gt; construct(T begin, T end) &#123;        vector&lt;pii&gt; ans;        int currentMin = *begin;        for (auto it = next(begin); it != end; ++it) &#123;            if (*it &lt; currentMin) &#123;                ans.push_back(&#123;currentMin, distance(begin, it)&#125;);                currentMin = *it;            &#125;        &#125;        ans.push_back(&#123;currentMin, distance(begin, end)&#125;);        return ans;    &#125;public:    int maximumScore(vector&lt;int&gt;&amp; nums, int k) &#123;        const int n = nums.size();        auto right = construct(nums.begin() + k, nums.end());        auto left = construct(nums.rbegin() + n - k - 1, nums.rend());        int l = 0, r = 0;        int ans = min(left[l].first, right[r].first) * (left[l].second + right[r].second - 1);        while (l + 1 &lt; left.size() || r + 1 &lt; right.size()) &#123;            if (l + 1 &lt; left.size() &amp;&amp; r + 1 &lt; right.size()) &#123;                if (left[l + 1].first &gt; right[r + 1].first) &#123;                    ++l;                &#125; else &#123;                    ++r;                &#125;            &#125; else if (l + 1 &lt; left.size()) &#123;                ++l;            &#125; else &#123;                ++r;            &#125;            ans = max(ans, min(left[l].first, right[r].first) * (left[l].second + right[r].second - 1));        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(nums.size()),\n空间复杂度: O(nums[i]) = O(2 * 10^4).\n其实，我对单调递减construct的函数实现是多余的。这种单调递减完全可以再双指针移动的过程中实现，此时，可以将空间复杂度降低到O(1).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 233","url":"/2021/03/25/LeetCode-weekly-contest-233/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (7)\n\n\n\n\n923 / 12037\nYoungForest\n13\n1:13:09\n0:29:59\n0:50:24\n1:13:09\nnull\n\n\n\n周末，整整耽误了3场比赛。\n双周赛没参加，周赛迟到半小时，紧接着参加KickStart，人已经废了。\n以后打比赛还是要养精蓄锐，好好打才行。\n第四题我最后其实是有思路的，无奈时间不够了。之前做过类似用Trie处理异或问题的题目，印象还挺深刻的。\n\n 1800. Maximum Ascending Subarray Sum\n签到题。2个变量分别记录当前符合递增条件的累加值和上一个元素的值，更新最大累加值。\nclass Solution &#123;public:    int maxAscendingSum(vector&lt;int&gt;&amp; nums) &#123;        int ans = 1;        int last = 0;        int current = 0;        for (int i : nums) &#123;            if (i &gt; last) &#123;                current += i;            &#125; else &#123;                current = i;            &#125;            ans = max(ans, current);            last = i;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1801. Number of Orders in the Backlog\n用TreeMap维护price和数量的 key, value. 按照题意进行更新即可。\ntemplate &lt;typename A, typename B&gt;ostream&amp; operator &lt;&lt;(ostream&amp; out, const pair&lt;A, B&gt;&amp; a) &#123;  out &lt;&lt; &quot;(&quot; &lt;&lt; a.first &lt;&lt; &quot;,&quot; &lt;&lt; a.second &lt;&lt; &quot;)&quot;;  return out;&#125;template &lt;typename U, typename T, class Cmp&gt;ostream&amp; operator &lt;&lt;(ostream&amp; out, const map&lt;U, T, Cmp&gt;&amp; a) &#123;  out &lt;&lt; &quot;&#123;&quot;; bool first = true;  for (auto&amp; p : a) &#123; out &lt;&lt; (first ? &quot;&quot; : &quot;, &quot;); out &lt;&lt; p.first &lt;&lt; &quot;:&quot; &lt;&lt; p.second; first = 0;&#125; out &lt;&lt; &quot;&#125;&quot;;  return out;&#125;class Solution &#123;    using ll = long long;    const int MOD = 1e9 + 7;public:    int getNumberOfBacklogOrders(vector&lt;vector&lt;int&gt;&gt;&amp; orders) &#123;        // 0 buy 1 sell        map&lt;int, ll&gt; buy, sell;        for (const auto &amp; v : orders) &#123;            int price = v[0], amount = v[1];            if (v[2] == 0) &#123;                // buy                for (auto&amp; p : sell) &#123;                    if (amount &lt;= 0 || p.first &gt; price) break;                    if (p.second &gt;= amount) &#123;                        p.second -= amount;                        amount = 0;                    &#125; else &#123;                        amount -= p.second;                        p.second = 0;                    &#125;                &#125;                while (!sell.empty() &amp;&amp; sell.begin()-&gt;second == 0) &#123;                    sell.erase(sell.begin());                &#125;                if (amount &gt; 0) &#123;                    buy[price] += amount;                &#125;            &#125; else &#123;                // sell                for (auto it = buy.rbegin(); it != buy.rend(); ++it) &#123;                    auto&amp; p = *it;                    if (amount &lt;= 0 || p.first &lt; price) break;                    if (p.second &gt;= amount) &#123;                        p.second -= amount;                        amount = 0;                    &#125; else &#123;                        amount -= p.second;                        p.second = 0;                    &#125;                &#125;                while (!buy.empty() &amp;&amp; buy.rbegin()-&gt;second == 0) &#123;                    buy.erase(prev(buy.end()));                &#125;                if (amount &gt; 0) &#123;                    sell[price] += amount;                &#125;            &#125;        &#125;        ll ans = 0;        // cout &lt;&lt; buy &lt;&lt; endl;        // cout &lt;&lt; sell &lt;&lt; endl;        for (const auto&amp; p : buy) &#123;            ans = (ans + p.second) % MOD;        &#125;        for (const auto&amp; p : sell) &#123;            ans = (ans + p.second) % MOD;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(orders.length * log orders.length),\n空间复杂度: o(orders.length).\n 1802. Maximum Value at a Given Index in a Bounded Array\n二分搜索。将最优化问题转化成判定问题。\n限定最大值后，使用等差数列求和计算总和。\nclass Solution &#123;    using ll = long long;public:    int maxValue(int n, int index, int maxSum) &#123;        // peek, peek - 1, ..., 1        // Sn=n*a1+n(n-1)d/2        // Sn=n(a1+an)/2        auto oneSide = [&amp;](const ll peek, const ll index) -&gt; ll &#123;            if (index + 1 &gt;= peek) &#123;                return ((peek) * (peek + 1) / 2) + index + 1 - peek;            &#125; else &#123;                return (index + 1) * peek + (index + 1) * (index) * (-1) / 2;            &#125;        &#125;;        // 0 1 2 3 4 5        // n = 6        // index = 2        auto sumOf = [&amp;](const ll peek) -&gt; ll &#123;            // cout &lt;&lt; &quot;oneSide &quot; &lt;&lt; oneSide(peek, index) &lt;&lt; &quot; &quot; &lt;&lt; oneSide(peek, n - index - 1) &lt;&lt; endl;            return oneSide(peek, index) + oneSide(peek, n - index - 1) - peek;        &#125;;        // first true        auto binary = [&amp;](ll lo, ll hi, function&lt;bool(const ll)&gt; predicate) -&gt; ll &#123;            while (lo &lt; hi) &#123;                ll mid = lo + (hi - lo) / 2;                if (predicate(mid)) &#123;                    hi = mid;                &#125; else &#123;                    lo = mid + 1;                &#125;            &#125;            return lo;        &#125;;        // f f f t t t        // cout &lt;&lt; sumOf(3) &lt;&lt; &quot; &quot;&lt;&lt; sumOf(2) &lt;&lt; &quot; &quot; &lt;&lt; sumOf(1) &lt;&lt; endl;        return binary(1, 1e9 + 7, [&amp;](const ll x) -&gt; bool &#123;            return sumOf(x) &gt; maxSum;        &#125;) - 1;    &#125;&#125;;\n时间复杂度: O(log maxSum),\n空间复杂度: O(1).\n 1803. Count Pairs With XOR in a Range\n类似的题目 LC 421 1707.\n使用Trie以解决XOR异或问题。时间复杂度一般为 O(31 * N).\nclass Solution &#123;    struct Trie &#123;        array&lt;Trie*, 2&gt; children;        int count = 0;    &#125;;    const int MAX_BIT = 16;public:    int countPairs(vector&lt;int&gt;&amp; nums, int low, int high) &#123;        const int n = nums.size();        Trie *root = new Trie();        for (int i : nums) &#123;            auto current = root;            for (int k = MAX_BIT; k &gt;= 0; --k) &#123;                if (current-&gt;children[(i &gt;&gt; k) &amp; 1] == nullptr) &#123;                    current-&gt;children[(i &gt;&gt; k) &amp; 1] = new Trie();                &#125;                current = current-&gt;children[(i &gt;&gt; k) &amp; 1];                current-&gt;count += 1;            &#125;        &#125;        auto countLessThan = [&amp;](const int target) -&gt; int &#123;            int ans = 0;            for (int i : nums) &#123;                auto current = root;                for (int k = MAX_BIT; k &gt;= 0 &amp;&amp; current; --k) &#123;                    const int x = (i &gt;&gt; k) &amp; 1;                    const int y = (target &gt;&gt; k) &amp; 1;                    if (y == 1) &#123;                        if (current-&gt;children[x]) &#123;                            ans += current-&gt;children[x]-&gt;count;     // take all xor = zero                        &#125;                        current = current-&gt;children[1 - x];                    &#125; else &#123;                        current = current-&gt;children[x];                    &#125;                &#125;            &#125;            return ans;        &#125;;        return (countLessThan(high + 1) - countLessThan(low)) / 2;            &#125;&#125;;\n时间复杂度: O(16 N),\n空间复杂度: O(16 N).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 234","url":"/2021/03/28/LeetCode-weekly-contest-234/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n672 / 12421\nYoungForest\n19\n1:19:08\n0:12:04  2\n0:23:51\n0:29:26\n0:54:08  3\n\n\n\n又要打卡了，已经连续5周残酷打卡了。而且确实自己本次做题没觉得多简单，WA5次，心态爆炸，但是排名却不理想。感觉还是LeetCode越来越卷了。\n\n 1805. Number of Different Integers in a String\n本题其实用Python做会好很多，实现起来更快。Python对字符串和大整数的优势还是无可比拟的。\n我还是坚持用C++ 完成，各种字符串不熟悉和不方便的操作。WA了2发。\nclass Solution &#123;public:    int numDifferentIntegers(string word) &#123;        for (char&amp; c : word) &#123;            if (!isdigit(c)) &#123;                c = &#x27; &#x27;;            &#125;        &#125;        while (!word.empty() &amp;&amp; word.back() == &#x27; &#x27;) &#123;            word.pop_back();        &#125;        if (word.empty()) return 0;        std::istringstream is(word);        unordered_set&lt;string&gt; ans;        while (is)        &#123;            string s;            is &gt;&gt; s;            reverse(s.begin(), s.end());            while (s.size() &gt; 1 &amp;&amp; s.back() == &#x27;0&#x27;) &#123;                s.pop_back();            &#125;            // cout &lt;&lt; &quot;xx : &quot; &lt;&lt; s &lt;&lt; endl;            if (s.empty()) continue;            ans.insert(s);        &#125;        return ans.size();    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1806. Minimum Number of Operations to Reinitialize a Permutation\n本题我是倒着思考的，\n操作的拟操作是 技术位置到后半段，偶数位置到前半段。\n而且观察变化的过程，只需要关注一个数，如果他回到原位置，剩下所有的数都会回到原位置。\nclass Solution &#123;    // operation: odd to half second, even to half first    // [0 1 2 3 4 5] 4    // [0 2 4 1 3 5] 3    // [0 4 3 2 1 5] 2    // [0 3 1 4 2 5] 1    // [0 1 2 3 4 5] 0    public:    int reinitializePermutation(int n) &#123;        int ans = 0;        int index1 = 1;        do &#123;            if (index1 % 2 == 1) &#123;                index1 = n / 2 + index1 / 2;            &#125; else &#123;                index1 = index1 / 2;            &#125;            ++ans;        &#125; while (index1 != 1);        return ans;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1807. Evaluate the Bracket Pairs of a String\n说实话，本题作为第3题，并没有相应的难度。完全可以作为签到题。\n直接做即可。\n知识点：字符串处理 + 字典/Map.\nclass Solution &#123;public:    string evaluate(string s, vector&lt;vector&lt;string&gt;&gt;&amp; knowledge) &#123;        unordered_map&lt;string, string&gt; m;        for (const auto&amp; v : knowledge) &#123;            m[v[0]] = v[1];        &#125;        string word;        bool left = false;        string ans;        for (char c : s) &#123;            if (c == &#x27;(&#x27;) &#123;                left = true;            &#125; else if (c == &#x27;)&#x27;) &#123;                left = false;                auto it = m.find(word);                if (it == m.end()) &#123;                    ans.push_back(&#x27;?&#x27;);                &#125; else &#123;                    ans.append(it-&gt;second);                &#125;                word.clear();            &#125; else &#123;                if (left) &#123;                    word.push_back(c);                &#125; else &#123;                    ans.push_back(c);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(s.size() + knowledge.size() * (knowledge[i][0].size() + knowledge[i][1].size())),\n空间复杂度: O(s.size() + knowledge.size() * (knowledge[i][0].size() + knowledge[i][1].size())).\n 1808. Maximize Number of Nice Divisors\n问题可以转换成 确定和，最大化乘积。\nsum 确定是primeFactors。然后好因子的数目就是乘积，也就是题目里最大化的目标。\n因为你观察好因子其实是每个质因数数目的乘积。\n在Google上搜索fix sum max multiplication，第3条就有Geekforgeek的一个类似问题Breaking an Integer to get Maximum Product. 其实LeetCode上也有原题343.\n我试图照搬它的代码，然而有2个地方不同：\n\ngeekforgeek上必须break，不能作为一个整体。而本题是可以不break的。这个涉及到特殊case, 即primeFactors = 2 或 3时，应改为返回 n.\ngeekforgeek上的代码采用一个for loop * 3. 时间复杂度是 O(n / 3). 在本题会超时。我自己写了pow以更快的方式*3，时间复杂度是 O(log n)。其实是LeetCode 50 Pow(x, n).\n\nclass Solution &#123;    using ll = long long;    const ll MOD = 1e9 + 7;    // https://www.geeksforgeeks.org/breaking-integer-to-get-maximum-product/    /* The main function that returns the max possible product */    ll mypow(ll a, ll b) &#123;        // a ^ b        if (b == 0) &#123;            return 1;        &#125; else if (b % 2 == 1) &#123;            return (mypow(a, b - 1) * a) % MOD;        &#125; else &#123;            auto x = mypow(a, b/2);            return (x * x) % MOD;        &#125;    &#125;    int maxProd(ll n)    &#123;       // n equals to 2 or 3 must be handled explicitly       if (n == 2 || n == 3) return n;       // Keep removing parts of size 3 while n is greater than 4       ll res = 1;       // while (n &gt; 4)       // &#123;       //     n -= 3;       //     res = (res * 3) % MOD; // Keep multiplying 3 to res       // &#125;        // 4 0        // 5 1        // 6 1        // 7 1        // 8 2        if (n &gt;= 5) &#123;            const int step = ((n - 5) / 3 + 1);            res = mypow(3, step);            n -= step * 3;        &#125;       return (n * res) % MOD; // The last part multiplied by previous parts    &#125;public:    int maxNiceDivisors(int primeFactors) &#123;        return maxProd(primeFactors);    &#125;&#125;;\n时间复杂度: O(log n),\n空间复杂度: O(1).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 235","url":"/2021/04/05/LeetCode-weekly-contest-235/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n889 / 11443\nYoungForest\n12\n0:27:18\n0:01:52\n0:07:49\n0:27:18\nnull\n\n\n\n 1816. Truncate Sentence\n签到题。再次强调一遍，字符串问题适合用Python做，真的只需要描述题目就可以了。\nclass Solution:    def truncateSentence(self, s: str, k: int) -&gt; str:        return &#x27; &#x27;.join(s.split(&#x27; &#x27;)[:k])\n时间复杂度: O(s.length),\n空间复杂度: O(s.length).\n 1817. Finding the Users Active Minutes\n暴力。以ID为统计每个用户的动作时间序列，然后排序去重。\nclass Solution &#123;public:    vector&lt;int&gt; findingUsersActiveMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; logs, int k) &#123;        // brute-force:        // logs.length + k        unordered_map&lt;int, vector&lt;int&gt;&gt; actions; // userId -&gt; actionMinute        for (const auto&amp; v : logs) &#123;            actions[v[0]].push_back(v[1]);        &#125;        vector&lt;int&gt; ans(k, 0);        for (auto&amp; p : actions) &#123;            auto&amp; v = p.second;            sort(v.begin(), v.end());            auto it = unique(v.begin(), v.end());            const int d = distance(v.begin(), it);            if (d &gt;= 1 &amp;&amp; d &lt;= k) ++ans[d - 1];        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(logs.length * log(logs.length) + k),\n空间复杂度: O(logs.length + k).\n 1818. Minimum Absolute Sum Difference\n贪心 + 二分搜索。 Greedy + Binary Search.\n对于每一个位置，试图换它以达到最小Diff. 使用二分搜索找到最近的可选值。\nclass Solution &#123;    using ll = long long;    ll MOD = 1e9 + 7;public:    int minAbsoluteSumDiff(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        const int n = nums1.size();        ll sumNums = 0;        for (int i = 0; i &lt; n; ++i) &#123;            sumNums += abs(nums1[i] - nums2[i]);        &#125;        ll ans = sumNums;        auto sortNums1 = nums1;        sort(sortNums1.begin(), sortNums1.end());        for (int i = 0; i &lt; n; ++i) &#123;            auto it = lower_bound(sortNums1.begin(), sortNums1.end(), nums2[i]);            if (it != sortNums1.end()) &#123;                ans = min(ans, sumNums - static_cast&lt;ll&gt;(abs(nums1[i] - nums2[i])) + static_cast&lt;ll&gt;(abs(*it - nums2[i])));            &#125;            if (it != sortNums1.begin()) &#123;                it = prev(it);                ans = min(ans, sumNums - static_cast&lt;ll&gt;(abs(nums1[i] - nums2[i])) + static_cast&lt;ll&gt;(abs(*it - nums2[i])));            &#125;        &#125;                return ans % MOD;    &#125;&#125;;\n时间复杂度: O(nums.length * log nums.length),\n空间复杂度: O(nums.length).\n 1819. Number of Different Subsequences GCDs\n比赛时TLE，没想出高效的算法。\n暴力DP，维护当前数组的子数组的所有子序列的GCD在一个Set中。\n时间复杂度: O(N ^ 2), N = nums.length,\n空间复杂度: O(max(nums[i])). gcd的数量，最多有这么多种可能。\nclass Solution &#123;public:    int countDifferentSubsequenceGCDs(vector&lt;int&gt;&amp; nums) &#123;        unordered_set&lt;int&gt; dp;        for (int x : nums) &#123;            unordered_set&lt;int&gt; newDp;            newDp.insert(x);            for (int a : dp) &#123;                newDp.insert(__gcd(a, x));            &#125;            for (int x : newDp) &#123;                dp.insert(x);            &#125;        &#125;        return dp.size();    &#125;&#125;;\n其他 GCD类似的题目，大家感兴趣可以一做：\n\nhttps://atcoder.jp/contests/abc191/tasks/abc191_f\n\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 236","url":"/2021/04/11/LeetCode-weekly-contest-236/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n1513 / 12115\nYoungForest\n12\n0:45:18\n0:02:57\n0:08:59\n0:40:18  1\nnull\n\n\n\n 1822. Sign of the Product of an Array\n签到题。多少负数，是否有0。\nclass Solution:    def arraySign(self, nums: List[int]) -&gt; int:        x = 1        for i in nums:            x *= i        if x &gt; 0:            return 1        elif x == 0:            return 0        else:            return -1\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1823. Find the Winner of the Circular Game\n经典的约瑟夫环问题。随便Google了一个: 约瑟夫环——公式法。\nclass Solution &#123;    int cir(int n,int m)    &#123;        int p=0;        for(int i=2;i&lt;=n;i++)        &#123;            p=(p+m)%i;        &#125;        return p+1;    &#125;public:    int findTheWinner(int n, int k) &#123;        return cir(n, k);    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1824. Minimum Sideway Jumps\n动态规划。\ndp[i][j] 表示从i的位置，第j个lane 到末尾需要的最小side jumps.\n需要注意的是 本题N &lt;= 5 * 10^5，Python TOP-BOTTOM的DP会爆栈。\n因此比赛时Runtime Error一次，加了\nsys.setrecursionlimit(110000)仍然不行，遂改成了Bottom-Up 的DP。\nclass Solution:    def minSideJumps(self, obstacles: List[int]) -&gt; int:        n = len(obstacles) - 1        dp = [[float(&#x27;inf&#x27;)] * 4 for i in range(n + 1)]        dp[n][1] = dp[n][2] = dp[n][3] = 0        for i in range(n - 1, -1, -1):            for j in (1, 2, 3):                if obstacles[i+1] != j:                    dp[i][j] = min(dp[i][j], dp[i+1][j])                for nj in (1, 2, 3):                    if j == nj: continue                    if obstacles[i] != nj and obstacles[i+1] != nj:                        dp[i][j] = min(dp[i][j], dp[i+1][nj] + 1)        return dp[0][2]\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1825. Finding MK Average\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 237","url":"/2021/04/18/LeetCode-weekly-contest-237/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n345 / 11446\nYoungForest\n18\n0:40:04\n0:03:21\n0:05:10\n0:25:30\n0:35:04  1\n\n\n\n久违的四题并进入前500名。终于可以免打卡了。\n已经连续打卡7周了，快要遭不住了呀。最近LeetCode难度提升不小，大佬入场也很多。要同时达到4题和前500属实不易。\n今天手速也算正常发挥.\n 1832. Check if the Sentence Is Pangram\n签到题。\n统计每个单词出现的次数，判断是否都大于0.\nclass Solution &#123;public:    bool checkIfPangram(string sentence) &#123;        vector&lt;int&gt; cnt(26, 0);        for (char c : sentence) &#123;            ++cnt[c - &#x27;a&#x27;];        &#125;        for (int i : cnt) &#123;            if (i == 0) return false;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1833. Maximum Ice Cream Bars\n贪心。优先买便宜的。\nclass Solution &#123;public:    int maxIceCream(vector&lt;int&gt;&amp; costs, int coins) &#123;        sort(begin(costs), end(costs));        int ans = 0;        for (int i : costs) &#123;            if (coins &gt;= i) &#123;                ++ans;                coins -= i;            &#125; else break;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(costs.length * log cost.length),\n空间复杂度: O(log cost.length).\n 1834. Single-Threaded CPU\n使用优先队列选择执行任务，根据题目要求，需要按processTime, index的顺序取。\n另外，任务还需要按照enqueueTime排序，加入到等待的优先队列中。\n此题C++是有坑的。\ntasks.length == n\n1 &lt;= n &lt;= 10^5\n1 &lt;= enqueueTimei, processingTimei &lt;= 10^9,\n因此，时间最后会超出int范围，需要使用long long解决。\n当然, 选择Python就没这个问题了。\nclass Solution &#123;    using ll = long long;public:    vector&lt;int&gt; getOrder(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) &#123;        using pii = pair&lt;ll, int&gt;; // processTime, index        // events        using tii = tuple&lt;ll, ll, ll&gt;;  // enqueueTime, processTime, index        vector&lt;tii&gt; events;        events.reserve(tasks.size());        for (int i = 0; i &lt; tasks.size(); ++i) &#123;            events.push_back(&#123;tasks[i][0], tasks[i][1], i&#125;);        &#125;        sort(begin(events), end(events));        vector&lt;int&gt; ans;        ans.reserve(tasks.size());        ll now = 0;        int i = 0;        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; wait;         while (i &lt; events.size() || !wait.empty()) &#123;            while (i &lt; events.size() &amp;&amp; get&lt;0&gt;(events[i]) &lt;= now) &#123;                wait.push(&#123;get&lt;1&gt;(events[i]), get&lt;2&gt;(events[i])&#125;);                ++i;            &#125;            if (wait.empty()) &#123;                wait.push(&#123;get&lt;1&gt;(events[i]), get&lt;2&gt;(events[i])&#125;);                now = get&lt;0&gt;(events[i]);                ++i;            &#125;            auto run = wait.top();            wait.pop();            ans.push_back(run.second);            now += run.first;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N), N = tasks.length,\n空间复杂度: O(N).\n 1835. Find XOR Sum of All Pairs Bitwise AND\n问题咋一看无从下手，只想到暴力方法，枚举所有的pair，时间复杂度显然不够：arr1.length * arr2.length = 10^10。\n但其实细想，对于这种位操作来说，每一位之间都是相互独立的。我们可以把问题简化成针对特定位的。只关注一个位的话，解法就呼之欲出了。\n我们只需要统计arr1和arr2中0 和 1的数目。\n假设arr1有x个0、y个1，arr2有a个0，b个1。\nAND 为 1的数目即为b*y，为0的数目为ax + ay + bx。\n再异或的话，只需要判断1的个数，即b*y，是不是奇数就OK了。\n这里C++又有一个坑，因为arr.length最大为 10^ 5, b*y是可以int溢出的。LeetCode因为编译器开了溢出检查，因此会报类似下面的错误。我也因此罚时一次。\n解决方案是要么用long long，要么 分别判断 (b % 2 == 1) &amp;&amp; (y % 2 == 1).\n\nLine 24: Char 26: runtime error: signed integer overflow: 100000 * 100000 cannot be represented in type ‘int’ (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:33:26\n\nclass Solution &#123;    pair&lt;int, int&gt; extract(const vector&lt;int&gt;&amp; arr, const int i) &#123;        int x = 0, y = 0;        for (int num : arr) &#123;            if (num &amp; (1 &lt;&lt; i)) ++y;            else ++x;        &#125;        return &#123;x, y&#125;;    &#125;public:    int getXORSum(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123;        // brute-force: arr1.length * arr2.length = 10^10        // smart: 32 * (arr1.length + arr2.length)        // x0 y1        // a0 b1        // AND 0 = (ax + ay + bx)        // AND 1 = (by)        // if AND 1 % 2 == 1:        //     k += (1 &lt;&lt; i)        int ans = 0;        for (int i = 0; i &lt; 31; ++i) &#123;            auto [x, y] = extract(arr1, i);            auto [a, b] = extract(arr2, i);            if ((b % 2 == 1) &amp;&amp; (y % 2 == 1)) &#123;                ans += (1 &lt;&lt; i);            &#125;        &#125;        return ans;    &#125;&#125;;","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 238","url":"/2021/04/25/LeetCode-weekly-contest-238/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n383 / 11635\nYoungForest\n18\n1:53:50\n0:01:05\n0:13:02\n0:20:59\n1:28:50 5\n\n\n\n\n 1837. Sum of Digits in Base K\n签到题。10进制转6进制。\nclass Solution:    def sumBase(self, n: int, k: int) -&gt; int:        ans = 0        while n &gt; 0:            ans += n % k            n //= k        return ans\n时间复杂度: O(log_k n),\n空间复杂度: O(1).\n 1838. Frequency of the Most Frequent Element\n本周周赛Q2 Q3都是滑动窗口题。事实上，从零宝大数据来看，Q2难度还是比Q3大的。\n首先想出暴力解法，尝试每个元素，试图把比它小的元素增至它，看最多有多少个。\n时间复杂度: O(N ^ 2), 估计会TLE。\nQ2 通常情况下还是可以暴力解的，虽然本题不可以。\n在暴力解的基础上，尝试优化。观察到，“试图把比它小的元素增至它”这个操作或许可以在O(1)的情况下完成，而不需要暴力尝试每个比它小的元素。因为那些元素已经被升至上一个尝试元素了。\n先排序。然后，从小到大尝试把所有值都增至nums[r]。\n窗口[l:r]维护这些被增至目标值nums[r]的元素。\n当r右移时，把窗口里的元素都从上个值更新到nums[r]。\n如果用了过多的增操作，则增加l，释放增操作。\n取窗口最宽值作为答案。\nclass Solution:    def maxFrequency(self, nums: List[int], k: int) -&gt; int:        # brute force: N ^ 2        # for each element, try to make it most frequency        # sliding window        nums.sort()        ans = 0        l = 0        for r in range(len(nums)):            if r &gt; 0:                # make all increment to nums[r]                k -= (nums[r] - nums[r-1]) * (r - l)            while k &lt; 0:                k += nums[r] - nums[l]                l += 1            ans = max(r - l + 1, ans)                    return ans\n时间复杂度: O(n log n + n),\n空间复杂度: O(1).\n 1839. Longest Substring Of All Vowels in Order\n相比上题，本题更是明显的滑动窗口题。\n窗口[l:r]的不变量是字串递增。\nclass Solution:    def longestBeautifulSubstring(self, word: str) -&gt; int:        # brute force: N^3, enumerate all substring * check each substring        # sliding window: N        # at least once, incresing        l = 0        r = 0        n = len(word)        cnt = [0] * 26        def check():            for i in &#x27;aeiou&#x27;:                if cnt[ord(i) - ord(&#x27;a&#x27;)] &lt;= 0:                    return False            return True        ans = 0        while r &lt; n:            cnt[ord(word[r]) - ord(&#x27;a&#x27;)] += 1            if r &gt; 0 and word[r] &lt; word[r-1]:                while l &lt; r:                    cnt[ord(word[l]) - ord(&#x27;a&#x27;)] -= 1                    l += 1            if check():                ans = max(ans, r - l + 1)            r += 1        return ans\n时间复杂度: O(word.length),\n空间复杂度: O(1).\n 1840. Maximum Building Height\n还是挺难的一道Hard题。\n相邻差值为1. 一开始想到用BFS，从高度限制小的开始遍历，更新周围的高度。也算是经典算法。\n然后TLE后，才注意到n &lt;= 10^9这个限制。O(N)的算法也肯定超时。\n注意restrictions.length &lt;= 10^5这一限制，大概率是要从这里下手的。\n因此，BFS时只更新被限制的块，块中间再用二分搜索找最高点（其实可以用O(1)的数学解法的，比赛时没好想法就二分暴力了）。\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int maxBuilding(int n, vector&lt;vector&lt;int&gt;&gt;&amp; restrictions) &#123;        map&lt;int, int&gt; rtxMap;        unordered_map&lt;int, bool&gt; seen;        seen.reserve(restrictions.size() + 2);        rtxMap[0] = 0;        rtxMap[n-1] = INF;        seen[0] = false;        seen[n-1] = false;        // bfs: O(N), TLE        using pii = pair&lt;int, int&gt;;        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; pq;        pq.push(&#123;0, 0&#125;);        for (const auto&amp; v : restrictions) &#123;            pq.push(&#123;v[1], v[0] - 1&#125;);            rtxMap[v[0] - 1] = v[1];            seen[v[0] - 1] = false;        &#125;        int ans = 0;        while (!pq.empty()) &#123;            auto [height, idx] = pq.top();            // cout &lt;&lt; height &lt;&lt; &quot;, &quot; &lt;&lt; idx &lt;&lt; endl;            pq.pop();            if (seen[idx]) continue;            ans = max(ans, height);            seen[idx] = true;            for (const int j : &#123;-1, 1&#125;) &#123;                const int next = idx + j;                if (next &gt;= n || next &lt; 0 || seen[next]) continue;                if (j == 1) &#123;                    auto it = rtxMap.lower_bound(next);                    if (it != rtxMap.end()) &#123;                        const int x = it-&gt;first;                        it-&gt;second = min(it-&gt;second, height + x - idx);                        pq.push(&#123;it-&gt;second, x&#125;);                    &#125;                &#125; else &#123;                    auto it = rtxMap.lower_bound(idx);                    // 2 5                    // next = 4                    if (it != rtxMap.begin()) &#123;                        --it;                        const int x = it-&gt;first;                        it-&gt;second = min(it-&gt;second, height + idx - x);                        pq.push(&#123;it-&gt;second, x&#125;);                    &#125;                &#125;            &#125;        &#125;                for (auto it = rtxMap.begin(); next(it) != rtxMap.end(); ++it) &#123;            const int leftIdx = it-&gt;first, leftHeight = it-&gt;second;            const int rightIdx = next(it)-&gt;first, rightHeight = next(it)-&gt;second;            if (leftIdx + 1 == rightIdx) continue;            // cout &lt;&lt; leftIdx &lt;&lt; &quot;, &quot; &lt;&lt; leftHeight &lt;&lt; &quot;, &quot; &lt;&lt; rightIdx &lt;&lt; &quot;, &quot; &lt;&lt; rightHeight &lt;&lt; endl;            int lo = min(leftHeight, rightHeight), hi = min(leftHeight + rightIdx - leftIdx, rightHeight + rightIdx - leftIdx);            while (lo &lt; hi) &#123;                const int mid = lo + (hi - lo) / 2;                bool deter = false;                if (mid - leftHeight &lt; rightIdx - leftIdx and mid - rightHeight &lt; rightIdx - leftIdx and mid - leftHeight + mid - rightHeight - 1 &lt; rightIdx - leftIdx) deter = true;                if (deter) &#123;                    lo = mid + 1;                &#125; else &#123;                    hi = mid;                &#125;                // t, t, t, f, f            &#125;            ans = max(ans, lo - 1);        &#125;        return ans;    &#125;&#125;;\nm = restrictions.length\n时间复杂度: O(m log m),\n空间复杂度: O(m).\n零神题解里有2次扫描的算法。虽然时间复杂度是一样的，但实现比较简单，常数上会更好些。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 239","url":"/2021/05/02/LeetCode-weekly-contest-239/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n78 / 10870\nYoungForest\n18\n0:52:57\n0:02:22\n0:09:37\n0:27:13\n0:47:57  1\n\n\n\n连续3周免打卡了，昨晚双周赛也做的不错手速场。\n最近的周赛确实难度有所降低，看来我还是适合做简单题目。Hard+还是不大行。\n\n 1848. Minimum Distance to the Target Element\n签到题。\nOne pass，记录最优答案。\nclass Solution &#123;    const int INF = 0x3f3f3f3f;public:    int getMinDistance(vector&lt;int&gt;&amp; nums, int target, int start) &#123;        int ans = -INF;        for (int i = 0; i &lt; nums.size(); ++i) &#123;            if (nums[i] == target) &#123;                if (abs(i - start) &lt; abs(ans - start)) &#123;                    ans = i;                &#125;            &#125;        &#125;        return abs(ans - start);    &#125;&#125;;\n 1849. Splitting a String Into Descending Consecutive Values\nBacktracking, 搜索可能的分割点。\nclass Solution:    def splitString(self, s: str) -&gt; bool:        n = len(s)        if n &lt;= 1: return False        @cache        def dfs(i: int, last: int) -&gt; bool:            if i &gt;= n: return False            if i != 0:                final = int(s[i:])                if final &lt; last and last - final == 1:                    return True            for j in range(i + 1, n):                new = int(s[i:j])                if new &lt; last and (i == 0 or last - new == 1):                    if dfs(j, new): return True            return False        return dfs(0, float(&#x27;inf&#x27;))\n时间复杂度: O(N^2),\n空间复杂度: O(N).\n虽然我们使用了backtracking，看起来好想时间复杂度很高，O(N ^ N), 但其实在dfs中的for循环中，符合条件可以dfs到下一层的可能路径只有1条。\n参考这个题解的分析.\n 1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number\n首先，我们需要复习一下LC 31. Next Permutation. 学习一下求解下一个枚举排列的方法。幸运的是，C++ STL 里已经提供了std::next_permutation函数可以直接用，均摊时间复杂度为O(1).\n使用k次next_permutation找到the Kth Smallest Number\n后，只需要采用贪心的思路就可以找到最小交换次数。\n即发现一个不相等的位置，就在后面找到一个最近的相等的数，通过交换挪的当前位置。\nclass Solution &#123;public:    int getMinSwaps(string num, int k) &#123;        auto s = num;        while(std::next_permutation(s.begin(), s.end()) &amp;&amp; k - 1 &gt; 0) &#123;            // std::cout &lt;&lt; s &lt;&lt; &#x27;\\n&#x27;;            --k;        &#125;        const int n = num.size();        int ans = 0;        for (int j = 0; j &lt; n; ++j) &#123;            if (num[j] == s[j]) continue;            // find next digit and swap it here            int i = j + 1;            for (; i &lt; n and num[i] != s[j]; ++i);            // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;            ans += i - j;            for (int x = i; x &gt; j; --x) &#123;                swap(num[x], num[x - 1]);            &#125;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(k + n^2),\n空间复杂度: O(n).\n 1851. Minimum Interval to Include Each Query\n本题和昨晚双周赛的最后一题有些像，需要用到离线计算的技术。\nintervals按照size从小到大排序，没新增一个interval，更新可以覆盖到的query的答案。\n这里需要用multimap维护待解决的queries。因为支持二分查找和删除，以及重复的query.\nclass Solution &#123;public:    vector&lt;int&gt; minInterval(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; queries) &#123;        // brute-foce: queries.length * intervals.length        // smarter: queries.length * log + intervals.length * log        const int n = intervals.size(), m = queries.size();        // sort interval by size less&lt;&gt;, find new queries        vector&lt;int&gt; ans(m, -1);        multimap&lt;int, int&gt; indexQueries;        for (int i = 0; i &lt; m; ++i) &#123;            indexQueries.insert(&#123;queries[i], i&#125;);        &#125;        sort(intervals.begin(), intervals.end(), [](const auto&amp; lhs, const auto&amp; rhs) -&gt; bool &#123;            return lhs[1] - lhs[0] &lt; rhs[1] - rhs[0];        &#125;);        int size = 0;        for (const auto&amp; v : intervals) &#123;            size = v[1] - v[0] + 1;            auto left = indexQueries.lower_bound(v[0]);            auto right = indexQueries.upper_bound(v[1]);            for (auto it = left; it != right; ++it) &#123;                ans[it-&gt;second] = size;            &#125;            for (auto it = left; it != right;) &#123;                auto nit = next(it);                indexQueries.erase(it);                it = nit;            &#125;        &#125;        return ans;    &#125;&#125;;\nn = intervals.length, m = queries.length\n时间复杂度: O(n log n + m log m + n log m),\n空间复杂度: O(m).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 240","url":"/2021/05/09/LeetCode-weekly-contest-240/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n272 / 11577\nYoungForest\n18\n1:15:29\n0:04:46\n0:14:19\n0:47:06\n1:10:29  1\n\n\n\n这周五一假期+大论文查重。心情被大论文折麽的十分焦虑，再坚持2周，挺过答辩就好了。\n等过了答辩，让我干啥都行。\n前几周因为国服自己的rating太高，不敢打了，怕掉分。转战了美服，现在把美服也打到2350了。rating也过高了。之后打算再次转战国服，因为最近新一年的招聘迫近，国服赞助商礼物比较丰厚。虽然去年只有几次排名足够靠前，拿到奖品，但好歹有个奖励，有比较小的期望。\n\n 1854. Maximum Population Year\n签到题。暴力枚举每个可能的年份。\nclass Solution &#123;public:    int maximumPopulation(vector&lt;vector&lt;int&gt;&gt;&amp; logs) &#123;        map&lt;int, int&gt; cnt;        for (const auto&amp; v : logs) &#123;            for (int i = v[0]; i &lt; v[1]; ++i) &#123;                ++cnt[i];            &#125;        &#125;        int maxValue = 0;        int maxYear = -1;        for (const auto&amp; p : cnt) &#123;            if (p.second &gt; maxValue) &#123;                maxYear = p.first;                maxValue = p.second;            &#125;        &#125;        return maxYear;    &#125;&#125;;\n时间复杂度: O(logs.length * MAX(death_i - birth_i)) = O(100 * 100),\n空间复杂度: O(MAX(death_i - birth_i)).\n 1855. Maximum Distance Between a Pair of Values\nclass Solution &#123;public:    int maxDistance(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int ans = 0;        for (int i = 0; i &lt; nums1.size(); ++i) &#123;            auto it = upper_bound(nums2.begin() + i, nums2.end(), nums1[i], greater&lt;&gt;());            ans = max(ans, static_cast&lt;int&gt;(distance(nums2.begin() + i, prev(it))));        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(nums1.length * log nums2.length),\n空间复杂度: O(1).\n本题也可以用双指针做，i 指向nums1的位置，j 指向nums2的位置。\n向右遍历 i，更新j。不变量是 j &gt;= i &amp;&amp; nums[j] &lt; nums[i].\n时间复杂度是 O(nums1.length + nums2.length).\n代码如下：\nclass Solution &#123;public:    int maxDistance(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;        int ans = 0;        for (int i = 0, j = 0; i &lt; nums1.size(); ++i) &#123;            while (j &lt; nums2.size() &amp;&amp; (j &lt; i || nums2[j] &gt;= nums1[i])) ++j;            ans = max(ans, j - 1 - i);        &#125;        return ans;    &#125;&#125;;\n 1856. Maximum Subarray Min-Product\n类似BFS，从数值大的元素开始遍历，尝试合并左右区间。\n具体实现需要 维护区间左右边界、最小值、区间和。可以采用类似并查集的思路。\nclass Solution &#123;    using ll = long long;    const ll MOD = 1e9 + 7;    const int INF = 0x3f3f3f3f;public:    int maxSumMinProduct(vector&lt;int&gt;&amp; nums) &#123;        const int n = nums.size();        // iterate from max to min        vector&lt;ll&gt; s(n, 0);        vector&lt;int&gt; right(n, 0);        vector&lt;int&gt; left(n, 0);        vector&lt;int&gt; minV(n, INF);        multimap&lt;int, int, greater&lt;&gt;&gt; index;        for (int i = 0; i &lt; n; ++i) &#123;            index.insert(&#123;nums[i], i&#125;);            minV[i] = nums[i];            left[i] = i;            right[i] = i;            s[i] = nums[i];        &#125;        ll ans = 0;        for (const auto&amp; p : index) &#123;            const int i = p.second;            const ll minValue = p.first;            if (i &gt; 0 &amp;&amp; minV[i-1] &gt;= minValue) &#123;                left[i] = left[i-1];                s[i] += s[i-1];            &#125;            if (i + 1 &lt; n &amp;&amp; minV[i+1] &gt; minValue) &#123;                right[i] = right[i+1];                s[i] += s[i+1];            &#125;            minV[right[i]] = minValue;            minV[left[i]] = minValue;            right[left[i]] = right[i];            left[right[i]] = left[i];            s[left[i]] = s[i];            s[right[i]] = s[i];            ans = max(ans, s[i] * minValue);        &#125;        return ans % MOD;    &#125;&#125;;\n时间复杂度: O(n * log n),\n空间复杂度: O(n).\n赛后经残酷群友讨论，\n类似的题目有：\nLC 84. Largest Rectangle in Histogram. 区别在于 84 是 最小值*子数组长度。本题是 最小值*子数组和。\n 1857. Largest Color Value in a Directed Graph\n拓扑排序。同时 遍历到每一个节点时，更新能到它的路径中每种颜色最大的。\nclass Solution:    def largestPathValue(self, colors: str, edges: List[List[int]]) -&gt; int:        n = len(colors)        m = len(edges)        indegree = [0] * n        graph = defaultdict(list)        for e in edges:            indegree[e[1]] += 1            graph[e[0]].append(e[1])                    # topo sort        def dfs(root):            ans = [0] * 26            ans[ord(colors[root]) - ord(&#x27;a&#x27;)] += 1            for n in graph[root]:                if n in path: return None                x = dfs(n, path)                if x is None: return None                for i in range(26):                    ans[i] += x[i]            return ans        ans = -1        q = collections.deque()        seen = 0        cnt = [[0] * 26 for i in range (n)]        for i in range(n):            if indegree[i] == 0:                cnt[i][ord(colors[i]) - ord(&#x27;a&#x27;)] += 1                q.append(i)                seen += 1                ans = max(ans, max(cnt[i]))                        while q:            front = q.popleft()            for i in graph[front]:                for x in range(26):                    cnt[i][x] = max(cnt[i][x], cnt[front][x])                indegree[i] -= 1                if indegree[i] == 0:                    q.append(i)                    cnt[i][ord(colors[i]) - ord(&#x27;a&#x27;)] += 1                    ans = max(ans, max(cnt[i]))                    seen += 1                        if seen == n: return ans        else: return -1\n时间复杂度: O(n + m),\n空间复杂度: O(n + m).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 242","url":"/2021/05/23/LeetCode-weekly-contest-242/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n165 / 12400\nYoungForest\n18\n1:07:14\n0:03:22 🐞1\n0:16:01 🐞1\n0:27:41  🐞1\n0:52:14\n\n\n\n提前40min AK。虽然因为粗心大意，前三题每题WA一次，导致15min罚时，但好的一点是这周应该不用每天残酷打卡了。正好全力以赴，准备周三的硕士论文答辩。\n三年的硕士生涯全靠周三一天了，毕其功于一役，加油，Forest！\n 1869. Longer Contiguous Segments of Ones than Zeros\n签到题。统计连续字串的长度，更新最长长度即可。\n因为更新最长长度的代码写错位置，写到了if的分支里，WA了一次。应该无论如何都要更新，所以要写在外面。\nclass Solution &#123;public:    bool checkZeroOnes(string s) &#123;        vector&lt;int&gt; longest(2, 0);        int length = 0;        char last = &#x27;2&#x27;;        for (char c : s) &#123;            if (c != last) &#123;                last = c;                length = 1;            &#125; else &#123;                ++length;            &#125;            longest[c - &#x27;0&#x27;] = max(longest[c - &#x27;0&#x27;], length);        &#125;        return longest[1] &gt; longest[0];    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1870. Minimum Speed to Arrive on Time\n直接暴力二分怼。之前总结的binary search模版很好用。基本只需要改几行代码就行了。\n因为浮点数精度WA了一次。10^-5 不够小，建议以后都用10^-9。\nclass Solution &#123;    using ll = int;public:    int minSpeedOnTime(vector&lt;int&gt;&amp; dist, double hour) &#123;        int lo = 1;        int hi = 1e7 + 1;        // f f f t t t        auto binary = [&amp;](ll lo, ll hi, function&lt;bool(const ll)&gt; predicate) -&gt; int &#123;            // return first true            while (lo &lt; hi) &#123;                ll mid = lo + (hi - lo) / 2;                if (predicate(mid)) &#123;                    hi = mid;                &#125; else &#123;                    lo = mid + 1;                &#125;            &#125;            return lo;        &#125;;        auto pred = [&amp;](const ll x) -&gt; bool &#123;            double ans = 0;            int i;            for (i = 0; i + 1 &lt; dist.size(); ++i) &#123;                ans += (dist[i] + x - 1) / x;            &#125;            ans += dist[i] / static_cast&lt;double&gt;(x);            // cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl;            return ans &lt;= hour + 1e-9;        &#125;;        ll ans = binary(lo, hi, pred);        if (ans &gt;= hi) return -1;        else return ans;    &#125;&#125;;\n时间复杂度: O(log dist[i] * dist.length) = log 10^5 * 10^5,\n空间复杂度: O(1).\n 1871. Jump Game VII\n很容易想到暴力的N^2解法。\n从头开始遍历，如果是0的话，更新之后所有可以到达的位置。\n时间复杂度为: s.length * (maxJump - minJump) = 10% * 10^5.\n优化的方向是“更新之后所有可以到达的位置”。显然，这步更新因为有很多重复的更新，因此花费很多。但是，我们考虑每次其实是更新一个区间（range），而且区间的大小相等，而且区间总是向右移动的。因此，我们发现，更新区间并不需要遍历minJump…maxJump，只需要从maxJump向前开始遍历，如果和之前已经更新过的区间重合了，就直接break结束更新就好了。因为每个位置最多被更新一次，因此时间复杂度是 s.length.\nclass Solution &#123;public:    bool canReach(string s, int minJump, int maxJump) &#123;        // brute-force: s.length * (maxJump - minJump) = 10^5 * 10^5        // better: s.length * 1        const int n = s.size();                vector&lt;bool&gt; reachable(n, false);        reachable[0] = true;        // &lt;= reach        for (int i = 0; i &lt; n; ++i) &#123;            if (s[i] == &#x27;0&#x27;) &#123;                if (reachable[i]) &#123;                    for (int j = min(maxJump, n - 1 - i); j &gt;= minJump; --j) &#123;                        if (reachable[i + j]) break;                        reachable[i + j] = true;                    &#125;                &#125;            &#125;        &#125;        return s[n-1] == &#x27;0&#x27; &amp;&amp; reachable[n - 1];    &#125;&#125;;\n时间复杂度: O(s.length),\n空间复杂度: O(s.length).\n 1872. Stone Game VIII\n类似之前的Stone Game，这种最优玩法的题目大多数属于 动态规划问题。\n即通过搜索所有可能的选择，找到最优结果。过程中有很多重复子问题，因此需要使用动态规划。\n最优化目标是(Alice’s score - Bob’s score)，Alice想要最大化，Bob想要最小化。其实都是最大化（我的分数 - 对方的分数）。\n另外，观察到操作的结果其实是石头的和，因此需要提前计算前缀和数组。\n问题转化成，从前缀和[i:]中挑一个数，使得的分数差最大；之后的后手只能从被挑的位置之后挑。\n定义\ndp(i) 为从前缀和[i:]中挑一个数的最大分数差，\n则状态转移方程为：\ndp(i) = max(presum[j] + dp(j + 1) for j in range(i,)).\n时间复杂度为 O(N^2), 显然超时。\n然而，在状态转移方程中其实还有重叠子问题, for loop max可以只计算一次，因此可以进一步优化到 O(N).\nclass Solution &#123;public:    int stoneGameVIII(vector&lt;int&gt;&amp; stones) &#123;        // presum        // i = 0        // pick i, ..., n - 1        // time: n ^ 2        const int n = stones.size();        vector&lt;int&gt; presum(n + 1);        presum[0] = 0;        for (int i = 0; i &lt; n; ++i) &#123;            presum[i+1] = presum[i] + stones[i];        &#125;        int maxDp = numeric_limits&lt;int&gt;::min();        vector&lt;int&gt; dp(n + 2, 0);        dp[n+1] = 0;        for (int i = n; i &gt;= 2; --i) &#123; // 这里需要注意结束条件，因为第一次挑选不能不合并或只合并第一个，因此presum[0],presum[1]是没用的。            maxDp = max(maxDp, presum[i] - dp[i + 1]);            dp[i] = maxDp;        &#125;        return maxDp;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(N).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 241","url":"/2021/05/16/LeetCode-weekly-contest-241/","content":"本周周赛和双周赛都翻车了，开始残酷打卡之旅。\n\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n717 / 11572\nYoungForest\n12\n0:23:51\n0:05:35\n0:17:33\n0:23:51\nnull\n\n\n\n\n 1863. Sum of All Subset XOR Totals\n签到题。暴力回溯，枚举所有的子集。\nclass Solution &#123;public:    int subsetXORSum(vector&lt;int&gt;&amp; nums) &#123;        int ans = 0;        function&lt;void(const int, const int)&gt; backtracking = [&amp;](const int i, const int current) -&gt; void &#123;            if (i == nums.size()) &#123;                ans += current;                return;            &#125; else &#123;                // use this                backtracking(i + 1, current ^ nums[i]);                // not use this                backtracking(i + 1, current);            &#125;        &#125;;        backtracking(0, 0);        return ans;    &#125;&#125;;\n时间复杂度: O(2^n),\n空间复杂度: O(n).\n 1864. Minimum Number of Swaps to Make the Binary String Alternating\n首先统计’0/1’的数目，看是否可以形成交替。\n再尝试2种交替方式，1在前/0在前。\n重点在于只需要关心不符合的数量即可，不需要考虑具体怎么交换。\nclass Solution &#123;public:    int minSwaps(string s) &#123;        int ans = s.size();        vector&lt;int&gt; cnt(2, 0);        for (char c : s) &#123;            ++cnt[c - &#x27;0&#x27;];        &#125;        if (abs(cnt[0] - cnt[1]) &gt; 1) return -1;        for (char first : &quot;01&quot;s) &#123;            int current = 0;            if (cnt.at(first - &#x27;0&#x27;) + 1 == cnt.at(&#x27;1&#x27; - first)) continue;            for (int i = 0; i &lt; s.size(); i += 2) &#123;                if (s[i] != first) &#123;                    ++current;                &#125;            &#125;            ans = min(ans, current);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(s.length),\n空间复杂度: O(1).\n需要注意的是,\nfor (char first : &quot;01&quot;s)\n一定不能写成。\nfor (char first : &quot;01&quot;)\n因为前者是 字符串常量（string literal），后者是C语言里的静态字符串，会有\\n结尾的。\n 1865. Finding Pairs With a Certain Sum\n首先观察数据规模，发现nums1.length小，但nums2.length大。考虑对小的做遍历，大的hash优化。\n使用一个反向hashtable记录nums2 值-&gt;index 的映射。\n时间复杂度:\n\n构造: O(nums2.length),\nadd: O(1),\ncount: O(nums1.length).\n空间复杂度: O(nums2.length).\n\nclass FindSumPairs &#123;    vector&lt;int&gt; nums1, nums2;    unordered_map&lt;int, unordered_set&lt;int&gt;&gt; m;public:    FindSumPairs(vector&lt;int&gt;&amp; _nums1, vector&lt;int&gt;&amp; _nums2): nums1(move(_nums1)), nums2(move(_nums2)) &#123;        for (int i = 0; i &lt; nums2.size(); ++i) &#123;            m[nums2[i]].insert(i);        &#125;    &#125;        void add(int index, int val) &#123;        // O(1)        m[nums2[index]].erase(index);        nums2[index] += val;        m[nums2[index]].insert(index);    &#125;        int count(int tot) &#123;        // O(nums1.length)        int ans = 0;        for (int i : nums1) &#123;            auto it = m.find(tot - i);            if (it != m.end()) &#123;                ans += it-&gt;second.size();            &#125;        &#125;        return ans;    &#125;&#125;;/** * Your FindSumPairs object will be instantiated and called as such: * FindSumPairs* obj = new FindSumPairs(nums1, nums2); * obj-&gt;add(index,val); * int param_2 = obj-&gt;count(tot); */\n 1866. Number of Ways to Rearrange Sticks With K Sticks Visible\n本题我只想到了N^3的解法。\n使用动态规划，状态转移方程为\nans = 0for j in range(k - 1, i):    ans = (ans + dp(j, k - 1) * f2(i-1, j)) % MODreturn ans\n即从高向低考虑，因为最高的一定可以被看见。枚举第i个木棍放的位置，剩下i-1个木棍需要抽一些放在i之后，之后的是一个枚举数。\n从时间复杂度上一定会超时，事实上果然如此，尽管我试图尽力从常数上优化。\n下面给出我最后超时的代码。\nMOD = 10**9 + 7@cachedef f(i):    if i &lt;= 1: return 1    else: return (i * f(i - 1)) % MOD@cachedef f2(a, b):    if a == b: return 1    else: return (a * f2(a - 1, b)) % MOD@cachedef dp(i: int, k: int) -&gt; int:    # [1:i], see k woods    # print(i, k)    if i &lt; k: return 0    elif i == k: return 1    elif k == 1:        # put i first and other after        return f(i - 1)    else:        ans = 0        for j in range(k - 1, i):            # put i first and [j+1, i-1] after            # pick num woods before            # num = i - 1 - (j + 1) + 1            # C_i^num * num!            # C(n,m)=n!/((n-m)!*m!)（m≤n）            # print(&#x27;add&#x27;, dp(j, k - 1), (factorial(i) // factorial(i - num)))            ans = (ans + dp(j, k - 1) * f2(i-1, j)) % MOD        return ansclass Solution:    def rearrangeSticks(self, n: int, k: int) -&gt; int:        return dp(n, k)\n我参考了一些题解，确实是递推公式有问题。\n其实从不同的角度都可以得到这个公式。\n\n能不能看到最后一根木棍\n第一类斯特林数\n\n小修我TLE的代码就OK了。\nclass Solution:    def rearrangeSticks(self, n: int, k: int) -&gt; int:        MOD = 10**9 + 7        @cache        def dp(i: int, k: int) -&gt; int:            # [1:i], see k woods            if i &lt; k: return 0            elif i == k: return 1            elif k == 0: return 0            else:                # last wood can be seen, it must be `i`. dp(i-1, k - 1)                # last wood can not be seen, (i - 1) * dp(i - 1, k)                return (dp(i-1, k - 1) + (i - 1) * dp(i - 1, k)) % MOD        return dp(n, k)\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 243","url":"/2021/05/30/LeetCode-weekly-contest-243/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n95 / 12835\nYoungForest\n18\n1:19:18\n0:02:50\n0:11:21\n0:36:27  🐞1\n1:04:18 🐞2\n\n\n\n零神大数据：\n1880,Check if Word Equals Summation of Two Words,check-if-word-equals-summation-of-two-words,1187.1641565458\n1881,Maximum Value after Insertion,maximum-value-after-insertion,1381.2168789318\n1882,Process Tasks Using Servers,process-tasks-using-servers,1979.1112273597\n1883,Minimum Skips to Arrive at Meeting On Time,minimum-skips-to-arrive-at-meeting-on-time,2587.8725248485\n\n 1880. Check if Word Equals Summation of Two Words\n签到题。按题目要求转换字符串到数字，再进行判断。\nclass Solution:    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -&gt; bool:        def toDigit(w):            ans = 0            for i in w:                ans = ans * 10 + ord(i) - ord(&#x27;a&#x27;)            return ans                return toDigit(firstWord) + toDigit(secondWord) == toDigit(targetWord)\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1881. Maximum Value after Insertion\n贪心。正数时插入到第一个比x小的数，负数时插入到第一个比x大的数。\nclass Solution:    def maxValue(self, n: str, x: int) -&gt; str:        # insert into the position where the first digit &lt; x        # negative first &gt; x        if n[0] == &#x27;-&#x27;:            for i in range(1, len(n)):                if ord(n[i]) - ord(&#x27;0&#x27;) &gt; x:                    return n[:i] + str(x) + n[i:]            return n + str(x)        else:            for i in range(len(n)):                if ord(n[i]) - ord(&#x27;0&#x27;) &lt; x:                    return n[:i] + str(x) + n[i:]            return n + str(x)\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1882. Process Tasks Using Servers\n直接暴力模拟即可。使用优先队列维护空闲服务器，等待任务和释放时间。\n模拟时需要注意时间不能1单位1单位地进行，而是只进行那些有事件发生的时刻。\n即任务开始等待，服务器释放。\n需要注意时间的大小可能会超过int, 用long long更保险些。\nclass Solution &#123;    using ll = long long;    using pii = pair&lt;ll, ll&gt;;public:    vector&lt;int&gt; assignTasks(vector&lt;int&gt;&amp; servers, vector&lt;int&gt;&amp; tasks) &#123;        // brute-force: (m + n) * log n        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; freeServers, releaseTime;        for (int i = 0; i &lt; servers.size(); ++i) &#123;            freeServers.emplace(servers[i], i);        &#125;        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; waitTasks;        const int m = tasks.size();        vector&lt;int&gt; ans(m);        for (int i = 0; i &lt; m; ++i) &#123;            waitTasks.push(i);            while (!releaseTime.empty() &amp;&amp; releaseTime.top().first &lt;= i) &#123;                const int idx = releaseTime.top().second;                freeServers.emplace(servers[idx], idx);                releaseTime.pop();            &#125;            while (!freeServers.empty() &amp;&amp; !waitTasks.empty()) &#123;                const int idx = waitTasks.top();                waitTasks.pop();                auto [weight, serverIdx] = freeServers.top();                freeServers.pop();                ans[idx] = serverIdx;                releaseTime.emplace(i + tasks[idx], serverIdx);            &#125;        &#125;        ll current = m - 1;        while (!releaseTime.empty() &amp;&amp; !waitTasks.empty()) &#123;            const int idx = releaseTime.top().second;            current = releaseTime.top().first;            freeServers.emplace(servers[idx], idx);            releaseTime.pop();            while (!releaseTime.empty() &amp;&amp; releaseTime.top().first &lt;= current) &#123;                const int idx = releaseTime.top().second;                current = releaseTime.top().first;                freeServers.emplace(servers[idx], idx);                releaseTime.pop();            &#125;            while (!freeServers.empty() &amp;&amp; !waitTasks.empty()) &#123;                const int idx = waitTasks.top();                waitTasks.pop();                auto [weight, serverIdx] = freeServers.top();                freeServers.pop();                ans[idx] = serverIdx;                releaseTime.emplace(current + tasks[idx], serverIdx);            &#125;        &#125;                return ans;    &#125;&#125;;\n时间复杂度: O((m + n) * log n),\n空间复杂度: O(m + n).\n 1883. Minimum Skips to Arrive at Meeting On Time\n动态规划。\ndp(i, k)表示，从dist0到i（inclusive），k次休息，结束的最早时间。\n状态转移方程为\ndp(i, k) = min(\ndp(i-1, k) + … 最后一站不休息\ndp(i-1, k-1) + … 最后一站休息\n)，\n然后使用二分搜索找到最小的k使得 dp(n-1, k) &lt;= hoursBefore.\n（其实不用二分也行，从小到大遍历寻找也行。因为时间复杂度瓶颈不在这里，而在计算dp那里）。\n最近经常遇到动态规划的题目，之前在找状态转移方程时，时间复杂度总是超。试图利用枚举最后一个休息位置发生在何处。正确的做法应该是，只枚举最后一站是否休息。可以将时间复杂度降一个n.\n本题有个坑是浮点数精度，我因此WA了2次。\n解决方法有二:\n\n增加err, 我这里用了10^-9, 在大多数情况下都是够了。\n转换成整型。可能需要用long long。在本题中就是把所有的 时间 * speed 用来表示距离，这种解决方案不存在精度丢失。\n\nclass Solution:    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -&gt; int:        n = len(dist)        err = 10**-9        @cache        def dp(i, k):            if i == 0:                return dist[0] / speed            if k == 0:                # no relax                return ceil(dp(i-1, 0) - err) + dist[i] / speed            if i == k:                # relax all                return dp(i-1, k-1) + dist[i] / speed            # not relax + relax            return min(ceil(dp(i-1, k) - err) + dist[i] / speed, dp(i-1, k-1) + dist[i] / speed)                               lo = 0        hi = n                if dp(n-1, n-1) &gt; hoursBefore + err: return -1                while lo &lt; hi:            mid = lo + (hi - lo) // 2            if dp(n-1, mid) &lt;= hoursBefore + err: # -err?                hi = mid            else:                lo = mid + 1                if lo == n: return -1        else: return lo\n时间复杂度: O(n ^ 2),\n空间复杂度: O(m ^ 2).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 244","url":"/2021/06/06/LeetCode-weekly-contest-244/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n142 / 14467\nYoungForest\n18\n0:51:13\n0:05:21\n0:09:54\n0:30:19\n0:46:13 🐞1\n\n\n\n下午约了 残酷东神 吃饭，一个rating 2700+的大佬。他本科浙大，在加拿大读研。这个暑假来北京旷视实习。因此我们有机会线下面基。\n\n 1886. Determine Whether Matrix Can Be Obtained By Rotation\n签到题。旋转3次 加上 原始 共4种状态，分别比较。旋转的话就是另外的一个LeetCode经典题目了，in-place还是实现起来比较复杂的。但因为n比较小，而且是签到题，我直接用了辅助数组。虽然时间复杂度上去了，但实现起来简单多了。\nclass Solution &#123;    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;        vector&lt;vector&lt;int&gt;&gt; cp = mat;        const int n = mat.size();        for (int i = 0; i &lt; n; ++i) &#123;            for (int j = 0; j &lt; n; ++j) &#123;                cp[j][n-1-i] = mat[i][j];            &#125;        &#125;        mat = move(cp);    &#125;public:    bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; target) &#123;        if (mat == target) return true;        for (int i = 0; i &lt; 3; ++i) &#123;            rotate(mat);            if (mat == target) return true;        &#125;        return false;    &#125;&#125;;\n时间复杂度: O(4 * n * n),\n空间复杂度: O(n * n).\n 1887. Reduction Operations to Make the Array Elements Equal\n理解整个减小的过程可以发现，每个数减到最小的操作数目其实等于小于他的元素（去除重复元素）的数目。\n因此，先排序，再One pass 统计“小于他的元素”数目之和。\nclass Solution &#123;public:    int reductionOperations(vector&lt;int&gt;&amp; nums) &#123;        const int n = nums.size();        sort(nums.begin(), nums.end());        int ans = 0;        int add = 0;        for (int i = 1; i &lt; n; ++i) &#123;            if (nums[i] &gt; nums[i-1]) &#123;                ++add;            &#125;            ans += add;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(N log N),\n空间复杂度: O(1).\n 1888. Minimum Number of Flips to Make the Binary String Alternating\n观察有：\n操作1的数目不限。也就是说 我们可以遍历所有位置，假设它是开头，枚举开头分别是0/1的2种情况，然后统计之后和之前的不符合预期的数量。\n统计“之前和之后不符合预期的数量” 这个操作可以通过维护之前/之后 奇偶位置 0/1 的数量 O(1)实现。\n因为奇偶问题，“之前不符合预期的数量”需要分开讨论。\n发现在偶数长度下，开头位置其实是无所谓的。这时可以进一步简化问题。\n奇数长度下，还是需要枚举每个开头位置才行。\nclass Solution &#123;public:    int minFlips(string s) &#123;        const int n = s.size();        if (n % 2 == 0) &#123;            vector&lt;int&gt; cnt(2, 0);            for (int i = 0; i &lt; n; ++i) &#123;                cnt[i % 2] += (s[i] - &#x27;0&#x27;);            &#125;            const int half = n / 2;            return min(half - cnt[0] + cnt[1], cnt[0] + half - cnt[1]);        &#125; else &#123;            vector&lt;int&gt; after(2, 0);            for (int i = 0; i &lt; n; ++i) &#123;                after[i % 2] += (s[i] - &#x27;0&#x27;);            &#125;            vector&lt;int&gt; before(2, 0);            int ans = numeric_limits&lt;int&gt;::max();            const int half = n / 2;            for (int i = 0; i &lt; n; ++i) &#123;                const int now = i % 2;                ans = min(ans, half + 1 - after[now] - before[1-now] + after[1-now] + before[now]); // 1 begin                ans = min(ans, after[now] + before[1-now] + half - after[1-now] - before[now]); // 0 begin                after[i % 2] -= (s[i] - &#x27;0&#x27;);                before[i % 2] += (s[i] - &#x27;0&#x27;);            &#125;            return ans;        &#125;    &#125;&#125;;\n时间复杂度: O(N),\n空间复杂度: O(1).\n 1889. Minimum Space Wasted From Packaging\n本题的暴力解法很容易想：\n遍历所有的boxes； 对于每一个供应商，再遍历所有的包裹；对于每一个包裹，找到仅大于它的盒子做包装。时间复杂度为：O(m * n * log m). 显然会TLE。\n题目中给了数据范围，其中一个值得我们特别关注: sum(boxes[j].length) &lt;= 10^5。\n也就是说，我们完全可以枚举每一个盒子，找到用它的包裹（可以通过二分搜索，找到它能装的最大包裹的位置。除了比它小的盒子装的，剩下就是它装的。）。然后通过前缀和快速计算空余空间。\n时间复杂度为：`O(sum(boxes[j].length) * log n + n log n)，恰好符合要求。\n因为最大空余空间是max(boxes[i][j]) * packges.length = 10 ^ 10, 因此int会溢出，需要使用long long.\n最后，千万不要忘记MOD。我因此WA一次。\nclass Solution &#123;    using ll = long long;    const ll MOD = 1e9 + 7;public:    int minWastedSpace(vector&lt;int&gt;&amp; packages, vector&lt;vector&lt;int&gt;&gt;&amp; boxes) &#123;        sort(packages.begin(), packages.end());        const int n = packages.size();        vector&lt;ll&gt; presum(n+1);        presum[0] = 0;        for (int i = 0; i &lt; n; ++i) &#123;            presum[i+1] = presum[i] + packages[i];        &#125;        ll ans = numeric_limits&lt;ll&gt;::max();        const int m = boxes.size();        for (auto&amp; b : boxes) &#123;            sort(b.begin(), b.end());            int lastIdx = 0;            ll current = 0;            for (int j : b) &#123;                auto it = upper_bound(packages.begin(), packages.end(), j);                const ll d = distance(packages.begin(), it);                const ll width = d - lastIdx;                current += width * j - (presum[d] - presum[lastIdx]);                lastIdx = d;            &#125;            if (b.back() &lt; packages.back()) &#123; // can not fit                            &#125; else &#123;                ans = min(ans, current);            &#125;        &#125;        if (ans == numeric_limits&lt;ll&gt;::max()) return -1;        else return ans % MOD;    &#125;&#125;;\n时间复杂度: O(sum(boxes[j].length) * log n + n log n),\n空间复杂度: O(n).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 245","url":"/2021/06/13/LeetCode-weekly-contest-245/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (5)\nQ3 (5)\nQ4 (6)\n\n\n\n\n1904 / 12724\nYoungForest\n12\n1:39:20\n0:02:52\n1:24:20 🐞 3\n0:21:30\nnull\n\n\n\n零神大数据：\n1897,Redistribute Characters to Make All Strings Equal,redistribute-characters-to-make-all-strings-equal,1309.1422268153\n1898,Maximum Number of Removable Characters,maximum-number-of-removable-characters,1912.8440554296\n1899,Merge Triplets to Form Target Triplet,merge-triplets-to-form-target-triplet,1635.6879273926\n1900,The Earliest and Latest Rounds Where Players Compete,the-earliest-and-latest-rounds-where-players-compete,2454.7653333657\n今天的周赛翻车了。第二题一开始算错时间复杂度了，一直妄图找到更优算法。之后看到80人提交才重新审视二分暴力的时间复杂度，竟然是没问题的。实现过程中又遇到1次WA（判断子序列时，相等字符忘记更新s的下标了），2次TLE（标记remove下标不能用unordered_set, 而要用vector。算是被卡常数了)。这周又要残酷打卡了，幸运的是，因为前2周的成绩比较好，本周残酷榜更新后我的排名不降反升。\n 1897. Redistribute Characters to Make All Strings Equal\n签到题。本质是判断所有的字符是否可以平均分配到n个单词中。\nclass Solution &#123;public:    bool makeEqual(vector&lt;string&gt;&amp; words) &#123;        const int n = words.size();        vector&lt;int&gt; cnt(26, 0);        for (const auto&amp; word : words) &#123;            for (char c : word) &#123;                ++cnt[c - &#x27;a&#x27;];            &#125;        &#125;        for (int i : cnt) &#123;            if (i % n != 0) return false;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O(sum(words[i].length)),\n空间复杂度: O(1).\n 1898. Maximum Number of Removable Characters\n最优化问题转判定问题（双指针判断是否是子序列），二分搜索。\nclass Solution &#123;    using ll = int;    vector&lt;bool&gt; mark = vector&lt;bool&gt;(1e5);public:    int maximumRemovals(string s, string p, vector&lt;int&gt;&amp; removable) &#123;        const int n = removable.size();        auto binary = [&amp;](ll lo, ll hi, function&lt;bool(const ll)&gt; predicate) -&gt; int &#123;            while (lo &lt; hi) &#123;                ll mid = lo + (hi - lo) / 2;                if (!predicate(mid)) &#123;                    hi = mid;                &#125; else &#123;                    lo = mid + 1;                &#125;            &#125;            return lo;        &#125;;        // cout &lt;&lt; s.size() &lt;&lt; endl;        // cout &lt;&lt; n &lt;&lt; endl;        return binary(0, n + 1, [&amp;](const ll x) -&gt; bool &#123;            for (int i = 0; i &lt; s.size(); ++i) &#123;                mark[i] = false;            &#125;            for (int i = 0; i &lt; x; ++i) &#123;                mark[removable[i]] = true;            &#125;            int pi = 0, si = 0;            while (pi &lt; p.size()) &#123;                while (si &lt; s.size() &amp;&amp; (mark[si] || s[si] != p[pi])) ++si;                if (si == s.size())                 &#123;                    // cout &lt;&lt; x &lt;&lt; &quot;:false&quot;  &lt;&lt; endl;                    return false;                &#125;                // if (s[si] != p[pi]) cout &lt;&lt; &quot;impossible&quot; &lt;&lt; endl;                ++si;                ++pi;            &#125;            // cout &lt;&lt; x &lt;&lt; &quot;:true &quot;&lt;&lt; si   &lt;&lt; endl;            return true;        &#125;) - 1;    &#125;&#125;;\n时间复杂度: O(log removable.length * (s.length + p.length)),\n空间复杂度: O(s.length).\n本题有个坑是说，标记s中哪些位置被标记时，不能用unordered_set（即使加reserve)，会超时。可以用vector&lt;bool&gt;。算是被卡常数了。\n 1899. Merge Triplets to Form Target Triplet\n因为每次合并操作是去最大值，因此，只要有一个数大于target的triplet不能用。\n所以把剩下可以用的都合并了，看能不能达到target。\nclass Solution &#123;public:    bool mergeTriplets(vector&lt;vector&lt;int&gt;&gt;&amp; triplets, vector&lt;int&gt;&amp; target) &#123;        vector&lt;int&gt; cnt(3, 0);        for (int i = 0; i &lt; 3; ++i) &#123;            for (const auto&amp; v : triplets) &#123;                if (v[i] == target[i] &amp;&amp; v[(i + 1) % 3] &lt;= target[(i + 1) % 3] &amp;&amp; v[(i + 2) % 3] &lt;= target[(i + 2) % 3]) &#123;                    ++cnt[i];                &#125;            &#125;        &#125;        for (int i = 0; i &lt; 3; ++i) &#123;            if (cnt[i] == 0) return false;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O(triplets.length),\n空间复杂度: O(1).\n 1900. The Earliest and Latest Rounds Where Players Compete\nTNL~\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 249","url":"/2021/07/11/LeetCode-weekly-contest-249/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (6)\nQ4 (6)\n\n\n\n\n74 / 12832\nYoungForest\n19\n1:06:48\n0:02:44\n0:07:11\n0:37:44\n1:01:48 🐞1\n\n\n\n周赛博客更新一不小心就鸽了3周。因为最近毕业+入职，确实比较忙。中间因为毕业旅行，甚至罕见地鸽了一次周赛和双周赛。\n本周算是入职亚马逊之后的第一周，全球排名也惊喜地达到了74名。仔细算算，自己上次周赛进前100名还是243场，也就是大概一个半月前的时间了。\n本周后2题都是hard，确实容易拉开距离。\n因为我国服rating达到了2460，我担心掉分，因此最近基本都在美服玩耍。美服是个2330的“小号”，基本很难掉分。\n 1929. Concatenation of Array\n签到题。Straight forward。Python竟然可以一行return nums + nums。\nclass Solution &#123;public:    vector&lt;int&gt; getConcatenation(vector&lt;int&gt;&amp; nums) &#123;        const int n = nums.size();        vector&lt;int&gt; ans(2 * n);        for (int i = 0; i &lt; n; ++i) &#123;            ans[i] = ans[i+n] = nums[i];        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n),\n空间复杂度: O(n).\n 1930. Unique Length-3 Palindromic Subsequences\n因为回文串的长度比较短，只有3. 因此，最多有26*26种回文串。可以用中间和两侧的字符表示这个回文串。\n因为是subsequence，需要用cntLeft和cntRight维护两侧字符是否满足要求。\nclass Solution &#123;public:    int countPalindromicSubsequence(string s) &#123;        vector&lt;vector&lt;bool&gt;&gt; seen(26, vector&lt;bool&gt;(26, false));        int ans = 0;        vector&lt;int&gt; cntRight(26, 0);        for (char c : s) &#123;            ++cntRight[c - &#x27;a&#x27;];        &#125;        vector&lt;int&gt; cntLeft(26, 0);        for (char c : s) &#123;            --cntRight[c - &#x27;a&#x27;];            for (char i = &#x27;a&#x27;; i &lt;= &#x27;z&#x27;; ++i) &#123;                if (cntRight[i - &#x27;a&#x27;] &gt; 0 &amp;&amp; cntLeft[i - &#x27;a&#x27;] &gt; 0) &#123;                    if (!seen[c - &#x27;a&#x27;][i - &#x27;a&#x27;]) &#123;                        ++ans;                        seen[c - &#x27;a&#x27;][i - &#x27;a&#x27;] = true;                    &#125;                &#125;            &#125;            ++cntLeft[c - &#x27;a&#x27;];        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(26*s.length),\n空间复杂度: O(26 * 26).\n 1931. Painting a Grid With Three Different Colors\n算是1411. Number of Ways to Paint N × 3 Grid的升级版。\n行数从3变成了1-5，但思想不变，仍然是 3进制的bit_mask + dp。\n用3进制bit_mask表示每一列的颜色状态，从上一列的颜色排列数量得到新的一列的数量。\nclass Solution &#123;    const int MOD = 1e9 + 7;public:    int colorTheGrid(int m, int n) &#123;        int pow3m = 1;        for (int x = 0; x &lt; m; ++x) &#123;            pow3m *= 3;        &#125;        auto ok = [&amp;](int i, int j) -&gt; bool &#123;            for (int x = 0; x &lt; m; ++x) &#123;                if ((i % 3) == (j % 3)) return false;                i /= 3;                j /= 3;            &#125;            return true;        &#125;;        auto isLegal = [&amp;](int i) -&gt; bool &#123;            int last = -1;            for (int x = 0; x &lt; m; ++x) &#123;                if (i % 3 == last) return false;                last = i % 3;                i /= 3;            &#125;            return true;        &#125;;                vector&lt;vector&lt;int&gt;&gt; match(pow3m);        vector&lt;bool&gt; legal(pow3m);         for (int i = 0; i &lt; (pow3m); ++i) &#123;              legal[i] = isLegal(i);         &#125;         for (int i = 0; i &lt; (pow3m); ++i) &#123;              // cout &lt;&lt; legal[i] &lt;&lt; &quot; &quot; &lt;&lt; endl;              if (!legal[i]) continue;              for (int j = 0; j &lt; (pow3m); ++j) &#123;                  // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;....&quot;;                  if (!legal[j]) continue;                  // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;****&quot;;                  if (ok(i, j)) &#123;                      match[i].push_back(j);                      // cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; &quot;;&quot;;                  &#125;              &#125;         &#125;        vector&lt;vector&lt;int&gt;&gt; dp(pow3m, vector&lt;int&gt; (n, 0));        for (int mask = 0; mask &lt; (pow3m); ++mask) &#123;            if (legal[mask])                dp[mask][0] = 1;            // cout &lt;&lt; dp[mask][0] &lt;&lt; &quot; &quot;;        &#125;        // cout &lt;&lt; endl;        for (int i = 1; i &lt; n; ++i) &#123;            for (int mask = 0; mask &lt; (pow3m); ++mask) &#123;                if (!legal[mask]) continue;                for (int left : match[mask]) &#123;                    dp[mask][i] = (dp[mask][i] + dp[left][i-1]) % MOD;                &#125;                // cout &lt;&lt; dp[mask][i] &lt;&lt; &quot; &quot;;            &#125;            // cout &lt;&lt; endl;        &#125;        int ans = 0;        for (int mask = 0; mask &lt; (pow3m); ++mask) &#123;            if (legal[mask])                ans = (ans + dp[mask][n-1]) % MOD;        &#125;        return ans % MOD;    &#125;&#125;;\n时间复杂度: O(3m2 + n*3^m),\n空间复杂度: O(n * 3^m).\n 1932. Merge BSTs to Create Single BST\n算法不难，但是实现起来比较复杂，corner case也容易fail。\n根据题目描述，找到每个根和叶子的对应，进行合并操作。\n最后还得检查是否是BST。\n/** * Definition for a binary tree node. * struct TreeNode &#123; *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;    tuple&lt;bool, int, int&gt; solve(TreeNode* root) &#123;        // is BST, max value, min value        if (!root) return &#123;true, 0, 0&#125;;        tuple&lt;bool, int, int&gt; ret = &#123;true, root-&gt;val, root-&gt;val&#125;;        if (root-&gt;left) &#123;            auto l = solve(root-&gt;left);            get&lt;0&gt;(ret) = get&lt;0&gt;(ret) &amp;&amp; get&lt;0&gt;(l) &amp;&amp; root-&gt;val &gt; get&lt;1&gt;(l);            get&lt;2&gt;(ret) = min(get&lt;2&gt;(ret), get&lt;2&gt;(l));        &#125;        if (root-&gt;right) &#123;            auto r = solve(root-&gt;right);            get&lt;0&gt;(ret) = get&lt;0&gt;(ret) &amp;&amp; get&lt;0&gt;(r) &amp;&amp; root-&gt;val &lt; get&lt;2&gt;(r);            get&lt;1&gt;(ret) = max(get&lt;1&gt;(ret), get&lt;1&gt;(r));        &#125;        return ret;    &#125;    bool isValidBST(TreeNode* root) &#123;        return get&lt;0&gt;(solve(root));    &#125;    int count(TreeNode* root) &#123;        if (!root) return 0;        return count(root-&gt;left) + count(root-&gt;right) + 1;    &#125;public:    TreeNode* canMerge(vector&lt;TreeNode*&gt;&amp; trees) &#123;        const int n = trees.size();        unordered_map&lt;TreeNode*, TreeNode*&gt; leaves;        unordered_map&lt;int, TreeNode*&gt; value2leaf;        vector&lt;TreeNode*&gt; equalLeaves;        bool bad = false;        unordered_set&lt;int&gt; seen;        function&lt;void(TreeNode*, TreeNode*)&gt; dfs = [&amp;](TreeNode* root, TreeNode* parent) -&gt; void &#123;            seen.insert(root-&gt;val);            if (parent) &#123;                if (value2leaf.find(root-&gt;val) != value2leaf.end()) &#123;                    bad = true;                    return;                &#125;                leaves[root] = parent;                value2leaf[root-&gt;val] = root;            &#125;            if (root-&gt;left) &#123;                dfs(root-&gt;left, root);            &#125;            if (root-&gt;right) &#123;                dfs(root-&gt;right, root);            &#125;        &#125;;        for (auto root : trees) &#123;            dfs(root, nullptr);            if (bad) return nullptr;        &#125;        TreeNode* ans = nullptr;        for (auto root : trees) &#123;            auto it = value2leaf.find(root-&gt;val);            if (it == value2leaf.end()) &#123;                if (ans != nullptr) return nullptr;                ans = root;            &#125; else &#123;                auto leaf = it-&gt;second;                auto parent = leaves[leaf];                if (parent-&gt;left &amp;&amp; parent-&gt;left-&gt;val == root-&gt;val) &#123;                    parent-&gt;left = root;                &#125; else if (parent-&gt;right &amp;&amp; parent-&gt;right-&gt;val == root-&gt;val) &#123;                    parent-&gt;right = root;                &#125;                            &#125;        &#125;        if (ans) &#123;            if (!isValidBST(ans)) return nullptr;            if (count(ans) != seen.size()) return nullptr;        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(trees.length),\n空间复杂度: O(trees.length).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 250","url":"/2021/07/19/LeetCode-weekly-contest-250/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (6)\nQ4 (6)\n\n\n\n\n192 / 13694\nYoungForest\n18\n1:22:27\n0:03:20\n0:09:15  🐞1\n0:28:08\n1:07:27  🐞2\n\n\n\n连续2周成绩还不错，前200。导致美服小号rating都要上2400了，以后打起来会更加需要小心翼翼。\n 1935. Maximum Number of Words You Can Type\n签到题。字符串问题用Python果然没错。光split这一项就值得。\nclass Solution:    def canBeTypedWords(self, text: str, brokenLetters: str) -&gt; int:        ans = 0        broken = set()        for i in brokenLetters:            broken.add(i)        def ok(word):            for c in word:                if c in broken:                    return False            return True        for word in text.split(&#x27; &#x27;):            if ok(word):                ans += 1        return ans\n时间复杂度: O(text.length),\n空间复杂度: O(text.length + 26).\n 1936. Add Minimum Number of Rungs\n贪心，如果够不到下一级，就在最远的距离上加一个。\n需要注意，不能一级一级加，而是用除法一次加完中间缺少的。否则，会TLE（我也因此罚时5min）。\nclass Solution &#123;public:    int addRungs(vector&lt;int&gt;&amp; rungs, int dist) &#123;        int ans = 0;                int last = 0;        for (int idx = 0; idx &lt; rungs.size(); ++idx) &#123;            const int i = rungs[idx];            if (i - last &lt;= dist) &#123;                last = i;            &#125; else &#123;                ans += (i - last - 1) / dist;                last = i;            &#125;        &#125;                return ans;    &#125;&#125;;\n时间复杂度: O(rungs.length),\n空间复杂度: O(1).\n 1937. Maximum Number of Points with Cost\n很明显的一道动态规划题目。\ndp[i][j] = points[i][j] + max(dp[i-1][k] - abs(k-j) for k in range(n))\n然而直接莽的话，时间复杂度是 O(m * n ^ 2). 显然会TLE。需要优化。\n上一行根据 abs的正负，可以分为\n前面的 dp[i-1] - (j - k) = dp[i-1] + k - j,\n后面的 dp[i-1] - (k - j) = dp[i-1] - k + j.\n可以使用2个TreeSet记录前后的 dp + k 和 dp - k，并在j更新的时候，更新这2个TreeSet.\n这样时间复杂度降为: O(m * n).\nclass Solution &#123;    using ll = long long;public:    long long maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        const int m = points.size();        const int n = points[0].size();        vector&lt;vector&lt;ll&gt;&gt; dp(m, vector&lt;ll&gt; (n, 0));        // i == 0        for (int j = 0; j &lt; n; ++j) &#123;            dp[0][j] = points[0][j];        &#125;        for (int i = 1; i &lt; m; ++i) &#123;            multiset&lt;ll&gt; before, after;            for (int k = 0; k &lt; n; ++k) &#123;                after.insert(dp[i-1][k] - k);            &#125;            for (int j = 0; j &lt; n; ++j) &#123;                ll add = 0;                if (before.empty()) &#123;                    add = *after.rbegin() + j;                &#125; else if (after.empty()) &#123;                    add = *before.rbegin() - j;                &#125; else &#123;                    add = max(*before.rbegin() - j, *after.rbegin() + j);                &#125;                dp[i][j] = max(dp[i][j], points[i][j] + add);                auto it = after.find(dp[i-1][j] - j);                after.erase(it);                before.insert(dp[i-1][j] + j);            &#125;        &#125;                        return *max_element(dp.back().begin(), dp.back().end());    &#125;&#125;;\n时间复杂度: O(m * n)，\n空间复杂度: O(m * n). 其实也可以降为O(n), 但写起来稍微麻烦些，对AC也没必要.\n 1938. Maximum Genetic Difference Query\nTrie + backtracking + 离线计算。\nTrie用来快速计算最大XOR，backtracking用来维护从根到当前节点的路径和更新Trie，离线计算用以得到query的答案。\n使用cpp需要注意Trie的实现方式。\n本题用shared_ptr会TLE，raw pointer + delete也会TLE。\n删了delete才AC，这是逼我内存泄漏呀。\n不过本题因为可以使用cnt表示节点状态，实际上也并不需要真正删除节点。\nclass Solution &#123;    const int MAX_BIT = 17;    struct TrieNode &#123;        array&lt;TrieNode*, 2&gt; children;        int cnt = 0;    &#125;;    void buildTrie(const int num, TrieNode* root, const int index) &#123;        if (index &lt; 0) return;        const int b = (num &gt;&gt; index) &amp; 1;        if (root-&gt;children[b] == nullptr) &#123;            root-&gt;children[b] = new TrieNode();        &#125;        root-&gt;children[b]-&gt;cnt++;        buildTrie(num, root-&gt;children[b], index - 1);    &#125;    void eraseTrie(const int num, TrieNode* root, const int index) &#123;        if (index &lt; 0) return;        const int b = (num &gt;&gt; index) &amp; 1;        // if (root-&gt;children[b] == nullptr) &#123;        //     cout &lt;&lt; num &lt;&lt; &quot;:&quot; &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; endl;        //     root-&gt;children[b] = make_shared&lt;TrieNode&gt;();        // &#125;        eraseTrie(num, root-&gt;children[b], index - 1);        root-&gt;children[b]-&gt;cnt--;        if (root-&gt;children[b]-&gt;cnt == 0) &#123;            // delete root-&gt;children[b];            root-&gt;children[b] = nullptr;        &#125;    &#125;public:    vector&lt;int&gt; maxGeneticDifference(vector&lt;int&gt;&amp; parents, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        const int n = parents.size();        const int m = queries.size();        vector&lt;vector&lt;int&gt;&gt; children(n);        int rootNode = -1;        for (int i = 0; i &lt; n; ++i) &#123;            if (parents[i] == -1) rootNode = i;            else children[parents[i]].push_back(i);        &#125;        vector&lt;int&gt; ans(m);        using pii = pair&lt;int, int&gt;;        vector&lt;vector&lt;pii&gt;&gt; offQueies(n);        for (int index = 0; index &lt; m; ++index) &#123;            offQueies[queries[index][0]].push_back(&#123;queries[index][1], index&#125;);        &#125;        // shared_ptr&lt;TrieNode&gt; root = make_shared&lt;TrieNode&gt;();        auto root = new TrieNode();        auto maxXOR = [&amp;](const int val) -&gt; int &#123;            int ans = 0;            auto current = root;            for (int i = MAX_BIT; i &gt;= 0; --i) &#123;                const int b = (val &gt;&gt; i) &amp; 1;                if (current-&gt;children[1 - b]) &#123;                    ans += (1 &lt;&lt; i);                    current = current-&gt;children[1 - b];                &#125; else &#123;                    current = current-&gt;children[b];                &#125;            &#125;            return ans;        &#125;;        function&lt;void(const int, vector&lt;int&gt;&amp;)&gt; dfs = [&amp;](const int current, vector&lt;int&gt;&amp; path) -&gt; void &#123;            for (auto p : offQueies[current]) &#123;                int val = get&lt;0&gt;(p);                int index = get&lt;1&gt;(p);                ans[index] = maxXOR(val);            &#125;            // cout &lt;&lt; current &lt;&lt; &quot; &quot;;            for (int child : children[current]) &#123;                path.push_back(child);                buildTrie(child, root, MAX_BIT);                dfs(child, path);                eraseTrie(path.back(), root, MAX_BIT);                path.pop_back();            &#125;        &#125;;        vector&lt;int&gt; path;        path.push_back(rootNode);        buildTrie(rootNode, root, MAX_BIT);        dfs(rootNode, path);        eraseTrie(path.back(), root, MAX_BIT);        path.pop_back();        return ans;    &#125;&#125;;\n时间复杂度: O(log (max(val_i)) * (parents.length + queries.length)),\n空间复杂度: O(parents.length), Trie的空间消耗其实是个等比数列求和。\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 254","url":"/2021/08/15/LeetCode-weekly-contest-254/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (6)\nQ4 (6)\n\n\n\n\n616 / 13755\nYoungForest\n18\n1:28:25\n0:03:14\n0:08:43\n0:37:17  🐞4\n1:03:25  🐞1\n\n\n\n一不小心，周赛博客又鸽了3周。虽然我一直在参加周赛，但赛后经常忘记总结和复盘。平日里对刷题也放松了练习。平时打卡不是让npy刷，就是抄之前的提交。毕竟自己做了1300+的题，经常出的题都是我做过的。\n主要还是工作后生活丰富了许多，刷题和周赛的优先级降低不少。多场双周赛我都鸽了，快活的诱惑太大了。\n 1967. Number of Strings That Appear as Substrings in Word\n签到题。字符串问题用Python So easy。可惜我Q3没有坚持用Python，否则这周免打卡也是极有可能的。距500名差10min。\nclass Solution:    def numOfStrings(self, patterns: List[str], word: str) -&gt; int:        ans = 0        for s in patterns:            if s in word:                ans += 1        return ans\n时间复杂度: O(sum(patterns[i].length * word.length)),\n空间复杂度: O(1).\n 1968. Array With Elements Not Equal to Average of Neighbors\n贪心。这道题答案并不唯一，但我看到大多数人的思路和我一样。\n即 大 小 间隔插，保证2侧的数都大于/小于中间的数。自然可以保证平均数也大于/小于中间的数。\nclass Solution &#123;public:    vector&lt;int&gt; rearrangeArray(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end());        const int n = nums.size();        int l = 0, r = n - 1;        vector&lt;int&gt; ans(n);        for (int i = 0; l &lt;= r; i += 2) &#123;            ans[i] = nums[l++];            if (l &lt;= r)                ans[i+1] = nums[r--];        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(n log n),\n空间复杂度: O(n).\n 1969. Minimum Non-Zero Product of the Array Elements\n贪心，尽量分成大的数和小的数, 即 1 * (2^p - 2) * 1 * (2^p - 2) * … * (2^p - 1).\n前面共(2^p - 2) / 2组数。\n证明见link\nWA 3 + Runtime Error 1 发。\nWA 1: 计算2^p不应加MOD，应直接计算。\nWA 2: 不加MOD的pow写错了，因为直接复制的加MOD函数，因此调用的是原函数，忘记更新成新函数。\nRuntime Error: 乘法越界。超过long long, 出现在base过大的情况下。（事实上可以先将base取模克服这种情况，无奈比赛时我心态已崩。直接转了python，没有细追究原因和解决方案。\nWA 3: 无奈转成Python, 但是因为又是复制原来的代码再改，在整除的地方有个地方忘改了又WA一发。而且python自带 带模的快速幂，其他语言都需要自欺实现。\n教训：比赛时复制粘贴再改代码要小心，可能疏漏一些地方没改。如果方便的话，不如重写一边。\nclass Solution:    def minNonZeroProduct(self, p: int) -&gt; int:        MOD = 10**9 + 7;        x = (2**p)        return ((x - 1) * pow(x - 2, ((x - 2) // 2), MOD)) % MOD\n 1970. Last Day Where You Can Still Cross\n并查集。Penetration，Princeton CS226讲Union-Find的练习题。\n不同的是，如果正向填水的话，unite的操作要向8个方向尝试。\n当然也可以反向扣水，这时连陆地是4个方向。\n注意需要采用dummy node连接边缘的层。\n另外一种常见的做法是，BFS + Binary search，有些暴力。虽然也能过，但时间复杂度会差很多。\nO(log(rows * cols) * rows * cols).\nRuntime Error 1发。\n居然把行列坐标转换成一维坐标写错了，导致数组越界，debug了好久。\n理应是r*col+c, 写成了r*row+c\nclass Solution &#123;    class UF &#123;    public:        vector&lt;int&gt; fa;        vector&lt;int&gt; sz;        int n;        int comp_cnt;    public:        UF(int _n): n(_n), comp_cnt(_n), fa(_n), sz(_n, 1) &#123;            iota(fa.begin(), fa.end(), 0);        &#125;        int findset(int x) &#123;            return fa[x] == x ? x : fa[x] = findset(fa[x]);        &#125;        void unite(int x, int y) &#123;            x = findset(x);            y = findset(y);            if (x != y) &#123;                if (sz[x] &lt; sz[y]) &#123;                    swap(x, y);                &#125;                fa[y] = x;                sz[x] += sz[y];                --comp_cnt;            &#125;        &#125;        bool connected(int x, int y) &#123;            x = findset(x);            y = findset(y);            return x == y;        &#125;    &#125;;public:    int latestDayToCross(const int row, const int col, vector&lt;vector&lt;int&gt;&gt;&amp; cells) &#123;        vector&lt;vector&lt;int&gt;&gt; nums(row, vector&lt;int&gt;(col, 0));        UF uf(row * col + 2);        vector&lt;vector&lt;int&gt;&gt; direcionts = &#123;            &#123;0, 1&#125;,             &#123;1, 0&#125;,            &#123;-1, 0&#125;,            &#123;0, -1&#125;,            &#123;1, 1&#125;,            &#123;1, -1&#125;,            &#123;-1, 1&#125;,            &#123;-1, -1&#125;        &#125;;        const int L = row * col;        const int R = row * col + 1;        for (int i = 0; i &lt; cells.size(); ++i) &#123;            const int r = cells[i][0] - 1;            const int c = cells[i][1] - 1;            // cout &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; endl;            nums[r][c] = 1;            // cout &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; endl;            if (c == 0) &#123;                uf.unite(r * col + c, L);            &#125;            // cout &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; endl;            if (c == col - 1) &#123;                uf.unite(r * col + c, R);            &#125;            // cout &lt;&lt; r &lt;&lt; &quot;, &quot; &lt;&lt; c &lt;&lt; endl;                        for (const auto&amp; d : direcionts) &#123;                const int dr = d[0];                const int dc = d[1];                const int nr = dr + r;                const int nc = dc + c;                if (nr &gt;= 0 &amp;&amp; nr &lt; row &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; col) &#123;                    // cout &lt;&lt; &quot;xx: &quot; &lt;&lt; nr &lt;&lt; &quot;, &quot; &lt;&lt; nc &lt;&lt; endl;                    if (nums[nr][nc] == 1) &#123;                        uf.unite(r * col + c, nr * col + nc);                    &#125;                &#125;            &#125;            if (uf.connected(L, R)) return i;        &#125;        return -1;    &#125;&#125;;\n时间复杂度: O(rows * cols),\n空间复杂度: O(rows * cols).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"LeetCode weekly contest 257","url":"/2021/09/06/LeetCode-weekly-contest-257/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (5)\nQ4 (6)\n\n\n\n\n222 / 12542\nYoungForest\n18\n1:32:31\n0:06:21  🐞1\n0:12:18\n0:24:28\n1:17:31  🐞2\n\n\n\n久违的不用打卡了。之前打了3周卡，实在是遭不住了呀。工作之后，花在刷题上的精力和时间都少了很多。很多卡都是让npy打的，或者干脆抄一份。一份付出一份回报。学如逆水行舟，不进则退。我周赛成绩下降确实是自己实力下降了。虽然我并不打算改变，并且慢慢接受了这个事实。但是我会坚持打周赛和呆在残酷群里，保持基本的做题手感即可，不需要对自己有太高要求。\n最近除了工作，花了很多时间在投资理财上。\n一方面学习相关知识。比如 关注了 喜欢玩基金的小瑜哥 的B站和微信公众号，还有 认真的天马 的B站和微信公众号。\n关注了有大半年时间了。小瑜哥妥妥的韭菜一枚，关注他有3点原因：他每日更新复盘视频，十分坚持和勤劳；视频内容很开心（准确地说，看他亏钱很开心），可以当作娱乐区UP看；他犯了很多韭菜的误区和大忌，我们可以从他的失败中学习教训，而不需要自己去失败。\n天马 是妥妥的知识型和保守型UP主，比较符合我的需求和观点。他微信公众号也是日更，每天早上8点准时更新。更新文章末尾有估值表，通过其可以买低估、卖高估。他的文章和视频也是以干货为主，值得反复学习和观看。\n同时关注了 YouTube 的 “NaNa说美股“。主要讲的都是美股大盘的变动。我之前买过200元 纳指100 和 标普500. 涨了一些就卖了。错过了后面的行情。美股确实是长牛，和 A股没法比。现在虽然继续涨，但已经历史新高了，我也不敢再买了。\n同时阅读投资书籍。之前读了《小狗钱钱》，最近读完了《小乌龟的投资智慧》和《股票大作手回忆录》。我在豆瓣均写简短的书评。\n其中《小乌龟》是我觉得最有用的一本书，尤其是对于长期（10年以上）的投资。打算以后准备退休钱的时候按照其投资。现在因为要准备买房出国的事儿，暂时还没有足够的长期资金。短期基本都要用。\n另一方面进行实践。把自己的资产分为4个部分 灵活取用（现金，货币基金）、保守的债卷基金 和 固收（定期）、偏风险的股票基金（以宽基指数 和 行业指数 为主）。\n半年前写过一个自己的投资故事，现在，我可以大胆的说我的知识和经验更加丰富和专业了。虽然并没有收益多少，但工作之后随着本金的增加，投资理财变得更加重要了。\n现在我总的股票仓位较低，大概不到 1/3，以其他3种保守投资为主。\n 1995. Count Special Quadruplets\n签到题。暴力枚举即可。不过因为着急，没仔细看题，忽略了index 递增的要求，擅自加了排序，导致WA一发。\nclass Solution:    def countQuadruplets(self, nums: List[int]) -&gt; int:        seen = set()        n = len(nums)        # print(nums)        for i in range(n):            for j in range(i + 1, n):                for k in range(j + 1, n):                    for l in range(k + 1, n):                        if nums[i] + nums[j] + nums[k] == nums[l]:                            # print((i, j, k, l))                            seen.add((i, j, k, l))        return len(seen)\n时间复杂度: O(n^4),\n空间复杂度: O(n)。\n 1996. The Number of Weak Characters in the Game\n做这题的时候，我就觉的它有些像354. Russian Doll Envelopes。\n先排序，按照一维递减，另一维递增的方式。\n然后遍历，因为前面的都保证第一维大于等于当前了，只需要看前面第二维最大的就可以了。这也是为什么第二维排序要递增的原因，在第一维相等的时候，第二位大的要排后面，才不会影响遍历时的比较过程。\nclass Solution &#123;public:    int numberOfWeakCharacters(vector&lt;vector&lt;int&gt;&gt;&amp; p) &#123;        sort(p.begin(), p.end(), [](const auto&amp; lhs, const auto&amp; rhs) -&gt; bool &#123;            if (lhs[0] != rhs[0]) &#123;                return lhs[0] &gt; rhs[0];            &#125; else &#123;                return lhs[1] &lt; rhs[1];            &#125;        &#125;);        int ans = 0;        int maxDefense = 0;        for (const auto&amp; c : p) &#123;            if (maxDefense &gt; c[1]) &#123;                ++ans;            &#125;            maxDefense = max(maxDefense, c[1]);        &#125;        return ans;    &#125;&#125;;\n时间复杂度: O(nlogn),\n空间复杂度: O(log n).\n 1997. First Day Where You Have Been in All the Rooms\n本题幸运的发现了问题的本质，很快并且代码行数很少地解决了问题。\n否则最后一题可能没时间Debug了。\n注意到0 &lt;= nextVisit[i] &lt;= i，因此奇数次的时候必然是要往回走/呆在原地。\n偶数次只能向前走一步。意味着当我们第一次（其实可以扩展到奇数次）走到位置i时，之前的所有格子都必然走过偶数次。\n因此状态转移方程是：\ndp(i) = dp(i - 1) + 1 + (dp(i - 1) - dp(nextVisit[i-1])) + 1,\n即 第一次走到前一个位置，走一步，退回到nextVisit[i-1]，再次走到前一个位置，再多走一步到当前位置。\nclass Solution:    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -&gt; int:        MOD = 10**9 + 7        @cache        def dp(i):            if i == 0: return 0            return (dp(i-1) * 2 + 2 - dp(nextVisit[i-1])) % MOD        n = len(nextVisit)        return dp(n-1)\n时间复杂度: O(N),\n空间复杂度: O(N).\n 1998. GCD Sort of an Array\n观察交换规则，可以发现交换的位置其实是一个并查集，2个元素可以通过第3个元素互换。\n问题转换成，原始位置要换到排序后的位置，需要经过一系列元素的交换，这些元素必须在同一个集（component）里。\n在同一个集的充分必要条件是 gcd 大于 1。\n因此，一个直接的想法（但是显然会TLE）是：\n\n两两算gcd, 更新union-find；\n排序原始数组，找到对应的排序后的位置；\n根据dfs原则，判断哪些元素必须在同一集，然后用之前算好的union-find去验证。\n\n时间复杂度为: O(N^2 + N log N + N).\n复杂度瓶颈在第一步的计算union-find这里。我们尝试优化它。\n观察数据规模：2 &lt;= nums[i] &lt;= 10^5，意味着我们可以计算每个元素的因子，然后把相同因子的元素通过因子unite起来。这里有个坑，我们不仅需要连接小因子，还需要把相应的大因子连接起来。可以把并查集的数组扩大，扩大后的位置用来表示因子，用一个+n偏移表示。\n时间复杂度降为 O(N * sqrt(num)), 这里大概是10^7, 其实还是可能会超时的。这也是我本题7次罚时的原因，在TLE的边缘疯狂试探。\n残酷群友提示：第四题和952. Largest Component Size by Common Factor 很像，要按因数去优化，不然会tle到死。不过我通过把局部数组移到类变量，这种常数优化AC了。\n不过这种按因数优化的方式还是很值得学习的，可以把获得因数的复杂度从O(sqrt(num))降为O(log num)：https://leetcode.com/problems/gcd-sort-of-an-array/discuss/1445180/C%2B%2BPython-Union-Find-and-Sieve-and-Sorting-Clean-and-Concise\nclass Solution &#123;    class UF &#123;public:    vector&lt;int&gt; sz;    int n;    int comp_cnt;    vector&lt;int&gt; fa;public:    UF(int _n): n(_n), comp_cnt(_n), fa(_n), sz(_n, 1) &#123;        iota(fa.begin(), fa.end(), 0);    &#125;        int findset(int x) &#123;        return fa[x] == x ? x : fa[x] = findset(fa[x]);    &#125;        void unite(int x, int y) &#123;        x = findset(x);        y = findset(y);        if (x != y) &#123;            if (sz[x] &lt; sz[y]) &#123;                swap(x, y);            &#125;            fa[y] = x;            sz[x] += sz[y];            --comp_cnt;        &#125;    &#125;        bool connected(int x, int y) &#123;        x = findset(x);        y = findset(y);        return x == y;    &#125;&#125;;    using pii = pair&lt;int, int&gt;;    array&lt;pii, 50000&gt; index;    array&lt;int, 50000&gt; reverseIndex;    array&lt;bool, 50000&gt; visited;public:    bool gcdSort(vector&lt;int&gt;&amp; nums) &#123;        // time: n log n + n ^ 2        // (10**5)**0.5        // = 316.22776601683796        const int n = nums.size();        for (int i = 0; i &lt; n; ++i) &#123;            index[i] = &#123;nums[i], i&#125;;        &#125;        sort(index.begin(), index.begin() + n);        for (int i = 0; i &lt; n; ++i) &#123;            reverseIndex[index[i].second] = i;        &#125;        const int maxX = *max_element(nums.begin(), nums.end());        UF uf(n + maxX + 10);        for (int a = 0; a &lt; n; ++a) &#123;            uf.unite(a, n + nums[a]);            for (int b = 2; b * b &lt;= nums[a]; ++b) &#123;                if (nums[a] % b == 0) &#123;                    uf.unite(a, n + b);                    // 有可能是倍数                    if ((nums[a] / b) &gt; 1) uf.unite(a, n + (nums[a] / b));                 &#125;            &#125;        &#125;        // N ^ 2, TLE        // for (int a = 0; a &lt; n; ++a) &#123;        //     for (int b = a + 1; b &lt; n; ++b) &#123;        //         if (gcd(nums[a], nums[b]) &gt; 1) &#123;        //             uf.unite(a, b);        //         &#125;        //     &#125;        // &#125;        for (int i = 0; i &lt; n; ++i) &#123;            visited[i] = false;        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            if (!visited[i]) &#123;                vector&lt;int&gt; group;                while (!visited[i]) &#123;                    visited[i] = true;                    group.push_back(i);                    i = reverseIndex[i];                &#125;                const int root = uf.findset(group[0]);                for (int i = 1; i &lt; group.size(); ++i) &#123;                    if (root != uf.findset(group[i])) &#123;                        return false;                    &#125;                &#125;            &#125;        &#125;        return true;    &#125;&#125;;\n时间复杂度: O(N * sqrt(N) + N log N),\n空间复杂度: O(N + max(nums[i])).\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"六神磊磊读金庸","url":"/2024/07/22/Liu-Shen-Lei-Lei-Du-Jin-Yong/","content":"豆瓣链接\n是六神磊磊同名公众号文章的集合，以不同金庸小说分类，一次性读完，大快人心。多次拍手称快。\n因为本身是微信公众号的文章，所以十分擅长吸引流量和观众。语言轻松诙谐，又十分有道理，算是对金庸小说的一些独特解读。作者十分读过很多遍小说，因此对于不同小说里的人物信手拈来，擅长横向（同一小说里的不同人物）和纵向（不同小说中的类似人物）对比，甚至很多小人物的遭遇和命运也都如数家珍。不仅关注主角们，也关注配角们，而且全是从他们各自的角度出发。体现出一个“悲天悯人”。这也是作者认为，金庸小说的核心之一。另一个是“侠之大者，为国为民”。角度也十分现代化，有时又跳出江湖，以公司或现实生活类比，幽默效果就出来了。\n尤其是很多金庸小说里，本身就有很多的借古讽今，借江湖讽刺当时的政治。六神磊磊当然也不敢揭露的太明显，只捡了一些无关痛痒的话来讲。希望有生之年，可以看到大家放开心讲话，这样的文学和社会都会有趣很多。\n王小波说过一句话：“在中国，历史以三十年为极限，我们不可能知道三十年以前的事。”\n","categories":["读后感"],"tags":["Reading","六神磊磊读金庸"]},{"title":"LeetCode weekly contest 255","url":"/2021/08/23/LeetCode-weekly-contest-255/","content":"\n\n\nRank\nName\nScore\nFinish Time\nQ1 (3)\nQ2 (4)\nQ3 (6)\nQ4 (6)\n\n\n\n\n406 / 11837\nYoungForest\n12\n0:36:07\n0:01:21\n0:09:54\n0:26:07  🐞2\nnull\n\n\n\n本周Q4极其难，思考了半个小时果断放弃，陪npy做可乐鸡翅去了。\n有趣的是，LC国服赛后挂了。取不到成绩，残酷榜默认0分。心疼国服的同学们。\n虽然之后恢复了，我上面的成绩就是恢复之后，加上国服的同学后的排名。\n因为今天其实有Google Kickstart比赛，因此参赛人数有所减少。\n 1979. Find Greatest Common Divisor of Array\n签到题。用C简直作弊，有自带的gcd函数，虽然是C 17才支持的，不过LeetCode恰好支持17.\nclass Solution &#123;public:    int findGCD(vector&lt;int&gt;&amp; nums) &#123;        sort(nums.begin(), nums.end());        const int smallest = *nums.begin();        const int largest = *nums.rbegin();        return gcd(largest, smallest);    &#125;&#125;;\n时间复杂度: O(n log n + log max(nums)),\n空间复杂度: O(1).\ngcd 的时间复杂度: link.\n 1980. Find Unique Binary String\n由于n的大小很小，因此直接暴力即可。\n数字转二进制字符串，和 二进制字符串转数字 都是网上现搜的。\nclass Solution &#123;public:    string findDifferentBinaryString(vector&lt;string&gt;&amp; nums) &#123;        // total number: 2 ^ n,        // 2 ^ 16 = 65536        const int n = nums.size();        unordered_set&lt;int&gt; seen;        for (const auto&amp; i : nums) &#123;            seen.insert(stoi(i, 0, 2));        &#125;        for (int i = 0; i &lt; (1 &lt;&lt; n); ++i) &#123;            if (seen.find(i) == seen.end()) &#123;                return std::bitset&lt;16&gt;(i).to_string().substr(16 - n);            &#125;        &#125;        return &quot;&quot;;    &#125;&#125;;\n时间复杂度: O(sum(nums[i].length) + 2 ^ n),\n空间复杂度: O(n).\n 1981. Minimize the Difference Between Target and Chosen Elements\n使用DP枚举所有可能的和，然后找最近的。\nclass Solution &#123;public:    int minimizeTheDifference(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int target) &#123;        // 1 * m ~ 70 * m = 4900        // 4900 * n * m = 24,010,000        const int MAXNUMBER = 70;        const int m = mat.size();        vector&lt;bool&gt; dp(MAXNUMBER * m + 1, false);        dp[0] = true;        for (int i = 0; i &lt; m; ++i) &#123;            vector&lt;bool&gt; newdp(MAXNUMBER * m + 1, false);            for (int j = MAXNUMBER * m; j &gt;= 0; --j) &#123;                if (dp[j]) &#123;                    for (int k : mat[i]) &#123;                        if (j + k &lt;= MAXNUMBER * m) newdp[j + k] = true;                    &#125;                &#125;            &#125;            dp = move(newdp);        &#125;        int i;        for (i = 0; target + i &lt;= MAXNUMBER * m || target - i &gt;= 0; ++i) &#123;            if ((target + i &lt;= MAXNUMBER * m &amp;&amp; dp[target + i]) || (target - i &gt;= 0 &amp;&amp; target - i &lt;= MAXNUMBER * m &amp;&amp; dp[target - i])) return i;        &#125;        return i;    &#125;&#125;;\n时间复杂度: O(m * max(mat[i][j]) * m * n) = 24,010,000,\n空间复杂度: O(max(mat[i][j]) * m).\nWA 一次：因为每行必须选一个数，不能不选。因此dp需要新开一个数组，不能复用原来的。\nRuntime Error 一次：target有可能大于MAXNUMBER * m，因此必须加判断。\n 1982. Find Array Given Subset Sums\n全球只有50人做出来。我思索了半个小时，仍然没有头绪。果断放弃帮npy做可乐鸡翅。虽然没有AK，但吃上了可口的鸡。\n赛后果然参考了零神的题解, yyds.\n","categories":["LeetCode"],"tags":["Competitive Programming"]},{"title":"六神磊磊读唐诗","url":"/2024/07/25/Liu-Shen-Lei-Lei-Du-Tang-Shi/","content":"有种“当年明月”的“明朝那些事儿”的感觉呀。不知道是刻意模仿，还是无意为之。\n经常和金庸小说互动，尤其是同样的“悲天悯人”。\n岳灵珊“自怜自伤还自怨，不悔情真不悔痴。”\n知识分子借古讽今，在文章中委婉表达观点是常态。磊磊 特意写了一篇“放下筷子骂娘的白居易”，表达对如今言论管制环境的不满，和唐代开放包容的向往和怀念。\n这一年读了太多的现实主义书，获得了不少知识和智慧。但这本书是最有浪漫主义色彩的，令人十分感动。\n唐诗的四种套路：田园有宅男，边塞多愤青，咏古伤不起，送别满基情。\n“我们经常把赞美等同于忠诚，把批评等同于敌对，这实在是一个天大的误区，罗隐告诉我们：从来都没有这个等式。”和如今的社会现实如此相似。\n","categories":["读后感"],"tags":["Reading","六神磊磊读唐诗"]},{"title":"Lunch IPython from differnt conda env","url":"/2017/11/02/Lunch-IPython-from-differnt-conda-env/","content":"reference\n# activate virtual python environmentactivate python27# install package ipykernel in virtual environmentpip install ipykernel# install ipython kernel for virtual environmentpython -m ipykernel install --user --name py27 --display-name &quot;Python (py27)&quot;# lunch jupyter QTConsole with specific kerneljupyter qtconsole --kernel=py27\n using mirror instead of cross GFW\nYou have 2 choices to make it work inside GFW.\n\nmirror(which I recommend for better speed)\nVPN\n\nmirror site\nLatest install package mirror site\n# add package source mirrorconda config --add channels https://mirrors.ustc.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes"},{"title":"毕设大论文撰写问题汇总及解决","url":"/2021/05/06/Mendeley-GB-T-7714-2005/","content":" Mendeley GB/T 7714-2005\n\n针对英文文献中作者名字使用了全大写\n针对英文文献中三个以上人名省略时使用了中文的“等”，而不是et al.\n\nSolution\n我配置了自己的参考文献格式，在此分享给大家。特色有：\n\n删除参考文献中的 // 。特别是会议后面多出来的这个分隔符\n\n 引用知网参考文献\n知网上没有Mendeley支持的Bib参考文献格式，因此，我写了一个网站可以在线进行参考文献的转换: 入口1 入口2\n","categories":["Paper"]},{"title":"米哈游 服务器开发 暑期实习","url":"/2020/03/20/Mihayo-backend-intern-interview/","content":" 一面\ntime: 2020-03-20 16:29:48\n上周五参加了在牛客网上的笔试。题目不难，分为计算机基础、算法 和 系统设计。\n计算机基础靠着本科的认真学习，没啥问题。算法也属于LeetCode medium难度，很快AC了。\n系统设计倒是难倒我了，并不擅长，也没有准备。需要设计一个 MOBA游戏的匹配机制，包括单人和组队。之前完全没想过，瞎写了一通。\n昨天收到电话，说我通过了笔试，约了今天下午2:30的电话面试。\n本科有个可爱的大佬舍友最后去米哈游了。我虽然对游戏不感冒，但本着多面试，多总结的态度，也报名了其春招内推。\n面试预计30min, 实际40min。\n自我介绍 + 项目经历 + 计算机基础。\n计算机基础又分为：\n\nC++\n操作系统\n数据库\n计算机网络\n设计模式\n\n我不会的有：\n\nTCP 3次挥手，最后的time_wait的作用\nC++ 父类析构函数为什么必需是虚函数\nMySQL\n\n事务 及 ACID\nBlock 和 Tag 区别\nBiLog是什么\ntimestamp, datetime的区别\n\n\n说出常用的设计模式，我讲了几个，但面试官好像并不满意\n\n没有手撕代码环节，稍微有些失落。\n 二面\ntime: 2020-04-03 12:54:20\n之前一面的帖子。\n二面距离一面过去了整整2周。中间HR还打电话希望我能到上海onsite二面。我只好如实说 学校现在不允许跨省区流动。贵司心也是大。最后还是按计划视频面试。\n整场面试持续50min。难度并不大，但由于是游戏公司，所以很多问题和项目是之前没有遇到或想过。\n 算法\n合并2个有序链表。\n 项目\n\nLinux下的项目。我告诉他我大多数全是Linux。\n之前大四做的一个游戏（软件工程作业）github。\n内存泄漏诊断\nprotobuf\n\n 计算机基础\n\n如何诊断网络问题？\n一致性哈希，增桶、减桶。\n单例模式，带模版的单例，多线程下的。这是共享屏幕在本地IDE实现的。\n\n 三面\ntime: 2020-04-08 12:58:36\n一面\n二面\n 语言基础\n实现智能指针shared_ptr的构造、析构函数。\n问：为什么count要用指针？\ntypename&lt;T&gt;class shared_ptr &#123;    T* data = nullptr;    uint32_t* count = 0;    shared_ptr(const shared_ptr&amp; a) &#123;        data = a-&gt;data;        count = a-&gt;count;        ++(*count);    &#125;    shared_ptr(T* t) &#123;        data = t;        if (t) &#123;            count = new uint32_t();            count = 0;        &#125;    &#125;    shared_ptr operator = (const shared_ptr&amp; a) &#123;        if (a == this) ;        else &#123;            if (this != nullptr) &#123;                --(*count);                if (*count == 0) &#123;                    delete data;                    delete count;                &#125;            &#125;            data = a-&gt;data;            count = a-&gt;count;            ++(*count);        &#125;    &#125;    ~shared_ptr() &#123;        if (data) &#123;            if (*count &gt; 0) &#123;                --(*count);            &#125; else &#123;                delete data;                delete count;            &#125;        &#125;    &#125;&#125;;typename&lt;T&gt;shared_ptr&lt;T&gt; make_shared() &#123;    return ret(new T());&#125;\n 算法\n\n1，7，10 三种面值硬币。\n给定一个n，最少硬币凑出这个值。\n\n我刚开始想要贪心，但面试官很快给出反例。\n\n15\n\n之后给出一个DP的O(N)的解法，面试官再提示N很大时，有何优化的思路。进而提出先mod最大公倍数，再对余数DP的O(1)解法。\ndp(n) = min(    dp(n - 1) + 1,    dp(n - 7) + 1,    dp(n - 10) + 1,); if n &gt;= 10;1 * 7 * 10 = 70O (7 + 1) = O(1)\n 数据结构设计\n设计一个百万量级排行榜 ，支持插入，按uid查找分数，按uid查找名次，按名次查找uid.\nfollow up: 分数相同时，按照上榜时间排序。\norder statisc treeint getSize(TreeNode* node) &#123;&#125;setmultisetorder_statisc_tree&lt;pair&lt;分数, 时间&gt;，uid&gt;：按名次查uid log Nhashmap&lt;uid, pair&lt;分数,时间&gt;&gt;: 按uid查分数 O(1)按uid查排名 O(log N)insert: O(1 + log N)\n 计算机基础\nLinux熟不\n排查线上某进程CPU为100%。\n 其他\n游戏公司的特别之处。\n玩过我们公司的游戏吗？（否）那平时玩什么游戏。\n最后面试官问我能不能毕业前提前来实习。我说不能，没发去上海。\n问题：贵司服务器开发内部分组情况。不同产品的后端共用情况。\n","categories":["interview"],"tags":["intern","Mihayo"]},{"title":"我的理想 -- 写于2013年升高三前","url":"/2013/06/07/My-dream-when-3rd-years-in-high-school/","content":"2013年6月7日，是高中大我一届的高三学长学姐高考的最后一天。\n从那天以后，就是我离高考最近了，虽然要到9月份才正式升入高三。\n当时我在 山西省襄汾中学 读书，不到17岁，写下这篇“我的理想”，以明志和激励自己。现在10年过去了（2023年6月，整理自己硬盘资料时，惊喜地发现了这篇“文献”），回头看，自己并没有实现当年的清华梦。遭受了社会毒打后，理想（包括文采）也远没有当年优秀。但是，当年的文字依旧让我感动，感谢曾经的自己。\n我曾是少年。\n正文开始\n孔子十有五而志于学，便确立了自己接下来几十年的人生理想，并为之矢志不渝地奋斗。我虽不是圣人，只是一名普通的中学生，但也有我自己的人生理想——世界因我而改变。当后人听到我的名字时，都会竖起拇指，并发出由衷的赞叹，就像我现在听到爱因斯坦这些伟人的名字一样。\n我渴望真理，就像嗷嗷待哺的羊羔渴望母乳一般，一刻不曾忘记探索。伟人们的故事深深吸引着我，阿基米德用的浴缸、砸在牛顿脑袋上的苹果、被瓦特看到的壶盖，这些都使我印象深刻。谁知道会是哪天，又会是哪一个人再次在海边拾到更为精美的贝壳呢？伟人在那些积累量变达到质变之前，又有谁知道他就是改变世界的人呢？没有人是先知，但这并没有关系，真正勇士，不会因为道路的曲折艰险，梦想的遥遥无期，路人的冷嘲热讽而畏葸不前，当然，我也一样。\n无论是在高中还是大学，都是人们积累量变的地方，没有量变便没有质变。为了达到质变，量变之苦是必须承受的。\n全中国都知道高三苦，高考难，考清华更难。但清华作为中国第一流大学是那么地吸引着芸芸考生，以至于全国各地高手都会以清华为梦想学府，再苦再累也心甘情愿，我也不例外。清华作为一所大学，不仅起到教书育人的作用，也为我们提供了一个平台，充分交流，发展的平台。我希望清华不仅教给我知识（改变世界的基础），还能让我与高手切磋，大师交流，提升自己的素质和能力。\n在现在社会，知识就是力量，知识就是财富。面对航母大国的技术封锁，中国航母之路从零开始，没有知识，从乌克兰拉回来的废铁怎能变身“辽宁舰”；没有知识，歼十五舰载机怎能做到一年之内成功首飞。我渴望知识，渴望在清华接受最前沿的知识，希望有朝一日，我能凭借自己的知识让世界刮目相看。\n光有知识还不够，还要有能力，素质。这些能力和素质包括对灵感和信念锲而不舍地追求的精神、善于观察、不断学习、团队合作意识、资源共享意识、创新能力、勇于质疑等等。科学史上的每一次进步都与这些息息相关：牛顿的“巨人效应”妇孺皆知：“我之所以比别人看得更远，是因为我站在巨人的肩膀上。”这便是资源共享的优势；法拉第坚信康德哲学，相信万物存在内在的统一，既然电能生磁（电流的磁效应），那么磁也能生电。于是他开始了大量的实验，一次失败，二次失败，三次失败······，失败的阴影笼罩着他，但他没有放弃。在经过十年艰苦卓越的努力后，他成功了，他发现了电磁感应定律。当时的科学家不少当初都有和他有相同的想法，但他们没有锲而不舍地追求，从而错失了改变社会的机会。我相信，在清华园，我能学到这些优秀的品质，为以后追寻梦想之路铺平道路。\n我为了这个遥远而又真实的理想时刻奋斗着。作为高中生，拿下高考便成为最近而又最可即的台阶，杀入清华，才能进一步地登高。一步一个脚印，我脚踏实地；披星戴月，我从不喊累。我深知，高三只有血汗不会欺骗我。用汗水默默耕耘，用艰辛肥沃贫瘠的土壤。我按照自己的计划，争分夺秒，充实自我，为了高考，为了清华，为了梦想战。\n\n\n\n","categories":["dairy"],"tags":["life"]},{"title":"Niz plum option key 在蓝牙模式下不响应","url":"/2021/10/13/Niz-plum-option-key-not-work/","content":"最近使用我心爱的Niz Plum 66键盘时遇到一个奇怪的bug。\n在蓝牙模式下，左option键失灵。因为我hammerspoon和其他应用的快捷键大量使用，虽然偶尔可以通过右option键短暂替代。但总不是回事儿，工作效率大幅降低。\n这个bug的引入我也不确定是如何来的。大概是我Mac开始连2个外界显示器开始的。\n奇怪的是，有线模式并没有问题。而且我试过蓝牙断开重连也并没有修复。换个蓝牙通道也无济于事。\n我在网络上进行了大量的搜索，并没有找到类似的问题和解决方案。最终还是在自己的不断摸索下成功修复了。因此记录下来，以防止未来再次遇到。\n参考说明书.\n\n恢复出厂设置: 同时按住键盘四角的四个键5秒钟。\n键盘开机，连接Mac。\n重新配置键盘设置, 如我的如下:\n\nFn + Command 从默认的Windows键位切换回Mac\nFn + ] 降低按键延迟\nFn + 右Shift 将右shift转成shift而非默认的 Up\n\n\n左Option键已成功修复。\n\n敬请享受自己的键盘吧！\n","categories":["折腾"],"tags":["键盘"]},{"title":"爱尔兰 办荷兰申根短期签证","url":"/2022/12/15/Netherlands-Visa-from-Ireland/","content":"\n终于在都柏林拿到心心念念的荷兰申根签证了，短期访问亲友签。\n因为朋友在阿姆读书，我在爱尔兰打工。因为爱尔兰不属于申根区。因此互相探望的话，我需要办申根签证，她需要办爱尔兰签证。\n10月底到达爱尔兰后，需要先办居留卡。有了居留卡才能办签证，因此拖到了10月底。\n时间线：\n11.23 网上填申请表。准备材料。\n11.24 网上刷到了办签证的time slot。\n12.5 Visa center 提交材料。\n12.11 打了新冠辉瑞疫苗。\n12.16 收到取护照的电话，也是签证有效期的开始。\n12.19 去Visa center取护照。\n12.22 坐飞机入境荷兰。\n花费：\n\n申请费 约18欧，填完申请表后交。\n签证费 约80欧，签证中心交材料时交。\n保险费 约24欧，准备保险材料时花的。\n\n总计 约 125欧。\n我是按照schengenvisainfo里的材料清单准备的。短期旅游类似，不过真正办的时候还有些区别。\n\n护照，IRP（居留）复印件。如果没有的话，也可以现场工作人员帮忙复印，不过还是提前准备好为好。\n不需要照片。\n之前申根签的复印件。\n\n别的注意事项还有：\n\n办签证的预约不大容易。经常没有位置。需要过几个小时就刷一下，看有没有放号。我是大概中午刷到的，1周半后的号。\n邀请信可以从网上搜模板，注意邀请人签字需要用中文的。一开始邀请人只签了英文的，但是因为和她的护照和居留复印件上地签字不同，需要重新签，发电子版到Visa center的邮箱里。\n可选邮寄和自取。邮寄需要加钱，自取可以更快拿到护照。因为我比较急，而且也住在都柏林，因此选了自取。\n最好提前4周办。我这次因为想赶在圣诞节前团聚，所以比较仓促。\n机票最好不要提前买，只需要提供航班信息即可。可以用网上的一些flight itinerary生成器免费生成. 即便买也要买能退的。Travel Itinerary 也是从网上随便找了个模板改的。\n保险貌似公司的Laya也有欧洲旅行的保障。不过我我还自己买了Chill的。可以去网上搜promotion code，还能打9折。最后是23.54欧一年。保险我打印了个人信息页 和 保额，把感觉有用的都打了，不过最后工作人员只抽走几张。\nBank statements 银行流水最好是爱尔兰当地银行的。我因为办银行卡比较慢，因此只有中国银行的。需要在现场手写一个cover letter给大使馆解释一下。我也提供了我的payslips佐证收入。\n最后的有效期只有3个半月，也是很扣了。虽然我在邀请信里写我每月都要过去。而且之前有4个月的比利时申根学生签。不过据说第二次办就会给2年的，等我签证快过期就去办。\n因为我在打工。Leave permission from the employer 就找HR要了一个，没有具体日期，因为我想经常过去。内容大概是会用25天年假和居家办公覆盖离开爱尔兰的时间。另外HR也提醒我，最多2周在另外一个国家工作。不知超了会有啥影响。\n\n","categories":["dairy"],"tags":["travel"]},{"title":"巴黎","url":"/2019/09/30/Paris/","content":"上周五赶上了9月27日比利时的法语区节日，学校放假，连上周末，我们恰好有3天的假期。在上上周从阿姆斯特丹回来的火车上，我们就定下了本次的去巴黎之旅。本次旅行的成员有：我、zfn、lsd、wyd。\n总的感受是：我太喜欢巴黎了，我爱巴黎.\n在这里，我深刻地感受到法国的文化自信。\n\n 第一天\n周五一大早，我们先乘火车到达Bruxell Nord站，转乘FlixBus直达巴黎。之所以坐大巴去，主要还是因为穷。最快的方式是 大力神火车，但需要99欧。大巴只需要15欧，缺点就是舒适性不足、速度慢。到达巴黎已经是下午1点半了。我们先买了巴黎公共交通的3天旅行通票，1-3Zone的。巴黎的行政区域划分为很多区，但交通系统分为5区，类似北京的二环、三环、四环、5环。买票可以选3区或5区。3区基本上可以满足大多数旅行需求，除了西北的莫奈花园和西南的凡尔赛宫。\n我们没有选择直接去青旅放行李，而是一鼓作气开始了市区的旅行。依次参观了巴黎圣母院、先贤祠，晚上吃了正宗的法餐，放了行李后又游览了凯旋门和埃菲尔铁塔。\n巴黎圣母院由于被烧毁还在修复，所以无法参观。我们仅在远处瞻仰了这座巴黎最有名的教堂。巴黎圣母院可以算是巴黎的地标，因为雨果的作品而名扬天下。即时被毁了，仍然是游客留念的必经之地。我们在被巴黎圣母院前合了影。从侧面可以看到正在修复的工程，之前从新闻上还不了解真正的损坏程度，近距离看的时候才发现，真的是毁了大半。修复工作需要持续数年，但愿之后我还有机会再次来到此地。\n\n先贤祠是法兰西民族纪念民族伟人的地方。地宫中摆放着很多我们耳熟能详的人的遗体，如伏尔泰、卢梭、雨果、居里夫人、戴高乐（遗体没进来，但名字进来了）等。地位有点像我国的“八宝山”。\n先贤祠位于一处高地，相比周围的建筑物可算宏伟。正门的门廊上刻着“伟人，祖国感谢你们”几个大字。在这里，我们也第一次感受到了巴黎的善意，我们凭借着比利时的D类签证，算是18～25岁的在欧洲居住的青年，国家维护的博物馆和景点全部免费。之后的凯旋门、卢浮宫、凡尔赛宫均免费。埃菲尔铁塔对所有12～24岁的Youth半价。\n正殿里用壁画讲述了巴黎的主保圣人 圣女日南斐法 的事迹。同时还摆放着著名的“科博拜”，1851年科博用这个摆证明了地球的自转。以往只在教科书上看到的照片，如今却身临其境。这种感觉还是很奇妙的。\n\n\n浏览完后，大家都已饥肠辘辘。所以我们去吃了法餐。\n法餐算是欧洲餐饮的扛把子，高端的代名词，以往只有贵族才有时间和钱吃这些。共分为前菜、正餐、和 甜点，吃完差不多要一个小时。虽然量比较大，但时间长，也还是能吃完的。我们在巴黎共吃了3顿法餐，我也吃了3只鸭腿。\n\n晚上我们参观了凯旋门和埃菲尔铁塔。\n凯旋门是著名的爱国主义教育景点。让我们在凯旋门上祝祖国母亲70周年生日快乐。\n看到凯旋门，我就想起阿汤哥在碟中谍6中骑着摩托环绕凯旋门的场景。可能是晚上来到这里，所以并没有想象中的宏伟和金碧辉煌。经过漫长的楼梯登顶后，可以看到以凯旋门为中心的巴黎夜景，整个街道以放射状铺开，远处的爱丽舍宫和埃菲尔铁塔清晰可见。\n\n晚上的埃菲尔铁塔真的是太美了。真个塔身都被明亮的黄灯所笼罩，每到整点还会有不断闪亮的白灯出现。查过周五地铁凌晨2点45才关门后，我们放心大胆地继续玩了。埃菲尔铁塔也知道12点45关门。事实上，当我们回到旅店，已经是1点了。\n虽然铁塔景区和战神广场参观免费，但登顶的电梯票必须买，好在我们还年轻，只需要12.7欧每人。\n铁塔上的观光区共分为second floor和TOP，其中TOP是真正意义上的塔顶，而second floor是底座的顶端。在塔顶，我们可以眺望整个城市。巴黎夜景尽收眼底，我脑中的多巴胺也不断分泌。来此求婚、拍婚纱照、羞羞的人也络绎不绝，我们竟然都遇到了。唯一要注意的是，塔上风很大，晚上多穿点。我们已经被吹成傻x了。\n\n 第二天\n今天的日程以步行为主。\n我们先后参观了卢浮宫、协和广场、香榭丽舍大街，并在塞纳河上做了游船。\n卢浮宫 是世界三大博物馆之首，也是世界上每年参观人数最多的博物馆。其余2个分别是 纽约的大都会博物馆，伦敦的大英博物馆。都是殖民和掠夺世界的列强，在他们的博物馆内可以看到整个世界的珍宝，其中也不乏从中国抢的宝物。16年时有幸去过大英博物馆，算上卢浮宫，我也算是打卡2/3了。希望以后有机会去纽约玩。\n卢浮宫宫内藏有“世界三宝”：蒙娜丽莎、断臂维纳斯、胜利女神。尤其是蒙娜丽莎，参观队列很长，每个人观看的时间也有所限定。整个博物馆很大，如果有时间的话，参观3天都是没问题的。由于我们本身只是游客，基本上也是走马观花，在重点藏品面前打个卡。在这里，你真的可以看到很多之前只能在教科书上看到的作品，如 历史课本中的 自由引导人民、拿破仑给皇后假加冕、蒙娜丽莎、断臂维纳斯，英语必修三的封面 贝聿铭金字塔。\n\n\n\n午饭照例吃了法餐，我继续吃了鸭子。\n\n饭后我们前往了 协和广场 和 香榭丽舍大街 步行。协和广场并没有想象中的大，也只有一个“人民纪念碑”可供观看。香榭丽舍大街 与 香榭丽舍公园紧邻，也与爱丽舍宫相邻。这也是法国总统居住和办公的地方，所以戒备森严，公园也根本进不去，我们很失望。\n\n在大街上短暂休息后，我们步行前往塞纳河岸码头乘坐游船。\n塞纳河因周杰伦的《告白气球》而名扬中华，我可以在塞纳河上乘坐游船，真是太棒了。巴黎城最早就是沿着塞纳河发展起来的，所以大多数历史古迹和地标建筑都位于河的两岸。由于太累了，我一上船就睡着了，直到快结束才醒来。14欧的船票大约睡了10欧的，也算是超值不菲的一觉。好在没有错过最后的埃菲尔铁塔，白天的埃菲尔铁塔有别样的壮美。完美体现了法国在第二次工业革命后的钢铁产能之大。在河中看岸边的铁塔，让我想起了红警中苏军磁化埃菲尔铁塔的任务。游戏设计者真是匠心独具，将这一著名铁塔和磁暴线圈结合起来。\n\n 第三天 凡尔赛宫\n凡尔赛宫 是今天的绝对主题，也不辜负我们花一整天时间在它上面。由于之前的通票买的是3圈内的，无法去5圈的凡尔赛宫，我们早上又买了去凡尔赛宫的return tickets. 去凡尔赛的交通十分方便，地铁可以直达。事实上，步行从巴黎市中心来此也只需要4小时。法国大革命爆发时，正是来自巴黎的愤怒的市民将凡尔赛宫包围，将当时的国王路易十六挟持至巴黎，结束了凡尔赛宫作为王宫和王权象征的历史。我很喜欢的一首歌Viva La Vida即是以第一人称的口吻描述路易十六的遭遇。路易十六和玛丽皇后也因叛国罪被国民议会在断头台铡死。\n来此之后发现参观人数众多，光在入口排队就排了一个多小时。不出所料，我们还是免费进。\n著名的镜厅。历史书上的 德意志第一帝国成立，凡尔赛条约签订 均是在这里发生的。\n\n路易十四在位50余年，代表着王权的巅峰。凡尔赛宫也是在他任内完成，并成为国王的王宫和王权象征。宫内也随处可见他的画像和雕塑。历史上的他也是十分自恋的一个人，和乾隆爷有一拼。\n\n\n 第四天\n因为wyd同学下午有课，我们选择了周一上午返回列日。清晨从青旅check out，由于3天通票已经过期，我们买了单程的去FlixBus的Bercy station的票。之后乘坐Bus回到Bruxell，在Nord站内的KFC打发掉午餐，乘IC火车回到列日。\n从Bercy站出发的时候遇到一个小插曲：一名男子试图用身体阻止我们的车出站，好像是有什么诉求，咱也不敢问。车站的保安试图说服和驱逐他，双方用身体反复对抗。经历一些周折，我们才得以出站。\n这里还是有很多不讲理的暴民在。我们要注意自己的安全，不要与之接触，必要的时候要寻求警方的帮助。如果是自己开车的话，千万不要开车门和窗户，把车门锁好，等待救援。\n我在KFC点了6只鸡翅的套餐，因为比较饥饿，感觉还蛮好吃的。不过后来越吃越想念国内的辣翅。这里的炸鸡翅和辣翅有些像，但味道差些。\n比利时有方便学生乘坐火车的GO PASS票，53欧可以乘坐10次，但仅限国内交通，也就是IC车。\n","categories":["dairy"],"tags":["travel","游记"]},{"title":"穷查理宝典 查理芒格的人生智慧","url":"/2024/08/07/Poor-Charlie-Almanack/","content":"每周一本书 18:穷查理宝典:查理芒格的人生智慧\n查理芒格去年底去世，享年99岁。惭愧现在才读集他思想大成的“穷查理宝典”。算是凝结他80年思想智慧的产物，因为原书第三版成书于2008年。最近看了太多的成功学书籍，对未来和自己真是充满了期待和自信。\n读传记，研究那些获得成功的人生和其他那些留下遗憾或者遭遇失败的人生。\n没有一个芒格认识的成功的朋友是不喜欢读书的。\n“迅速歼灭不该做的事情，接着对该做的事情发起熟练的、跨学科的攻击，然后，当合适的机会来临—只有当合适的机会来临—就采取果断地行动”。和“孙子兵法”的思想很像，孙子兵法不愧是三千年的经典，是人类智慧的总结。\n\n简化人物的最佳方法一般是先解决那些答案显而易见的大问题。\n伽利略说，唯有数学才能揭示科学的真实面貌，因为数学似乎是上帝的语言。\n光是正面思考问题时不够的，你必须进行反面思考。\n最好的、最具有实践性的智慧是基本的学术指挥。前提：以跨学科的方式思考。\nlollapalooza效应，通常在几种因素的共同作用下才会出现。\n\n爱因斯坦：我的成就取决于四个因素，首先是自我批评，然后才是好奇心、专注和毅力。\n我只想知道将来我会死在什么地方，这样我就永远不去那儿了。\n后面有多篇演讲稿，内容有些类似，其实是继承关系。第11讲是最长，也是集大成者。\n","categories":["读后感"],"tags":["Reading","穷查理宝典"]},{"title":"编程珠玑 Programming Pearls","url":"/2024/02/05/Programming-Pearls/","content":"豆瓣链接\n计算机编程和软件的经典书籍，成书于1986年，算是计算机的中古时期了，PC时代的开始。因此书中很多例子可能对于“现代”程序员来说，有些陌生和不理解。如对算法的注重、内存的关注、磁盘相关的编程和标准库的放弃使用。有些书中强调的重要概念，如今也已家喻户晓，属于基本能力了。如二分、排序等算法、字符串、BST、堆等数据结构，程序时空复杂度估计和调优。阅读经典，总是有种和大师隔着时空对话的感觉，真是爽快和崇拜。此书常读常新，大学时读过，好像还买过纸质书籍，如今学习编程也有10年时间了，正式进入工业界也快3年了。再次读下来，感觉十分简单，但却如此深刻。经典果然永垂不朽。\n","categories":["读后感"],"tags":["Reading","编程珠玑"]},{"title":"手把手教你 QDII 场外转场内 套利","url":"/2024/01/25/QDII-off-exchange-to-on-exchange-arbitrage/","content":"最近QDII场内基金高溢价大家似乎都听说了。溢价是说，场外基金的市场价格，高于场外基金的净值。疯狂的如 美国50ETF（SH513850）曾达到30+点，日经ETF（SH513520）20+点。普通的也有2个点。基金公司和券商都发布声明说，溢价过高的风险提示。高溢价会导致套利资金过来，然后抹平溢价。套利是说，在场外申购基金，然后转到场内，再卖出。在基金不涨不跌的情况下，至少可以有溢价的收益。正常情况下，因为市场本身的调节作用，对于基金规模大，交易量大的正常基金，如 很多 沪深300ETF(SH510300)，溢价几乎没有。但QDII因为外汇等各种限制，有限购，规模小，交易量小等特点，套利基金并不能自由地无限进行，因此十分容易形成溢价。\n我前几年恰好购买了一些QDII场外基金（标普500ETF SH513500, 纳斯达克100 SH513100, 中概互联网ETF），之前都是直接在场外买卖的。没想过转场内交易。因为虽然套利门槛没那么高，但对于新手来说也不低，操作比平时购买基金难不少。最近的高溢价引起了我的极大兴趣，也在网上查了不少资料和教程，并没有想象中的那么容易和资料多。因此总结于此，方便后人参考。我以我的 场外”易方达e钱包“，场内 ”华泰券商 涨乐财富通“ 为例。其他的场外基金和场内券商，大同小异。之前我那么多QDII直接场外卖出，好亏呀。\n\n\n查询基金TA账户。首页“易方达e钱包” “我的” “账户设置” ，最下面倒数第三项“基金账户”。深圳是98开头的12位数，上海99开头的12位数。\n\n\n建立账户的场内场外连接。“涨乐财富通”，下方按钮 “账户”也面，最下面“更多功能”，搜索“场内外对应关系维护”。办理时间是交易日北京时间9.15-15.45。连接自己的账户即可。\n\n\n咨询证券营业部交易所席位号，深圳6位数，上海5位数。在券商App上可以得到自己营业部和客户经理的联系方式。我的客户经理开户的时候就加了我微信，所以我直接在微信上问了。回复很快。\n\n\n在基金账户上转托管。必须登录官网，手机App不行。点击持有的基金份额后的“详情-转托管”。必须整数份额。2个工作日到券商账户。“涨乐财富通”也有“基金场外转场内”的服务，交易时间交易日北京时间9.30-15.00，但查不到我的基金份额。我理解，只有在券商账户上，场外买的基金才能在这里转。在基金公司或第三方（支付宝、银行、蛋卷雪球）上买的不行，只能去对应的地方转出。\n\n\n到达场内后，就可以在二级股票市场直接卖掉了。相比在场外卖掉，多了溢价的收益。\n\n\n","categories":["Life"],"tags":["money","投资","QDII","套利","场外转场内","Investment"]},{"title":"Queue and Stack","url":"/2019/02/17/Queue-and-Stack/","content":"今天我们一起学习2种重要的数据结构：队列 和 栈。\n本文根据LeetCode上的Explore教程 Introduction to Data Structure - Queue &amp; Stack 整理而成。\n Introduction\n最常用的Collection是数组(Array)，其最常使用的获取数据的操作是随机获取(Random access), 在C++中一般称作 subscribe。\n但是有时，我们想要限制处理数据的顺序。最常见的限制是：先进先出(First in first out), 后进先出(Last in first out)。分别对应2种数据结构 队列(Queue) 和 栈(Stack)。\n我们从 定义、实现 和 每种数据结构的内置操作 分别学习 队列 和 栈。\n学习目标：\n\n理解数据处理顺序FIFO和LIFO的原则；\n手动实现数据结构；\n熟悉语言内置的Queue和Stack；\n解决基础的Queue-related问题，尤其是BFS；\n解决基础的Stack-related问题；\n理解系统的栈如何帮助你，在解决dfs和其他递归问题的时候。\n\n Queue: First-in-first-out Data Structure\n 定义\n先进先出 最普遍的比喻是排队(也就是队列), 最早进入队列的人最早被服务到。\n所以队列总共只有2个modify 方法：\n\nenqueue\ndequeue\n\n 实现\nQueue并不是基础的数据结构，我们可以用内置的数组来实现它。在C++中，Queue是container adapter, 并不是真正的container，其内部其实是deque。\n实现实例：\n#include &lt;iostream&gt;class MyQueue &#123;    private:        // store elements        vector&lt;int&gt; data;               // a pointer to indicate the start position        int p_start;                public:        MyQueue() &#123;p_start = 0;&#125;        /** Insert an element into the queue. Return true if the operation is successful. */        bool enQueue(int x) &#123;            data.push_back(x);            return true;        &#125;        /** Delete an element from the queue. Return true if the operation is successful. */        bool deQueue() &#123;            if (isEmpty()) &#123;                return false;            &#125;            p_start++;            return true;        &#125;;        /** Get the front item from the queue. */        int Front() &#123;            return data[p_start];        &#125;;        /** Checks whether the queue is empty or not. */        bool isEmpty()  &#123;            return p_start &gt;= data.size();        &#125;&#125;;int main() &#123;    MyQueue q;    q.enQueue(5);    q.enQueue(3);    if (!q.isEmpty()) &#123;        cout &lt;&lt; q.Front() &lt;&lt; endl;    &#125;    q.deQueue();    if (!q.isEmpty()) &#123;        cout &lt;&lt; q.Front() &lt;&lt; endl;    &#125;    q.deQueue();    if (!q.isEmpty()) &#123;        cout &lt;&lt; q.Front() &lt;&lt; endl;    &#125;&#125;\n 循环队列 Circular Queue\n在之前的实现中，p_start之前的内存空间是被浪费掉的。为了充分利用，我们可以在内部使用循环利用array。\nCircular Queue也叫做&quot;Ring Buffer&quot;。\nRing Buffer的实现：\nclass MyCircularQueue &#123;    vector&lt;int&gt; data;    int head;    int size;public:    /** Initialize your data structure here. Set the size of the queue to be k. */    MyCircularQueue(int k) &#123;        data.insert(data.begin(), k, 0);        head = 0;        size = 0;    &#125;        /** Insert an element into the circular queue. Return true if the operation is successful. */    bool enQueue(int value) &#123;        if (isFull())            return false;                data[(head + size) % data.size()] = value;        size++;        return true;    &#125;        /** Delete an element from the circular queue. Return true if the operation is successful. */    bool deQueue() &#123;        if (isEmpty())            return false;                head = (head + 1) % data.size();        size--;        return true;    &#125;        /** Get the front item from the queue. */    int Front() &#123;        if (isEmpty()) return -1;        return data[head];    &#125;        /** Get the last item from the queue. */    int Rear() &#123;        if (isEmpty()) return -1;        return data[(head + size - 1) % data.size()];    &#125;        /** Checks whether the circular queue is empty or not. */    bool isEmpty() &#123;        return size == 0;    &#125;        /** Checks whether the circular queue is full or not. */    bool isFull() &#123;        return size == data.size();    &#125;&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue* obj = new MyCircularQueue(k); * bool param_1 = obj-&gt;enQueue(value); * bool param_2 = obj-&gt;deQueue(); * int param_3 = obj-&gt;Front(); * int param_4 = obj-&gt;Rear(); * bool param_5 = obj-&gt;isEmpty(); * bool param_6 = obj-&gt;isFull(); */\n Queue的应用\n最典型的应用，BFS。\nBFS(Breadth-first Search)一般用来发现从根节点到目标节点的最短距离。\n应用BFS的场景：\n\ndo traversal\nfind the shortest path\n\n场景中常使用的数据结构：\n\n图\n树\n\n在具体应用中，BFS里的节点可能是真正的节点或状态，边可能是真正的边或状态间的转移。\nBFS的模版，一定要背下来，以后面试或做题提高速度和bug-free的可能。\n template 1\n/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) &#123;    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    // BFS    while (queue is not empty) &#123;        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) &#123;            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) &#123;                add next to queue;            &#125;            remove the first node from queue;        &#125;    &#125;    return -1;          // there is no path from root to target&#125;\n template 2\n/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) &#123;    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    Set&lt;Node&gt; visited;  // store all the nodes that we&#x27;ve visited    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    add root to visited;    // BFS    while (queue is not empty) &#123;        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) &#123;            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) &#123;                if (next is not in used) &#123;                    add next to queue;                    add next to visited;                &#125;                remove the first node from queue;               &#125;        &#125;    &#125;    return -1;          // there is no path from root to target&#125;\n\n在每一轮中，队列中的节点都是等待被处理的。\n没经历一次外层的while循环，都离root更远一步， step++。\n\n template 2\n在图中，确保每个节点不被多次访问很重要。否则BFS会陷入无限循环。此时，我们增加一个hashset用来标注是否节点已经被访问到。\n/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) &#123;    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    Set&lt;Node&gt; visited;  // store all the nodes that we&#x27;ve visited    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    add root to visited;    // BFS    while (queue is not empty) &#123;        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) &#123;            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) &#123;                if (next is not in used) &#123;                    add next to queue;                    add next to visited;                &#125;            &#125;            remove the first node from queue;           &#125;    &#125;    return -1;          // there is no path from root to target&#125;\n什么情况下可以不使用visited呢？\n\n你确定不会出现重复访问的情况。比如，遍历树的时候。\n你确实想要把一个节点加入队列多次。\n\n 栈 Stack\n提到栈，我就想起周杰伦的《七里香》。歌中唱到，\n\n雨下整夜，我的栈溢出就像雨水。\n\n在LIFO数据结构中，最新被添加的元素最早被处理。在栈中，添加元素的操作叫做push(压栈)，移除元素的操作叫做pop（弹出）。虽然在C++中，queue的操作也是同样的名字，但在大多数语言中，push 和 pop是stack专有的。\n像队列一样，绝大多数语言提供了built-in的stack库，你不需要重复造轮子，只需要熟悉stack的常用操作，包括 push, pop, top（获取栈顶元素）。\n 单调栈的应用\nhttps://leetcode.com/explore/featured/card/queue-stack/230/usage-stack/1363/\nIntution: 维护一个单调递减的栈，遍历一遍数组T，如果将其放入栈中，把栈中比它小的元素都pop出来，并计算出相应的间隔。\n时间复杂度：O(n),\n空间复杂度: O(n).\nclass Solution &#123;public:    vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123;        vector&lt;int&gt; result(T.size(), 0);        stack&lt;pair&lt;int, int&gt;&gt; s; // temperature, day        for (int i = 0; i &lt; T.size(); ++i) &#123;            while (!s.empty() &amp;&amp; s.top().first &lt; T[i]) &#123;                pair&lt;int, int&gt; current = s.top();                result[current.second] = i - current.second;                s.pop();            &#125;            s.push(&#123;T[i], i&#125;);        &#125;                return result;    &#125;&#125;;\n stack 和 DFS\nDFS是stack的重要应用之一，可以用来寻找从根节点到目标节点的路径(注意不一定是最短)。DFS是回溯的一种算法，只有到达最深的节点才进行回溯，尝试其他路径。\n DFS 模版 1，递归版本\n/* * Return true if there is a path from cur to target. */boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) &#123;    return true if cur is target;    for (next : each neighbor of cur) &#123;        if (next is not in visited) &#123;            add next to visted;            return true if DFS(next, target, visited) == true;        &#125;    &#125;    return false;&#125;\n DFS 模版 2，迭代版本\n递归版本的优点是实现起来更加简单。缺点是，如果递归深度太深，会stack overflow。\n这时，你可能会想要用 BFS 或者 用显式的栈实现DFS。\n/* * Return true if there is a path from cur to target. */boolean DFS(int root, int target) &#123;    Set&lt;Node&gt; visited;    Stack&lt;Node&gt; stack;    add root to stack;    while (s is not empty) &#123;        Node cur = the top element in stack;        remove the cur from the stack;        return true if cur is target;        for (Node next : the neighbors of cur) &#123;            if (next is not in visited) &#123;                add next to visited;                add next to stack;            &#125;        &#125;    &#125;    return false;&#125;\n实现的逻辑和递归解法相同。只不过我们使用while循环和显式的stack来模仿系统栈。\n Implement Queue using Stacks\n用栈来实现队列。\n我记得在程序员面试金典上遇到过一样的题目，感觉是一道很经典的题目。需要面试者对队列和栈都非常熟悉才行。\nIntuition: 队列是FIFO，栈是LIFO，所以我们可以用2个栈来实现一个队列。定义将一个栈装入另一个栈的操作为颠倒。我们可以通过颠倒, 将LIFO变为FIFO，而且只有在需要dequeue的时候，才需要做颠倒的操作。\nclass MyQueue &#123;    stack&lt;int&gt; a, b;public:    /** Initialize your data structure here. */    MyQueue() &#123;            &#125;        /** Push element x to the back of queue. */    void push(int x) &#123;        a.push(x);    &#125;        /** Removes the element from in front of queue and returns that element. */    int pop() &#123;        if (b.empty()) &#123;            while (!a.empty()) &#123;                b.push(a.top());                a.pop();            &#125;        &#125;        int ret = b.top();        b.pop();        return ret;    &#125;        /** Get the front element. */    int peek() &#123;        if (b.empty()) &#123;            while (!a.empty()) &#123;                b.push(a.top());                a.pop();            &#125;        &#125;        return b.top();    &#125;        /** Returns whether the queue is empty. */    bool empty() &#123;        return a.empty() &amp;&amp; b.empty();    &#125;&#125;;/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * bool param_4 = obj.empty(); */\n Implement Stack using Queues\n那么如何用FIFO实现LIFO呢？解法可能不是那么明显，但却十分简单。每次push时，都把队列里的元素重新入对一遍，就把最后入对的放到第一个位置了。\n 总结\ndfs 和 bfs 属于想法简单，但实现起来不容易，尤其是bug-free并且快速地实现更属不易。\n由于考察的编程基础涉及广泛，面试官也特别喜欢考类似的题目。几个模版必须熟练背会才行。\n队 和 栈 更是基础的数据结构。在计算机科学中随处可见，虽然很多时候不会直接考察，但很多算法都要用到。熟练手写stack 和 queue 和使用built-in的stack 和 queue是每个合格程序员的基础。\n","categories":["Programming"],"tags":["LeetCode"]},{"title":"现实不似你所见 量子引力之旅","url":"/2024/03/01/Reality-Is-Not-What-It-Seems-The-Journey-to-Quantum-Gravity/","content":"豆瓣链接\n又一本读起来很爽，欲罢不能的书。除了熟悉的希腊哲学到经典物理，再到现代物理（相对论和量子物理）的故事（书中讲的相对简略些，但有不同的角度。这部分也可以看曹天元的“上帝掷骰子吗&quot;，同样十分精彩，讲的故事更多），本书主要重点讲了最前沿的“圈量子引力学”，也即试图融合相对论和量子力学的一个理论。作者目前更相信这个圈理论，而不是当今火热的弦/膜理论。当然，这些是已知和未知的交界，目前还没有绝对的优势和证据确定哪方是正确的。\n曾经年少时，也有物理梦。从初中，正是接触开始，到高中时达到顶峰。自认为还有些聪明，对科学十分感兴趣，物理当然是科学王冠上的明珠。那种解释和预测世界的能力，还有不断颠覆你世界观的发现，令人颅内高潮迭起。那些物理先贤们的故事，充满了吸引力和震撼，令我崇拜和向往。不是生物、化学、地理这些可以比拟的。可能也就数学可以更牛逼吧。当然，最终还是从理想主义，越来越现实主义了。大学还是选了赚钱多，好找工作的计算机专业。从此”一入侯门深似海，从此萧郎是路人“, 转眼已过10年时间。不过选择还是正确的，一路上见了太多物理转码的朋友。当然也有坚持物理道路的同学，在做高能物理，也有做量子计算机的。所以，作为爱好物理和科学的门外汉，很享受这种阅读物理科普书籍的感觉，那种更新的哲学和视角，让人可以不在乎现实世界的烦恼，单纯享受作为智慧生命的快乐。\n","categories":["读后感"],"tags":["Reading","现实不似你所见-量子引力之旅"]},{"title":"SSD: Single Shot MultiBox Detector 配置使用总结","url":"/2017/01/12/SSD-Single-Shot-MultiBox-Detector-configuration/","content":" 实验环境\n\nUbuntu 16.04\nCPU only (自己的机器上没有NVIDIA的卡, AMD说起来都是泪.)\n\n 环境配置\n基本上是按照官方文档. 这里只展示与文档中不同的部分.\n\n Makefile.confile\n\nline 8: CPU only\nline 79, 80: support for python3\nline 81: /usr/lib/python3.5/dist-packages/numpy/core/include -&gt; /usr/local/lib/python3.5/dist-packages/numpy/core/include\nline 95: fix fatal of hdf5\n\n 遇到的问题\n\n./include/caffe/util/hdf5.hpp:6:18: fatal error: hdf5.h: No such file or directory\n\n应该只有Ubuntu15.10+的版本才会遇到这样的问题, 原因是hdf5的头文件和库的路径在新版本中发生了改变.\n解决方法\n\n/usr/bin/ld: cannot find -lopenblas\n\n$ locate libopenblas.so/usr/lib/libopenblas.so.0$ sudo ln -s libopenblas.so.0 libopenblas.so\n参考\n\n/usr/bin/ld: cannot find -lboost_python3\n\n解决方法\n"},{"title":"SSH 通过跳板机登陆服务器","url":"/2021/03/26/SSH-proxy-by-jump-server/","content":" 动机\n接上篇解决台式机Ubuntu VPN访问公网资源的问题后，我尝试了配置跳板机访问杭研院机器。\n在科研工作中，MAC笔记本无法连接OpenVPN，从而访问杭研院机器。我的台式机Ubuntu已经配置好了VPN，可以访问服务器。我现在想通过台式机Ubuntu中转，从而实现MAC“直接”访问杭研院。抽象一下问题为：\n\nA可以访问B\nA不可以访问C\nB可以访问C\n我现在想A访问C\n\n由于工作中主要使用SSH，因此，问题简化成A通过SSH直接登陆C。\n我经过不屑的网上搜索和尝试，总结了2中技术和方法实现我的目的。\n\nSSH 代理\nSSH 隧道\n\n\n SSH 代理\n这种方法最简单，不需要在B上进行任何操作，无缝连接C。\nA上执行，其中rentao@10.134.150.154是B，ldmc@192.168.131.181是C。\nssh -o &quot;ProxyJump rentao@10.134.150.154&quot; ldmc@192.168.131.181\nReference: 穿越跳板机\n SSH 隧道\nB上执行:\nssh -f -N -L 0.0.0.0:9906:192.168.131.181:22 ldmc@192.168.131.181\nA上执行:\nssh -p 9906 ldmc@10.134.150.154\n虽然这种方法看起来更麻烦些，需要A B协作。但是相比第一种方法，其实更加灵活。可以通过SSH 隧道的方式通过B中转暴露更多C的服务（如观察训练数据的tensorboard HTTP服务也是我常需要暴露的），并不一定是SSH登陆。\nReference: SSH 端口转发：SSH 隧道\n","categories":["折腾"],"tags":["tech"]},{"title":"Hexo 创建中英文博客","url":"/2021/09/07/Setup-English-blog/","content":"自从来到亚马逊工作，接触英文和外国同事比较多。锻炼使用英语的需求越来越大。而且为了和国际接轨，我决定创建自己的英文博客。\n 步骤\n以中文博客为模版，创建英文博客。\ncp -r Hexo HexoEn\n\n删除HexoEn中没用的中文博文和资源。\n在Github创建一个新repo：“en”.\n修改HexoEn _config.yml配置文件。注意部署分支为gh-pages, 这个GitHub默认的pages分支，如果不同的话，需要去repo的Setting-&gt;Pages配置一下你自定义的分支:\nlanguage: - endeploy:  type: git  repo: git@github.com:YoungForest/en.git  branch: gh-pagestheme_config:  menu:    home: / || fa fa-home    about: /about/ || fa fa-user    tags: /tags/ || fa fa-tags    categories: /categories/ || fa fa-th    archives: /archives/ || fa fa-archive    中文: https://youngforest.github.io || fa fa-language # 图标可以去该网站搜索：https://fontawesome.com/v4.7/icons/\n中文Hexo _config.yml配置文件:\nlanguage: - zh-CN- entheme_config:  menu:    home: / || fa fa-home    about: /about/ || fa fa-user    tags: /tags/ || fa fa-tags    categories: /categories/ || fa fa-th    archives: /archives/ || fa fa-archive    English: https://youngforest.github.io/en/ || fa fa-globe\n这样中英文博客就可以在Menu互相外链了。\n部署博客，看看效果如何。\nhexo generate -d\n把HexoEn也推到远端，做保存和同步。注意，这里和deploy用的是同一个repo, 但是不同的分支。\ngit remote remove origingit remote add origin git@github.com:YoungForest/en.gitgit push -u origin master\n 最后的效果\n中文博客：https://youngforest.github.io\n英文博客：https://youngforest.github.io/en/\n","categories":["折腾"],"tags":["Hexo"]},{"title":"食南之徒 马伯庸","url":"/2024/10/20/Shi-Nan-Zhi-Tu/","content":"每周一本书24：食南之徒 马伯庸\n作者貌似是在借汉朝的南越问题，映射台湾问题。马伯庸还是那么擅长，借用史书上的只言片语，脑补出完整的悬疑故事。之前的“两京十五日”，“长安的荔枝”都是如此。\n十分不错的长篇小说，尤其是对食物的描写，让人感到真诚和流口水。就是结局过于悲惨，“甘蔗”一家人都死了。悬案也终究没有告破和昭雪，虽然读者们和男主都知道真相了，迟到20+年的惩罚，也来的太迟了。男主要是再晚几年，凶手就善终了。但仍然作威作福那么多年，害了不少人。\n狐死首丘，万里运枣树苗，孤宫独守。赵佗 的这些情感，作为一个离开家乡10年有余，如今甚至流落海外的移民，真是感同身受，都要哭死了。但我也如同赵佗，也知道，回不去了。记忆中的故乡已经远去，即使勉强回去以减思乡之愁，也是无济于事，反而带来更大的痛苦。因为现实的家乡，和你想象中的，其实是完全不同的。思乡的人，总是美化这些。记吃不记打，好了伤疤忘了疼。过去没有想象中那么美好，现在没有想象中那么不好，未来远比想象中要好。\n","categories":["读后感"],"tags":["Reading","食南之徒","马伯庸"]},{"title":"太白金星有点烦 马亲王解构西游记","url":"/2024/08/21/Tai-bai-jin-xing-you-dian-fan/","content":"马伯庸新作，十分，推荐。后记中说是消遣之作，读起来也确实畅快和消遣,2天读完，爱不释手。私认为质量仅次于长篇“古董局中局”，超过“两京十五日”，“长安十二时辰”和“长安的荔枝”，“我读书少，你可别骗我”，“显微镜下的大明”。亲王的书，我也是读了不少。算是最喜欢的当代中国作家了。一个作家的书能让我读这么多的，国外还有一个“东野圭吾”，国内还有一个“金庸”。\n解构了经典四大名著之“西游记”，凭借对人性和官场的洞察，写的故事反而比原版更有说服力，也更符合现代叙事。其中的冤假错案，山头斗争，权力制衡，发挥的淋漓尽致。很早就听说过一种说法（大概是早年知乎上看到的），孙悟空之所以大闹天宫，是被天庭刻意为之的，趁此各个部门把锅甩给齐天大圣，尤其是地府的“生死簿”，估计本身就是很多漏洞，趁此销毁证据。“太白”恰好把此观点发扬光大，借取经表演，也揭露500年前大闹天宫的真相。扩展成一部10万字的中篇小说。读起来诙谐幽默，让人捧腹，但细思又极恐。其中不乏揭露现实，或借古讽今之意，但也充满着“马伯庸”一贯的悲天悯人，悬疑反转。\n","categories":["读后感"],"tags":["Reading","太白金星有点烦"]},{"title":"腾讯 微信事业部 暑期实习生 面试","url":"/2020/03/11/Tencent-WeChat-backend-intern-interview/","content":" 一面\ntime: 2020-03-11 10:28:43\n上周HR联系沟通了下意向工作城市，但是没约具体面试时间。\n昨晚8点半忽然接到广东深圳的电话，问是否方便，直接开始了面试（惊不惊喜，刺不刺激？）。面试官网还不太好，中间出了不少问题。比如手撕代码时，对方网站内容不能及时刷新。\n 计算机基础\n 分布式、深度学习\nBN层，dropout。如何计算？\nBN: mean, valence。\n单机训练 和 多机训练 区别。\n多机训练时，如何把各个单机得到的loss reduce下。\n数据并行训练 和 模型并行训练。\n百亿级特征训练。百亿级是指？\n 语言基础 C++\nhashtable实现\nshared_ptr, unique_ptr, weak_ptr 区别\nmove语义\n 算法题\n二叉树深度。\n二维数组，横竖都非递减，寻找目标值。O(m + n)。leetcode240\n 反问\n问题：贵组的工作内容，为何问如此多深度学习和分布式的问题？\n答：大规模分布式训练框架，技术栈：C++，Python\n 二面\ntime: 2020-03-17 21:59:18\n等了一周，终于等来了第一个复试。和上次面我的面试官是同组的。应该是因为技术栈比较契合，所以被分布式训练框架组把简历给捞出来了。\n首先问了很多项目和实习经历相关的内容。比如最有挑战性的任务，遇到的困难，怎么解决的？我按照传说中的STAR方法回答了，但是面试官好像并不是很满意。我平时最不擅长讲这些，面试多了也学会一点。还是手撕代码来的干脆和直接（以Google为代表，上来就是干），就像八股文一样，也好准备。\n基础知识:\n\nshared_ptr, unique-ptr的区别\n死锁的必要条件和解决方法\nTCP，UDP的区别\nTCP如何保证可靠\n\n分布式：\n\npytorch的架构、类和C++接口的封装，语言之间的调用\n多机多卡训练如何更新参数\n\n算法题：\n给定一个很长的有序数组，和另一个无序数组，将无序数组插入有序数组中，需要保证结果仍然有序。\nGiven sorted vector sorted_a and unsorted vector b;   size of a is about 1G\nvector sorted_a;\nvector b;\ninsert b to sorted_a as fast as possible, result sorted_a should be sorted, too.\nvoid insertSortedVector(vector&lt;int&gt;&amp; sorted_a, vector&lt;int&gt;&amp; b) &#123;    if (sorted_a.emtpy() || b.empty()) return;        sort(b.begin(), b.end());        int a_tail = sorted_a.size() - 1;        int b_tail = b.size() - 1;        sorted_a.resize(sorted_a.size() + b.size()); // 可能有 sorted_a.size()        int after_tail = sorted_a.size() - 1;        while (a_tail &gt;= 0 &amp;&amp; b_tail &gt;= 0) &#123;            if (sorted_a[a_tail] &gt; b[b_tail]) &#123;            sorted_a[after_tail] = sorted_a[a_tail];            --a_tail;        &#125; else &#123;            sorted_a[after_tail] = b[b_tail];            --b_tail;        &#125;        --after_tail;    &#125;    while (b_tail &gt;= 0) &#123;        sorted_a[after_tail] = b[b_tail];        --b_tail;        --after_tail    &#125;&#125;\nTime: O(a.size() + b.size() * log b.size())\nSpace: O(1)\n写完代码后让我不停的优化，提示不是在时间复杂度级别的优化。我找了好几处（上面的代码是我的最终版本），最后才让面试官满意。\n 三面\ntime: 2020-03-19 09:06:13\n昨天下午刚刚结束二面，今天下午接到HR的电话，约了晚上8点的面试。通过牛客网的平台，视频面试+手撕代码。共1个小时20分钟。\n上来简短的自我介绍之后就开始了手撕代码了，我喜欢。共4道题目,都不难，LeetCode Easy/Medium水平。就是前2题一定要用C写比较不舒服。\n手撕了50min代码，开始基础知识问答，包括操作系统、计算机网络、数据库、数据结构等。面试官那里估计有一个问题列表，问的很快，很多。我回答后就记下些什么。我没有准备过计算机基础的面试内容，全靠本科时认真学习残留下来的那些知识。大多数都足够了。印象深刻的只有没答上来的：\n\nTCP 拥塞控制 和 流量控制 的区别和实现\n数据库中 聚簇索引 和 普通索引的区别\nIO的异步、阻塞、多路复用 的区别\n\n接下来又问了之前的实习和项目经历。我写了5个，问了3个，问的还很细。\n问完之后，面试官很干脆的就结束了面试。我从高强度的面试状态中久久不能恢复。\n3次面试2次都是晚上进行，加班状态可以看到。只有3面的面试官开了视频，看到大佬的发际线，我感觉自己实力实在太弱了。\n 四面\ntime: 2020-03-19 23:53:31\n昨天晚上刚刚结束了三面，今天早上收到四面的电话，约了晚上的面试。\n上来先刚了3道算法题，我喜欢。\n- 递增循环整数数组，从里面找出最小的元素\n\n在二叉排序树上面找出第3大的节点\n打印变长为n的回形矩阵\n\n然后就问了项目和实习经历，快手的2个项目和HAWQ修改BUG的经历。\n问了面试官，join.qq.com上的状态为什么只有1次面试的状态。\n答曰：同一个候选人，会被不同的组挑到，然后面试。怪不得1面、2面 和 3面、4面无论是面试风格、问题、还是平台都有所区别。\n1、2面是明显的分布式框架组的。3、4面可能不是，忘记问了。\n下午还参加了微软SWE intern的面试，当时就觉得凉了，晚上果然收到Thank you Letter. 一首凉凉送给自己。秋招加油，再接再厉！\n 五面\ntime: 2020-03-20 17:40:42\n今天面完米哈游后，正在做快手的评测，忽然收到要半个小时后5点的电话面试。\n说实话，面到第五面我已经心力交瘁了，想要疯狂吐槽了。不过五面十分简单，只持续了15min。\n自我介绍 + 项目 + 计算机基础。\n计算机基础问了三、四面我没答上来的问题，应该是故意的。不过好在我每次面试完都会进行总结，复习没答上来的知识。\n你认为你的优点和缺点是啥？\n\n优点：计算机基础扎实、算法没问题\n缺点：不适合科研，创新、创造能力不足\n\n之前实习换公司的原因。\n可以实习的时间和方式？\n接下来等HR面。\n他是 微信搜索服务 组的。三、四面 也是。前2面是分布式框架组的，无论是面试方式还是内容都有所不同。他说应该是 分布式训练框架组 我没过，然后简历释放出来给了他们组。他只能看到三、四面的面试评价，跨组的就是不透明的。我确实对分布式训练的基础知识和经验不足。\n我也能理解为啥要有5次面试了。\n 七面\ntime: 2020-03-31 19:22:14\n上周三约了HR面试，闲聊了半天，和技术面的套路差别很大。因为我说我实习想在北京，所以又约了这周一（今天）下午的一次北京同事的技术面试。北京这边应该就只有一个技术面试，还有HR面试。\n视频面试采用牛客网平台，分为 项目、算法、数据结构、计算机基础。\n 算法题\n\n逛街\n小Q在周末的时候和他的小伙伴来到大城市逛街，一条步行街上有很多高楼，共有n座高楼排成一行。\n小Q从第一栋一直走到了最后一栋，小Q从来都没有见到这么多的楼，所以他想知道他在每栋楼的位置处能看到多少栋楼呢？（当前面的楼的高度大于等于后面的楼时，后面的楼将被挡住）\n输入描述\n输入第一行将包含一个数字n，代表楼的栋数，接下来的一行将包含n个数字wi(1&lt;=i&lt;=n)，代表每一栋楼的高度。\n1&lt;=n&lt;=100000;\n1&lt;=wi&lt;=100000;\n输出描述\n输出一行，包含空格分割的n个数字vi，分别代表小Q在第i栋楼时能看到的楼的数量。\n示例1\n输入\n6\n5 3 8 3 2 5\n输出\n3 3 5 4 4 4\n说明\n当小Q处于位置3时，他可以向前看到位置2,1处的楼，向后看到位置4,6处的楼，加上第3栋楼，共可看到5栋楼。当小Q处于位置4时，他可以向前看到位置3处的楼，向后看到位置5,6处的楼，加上第4栋楼，共可看到4栋楼。\n\nLeetCode medium难度，秒杀，正反使用2次单调递减栈即可。需要注意的是，看到的楼包括当前楼，所以当前楼会正反计算2次，最后需要减1。\n#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;iostream&gt;using namespace  std;int main() &#123;    int n;    cin &gt;&gt; n;    vector&lt;int&gt; height(n);    for (int i = 0; i &lt; n; ++i) &#123;        cin &gt;&gt; height[i];    &#125;    vector&lt;int&gt; ans(n, 0);    stack&lt;int&gt; s;    auto process = [&amp;](int i) -&gt; void &#123;        while (!s.empty() &amp;&amp; height[s.top()] &lt;= height[i])  &#123;            int t = s.top();            s.pop();            ++ans[i];        &#125;        s.push(i);        ans[i] += s.size();    &#125;;    for (int i = 0; i &lt; n; ++i) &#123;        process(i);    &#125;    while (!s.empty()) &#123;        s.pop();    &#125;        for (int i = n - 1; i &gt;= 0; --i) &#123;        process(i);    &#125;    for (int i = 0; i &lt; n; ++i) &#123;        -- ans[i]; // delete repeated self(count twice)        cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        return 0;&#125;\n 数据结构\n设计一个支持序列化和反序列话的HashMap。我之前没有接触过类似问题，了解过一些序列化的知识。就设计了一个 线型探查版 的hashmap, 因为这样所有数据都可以存储在一个数组中，方便序列化。\n为了方便实现，并没有考虑泛化和扩容，虽然提前和面试官沟通过。面试官还是抨击了线型探查对空间利用有问题，说是单个bucket中有过多元素时会有问题。对此我并不苟同，然后有讨论了半天。最后他有怼我说，没别人实现的好，insert时没有考虑扩容。因为我之前已经和他沟通过不考虑扩容和泛化以简化问题。对此，面试官不免有些为了怼而怼的嫌疑，我是并不信服的。我问他别人怎么实现，主流方法如何？他只是说没有标准答案。\nstruct HashMap &#123;    const int capity = 1 &lt;&lt; 7;    array&lt;int, capity&gt; data;    const int NOT_EXIST = -1;    HashMap() &#123;        memset(data.data(), capity * sizeof(int), -1);    &#125;    void searilize(const string&amp; file_name) &#123;        // 把data内容写到文件中        std::ofstream fout (file_name, std::fstream::binary);        auto&amp; d = static_cast&lt;array&lt;char, capity*sizeof(int)&gt;&gt;(data)        std::copy(d.begin(), d.end(), std::istreambuf_iterator&lt;char&gt;(fout));    &#125;    void load(const string&amp; file_name) &#123;        // 把文件内容读到data中        std::ifstream input(file_name, std::ios::binary );        std::copy(             std::istreambuf_iterator&lt;char&gt;(input),             std::istreambuf_iterator&lt;char&gt;( ),            static_cast&lt;array&lt;char, capity*sizeof(int)&gt;&gt;(data).begin());    &#125;    int get(int key) &#123;        int hashcode = hash(key);        int bucket = hashcode &amp; 6;        for (int i = bucket; i &lt; 1 &lt;&lt; 6; ++i) &#123;            if (data[i] == key) &#123;                return data[i + (1 &lt;&lt; 6)];            &#125; else if (data[i] == NOT_EXIST) &#123;                return NOT_EXIST;            &#125;        &#125;        return NOT_EXIST;    &#125;    void insert (int key, int value) &#123;        int hashcode = hash(key);        int bucket = hashcode &amp; 6;        for (int i = bucket; i &lt; 1 &lt;&lt; 6; ++i) &#123;            if (data[i] == NOT_EXIST || data[i] == key) &#123;                data[i] = key;                data[i + (1 &lt;&lt; 6)] = value;            &#125;        &#125;    &#125;&#125;\n 计算机基础\n\n多态。构造函数不能虚函数，析构函数可以虚函数。\n并发了解。\n\n 其他\n自己的优点：\n我讲了 基础扎实、算法好 （刷题多）。\n他讲了他对刷题的看法。虽然不排斥刷题，但说了很多ACM选手的问题，工程实现考虑不周。感觉他有很多怨言呀。\n他还问了为什么本科时成绩好，研究生时不那么好？\n我如实说了，研究生成绩不重要。\n面试官小哥哥早年也在北航读过书，最后我还聊了一下我实验室的现状。\n 八面 又一次迷一般的面试 差评\ntime: 2020-04-13 12:59:03\n今天(4.13)上午11:30接到电话，随即开展了40min的面试。根本没有提前约我的时间，让我手头的很多事情都中断了。而且他说之前他们组的同事应该已经给我一面了。但是之前腾讯的7次面试都是别的组面的。\n 内容\n自我介绍，项目介绍。\n各种C++的容器的API的问题，时间复杂度。\n竟然让我设计一个推荐系统，我内心…只是简单说了下一些常见的推荐算法的实现。\n 2道算法题\n\n\n实现 strcpy 拷贝字符串\n\n\nvoid strcpy(const char* source, const char* destination) &#123;    if (source == NULL || destination == NULL) return;    int i = 0;    while (source[i] != &#x27;\\0&#x27; &amp;&amp; source + i != destination) &#123;        destination[i] = source[i];        ++i;    &#125;&#125;\n\n\n10亿个整型，查找其中不重复的数字\n\n\nvector&lt;int&gt; findUnique(const vector&lt;int&gt;&amp; v) &#123;    // 4G    bitset&lt;1 &lt;&lt; 32&gt; seen;    // 4G    for (int i : v) &#123;        seen.set(static_cast&lt;unsigned int&gt;(i));    &#125;    vector&lt;int&gt; ans; // 4 G = 10亿 * 4    for (size_t i = 0; i &lt; seen.size(); ++i) &#123;        if (!seen[i]) &#123;            ans.insert(static_cast&lt;int&gt;(i);        &#125;    &#125;    return ans;&#125;\n面试官是 微信kitcup推荐系统组的。我直接提意见说下次面试提前约，这次十分仓促，状态也不好。\n这个面试官的态度也是我遇到过的最差的一批，多次和他沟通时，他说“不要问我”。很多问题问的也是不明所以，给他差评。真想投诉他。\n 九面\n本次面试大概只持续了10min，问了一道“判断链表是否是回文”的算法题。要求时间复杂度O(N), 空间复杂度O(1)。LeetCode medium难度吧。\n之后问我，看到我之前面了腾讯很多次，都到HR面了。为什么没有签？我说是因为工作地点冲突的原因。我期望在北京，他们组都在深圳。面试官说，那我也是面深圳的岗位。你填报志愿填的服从调剂。然后也没必要继续面下去了。史上最快的面试！！😂\n我之后去官网看了下，还真是，重新改了下，不服从调剂了。希望北京的组能捞起我。不知道组里的工程师能不能定向捞人呀，不然可以联系一下在腾讯工作的同学和师兄。\n 4.26 笔试\nTX的笔试难度还是挺大的，尤其是第2题和第3题。不过TX并不生产算法题，它只是算法题的搬运工。\n 2. 寻找2个点集中最近的对\n原题链接\n大雪菜提供了视频讲解。简而言之，就是把2个点集的点分别做个标记，然后利用一个点集内找最近对的算法（不同标记的点，相当于无穷远）。一个点集内找最近对就是一个十分经典的问题了，采用分治可以解决。\n时间复杂度: O(N log N), 空间复杂度: O(N).\n 2. 卡牌翻转\n原题 Swap and Flip\n动态规划。DP[mask][i]表示mask中的牌在最左边，第i个牌在这些牌中的最后，保证非降的最小操作数。\n\n时间复杂度: O(n^2 * 2^n),\n空间复杂度: O(n * 2 ^ n)\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const int INF = 0x3f3f3f3f;int main() &#123;    int N;    cin &gt;&gt; N;    vector&lt;int&gt; A(N);    vector&lt;int&gt; B(N);    for (int i = 0; i &lt; N; ++i) &#123;        cin &gt;&gt; A[i];    &#125;    for (int i = 0; i &lt; N; ++i) &#123;        cin &gt;&gt; B[i];    &#125;    vector&lt;vector&lt;int&gt;&gt; dp((1 &lt;&lt; N), vector&lt;int&gt;(N, INF));    // dp[mask][i]: the minimum operation when cards in mask are in leftmost and the ith card is in the end    for (int i = 0; i &lt; N; ++i) &#123;        dp[1 &lt;&lt; i][i] = 0;  // there is no card in leftmost whose id larger than i    &#125;    for (int s = 0; s &lt; (1 &lt;&lt; N); ++s) &#123;        for (int i = 0; i &lt; N; ++i) &#123;            if (((s &gt;&gt; i) &amp; 1) == 0)                continue;                  // i is not in state            int c = __builtin_popcount(s); // card number in s            int value_i = (c % 2) == (i % 2) ? B[i] : A[i];            int cost = c; // the number of card in s, whose id is larger than j            for (int j = 0; j &lt; N; ++j) &#123;                if (((s &gt;&gt; j) &amp; 1) == 1) &#123;                    --cost;                    continue; // j is in state already                &#125;                int value_j = (j % 2) == (c % 2) ? A[j] : B[j];                if (value_j &gt;= value_i) &#123;                    dp[s | (1 &lt;&lt; j)][j] =                        min(dp[s | (1 &lt;&lt; j)][j], dp[s][i] + cost);                &#125;            &#125;        &#125;    &#125;    int ans = INF;    for (int i = 0; i &lt; N; ++i) &#123;        ans = min(ans, dp[(1 &lt;&lt; N) - 1][i]);    &#125;    ans = ans &gt;= INF ? -1 : ans;    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;\n","categories":["interview"],"tags":["intern","Tencent"]},{"title":"纳瓦尔宝典 财富与幸福，人生智慧的集合","url":"/2024/07/27/The-Almanack-of-Naval-Ravikant/","content":"豆瓣链接\n前半本财富，适合35岁前读，改变现状。很多智慧也是世界上比较公认和容易的。后半本幸福，适合35岁后读，接受现状。但就比较主观和因人而异了，属于更大的智慧，也更加难得了。最后Die with zero (也是一本书).\n和之前读过的很多书都串起来了，真就是一份宝典。很多智慧只是只言片语，就讲清楚了。比如，“原子习惯”中如何培养好习惯，摒弃坏习惯，习惯的重要性；“金钱心理学”中财富的定义，如何获得财富；再如 “进化心理学”，“欲望的演化”中关于人类心理学和两性心理的论述。当然，这些书都写的详细的多，可操作性更强，属于术的部分。“纳瓦尔宝典”是一个集锦，纳瓦尔作为一个聪明人，读过很多书的人，几十年来积累的智慧总结。用他所推崇的“费曼学习法”，讲给大家。不同的人，有不同的人生阅历和阅读，感受就完全不一样。真是相见恨晚。\n痛苦时刻的一个定义是：当你看到实物的真面目不是你本来想要的样子时，你是痛苦的。\n对美好现实的渴求蒙蔽了对真实世界的认知。所谓痛苦，就是无法继续无视事实。\n科学最重要的是可证伪性。\n纳瓦尔推荐阅读原著和经典。但不敢苟同，很多原著都是几百年，上千年的历史了。阅读门槛很高，也不容易理解，有些内容也会过时或受局限。比如“孙子兵法”虽然只有5千多字，但直接去读就很难。我选择读了“华杉”的讲解版本。也可能是我太菜了吧。\n“如果能活1000次，那么其中的999次，我都过着成功的生活。”纳瓦尔的成功不是靠运气，而是靠自己的认知。就像冯小刚的“1942”中的 张国立 说的那样，“再给他十年他还能成为地主。”当然大环境也很重要。我当然相信 张国立 是知道怎么重新白手起家的，也会成功。但土地革命、社会主义改造、人民公社的历史进程很快就到来了。通过像“白鹿原”中贫民紧衣缩食，心思活泛，丰年屯粮，灾年买地，成长为地主的日子已经一去不复返了。迎接他的，也只是千百年未有之大变局。\n智慧是一种知道个人行为的长期后果的思维能力。\n","categories":["读后感"],"tags":["Reading","纳瓦尔宝典"]},{"title":"华杉讲透《孙子兵法》","url":"/2024/05/06/The-Art-of-War-by-Sunzi/","content":"豆瓣链接\n看完《狂飙》，也来看《孙子兵法》。原版看不懂，来看解读。老高的视频也看了，确实牛。高启强一本“孙子兵法”定“京海市”，从一个小鱼贩，成长为一代黑白势力老大。当然只靠孙子兵法有些夸张，但确实是必要条件。读完后，感觉“孙子兵法”就像是武侠小说里的“九阴真经”，虽然是讲兵法，但因为万事万物后面有千丝万缕的联系。其中的不少道理，放在商业，甚至个人生活中也是有用的，尤其是投资理财。之前了解到的一个信息模型：“智慧，知识，和信息”，是从重要到次要，从少到多的。真正的智慧是大道至简的，几句话就能说清楚的。孙子兵法，主要讲的就是智慧和知识，还有如何搜集信息和情报，所以才能五千年经久不衰。\n对我启发最大，对普通生活最有价值的几点：\n\n先胜而后战。先通过计算基本面，分析胜败几率和成本回报。如果能胜利，才发动战争。尤其是对于我这样比较保守的人，尤其适合。回顾我这28年的生涯，在重要抉择时，我确实都是选择了更保守更稳妥的方案。虽然也会遗憾后悔，但这确实是更适合我的策略。我对风险更加厌恶，对于安全边际十分敏感。不过稳妥方案的话，其实后果也不错。慢慢地获得了自己想要的东西，学业事业也算是成功。\n知己知彼，关键是知己。越长大，对世界和自己了解越多，越发现有太多自己不知道和不了解的事情。相比世界来说，了解自己更难但更重要。光是自己，竟然也是这么地复杂和有趣。包括经典的哲学三问：“我是谁”，“我从哪里来”，“我要到哪里去”。我向来相信求仁得仁。知道自己想要什么，才能最终获得。我也是个J人，需要有个目标去前进，才能更安心的生活。\n谋定而后动。要能等待，要忍耐。一战而定。就像之前高考前被学校鸡血的那样，人生关键的节点就那么几个，大多数时间都是蛰伏和平淡的。要学会享受、利用和珍惜这些平淡的时光，也要做好准备，这样机遇或考验到来时，才能把握住。投资也是一样，少操作，少关心股市涨跌，有闲钱就梭哈标普500就行。\n\n","categories":["读后感"],"tags":["Reading","孙子兵法"]},{"title":"历代经济变革得失","url":"/2024/01/29/The-gains-and-losses-of-economic-changes-in-the-past-dynasties/","content":"豆瓣链接\n今年读过最棒，最能引起共鸣，启发思考最多的一本书。极力推荐。有许多想分享的思考和感受，但不好把握尺度。如此大胆，如此勇敢。总结了自古至今的经济改革，尤其是近代之后，6次“国进民退”。很多思考和振聋发聩的金句。虽然有故意忽略张居正改革的嫌疑，但瑕不掩瑜。中央集权的经济改革必定与民争利，以国富兵强和统治稳定为目的，但长期看反而会导致官商勾结、民变四起。自由主义、法制、保护私有财产、资产阶级、科技进步才是长久之计，尤其是对于国家和人民而言。经济改革的根本还是政治改革，没有配套的制度，经济改革就不可能彻底，已有的成就还会失去。本书\n写于2013年，之后的事他没写。13年后的改革，是为中国近代史上第7次国进民退。标志事件是国央企的重新崛起和对民营资本家的更强控制。20年阻止阿里上市，开启了限制资本无序扩张的序幕。同样是以共同富裕为借口。最后的结果我们也看到了，一鲸落万物死。\n后记中，吴晓波提到的四股前所未有的新势力：互联网、非政府组织、企业家和自由知识分子。寄予厚望，推动经济改革和体制变革。10年之后，这四股势力基本荡然无存。\n一些我很喜欢的选段，真是一阵见血。值得反复品味:\n\n如果不研究历代经济的变革，其实无法真正理解当前的中国。\n\n\n在这个世界上，人性的贪婪都是需要制度基础的，好的制度会遏制人的恶，反之则会催化和放大之。在这个意义上，比人的贪婪更可怕的是制度的贪婪。大清官王安石创造了一个贪婪的集权制度，他的后继者就会把这种贪婪和集权推向极致，并必然地产生异化，这是一条“惯性之路”。\n\n\n发生在王安石时代的这两个时间具有分水岭般的意义。自由的城市催生自由的商业，自由的大学催生自由的思想，而自由的商业和思想又是人类文明走向现代社会的两块奠基石。\n\n\n明清治国者有特别发达的“专制智慧”，他们真正发现了“专制的秘密”：政权想要稳定，危险无非来自两处，一曰外患，一曰内忧。除外患，断绝一切联系时不二法门，所以要把国家变成一个铁桶。解内忧，控制、削弱民间的组织力量是关键，所以要把人民打成散沙。\n铁桶阵和散沙术，是明清治国者的两大法宝。\n\n\n法国思想家托克维尔尝言：“对于一个坏政府来说，最危险的时刻通常就是它开始改革的时刻”。\n\n\n哈耶克 开始于“致命的自负”，终而“通往奴役之路”。\n\n下面的政府指中华民国南京国民政府。\n\n民间企业家阶层对政府彻底失望。当时最大的私营集团控制人荣德生向政府上书，他写道：“若论国家经济，统治者富有四海，只须掌握政权，人民安居乐业，民生优裕，赋税自足……能用民力，不必国营，国用自足。不能使用民力，虽一切皆归官办，亦是无用。因官从民出，事不切己，徒然增加浪费而已”荣德生的这段表述可圈可点，至今是普世道理，可惜不为当政者闻。\n\n中国历代经济改革主旋律：\n\n其一，维持国家统一和中央集权的大一统原则；\n其二，抵御外敌、强盛国家的强国原则；\n其三，发展国营事业、节制民间资本的国有经济优先原则。\n\n中国历代经济改革种的4大利益集团：\n\n中央政府，地方政府\n无产阶层，有产阶层\n\n如此大胆，如此勇敢。竟然写了49年到78年间的，经济改革。\n\n在整个计划经济时期，农民是一个被背叛和剥夺的阶层。他们失去了土地，被剥夺了进入城市的权利，他们创造的财富以“剪刀差”的方式转化为国家资产，而他们的生活质量却没有得到相应的改善。\n\n\n到1976年，中国是一个封闭自守的、与世界经济体系基本“绝缘”、高度集中而没有活力的经济体，沿用司马光对汉武帝的评价，此时的执政者“有亡秦之失，而免亡秦之祸”。\n\n对改革开放的评价:\n\n在将近三十年的时间里，邓小平的这些话语形成一种强大的社会共识，进而勾勒出本次改革的几个基本特征：功利务实、被动渐进、非均衡、不彻底。\n\n\n法国启蒙思想家孟德斯鸠尝言：“土地出产之少，主要不在于土地肥沃程度，而在于居民是否享有自由。\n\n本书写于2013年，之后的事他没写。13年后的深化改革，我愿称之为中国近代史上第7次国进民退。标志事件是国央企的重新崛起和对资本家的更强控制。\n后记中，吴晓波提到的四股前所未有的新势力：互联网、非政府组织、企业家和自由知识分子。寄予厚望，推动经济改革和体制变革。10年之后，这四股势力基本荡然无存。\n\n地方缺乏自治意识、政府与民间缺乏契约意识、知识分子缺乏独立意识、企业家阶层缺乏阶层意识。\n\n\n只有自由和市场经济方能在现代激烈的竞争中存活，过去的中央集权主义，在外部势力的角逐下，不得不对地方和小资产阶级退步。\n\n20年阻止阿里上市，开启了限制资本无序扩张的序幕。同样是以共同富裕为借口。最后的结果我们也看到了，一鲸落万物死。到23年，撞到南墙，经济下滑趋势明显，开始重新鼓励民营经济和外资的时候，内外资都已成惊弓之鸟，全无信心。\n\n布罗代尔曾很简洁地说道：“中国社会，政府的权力太大了，使富有的非统治者不能享有任何真正的安全。对任意征收的恐惧始终挥之不去。”\n\n","categories":["读后感"],"tags":["Reading","历代经济变革得失"]},{"title":"Ubuntu OpenVPN 无法获取公网资源","url":"/2021/03/18/Ubuntu-vpn-cannot-access-public-resource/","content":"由于科研需求，我需要连接杭州研究院的VPN，才能使用显卡做神经网络的训练任务。\n然而在Ubunut 18.04配置好OpenVPN后，发现一个难题：连上VPN后无法上外网（百度等网站，不是墙外的网站，而是相对局域网内网的“外网”），断开VPN后可以连外网，但无法连接杭研院的资源。鉴于工作中，外网和杭研院内网基本缺一不可，我花了2天时间调研和修复改问题。而且其他同学使用VPN并没有类似问题，所以我认为是Ubuntu独特的问题。修复的操作很简单，但定位到问题的过程十分坎坷。\n 现象整理\n连接VPN后，可以ping通baidu的IP，但浏览器无法连接baidu，也无法直接ping通baidu.com。浏览器只能打开杭研院和北航内部的网站。\n初步判断是网络上DNS服务器的问题，但调研之后发现DNS的配置并无问题。\n猜测是访问外部资源时，理应的DNS解析并没有办法完成。\n最后在网上查了半天，才发现真正的问题（VPN本地配置问题）和解决方案。\n 解决方案\n网上最类似的一个问题和解决方案\n由于我是Ubuntu 18.04, 并不大一样。\n在我这里给出我的完整解决方案，以供大家参考。\n打开VPN的配置。\n\n\n勾选“Use this connection only for resources on its network&quot;\n\nApply后，重新连接VPN即可解决问题。\n 后记\n下一步，我还会试着在Ubuntu上装个跳板机。这样我的Mac或许可以通过该跳板机连入杭研院的机器。 (已经成功啦，下篇更新在这里)。\n","categories":["折腾"],"tags":["Linux"]},{"title":"谈谈西方政治正确","url":"/2022/11/19/Western-political-correctness/","content":"\n无论是在国内时看国内的新闻，还是来到爱尔兰后的真实感受，政治正确都是西方一个很明显的特点。国内普遍的观点是政治正确比较愚蠢，属于自掘坟墓，然而来了这里发现，他们本身竟以此为豪。今天就分享一些我自己关于政治正确的一些原因分析和看法。\n\n最早的科学和工业化。难听点说就是“吃的太饱”。化肥、农药、机械的使用。哈伯固氮法。物质生活比较富裕，有余力做政治正确。比较典型的案例是各种环保组织，正所谓“饱暖思淫欲”，就像追求写高尚的东西，如环保、贫困。各种发展中国家自然是没有这种政治正确能力的。当然，大多数情况也只是为了满足自己本身的更高级些欲望，只不过看起来体面的多。不像我国是真金白银，切实解决贫困环保等问题的。\n傲慢与偏见。难听点就是“何不食肉糜”。在几百年长期经济领先的情况下，从上到下都对世界范围发展的不平衡不了解，媒体和教育也都是以西方为视角的。比较典型的案例是瑞典的环保少女。古话说的好“读万卷书，行万里路”，“读万卷书”能减少时间上的偏见，“行万里路”能降低空间上的偏见。只有你知道的更多，拥有强大的共情能力，才能避免傲慢与偏见。\n经济发展的客观需要。中国自古就自称中国，因为农业化比较早，比周边“蛮夷”发达。从先秦到唐代，中国从上到下也是充满了制度自信，对不同民族的人是相对比较欢迎和重用的，以唐代为巅峰。自宋以降，随着发展的相对优势降低，就明显保守排外了。西方现在处于经济发展的领先地位，发达的工业化本身就会导致出生率降低，一方面需要不同民族、国家的人来建设，需要引入人口做各种服务业和工业；另一方面也相对比较自信。因此以多样化和包容性为特点，对少数群体过于照顾的政治正确就成了主流。\n历史人口交流的习惯。另一方面，中国的统一和扩张已经到达农业社会的极限了，把东亚这块比较适合生存的土地和周边的地区都已经同化，与外界交流也就少。其实从世界范围来看，欧亚大陆是核心大陆，而欧亚大陆的中心其实在中东，也就是现在的阿拉伯世界。中东西接欧洲，南抵非洲，东连接南亚和中亚、东亚。从亚洲，欧洲的名字来源就可以得知。欧洲源自“欧罗巴”，是闪族语，意为日落之地。亚洲源自“亚细亚”，是腓尼基语，意为日出之地。而且不像中国历史上以大一统为主，西方是以分裂为主的。因此不同民族之间的交流十分频繁和自然。现在往欧洲移民的难民也以中东、北非为主。距离上很近，天然的地理障碍很少，很容易人口涌入。\n\n","categories":["dairy"],"tags":["life"]},{"title":"国家为什么失败 Why Nations fail","url":"/2025/06/23/Why-Nations-fail/","content":"一定要读英文版或台译本，懂得都懂。虽然中国是一个历史上失败国家和榨取型制度短暂成长国家的经典案例,但全书中着墨不算很多. 然而作为一个中国人,其他国家的案例也是值得学习的,我之前并不了解.尤其是很多非洲和拉美的案例. 但我心中处处在验证着中国的失败. 对比从一开始接受的社会主义教育 (可怕的洗脑 和 历史/政治重新书写), 和自己成年以后看的各种历史,经济,政治书, 还是十分认同书中的观点的. 我自己也在用脚投票. 时间不够可以关注这2小节.\n13章 当前的国家为什么会失败 （5）新专制主义\n描述 共产主义的榨取制度。\n15章 理解富裕与贫困 （2）威权式成长难以抗拒的吸引力\n解释中国的成长无法持续。\n我也曾经对中国的政治改革充满希望, 但如今已经完全不抱希望，润了润了。\n广纳式经济和政治制度是持续性成长的必要条件。\n关键时期、制度漂移 等决定了制度发展。\n不支持历史决定论，虽然制度变化基于之前的制度基因，有良性循环和恶性循环，但也充满了偶然性。\n贫穷是制度导致的，1. 缺乏集权的政府。或 2. 榨取型经济制度和政治制度。\n持续的经济成长需要对广大人群充满诱因和保障，关键在于 熊彼得 所说的“破坏性创新”。这也是为什么榨取型制度阻碍持续成长的根本原因。\n\n即使是科技创新也不一定会带来农业增产。事实上，我们都知道称作伊尔约龙特人的澳大利亚原住民，采用钢斧这项重大科技创新后并未导致更努力工作，反而是睡觉的时间更长，因为维持生存所需变得更加容易，而没有更努力工作的诱因。\n(笑死我了，和我一样）\n\n\n19世纪末、20世纪初，流氓大亨及托拉斯之兴起充分说明一项事实：市场本身并不保证会有广纳式制度。\n\n","categories":["读后感"],"tags":["Reading","国家为什么失败"]},{"title":"武汉游记 暨硕士毕业旅行","url":"/2021/07/02/Wuhan-trip/","content":"终于毕业了，筹划了许久的毕业旅行也正式提上议程。因为要等npy考完试，而且入职前要回来，最好还有几天休息和置办家具。我和npy只有1周时间旅行。共去了3个地方，山西临汾-&gt;湖北武汉-&gt;湖北随州。\n目的大概是见我的家长，看望npy十年没见的奶奶。\n 6/24 Day 0\n这天领毕业证，收拾宿舍并退宿，送走了舍友，晚上等npy考完试，然后去十里堡看房。回学校取旅行行李，然后去火车站附近的酒店。洗漱完就已经1点多了，亲热好久才睡觉。毕竟距上次开房已经2个半月了，还是npy生日出去的。\n 6/25 Day 1\n中午睡到11点。打车去北京西站，虽然离得很近，但还是开车前10分钟才上了车。\n坐D2003到达襄汾西站。爸爸和小爸来接，一起去风情街的油粉饭馆吃了饭，妈妈和姐姐也来了。\n 6/26 Day 2\n第二天早上在家吃饭，随后2辆车带npy去龙树峪玩。爬山，走了玻璃桥和石头滑梯。\n中午回村里接上奶奶，再回城里尉村拉面馆吃大餐。\n下午回家休息了2个小时，开车带npy去市里的商场玩。吃了美食城的麻辣拌。\n 6/27 Day 3\n上午在家做饭吃。本来打算做焖面，但因为我买错了豆角。最后做了西红柿鸡蛋手擀面吃。\n吃完饭稍事休息，爸爸开车送我们去机场。\n乘坐飞机傍晚到达武汉天河机场，坐地铁到汉口站，在附近的宾馆留宿。\n晚上去万松园，吃了生煎、牛肉粉、臭干子。\n逛了中山公园，和旁边的商场。不过因为9点半商场要关门，只在一楼拍了一些照片。\n初到武汉就品尝到江城的威力，早上下了暴雨，虽然我们晚上到了之后没雨。但十分潮湿和炎热，再加上武汉的吃的都辣，走两步路身上就全湿了，真是要了我亲命了。\n 6/28 Day 4\n中午在火车站旁吃了热干面，还不错。坐高铁去随州南。npy姑姑和姑父接站。随后去村里爷爷奶奶家坐，并吃了晚饭。晚上姑父接我们回市里宾馆住。吃了小笼包子和水果酸奶。因为晚上没吃饱。农村的饭菜还是顶不住，出于礼貌和饥饿吃了一些。\n 6/29 Day 5\n早上赶早，吃了襄阳牛杂面，喝了米酒。随后去爷爷奶奶家继续坐了一上午，和爷爷奶奶告别。\n中午回市里吃小龙虾（虾子）。姑姑请客，真过瘾。\n下午坐高铁回武汉，还住原来的宾馆。\n出站时遇到了网红“罗翔老师”，合影发朋友圈。\n晚上去“户部巷”小吃街，吃了\n走了著名的武汉长江大桥。没成想过了桥，到了汉阳，这里都是大马路。而且晚上快12点了，也没公交，和小黄车。打车回了汉口站。大家还是尽量不要步行去一些奇怪的地方。还好出租车特别多，否则真的绝望。\n 6/30 Day 6\n江汉大道\n 7/1 Day 7\nG520一大早回北京。到学校搬家，晚上去宜家购置家具，又花了2400大洋。\n旅行真是花钱，搬家也是。\n","categories":["dairy"],"tags":["travel"]},{"title":"时势 周期波动下的国家、社会和个人","url":"/2024/06/04/Xiao-Lin/","content":"本书豆瓣链接\n小Lin是我最喜欢的UP主之一了。美女、学霸、华尔街投行、创业。各种引人注目的标签。而且她的视频确实质量比较高，制作精良，然后又通俗易通。看她的书支持一下。全书的内容，其实她的视频里都讲过，甚至讲的还更好。毕竟视频展示各种图表也更方便。所以，其实不读这本书，只看她的油管或B站视频也是足够的。读本书最神奇的地方在于，自带语音功能。不得不感叹人类大脑的强大，读的时候，脑袋里面会自动播放小Lin的语音和视频，算是一次不错的体验了。而且也就当是复习一下之前的视频里讲的知识。\n不过，还是要强调一点。小Lin的视频和书，都是科普向的，虽然宏观经济的干活不少，但总体是轻松娱乐向的。虽然又很多文献和数据做支撑，但仍然显得十分浅显，许多因果关系也并未如她分析的那样。毕竟经济学是十分复杂的学问。很多时候是拿着后视镜去寻找原因，而不是根据现在预测未来。炒股或关注经济的朋友，应该都有这个感受。每个分析师分析的都不一样，而且话也不说死，最后过了半年，发现和当初分析的大相径庭，但仍能自圆其说。我自己也关注了一些投资的UP主，在这里就不举例和介绍给大家了，免得误人子弟。\n","categories":["读后感"],"tags":["Reading","时势","小Lin说"]},{"title":"碧血剑 国士无双袁崇焕","url":"/2023/08/20/Yuan-Chong-Huan/","content":"豆瓣链接 碧血剑\n小说本身6分，但后附的《袁崇焕评传》写的十分好，有历史，也有金庸的评论。关键是很多关于明亡观点和我不谋而合。值得10分。 感想颇多，短评装不下。写了一个很长的书评\n袁崇焕真是国士无双。明清易代是中国最后一次封建王朝的改朝换代，也由于离得近，记载和历史记忆十分清楚。而且由于多方势力角逐，戏剧性也很强。结局是鞑子入主中原，建立起长达268年对中国关内的统治。更是悲剧收场，使得更加令人惋惜痛恨。1644年，是顺治元年，崇祯十七年，永昌元年，感谢金庸以此为背景，撰写了这部武侠小说。这部小说也串起来了金庸的其他小说，比如《鹿鼎记》，九难，归辛树，冯难敌 等人物均有出场。\n最早接触这段历史是小时候看各种清宫剧，比如《孝庄秘史》。后来就是大学时看 当年明月 的《明朝那些事儿》，算是最这段历史有了比较详细的了解。对于明朝后期的这段悲剧历史，当年明月 可以说是也不愿多写，尤其是他作为一个公务员，不知是有意还是无意，擅长写春秋笔法。为明朝皇帝增光添彩，掩盖过失，尤其以 英宗 和 崇祯 为甚。读完最后的感觉竟然是，”诸臣误朕“有道理，明朝灭亡的原因是”大明气数“已尽。很多变化其实也不明所以。比如 从天启到崇祯，突然就从众正盈朝，到阉党横行，即使灭亡阉党之后，仍是全员巨贪。\n之后后来我接触更多文学作品和评论后，才明白 当年明月 的书对历史真相的掩盖和扭曲。比如 《大明王朝1566》，马亲王的《两京十五日》。金庸在《碧血剑》的后记中，也不辞辛劳，特意着墨记述了袁崇焕和明末的真相。是他武侠小说中罕见的篇幅，已占全书10%。恐怕大家不了解当时的历史。十分感谢。\n明朝的灭亡，最大原因是体制问题，自秦以降，中国的整体趋势是君主集权不断加强。专制体制有很多缺点。如以权力为根本，对上负责，而不是对下负责；互相制约，效率低下，具体到明末，就是边疆大臣被多方面掣肘，做很多不愿意做的事情。如袁崇焕被高第逼得莫名奇妙，放弃宁远以东2百里防线。孙传庭被崇祯逼得出山西与闯军决战河南。武将被不懂军事的文官，好不容易遇到懂军事还忠心的文官主政（熊廷弼，孙承宗，袁崇焕，孙传庭），还被朝臣和太监掣肘，无法施展抱负。大有现在的“治不了敌人，还治不了你吗”。正像黄炎培问”如何摆脱历史周期律“，毛泽东答”实现民主，人民监督政府“。民主起源于希腊雅典，在法国启蒙运动中发展成现代民主，最后逐渐占据人类文明的主流价值观。如今在21世纪，即使是专制政权，也得标榜”民主自由“。当然400年前，中国人有历史局限性，是无论如何也没法实现的了。但当今的中国人，不应该再不明白了。\n其次原因，就在于皇帝。万历、泰昌、天启 和 崇祯。尤其是崇祯，忠奸不分，刚愎自用。虽然最后君王死社稷，但仍不明白，说什么”诸臣误朕“，推卸责任。虽然忠臣能臣比例少，但还是有一些的，都被他逼走或逼死，甚至直接处死。在这样的环境下，当然是劣币驱逐良币，反而最后留下的，都是奸臣懦夫了。\n最后，才是官员的结党和腐朽。但这并不是从崇祯或是万历才开始的，而是从洪武建国伊始就开始了，然后不断发展严重，最后积重难返，不治身亡。归根揭底，还是体制的原因。因为人性都是自私的，在专制体制下，任何利益集团都只会为自己谋福利。权力是福利的根本，也就是说对权力的来源负责，最后的结果就是欺上瞒下。体制内的监督是无济于事的。无论是过去，还是现在。这也就是为什么中国之前多次讲要“政治体制改革”。\n女主温青的性格真的很像我的前女友。因为原生家庭的原因，情绪十分不稳定，科学点说是“边缘型人格障碍”和多动症。所以，虽然很多读者可能受不了她，但是我还是能理解女主的。在和ex一起的3年中，我用自己的爱去包容她，帮助她在性格上和学业事业上都成长很多。虽然确实难相处，但也算全力以赴，竭尽全力了。最后虽然我俩分开了，但看到袁承志和温青互相倾心，可以在海外享受太平，也算是一个不错的安慰吧。\n袁承志作为大男主，虽然其貌不扬，但将门之后，武功又高，又有侠义之气，引得多位女子的清新。尤其是阿九的一往情深，真的是让人难舍。阿九更是得知大哥和青姐的事情后，选择出家，成全他们，真的是慷慨呀。以袁承志的角度，金庸穿起了崇祯中后期的历史事件，表达了他认为的亡国原因，以及闯王失败的原因。尤其是明末那种天下大乱，民不聊生的场景，看的令人心痛。统治者和统治阶级口口生生爱百姓，闯王和皇太极也是如此，但真正做的事却是伤害百姓。果然是 兴，百姓苦，亡，百姓苦。人民还是得自己站起来，不是推举谁做皇帝，而是用民主制度，真正的把权力放在制度的笼子里。权力在民，而非个人或某个小集体。\n","categories":["读后感"],"tags":["Reading","碧血剑"]},{"title":"atom 浅尝辄止","url":"/2017/04/08/atom-explore/","content":" 配置代理\n笔者的需求是在markdown文档中插入LaTeX公式, atom默认的markdown-preview包无法满足要求. 经过搜索, 社区包markdown-preview-plus可是满足该需求.\n atom包管理\n按照官方教程, 安装失败\n\nInstalling “markdown-preview-plus@2.4.9” failed.\n\n在log中, 笔者发现了这样的请求\n\nGET https://atom.io/download/electron/v1.3.13/iojs-v1.3.13.tar.gz\n\n笔者接着使用浏览器测试该网址, 无法相应, 猜测是被q了. 幸运的是, atom文档中考虑到使用代理的需要, 并给出了guide.\n配置apm的代理\n最后, fq基本功. 不解释.\n 具体命令\nsean@sean-OptiPlex-790:~$ apm config set https-proxy http://localhost:8123sean@sean-OptiPlex-790:~$ apm config get https-proxyhttp://localhost:8123/sean@sean-OptiPlex-790:~$ apm install markdown-preview-plusInstalling markdown-preview-plus to /home/sean/.atom/packages ✓","categories":["折腾"],"tags":["atom"]},{"title":"突破百度云限速","url":"/2018/11/05/baidu-cloud-download-speed-hack/","content":"最近因为英语学习的需要，经常到百度云上下载一些大文件。众所周知，百度云对下载进行了限速，不开他家的会员的话，下载速度只有几十k/s。实在不能忍，遂搜索了限速破解工具，下载速度达到了15M/s，哈哈。在此分享给大家。\n不过需要注意的是，由于百度云也会更新限速机制，防止大家滥用。所以如果本文的方法失效的话，也不足为奇，还可以在网上寻找其他更新的方法。要相信广大程序员的力量。\n截止至2018年11月5日，此方法是可行的。\n\n获取百度云 原始连接\n运行脚本后，百度云的下载界面会变成这个样子。\n\n至于为什么点压缩连接呢？因为我发现用&quot;复制链接“并不能获取文件本身的下载地址；而且下载压缩包也更快。\nhttp 多线程下载工具\n\n","tags":["tech"]},{"title":"丰宁坝上草原2日游","url":"/2018/10/07/bashang-grassland/","content":"如何欢度2018年最后一个假期–国庆节呢？我选择了跟团(北京初心户外)去河北丰宁的坝上草原骑马。9月30号晚19点半在惠通西街南口集合上大巴。一路向北，9点半到达一个北京最北的服务站时，已经感觉很冷了。晚上近12点到达丰宁县的一个农家乐住宿时，天气已经非常冷了。据房东说，前一天刚刚下过雪，所以这两天非常冷。后来国庆节后刷朋友圈时，看到去什么沙漠、戈壁、火山的，无一例外都是很冷。所以，秋天去这些地方，还是要三思而后行的，做足充分准备的。出发前，领队反复强调需要带厚衣服，最好是羽绒服。我从小怕冷，直接带了最厚的羽绒服–500g 绒的加拿大鹅。据说这衣服去南极都没问题，我没去过南极，不知真假。但这件衣服抵抗秋天的草原夜晚的温度，还是一点问题也没有的。\n\n第一天上午，到村庄附近骑马，80元/小时。这个旅行团来骑马的有40余人，上马的时候很混乱。我稀里糊涂就跟着一批人走了。这批人由大约20名游客，3个马夫组成。通过后来的交流，我才知道，自己上了一条“贼船”。怎么个贼法呢？首先，我们绕了一大圈，走了最远的路线。这意味着，最长的时间(4小时)，最高的花费。过长的骑马对于第一次上马的我来说，度过了最初的激动和策马奔腾后，到最后回程的时候简直是一种折磨。马归心似箭，总想快跑，而我已经内脏都要被颠碎了。回来之后，腰背疼了4天，尾椎骨也破了，小腿的胫骨中部被马镫磨烂了，过了一周才慢慢痊愈。当然绕远也有好处。我们经过了附近风景最美的“情人谷”。山丘、草原、蓝天、白云相映生辉，组成一幅幅屏保级的图案。在马上随手一拍就是美景。尤其是还能看到成片的白桦林，远近不一的成群的风力发电机和覆盖着白雪的山顶。其次，我们中间休息了3次。每次休息都在简陋的茶房，加起来休息时间竟达到了1个小时。然而这些都是仍然算是收费的。你可以认为这些马和马夫在带薪休假。最后，回到农家乐已经下午一点了。12点开饭，回的早的人有大鱼大肉，回的晚的人只剩残羹冷炙了。\n下午，乘车参观了 大汗行宫 外围 和 闪电湖。\n晚上，品尝了烤全羊，和众人一起点篝火、放烟花。\n第二天上午，去 草原游乐场 玩耍。\n最后放一张骑马的照片，同行的人，由于我人高，所以分配到的马也大。\n\n 后记\n本次旅行的所有花费：\n\n报名费 350\n骑马 350\n闪电湖 20\n游乐场 40\n路上零食 10\n总计 770\n\n","categories":["dairy"],"tags":["travel"]},{"title":"Best implement to use pair as key to std::unordered_map in C++","url":"/2020/05/27/best-implement-to-use-pair-as-key-to-std-unordered-map-in-C/","content":"Reference: C++ Standard Library: A tutorial and reference, Second version Chapter 7.9.2: Creating and Controlling unordered Container\nAll solutions I found in Google use XOR to generate hashcode of pair, which is totally bad. see why-is-xor-the-default-way-to-combine-hashes. However, the book has given us the best solution, using hash_combine, which is taken from Boost. The solution is much better than XOR when I tested it in Online Judge(Atcoder). I organized the code as a template as follow. You can copy and paste it as much as you can. And it is convenient to change it to fit any custom struct/class.\n#include &lt;functional&gt;// from boost (functional/hash):// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html templatetemplate &lt;typename T&gt;inline void hash_combine(std::size_t &amp;seed, const T &amp;val) &#123;    seed ^= std::hash&lt;T&gt;()(val) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);&#125;// auxiliary generic functions to create a hash value using a seedtemplate &lt;typename T&gt; inline void hash_val(std::size_t &amp;seed, const T &amp;val) &#123;    hash_combine(seed, val);&#125;template &lt;typename T, typename... Types&gt;inline void hash_val(std::size_t &amp;seed, const T &amp;val, const Types &amp;... args) &#123;    hash_combine(seed, val);    hash_val(seed, args...);&#125;template &lt;typename... Types&gt;inline std::size_t hash_val(const Types &amp;... args) &#123;    std::size_t seed = 0;    hash_val(seed, args...);    return seed;&#125;struct pair_hash &#123;    template &lt;class T1, class T2&gt;    std::size_t operator()(const std::pair&lt;T1, T2&gt; &amp;p) const &#123;        return hash_val(p.first, p.second);    &#125;&#125;;#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123;    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;    return 0;&#125;\nThere is a hash implementation for Tuple. I updated the answer inStackOverflow。Please go there if you need hash tuple.\n","categories":["Programming"],"tags":["C++","hash","unordered_map","English"]},{"title":"MAC 手动编译 build qBittorrent","url":"/2021/02/27/build-qBittorrent/","content":" 起因\n最近毕业压力比较大，想在北邮人上下载个电影看看，放松下。却发现一直使用的做种下载工具qBittorrent无法打开了。在网上寻找了半天原因和解决方案。\n最终确认是MAC更新的锅，qBittorrent 属于认证不完整的应用：Issue 11570。\n解决方案有二：\n\n禁掉APPLE的安全检查\n自己手动编译一遍应用\n\n由于某些原因，我无法对MAC做过多的系统更改。只好尝试第二个解决方案。事实证明，手动编译qBittorrent并不简单，一下午就此度过，电影也不用看了。为方便有相同问题的同学参考，我记录我的解决方案于此。因为在我编译构建过程中，网上并没有类似的教程或是参考，而且确实有不少坑。\n 步骤\n如果之前没有QT环境，./configure会报找不到qmake的错误。需要配置相应的环境。\nbrew install qtecho &#x27;export PATH=&quot;/usr/local/opt/qt/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrcexport PATH=&quot;/usr/local/opt/qt/bin:$PATH&quot;export LDFLAGS=&quot;-L/usr/local/opt/qt/lib&quot;export CPPFLAGS=&quot;-I/usr/local/opt/qt/include&quot;export PKG_CONFIG_PATH=&quot;/usr/local/opt/qt/lib/pkgconfig\n如果之前没有boost环境，会报找不到boostlib的错误：\nchecking for boostlib &gt;= 1.65 (106500)... configure: We could not detect the boost libraries (version 1.65 or higher). If you have a staged boost library (still not installed) please specify $BOOST_ROOT in your environment and do not give a PATH to --with-boost option.  If you are sure you have boost installed, then check your version number looking in &lt;boost/version.hpp&gt;. See http://randspringer.de/boost for more documentation.configure: error: Could not find Boost\n需要安装boost环境。\nbrew install boost\nbrew install libtorrent-rasterbar\n如果遇到报错，\nError: Directory not empty @ dir_s_rmdir - /usr/local/opt/openssl\n可以删掉对应文件夹或是更改其所有人chown.\nbrew cleanupsudo rm -rf /usr/local/Cellar/openssl/1.0.2q\n在我brew install libtorrent-rasterbar后再./configure时，仍然会发生该库版本不对的问题：\nRequested &#x27;libtorrent-rasterbar &gt;= 1.2.11&#x27; but version of libtorrent-rasterbar is 1.2.10\n因为brew的formula中只有1.2.10，我们只好手动编译一个新版了。\n去github找到libtorrent-rasterbar对应版本的源码：download。按照文档中的构建说明编译安装即可。\n对于MAC来说：\nbrew install boost-build boost openssl@1.1echo &quot;using darwin ;&quot; &gt;&gt;~/user-config.jamb2 crypto=openssl cxxstd=17 openssl-lib=/usr/local/Cellar/openssl@1.1/1.1.1j/lib openssl-include=/usr/local/Cellar/openssl@1.1/1.1.1j/include releaseb2 crypto=openssl cxxstd=17 openssl-lib=/usr/local/Cellar/openssl@1.1/1.1.1j/lib openssl-include=/usr/local/Cellar/openssl@1.1/1.1.1j/include install --prefix=/usr/local\nexport libtorrent_LIBS=&quot;-L/usr/local/lib&quot;export libtorrent_CFLAGS=&quot;-I/usr/local/include&quot;export openssl_CFLAGS=&quot;-I/usr/local/Cellar/openssl@1.1/1.1.1j/include&quot;export openssl_LIBS=&quot;-L/usr/local/Cellar/openssl@1.1/1.1.1j/lib&quot;./configuremake &amp;&amp; make installqbittorrent\n\n除此之外，你还可以参考官网的另外一些编译构建文档. 这里提供了使用CMake或QT Creator的编译方案。\n","categories":["tech"],"tags":["折腾"]},{"title":"codeforces round 633 Div2","url":"/2020/04/12/codeforces-round-633-Div2/","content":"官方题解\ncodeforces上题目一般高于平时的面试题。如果是为了面试的话，只刷LeetCode就可以了。不过如果是对算法和竞赛感兴趣，强烈鼓励试一试。题目的数量和质量都远超LeetCode。而且为不同水平的同学有不同的赛道，题目难度也不同。对于高水平玩家来说，竞赛体验会好的多。\n我目前共参加过2场Div.2，rating 1480。没错，初始值是1500，我反而掉下来了。\n A. Filling Diamonds\n可以用动态规划的方式思考这个问题。对于长度为n的belt来说，共有2种状态：\n\n\n\n\n/\n和\n1.\n/\n\\\n状态转移方程有:\ndp[n][0] = dp[n-1][1] + dp[n-1][0],\ndp[n][1] = dp[n-1][1].\n对于初始值有:\ndp[0][1] = 1,\ndp[0][0] = 0.\n答案为: dp[n][0].\n通过该方程可以很快地得出dp[n][0] = n。\n时间复杂度: O(1),\n空间复杂度: O(1).\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;using ll = long long;int main() &#123;    int T;    cin &gt;&gt; T;    while (T--) &#123;        int n;        cin &gt;&gt; n;        cout &lt;&lt; n &lt;&lt; endl;    &#125;    return 0;&#125;\n出题人也很骄傲地说，这是目前最简单的Div.2 A了。代码很简单，但是思路还挺巧妙。\n B. Sorted Adjacent Differences\n贪心。先排序，从中间开始选，向右跳一下，向左跳一下。\n时间复杂度: O(n log n),\n空间复杂度: O(n).\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int SIZE = 1e5 + 5;using ll = long long;vector&lt;int&gt; a(SIZE);int main() &#123;    int T;    cin &gt;&gt; T;    while (T--) &#123;        int n;        cin &gt;&gt; n;        for (int i = 0; i &lt; n; ++i)&#123;            cin &gt;&gt; a[i];        &#125;        sort(a.begin(), a.begin() + n);        int current = (n - 1) / 2;        int left = current, right = current;        bool direction = true;        // [left, right]        while (current &gt;= 0 &amp;&amp; current &lt; n) &#123;            cout &lt;&lt; a[current] &lt;&lt; &quot; &quot;;            if (direction) &#123;                ++right;                current = right;            &#125; else &#123;                --left;                current = left;            &#125;            direction = !direction;        &#125;        cout &lt;&lt; endl;    &#125;    return 0;&#125;\n C. Powered Addition\n问题可以转化为: 可以给数组中的任何数 加 最多 2^k - 1. 使得整个数组非递减。求最小的k.\n时间复杂度: O(N),\n空间复杂度: O(N).\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;using ll = long long;int main() &#123;    int T;    cin &gt;&gt; T;    while (T--) &#123;        int n;        cin &gt;&gt; n;        ll max_value_in_array = numeric_limits&lt;ll&gt;::min();        ll max_demand = 0;        for (int i = 0; i &lt; n; ++i)&#123;            ll current;            cin &gt;&gt; current;            if (current &gt; max_value_in_array) &#123;                max_value_in_array = current;            &#125; else &#123;                max_demand = max(max_demand, max_value_in_array - current);            &#125;        &#125;        int ans = 0;        ll could_present = 1;        while (could_present &lt;= max_demand) &#123;            ++ans;            could_present *= 2;        &#125;        cout &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n","categories":["Programming"],"tags":["codeforces","contest"]},{"title":"face++ 面试","url":"/2018/08/14/face-interview/","content":"一个清华的毕业生做为面试官，一开始问了我之后的工作意向。我回答说是“算法工程师”，其实我这次面的是开发岗，就被大佬教育了一顿。说你是不是投错组了，还没找到自己感兴趣的方向嘛。之后问我，现在在快手的实习是做什么的？我讲了一些。然后又被diss了。说这些特征工程之后都会被深度学习所取代的。\n正式进入面试只问了2个问题：维护最小值的队实现，和 维护最小指的栈实现。\n之后本来有二面的，后来没找到面试官就不了了之了。\n我是对这次面试结果不抱太大期望的，毕竟过程比较水，也不是很愉快。果然之后face++那边一直都没有消息。\n","categories":["interview"],"tags":["intern","旷视"]},{"title":"Find all unique pairs of maximum and second maximum elements 子数组的最大值和次大值对","url":"/2019/12/14/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/","content":"问题的根源是有个同学问了个lucky number的问题Codeforces 280B, Codeforces 281D也是同样的问题。\nFind all unique pairs of maximum and second maximum elements over all sub-arrays in O(NlogN)\n幸运数的定义为：数组中子数组的最大值和次大值的XOR值。寻找所有幸运数中的最大的。\nBrute force 的解法是枚举所有的子数组，时间复杂度为O(N ^ 2).\n有没有更优的方法呢？\n今天要讨论的就是这个问题。\n 通用的解法，快速寻找 最大次大值对 算法\n寻找子数组中最大值和次大值其实是有快速算法的:\nFind all unique pairs of maximum and second maximum elements over all sub-arrays in O(NlogN)\n基于这个的观察：数组中的每个数，如果想要成为次大值，就只能和向前的第一个比他大的数 或 向后的第一个比他大的数组成。\n我们可以维护一个 单调递减栈，加入新数时，维持单调递增需要弹出所有小于它的数，这时新数就是被弹出来的数后面的第一个比他大的数；栈顶中最大的数 就是 新数 向前的第一个比他大的数。\n时间复杂度: O(N),\n空间复杂度: O(N).\n#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;using ll = long long;int solve() &#123;    ll N;    cin &gt;&gt; N;    vector&lt;ll&gt; nums(N);    for (ll i = 0; i &lt; N; ++i) &#123;        cin &gt;&gt; nums[i];    &#125;    stack&lt;ll&gt; st;    st.push(nums[0]);    ll ans = 0;    for (ll i = 1; i &lt; N; ++i) &#123;        while (!st.empty() &amp;&amp; nums[i] &gt; st.top()) &#123;            ans = max(ans, nums[i] ^ st.top());            st.pop();        &#125;        if (!st.empty()) &#123;            ans = max(ans, nums[i] ^ st.top());        &#125;        st.push(nums[i]);    &#125;    return ans;&#125;int main() &#123;    ll ans = solve();    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;\n 我独立思考出的解法\n我的解法利用了XOR的性质，如果换成别的运算就不通用了。\n首先遍历一遍找到最高的位数。\n再遍历一遍找到最高的位数为1的那些数，我们先称其为 最高数。\n从这些最高数出发，往两边扩充，直到遇到另一个最高数，在这个过程中寻找次大数并更新幸运数的最大值。可以证明，每个数最多被找2次。\n所以，总的时间复杂度是 O(N), 空间复杂度 O(N).\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;using ll = long long;int solve() &#123;    int N;    cin &gt;&gt; N;    vector&lt;ll&gt; nums(N);    for (ll i = 0; i &lt; N; ++i) &#123;        cin &gt;&gt; nums[i];    &#125;    const int MAX_BIT_BEGIN = 40;    vector&lt;vector&lt;ll&gt;&gt; flag(MAX_BIT_BEGIN + 1, vector&lt;ll&gt;(2, 0));    for (ll i : nums) &#123;        for (ll j = 0; j &lt;= MAX_BIT_BEGIN; ++j) &#123;            ++flag[j][((i &gt;&gt; j) &amp; 1)];        &#125;    &#125;    ll max_bit = MAX_BIT_BEGIN;    for (; max_bit &gt;= 0; --max_bit) &#123;        if (flag[max_bit][0] &gt; 0 &amp;&amp; flag[max_bit][1] &gt; 0) &#123;            break;        &#125;    &#125;    if (max_bit == 0) &#123;        return 1;    &#125; else if (max_bit &lt; 0) &#123;        return 0;    &#125; else &#123;        vector&lt;ll&gt; max_bit_is_1_indexs;        for (ll i = 0; i &lt; N; ++i) &#123;            if (((nums[i] &gt;&gt; max_bit) &amp; 1) == 1) &#123;                max_bit_is_1_indexs.push_back(i);            &#125;        &#125;        ll ans = 0;        for (ll index : max_bit_is_1_indexs) &#123;            ll second_max = 0;            for (ll i = index - 1; i &gt;= 0 &amp;&amp; ((nums[i] &gt;&gt; max_bit) &amp; 1) == 0;                 --i) &#123;                second_max = max(second_max, nums[i]);                ans = max(ans, nums[index] ^ second_max);            &#125;            second_max = 0;            for (ll i = index + 1; i &lt; N &amp;&amp; ((nums[i] &gt;&gt; max_bit) &amp; 1) == 0;                 ++i) &#123;                second_max = max(second_max, nums[i]);                ans = max(ans, nums[index] ^ second_max);            &#125;        &#125;        return ans;    &#125;&#125;int main() &#123;    ll ans = solve();    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;","categories":["Programming"],"tags":["Algorithm"]},{"title":"国内外企 和 欧洲外企 对比","url":"/2023/10/18/foreign-companies-comparision-between-China-Europe/","content":"笔者有幸在国内的外企和欧洲的外企都工作过，2家都是美国的跨国企业，因此对于中国和爱尔兰，都是外企。且都属于互联网行业。总的感受一句话，全靠同行衬托。\n中国的外企的特点就是，Work Life Balance，不加班，福利好，包裹好，十分人性化。同事水平也都十分高，基本都是名校毕业。当然最近几年，国内互联网行业的薪资水平也都追上甚至还有的反超了，比如新兴的 字节跳动 和 拼多多。我在这家外企呆了2年时间。因为是疫情后加入，基本都是在家办公，甚至远程入职。人性化最大的体会是，21年北京户口大赦，当时政策的规定是有半年和3年的指标，公司和员工协商决定。也就是你交够社保到半年和3年后，开始办户口。说是协商，其实员工处于弱势地位，并没有多少选择。外企基本都是让员工自己选，员工当然都选半年的。当时，主流的国内互联网公司，基本都是给3年的。更有甚者，还追加服务期到5年，得签协议，提前离职需要按比例退钱。在大家普遍5天年假的情况下，外企给到了12天。公积金也按照顶格12%给。中国劳动法其实定的标准很高，比如裁员的赔偿是N+1，比欧洲的标准N/2 要高不少。23年上半年，美国科技大厂大裁员，我的前司也不例外，中国办公室也有受影响，但给了N+6的赔偿。还是挺香的。\n欧洲的外企，Work Life Balance，不加班 这些优势都没有了。因为欧洲本地企业，更加Work Life Balance，不加班。美企的文化反而在这方面处于劣势。不过，福利好，包裹好的优势依旧存在。毕竟美企基本都是跨国企业，从全世界赚钱，有钱许多。而且美国本土程序员薪资很好，因此即使在欧洲只给一半薪资，也是要高于市场水平的。欧洲外企的国际化和多样性很足，同事都是来自不同国家的，甚至本地人都不是特别占优势。相反中国的外企，都是中国人占大多数，外国人极少数。欧洲本地企业，大多数还是本地人居多。除了那种外国人开的企业。但欧洲外企同事的整体水平是要比中国外企的差一大截的。我认为主要原因是，欧洲外企的生态位在欧洲就业市场，并不如中国外企那样占优势，吸引人；很多优秀的人才也是直接被吸引到美国了，不会在欧洲长待。\n中国和欧洲外企工作的共同点：都要和美国开会，中国是早上，欧洲是晚上，都不怎么方便。重要的项目和组还是都在美国，中国和欧洲办公室都相对边缘。三个地方也存在着很多合作。比如On Call的话，如果有的组发展的比较早，会配置美国，爱尔兰/英国，中国/印度，3个时区的小组分别负责，每个时区只用管8个小时，从而建立24小时都有人在上班的全天候服务模式。发展晚些的就只能有2个时区的小组，各12小时。最差的是一个时区管24小时，晚上的警报真是要工程师的老命。\n","categories":["Life"],"tags":["Europe","Amazon","Microsoft","China"]},{"title":"用gitbook写一本书","url":"/2019/07/16/gitbook/","content":"与博客不同，一本书相对内容更为完成，更为体系。博客相比之下就零散的多。不过优秀的系列博客也常常被改编成书。\n如果你想分享规模更大，成体系的知识的话，写本小书是个很好的选择。\n本文介绍一个工具GitBook，可以用Markdown写书，放在GitHub上，生成网页版和PDF版本的书籍。相较传统的Latex，更简单方便。适合当代程序员。\n本文参考的资料主要来源于官网，相较之下，重点更突出，可以快速地 初始化、撰写、发布 一本书。\nInstall gitbook command line tool:\nnpm install gitbook-cli -g\nCreate a book:\ngitbook init ./directory\nPreview and serve your book:\ngitbook serve\nOr build the static website:\ngitbook build\nDebug for better error message with stack trace:\ngitbook build ./ --log=debug --debug","categories":["Programming"]},{"title":"为GitHub Page绑定自己的域名","url":"/2018/05/07/github-page-binding-domain/","content":"我使用的是腾讯云的免费域名.\n除此之外, github上也需要进行一定的设置, 可以参考官方帮助文件.\n"},{"title":"大三上的反思","url":"/2016/11/09/gogogo/","content":"最近经历了两件事情, 使得我感觉需要反思一下近几年的自己.\n第一件事是, 昨晚的编译测试一没过, 具体地说是正确的程序没有跑出正确的结果. 编译测试让我想起两年前的计组测试, 进而想了很多.\n第二件事是, 今天早上的编译课上的小测, 第二道题完全不会, 想要抄别人的也没有的抄, 周围人没有靠谱的, 靠谱的不在周围. 这让我再次认识到, 只有自己才是最靠得住的, 如果自己都靠不住, 那就没人可以真正依靠了.\n 往者\n大一时抱怨数学课太多, 大家纷纷在说说上晒课表, 说&quot;我上的是计算机系, 不是数学系&quot;之类的. 现在看来, 当时真是太naive, 事实上, 现在的我最喜欢数学课了, 而不是计算机课. 究其原因, 当时的专业课只有C语言, 当时的大计基python也确实对计算机学习很重要, 但这些比起现在的专业课真是太简单了. 对于可怜的GPA来说, 大一是最重要的, 因为那些我们不喜欢的数学课, 英语课占的学分很多. 一个学长告诉我说, 你的成绩基本上大一就已经定了. 现在看来, 确实是这样, 只有对自己的无能更加愤怒.\n大二上抱怨计组太难, 6系不是人呆的地方. 熬夜成了家庭便饭, 考期甚至有两门课需要刷夜, 经历了胸闷心痛的感觉. 大二下抱怨OO制度没人性, OS实验懒惰没有申优.\n大三到了该考虑出路的时候, 才发现别人是从一上大学就有了目标并为之奋斗四年, 现在到了即将收获果实的季节; 而自己却发现很多事情都已经为时甚完了; 要GPA, 有前两年的基础, 现在已经很难获得提高了; 要语言考试的成绩, 自己六级飘过的水平, 加上懒惰的习惯, 很难将命运全然托付之; 要找工作, 进顶尖公司, 赚大钱, 自己没有竞赛经验, 算法渣的一比, 自己都羞愧的向优秀的学长道歉. 感觉自己难道真的成了扶不起的阿斗了?\n 出路\n 保研\n这条路是最有可能也是现在面临的最轻松的一条路了, 但看着自己可怜的GPA, 现在已无力力挽狂澜, 只能任人宰割. 外推是绝无可能了, 甚至保本校我都不敢打包票, 毕竟后面还有一大堆加分的.\n 工作\n就像舍友zjy说的, 自己什么都不会, 哪里有公司会要呐. 我和他的处境类似, 虽说2年半来认真学习专业知识, 但无论是深度还是适合度, 都与市场上的需求相差甚远. tls自然不同担心, 有ACM的丰富经验再此, 无论是出国留学还是进入国际顶尖公司, 固然是走上人生巅峰了.\n 留学\n说起来, 自从2016年暑假去英国呆了两周, 竟然有了出国深造的想法和勇气. 没想到已半年过去, 锐气已然消失, 但信念仍存. 虽无背水一战的勇气, 但也有不屈服命运的倔强.\n 创业\n这个选项是留给别人的, 我从来都是想也不敢想. 没有资金, 没有人脉, 没有强爹, 没有素质, 也没有勇气.\n 来者\n新的一年, 新的学期. 这一年, 至少将决定接下来2年的发展, 甚至会决定一生的命运.\n加油!\n","categories":["dairy"],"tags":["life"]},{"title":"游记 | 穗港澳","url":"/2018/10/09/guangzhou-tour/","content":"国庆节后，我和二师兄有机会前往广东，依次游览了广州、澳门 和 香港。10月6号从北京出发，坐10个小时高铁，来到广州南站，之后落塌广东大厦。\n 广州\n第一天先歇一天，在广州玩。早起去爬越秀公园。由于是长假的最后一天，年轻人都玩累了躺在家里休息，大街上和公园里只能看到大量的中老年人在锻炼身体。在公园里，我终于亲眼看到了生长在南方的“木棉”。想起《致橡树》中的诗句，“我愿做你身旁的一株木棉…“；和 《致橡树》电视剧中的情节。橡树 和 木棉 分别生长在北方和南方，注定不能生长在一起。知道这一点的话，才能体会到《致橡树》中传达的悲伤的情感。\n之后到了9点，吃早茶的时间。我们来到“陶陶居”–广州很有名的早茶连锁店，一起吃早茶。早茶是广东的特色。算是早餐，但是可以吃一上午。很多本地人会每天吃早茶，在那里喝一上午的茶，聊一上午的天。很佩服那些吃早茶可以吃一上午的人，羡慕他们的悠闲自在。我是绝对坐不住的，也坐不起。每天早上不学习工作的话，我估计很快就会被淘汰、饿死。早茶 主要包含茶和茶点。一上来会给你一个小盆，后来我才知道是用来涮餐具的。用滚烫的茶水清洗盘子和碗筷，既消了毒，又给餐具带来了茶的清香。茶可以无限续杯，否则怎么坐一上午呢。茶点真是好吃极了，此行不虚。\n吃完早茶后，时间还早，我们就去了城南的沙面公园玩。这里有大量租借时期的建筑和遗留。我很喜欢这里。有很多家长带着来自在公园嬉戏，西式建筑也很符合我的口味，每栋都有自己的特色，因为是不同国家修的。让我想起天津的租界和老房子。在这里，我们还误打误撞进了一家豪华的酒店–白天鹅。二楼的自助餐给我留下了深刻印象。385一位，但由于当天还是国庆假期，425一位。我们进去看了看就出来了，还是等以后有钱了再光临这里吧。我对这里的深刻印象不是因为这里的自助餐有多豪华、多可口，而是这里的位置。落地窗外就是珠江，给人一种整座酒店浮在珠江上一样。满足了我对有钱人奢华生活的想象。这样贵的酒店，生意竟然特别好。更是有人包下整个餐厅举办婚礼。中国有钱人真多，贫穷限制了我的想象。我等屁民，还是紧衣缩食，看看就好了。\n中午吃饭的时候去了一家网红店–吴财记云吞面。位置极其偏僻，人还居多，几乎座无虚席，等的时间还很长。好在味道还可以。我点的炸云吞，不过二师兄点的云吞面味道就一般了。城南是老城区，怎一个破字了得，一点也没有一线城市的氛围。不过晚上到天河区后，就知道，广州当得起一线的地位。\n吃完饭后坐地铁回酒店休息。4点时出发去 中山大学（也叫 双鸭山大学）参观。中山大学的校园很漂亮，妹子也特别多，有个门直接面向珠江，顺江而上就是广州塔。我们骑单车沿着江、跨过桥，总算来到最繁华的天河区了。在这里我们体验了资本主义的奢华和腐败，从此励志好好学习，做共产主义的接班人。我们晚上在地下商场的网红店吃了 鸡煲。打算找个超市买点水果和早餐就回酒店。跟着导航到了一家附近看起来不错的超市，进去后，才一脸蒙蔽，太贵了，消费不起。在二师兄的怂恿下，我破费了一码，买了价值50元的一小盒指头大小的西瓜。最后证明，小西瓜巨难吃，全都浪费了。二师兄这次旅程中都是，聊什么吃的都吹牛说巨好吃。除此之外，没有其他形容词了。等我真正吃到是，发现大多数都一般般，少数食物倒是挺好吃的。我不是个吃货，对这些也没有研究和感受。吃了更多的也是浪费。\n\n 澳门\n去港澳的行程是早就规划好的，也正是这两个特别行政区吸引了二师兄，否则，单单一个广州他是不会和我来的。我提前一个月办好了港澳通行证，当时还经历了一些小波折。出入境管理中心的网站今年更新了，但最近新系统一直处于宕机状态。不知道是有意还是无意，但这无疑很大地提高了公民出境的难度。我等不到系统修复了，只好去不需要预约的海淀出入境大厅办理了港澳通行证。从办理到收到，算上休息日一共14天，效率还可以。二师兄是在我之后办的。他的做法是不停地刷新预约系统，偶尔就可以进去，完成了预约，在花园路派出所就直接办了，而且还办了二次往返的签注。我只有一次出入境的签注，但已经足够了。\n去澳门的路线是乘坐广州-珠海的城际高铁，10分钟一趟公交化运行及其方便。从珠海站下来就是拱北口岸，步行可过关。来到澳门一侧后，就是停车场，有各大赌场的免费接送班车，可以方便的前往凼仔和澳门半岛。我们随便找了一家大巴就走了，最后来到了威尼斯人。\n澳门以赌场闻名。如果说，香港金融中心的地位在大陆有近有广州、远有上海的竞争；澳门的优势可是独一无二的。此次去澳门，真的是长见识了。\n我们先后去了2家赌场，威尼斯人 和 银河。上午在威尼斯人，我们赢了130港币，中午去官也街吃喝，很快就把赢了的钱挥霍完了。下午赌意未尽，又去了另一家大赌场–银河。此次输了100港币，悻悻而退。小赌怡情，大赌伤身。当我拿着ticket去兑换400港币(取了500，输了100）时，前面2个其貌不扬的大叔，兑换的是筹码，兑换的结果有大概10cm厚的几沓1000港币的现金，看上去有几十万。真是不能以貌取人。赌场还是有钱人玩的地方。我们花了100块体验一下就好。与银河的缘分在于，晚上我们打算回拱北口岸时，坐公交方向坐反了，最后又从澳门半岛回到了凼仔的银河赌场。之后干脆在银河吃了晚饭(KFC，这些天二师兄吃快餐都要吃吐了)，坐赌场的大巴回拱北口岸了。\n下午我们还去了澳门半岛，参观了著名的 大三巴牌坊，逛了附近的街市。\n这里也有很多赌场，包括 新旧葡京。我们最后克制住了赌意，一是没钱，二是已经玩的很累了，就像找个地方休息。黄赌毒不能碰，真的是太有道理了。根本克制不住自己的，干脆就不要沾染的好。\n大三巴牌坊其实是一个古老教堂的前墙，后来教堂由于大火毁坏，只留下了这面墙。后来成为历史课本上象征澳门的标志。\n\n 香港\n香港比澳门大的多，我们把最后2天的时间都留在香港了。今年，广州和香港的城际高铁已经开通，每半个小时一趟。乘客只需在香港西九龙站一地两检，十分方便。随着10月份珠港澳大桥的正式开通，珠三角的城际交通会更加方便。我们于10号晚乘坐高铁到达西九龙，出站后就可以换乘地铁。吐槽一下香港的地铁设计。香港地铁不像国内的地铁，换乘站地铁站不只是一个地铁站，还是一个商场。线路换乘就更复杂了，你要在商场中穿梭，甚至有时需要先出站后进站，十分不方便。换乘的线路标示还算清晰，但有个问题是，你跟着指示来到了正确的位置，没有标示告诉你到了。另一方面，地铁报站每站途中只报一次，到站了也不报；不像国内地铁，不停地报站，到站了使劲地告诉你到达哪站了，生怕你坐过站。我们刚去的时候一脸捉瞎，不过很快就适应这些问题了。但用户体验还是极差的。\n图便宜，我们订了一家每晚近600RMB的酒店（皇悦酒店）。果然便宜没好货。香港的酒店外观、走廊、服务人员都不错，只是房间极其狭窄局促，被褥也很潮湿。住2天我们就受不了了，再住下去就要疯了。早就听说香港“居大不易”，现在可算有了切身体会。香港繁华是繁华，居家过日还是不适合的。\n前台的糖巨还难吃，就不能像内地一样放些好吃的薄荷糖嘛，毕竟客户都是内地的呀！\n第一天，以游玩迪士尼乐园为主，晚上去吃了网红的牛腩面。迪士尼乐园可能比不上很多游乐场(包括 大家一直推荐的海洋公园)，年代久远，世界上最小的迪士尼乐园，但这一天我们玩的还是非常开心的。因为在这个地方，我不需要考虑生活的琐碎，人生的规划，只需要像一个孩子一样玩耍就好了。这种感觉很久违了。由于是工作日，乐园的游客比较少，大多数项目都不需要排队。工作日出来玩的，除了我们这样的傻逼，可能就只有富二代们带着孩子出来玩了。很多年轻夫妇看上去确实不像穷人，穷人现在肯定都在哼哧哼哧地工作或者学习呐！\n第二天，我们以太平山观光和购物为主。一大早，坐有名的“叮叮车”来到太平山底。\n买了缆车上行和摩天阁的套票，之所以没买往返的缆车，是因为攻略上建议下山的时候可以乘坐巴士，体验不同的交通工具。“缆车”名为“缆车”，其实和我们在其他山上做的缆车完全不同，更像是有轨电车。不过这个有轨电车是登山用的，上山期间基本上坡度特别陡，有时能达到45度。是次不错的体验。\n到达太平山顶的摩天阁，就可以俯瞰整个香港了。当天的天气特别好，蓝天白云。香港岛和新街尽收眼底。ifc、维港、和其他所有的地标建筑，都可以看到。大有一种指点江山、激扬文字的快感。不过在上面看个一个小时大概也就够了，都是那些建筑和景色，除非换个时间段，否则全无新意。我们在港呆的时间有限，否则傍晚过来，或者晚上过来看维港的灯火，都是很不错的选择。\n太平山也是我到过的最靠南的地方了。\n我们按照攻略上的指示，乘坐了小巴士。司机带着我们在蜿蜒的山路上疾驰，时不时有做过山车的感觉。说实话，香港的司机开车真是快，就是不知道有没有香港的记者快。乘坐巴士的好处是可以一路做到维港边的ifc楼下，而我们下一站的目的地就在于此，ifc的apple store。来香港购置电子产品尤其是苹果家的手机电脑应当是不错的选择，汇率加上税收优惠可以省上不少钱。所以此次我们二人揣了2部iPhone xs，一台Macbook Pro就出境了。\n下午从ifc坐船渡过海峡，来到尖沙咀的海港城购物，二师兄主要想去那里买些衣服和化妆品。由于玩了一天都没有休息，到了诺大的商场二人都很疲惫了。而且海港城店铺的设置和大陆的有很大区别，我们找店找餐厅就废了很大劲。外加上衣服并没有很实惠，想帮大师兄代购的索尼耳机竟然还没大陆便宜。基本上空手而归，人逛的也很疲惫。到了最后我基本到了一家店就找地方坐着或躺着，等二师兄逛完就走。\n海港城离西九龙高铁站已经很近了，所以我们边走边逛，来到高铁站。然后坐上高铁回广州了。\n回到广州，躺在上广东大厦的大床上，觉得还是广州的酒店好。起码床铺是干燥的，房间空间也大的多。\n\n 北京\n10月13号，我们坐上高铁，沿着京广线一路向北，回到帝都。下午6点一回到北京，甚至还在地铁上，就觉得整个人感觉都不一样了。没有在外的很皮、很想玩的心情了，整个身心都收回来了。满脑子想的都是这一周挤压的工作和荒废的学业，想想也是，从中秋节开始放飞自我，有半个月没有好好学习了。二师兄也很佩服我，在外很浪，但一回到北京很快就可以重新进入状态。\n我从来不是一个能玩会玩的人。这次出门可多地方承蒙二师兄的照顾，很多事情的是他在操心，偶尔我试着操心带带路还带错了。我生来就是不会操心的人，在学习生活中因为这样还经常把事情办砸。当然这样的性格也有很多好处。比如，我可以轻松地专心做一件事情；想的少，相应的烦恼也少。凡事都是双刃剑。我接受这样的自己，但也尝试寻找一个平衡，虽然不会操心，但往往该操的时候还是要操的。\n虽然已经在帝都呆了4年了，但最近的我一直有种强烈的感觉：自己以后不会定居在这里。一来，北京居大不易，户口卡的很死；二来，外面的世界诱惑太大，机会也很多。将来会漂泊在何方呢？无论最后的答案是什么，我都希望是自己的选择，在任何地方都要活得精彩。\n","categories":["dairy"],"tags":["travel","游记"]},{"title":"gvim configuration for windows","url":"/2017/03/26/gvim-configuration-for-windows/","content":"最近由于准备GRE, 整天背单词, 练听力和写作, 很是心烦, 很久没折腾了, 所以抽出时间, 给自己的笔记本下载并配置gvim, 也算是休憩.\n 下载\n 配置文件\n与Linux不同, Windows中gvim的配置文件为$HOME/_vimrc(个人配置文件), $VIMROOT/_vimrc(系统配置文件), 默认情况下为C:\\Program Files (x86)\\Vim. 除此之外, 还可以有_gvimrc文件, 只有在gui情况下打开才会读取, 在terminal下不会. 这对于两者应用不同的配置很有帮助, 尤其是使用不同的主题, 同一主题下, 两者的效果很不同. 这样就避免了使用if(has'gui_running')这样复杂的配置内容.\n .vimrc配置\n 打开配置文件\n\n:e $MYVIMRC: 打开用户配置文件, 如果没有的话可以参考help vimrc\n:e $MYGVIMRC: 打开GUI用户配置\nhelp vimrc中推荐的配置文件位置是$HOME/vimfiles/vimrc(Windows)或~/.vim/vimrc(Windows), 这样比起$HOME/_vimrc和~/.vim更portable.\n\n 个性化内容\n$MYGVIMRC\nset clipboard=unnamed   &quot; 与Windows公用clipboard, 默认情况下, y, p只使用vim的clipboard, 不是很方便set colorscheme monokai &quot; 一个我比较喜欢的主题, 不过在terminal下很难看, 所以放在gvimrc中set guifont=Consolas:h18:cANSI:qDRAFT   &quot;换个字体, 默认字体忍不了\n$MYVIMRC\nset numberset nobackup    &quot;不产生~文件set noswapfile  &quot;不产生.swp文件set noundofile  &quot;不产生.un文件set encoding=utf-8  &quot;默认为cp936, 改为与系统兼容的utf-8set fileformat=dos  &quot;换行符以\\r\\n为准set fileencoding=utf-8  &quot;与系统兼容syntax enable\n markdown支持\nvim的插件可以说可以满足你的任何需求, 然而在这里我不是用vim插件, 而是使用chrome extension满足自己的需求. 理由是配置更简单, 未来其他编辑器也可以利用.\n插件安装和使用说明\n绑定快捷键. 在vimrc中加入:\n&quot; Open markdown files with Chrome.autocmd BufEnter *.md exe &#x27;noremap &lt;F5&gt; :!start C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe %:p&lt;CR&gt;&#x27;\n使用时按F5就可以了.\n 后记\n这篇post就是用gvim for MS-WINDOWS完成的.\n","categories":["折腾"],"tags":["vim"]},{"title":"我的投资故事（二）2023","url":"/2023/06/21/investment-2023/","content":"距离上篇我的投资故事（一）已经过去2年时间了，这2年，无论是我的投资观念，还是投资成果，都有了很大的进步。在此，我总结分享我的2022-2023年的投资故事。博客原文。\n最重要的变化是，经过5年的投资，终于扭亏为盈啦。\n 国际大环境\n由于疫情2年的无限量化宽松，俗称“大放水”，美股在2021年底达到历史最高点。之后2022年，欧美通胀高企，Fed又出面强硬加息了。一年时间，从0加到5%。中间多次75基点，不可谓不快。\n","categories":["Life"],"tags":["money","投资"]},{"title":"我的投资故事（一）","url":"/2021/03/22/investment/","content":"分享我的投资故事。\n首发于 Forest的博客.\n 初出茅庐\n小时候，没啥理财习惯和资本。一是没零花钱，二是压岁钱基本需要上交。有一年，大概是为了培养我的理财意识，爸爸带我去建设银行开了户，几百块钱的压岁钱给我补齐到一千，存进了存折。定期一年，自动复利。\n本身是很好的开端。大概是我家对钱的追求不那么在意，这笔钱竟然忘记了。我之前设置的密码也说是不对。后来长大了竟然取不出来了。\n而且一开始是通过户口本办的。当年小孩子都没身份证，不像现在。\n后来去建设银行说了这个事情后，工作人员说必须开户整周年的当天才能取出来。也是醉了。\n后来我过上了北漂生活，半年才能回一次家。赶不上时间，也怕麻烦，这笔钱竟然就一直在那里。\n这次理财经历算是一次失败的教训，毕竟本金都取不出来了。\n 再试牛刀\n上大学后，终于有独立花钱和管钱的权限了。一开始，只是父亲给的生活费和学费；再到后来有了不菲的奖学金和助教工作收入，基本实现了经济独立。因为花费和收入都较少，也没有专门打理；学成一定之后，有了实习工作，开始每天三百，之后每天四百，竟然有了几万的积蓄。这时候，我看到自己挣得钱，第一反应是存起来，就有了理财的再试牛刀。\n当时余额宝和朝朝盈的收益还不错，绝大多数钱都放在里面，也不用操心。后来了解到基金这么个玩意儿。虽然之前父亲买过基金，还赔了钱。不过好在他一直没取出来，之后也一直没看，也不能叫赔。现在说不定还赚了不少也是有可能的。我想当然认为自己也可以。而且当时已经到了2018年，在支付宝上买卖基金十分方便。我梭哈了支付宝给我推荐的一只鸡：嘉实环保低碳股票。支付宝说该基金过往收益多牛，我也觉得环保是未来的方向，就买了6千块钱的。\n先说结论，又一次失败的理财投资。也是第一次当韭菜，感觉到资本市场的寒冷。最后清仓时赔了1600元，持有时间半年。\n总结几点教训：\n\n相信支付宝的推荐，没有自己的思考。要知道，APP或其他经理推荐给你的不一定是能让你挣钱的，但一定是可以让它们挣钱的。所以不要听信其一面之词，而是要有自己的思考和理解。大多数时候，APP的推荐都是不靠谱的。\n持有时间过短。当是持有了半年，割肉离场，后来2年多时间没大规模碰基金。我以为已经是坚持挺长时间的了。后来发现基金持有基本上是要以年为单位的。基金持有大于3年也绝不是空穴来风。后来发现该基金确实后来有涨了上去，而且涨的不少。不过这些都是在我清仓后面几年的事情了。\n一开始就碰股票基金，而且是比较激进的行业型基金。涨的快回撤也大，一般人确实遭不住。环保确实是未来的方向，但这个未来可能以年甚至十年来计，绝不是我能hold住的。新手一开始应该购买货币基金（也就是余额宝之类的），然后是债卷基金，最后是股票型的指数基金。行业基金能不碰就不碰，如果碰了，你一定要对该行业有独特的信仰，支撑你坚持下去。\n\n本次被割之后，我之后就很少碰基金了。只有一次小额投资。\n读研之后，有一次上党课。有个讲国际关系的老师说石油要涨，推荐大家买石油。我买了500块钱的QDII的石油基金，后来持有半年收益10%，然后清仓了。这也是我第一次从基金上挣钱。总结经验是党课还是挺有用的，研究国际关系的老师还是牛逼的。追随他们确实顺从国际大势，从中获利。\n 韭菜归来\n疫情过后，由于全球各国放水印钱，各国故事都开始疯涨。基金和股票也重新回归大众的目光。\n我也再次没有忍受住诱惑，加入到“韭零”后买基大军。\n大概是20年4月份，我陆续买了1500块基金，集中于地产和银行。大多数持有半年，2只基持有一年。\n总的还说是收支平衡（靠2只银行基金，最后小盈利几十块）的一次失败投资。教训主要是：\n\n追涨杀跌。把跌的卖了，此时亏了60块，继续持有涨的2只基。虽然这2只基不负众望，1年涨了10%，弥补了一些损失，但相比同期沪深300啥的也是比不过的。\n在基金最热的时候入场，买在了高点。正所谓巴菲特说的“别人贪婪我恐惧，别人恐惧我贪婪”。我在大家贪婪时入场，果然买在高点。即使是后来盈利的2只基也是买到了高点，只涨了10%。如果在高点前或跌了后买会更划算。\nagain，持有时间不够长。从心理上没有做好长期持有的打算，也没有忍受回撤的能力。\n\n转眼来到21年，此时全球疫情继续，股市继续火热，我作为韭菜又入场了。这次是火热的白酒。我本次投资主要买了白酒/消费和沪深300指数基金。买前包括买后还补习了不少基金知识，稳定自己的信心。\n然而又是高点（事实上是高点前一点）。目前已经亏了13%，大概300块了。最多时候亏17%，400块。\n不过本次我做好了长期持有（3年），装死卧倒不动的打算（其实也算是被套牢了）。而且仍然继续加仓，以实现传说中的右侧交易。只要我不割肉卖出，就不算亏。而且基金便宜了，更要买入了。相信随着疫情的过去，全球经济会缓慢恢复的。\n另外一个经验是，沪深300确实比大多数基金经理更牛逼。涨的时候可能比不上行业基金，但市场波动，抱团股下跌的背景下，谁优孰劣就知道了。\n未来我会继续关注和学习投资和基金，是不是韭菜，只能10年以后再见分晓。\n","categories":["Life"],"tags":["money","投资"]},{"title":"景弛（文远之行）面试","url":"/2018/09/28/jingchi-interview/","content":"昨天参与了景驰科技的实习生面试。此次实习生面试是实验室统一安排的，并不是我自己找的。\n形式为在线面试。总共2轮，预计每轮1小时，实际上第二轮只问了半个小时。第一轮用的Skype，通话质量比较差，视频输出也没有。第二轮，用的微信语音 + collabedit。效果好了很多。\n技术面都很简单。因为是招数据标注平台的码农实习生嘛，自然要求超级低。感觉自己要被廉价卖掉了。\n\n 一面\n一面问了项目和一道括号匹配的问题。\n 二面\n二面问了项目和一道三数之和的问题。过程中，因为我在简历里写的项目是 大三时在act云计算和系统安全组实习做的一系列项目 和 大四做的毕设。尤其是大三的项目，都是琐碎的小项目，而且年代过于久远，很多细节我都记不清了。所以，我干脆提到了我大四做的2次实习。当听到我曾经在快手实习过3个月后，Eric(二面的面试官)很感兴趣。和我聊了一会儿实习的经历，就开始聊景驰的一些技术细节和在景驰科技实习的要求。\n HR面\n下午回到宿舍后，HR小姐姐又给我打了20min电话，也就是聊了一些实习和公司的问题。通过这次交谈，我也对景驰科技有了进一步的了解。\n景驰总共只有150人，总部在广州。在北京和硅谷有研发中心。其中北京这边刚刚建立，只有七八个人。硅谷那边有60+人。主要人员都集中在广州。\n我还问了她transfer到硅谷的问题。她说，硅谷那边大多数在那边直接招的人，当然优秀的员工想要过去也是可以的(估计只是想吸引我)，甚至还有员工领着硅谷的薪水在中国工作。那岂不是年薪巨高（相对中国这边）。\n从Eric和HR的谈话中，我感觉景驰真的很缺人。估计我们都会被招，毕竟便宜嘛。\n我的计划是先实习3个月，认识一些人，学习一些技能。之后想办法再跳出来。继续实习下去，边际收益比较低。\n总之，我现在时间已经不多了。做什么事情都要 不忘初心…\n","categories":["interview"],"tags":["intern","WeRide"]},{"title":"kaggle入门之-titanic","url":"/2018/08/14/kaggle-titanic-tutorial/","content":"为了更快地锻炼自己数据挖掘的能力，我计划最近一个月花一定的时间在kaggle比赛上。目前的计划是把Tutorial上的比赛、Datasets和牛人们的notebook跟完作为入门。之后再选择一个简单的常规比赛参加。\n至于最后是否像欢哥一样走上数据挖掘竞赛之路，看入门之后的感受。自己是否愿意继续花大量的精力在上面。\n数据挖掘的能力主要分为2部分：\n\n机器学习\n特征工程\n\n之前在快手推荐组实习的时候，工作也涉及这些。推荐系统也算是数据挖掘的一个分支，从结果上看，是预测某个item是否会被用户点击。\nTitanic: Machine Learning from Disaster作为大多数人入门kaggle的第一步，确实是对数据挖掘技巧的集中体现。相反，最近在kaggle上比较火的比赛，都是和CV或NLP相关的。领域知识的要求更高，淡化了通用的数据挖掘技能。\n在kaggle上还有许多其他的教程可供用户学习，我今后会选择其中的一些进行重点学习，争取在开学前入门kaggle。\n\nTitanic训练的技能为：\n\n二分类(活/死)\nPython/R 基础\n\nnotebook link这是我本次跟的notebook。\n我把所有的代码都手敲了一遍，拒绝复制粘贴；该完成的Exercises也全部完成；对比赛的一般流程有了初步了解：\n\n题目理解\n数据理解\n数据预处理\n机器学习建模\n模型评估\n提交结果\n\n 题目理解\n在问题描述中，一般会给出数据集的背景、每个challenge的目标、还有所需的技能。\n还可以判断出需要哪些领域知识。比如在Titanic中，20世纪初 西方人的姓名、贵族爵位、船的相关知识都是极其有帮助的。\n看完问题描述后，可以有自己基本的猜测：什么因素对是否存活影响最大？\n我会想到 年龄和性别。媒体不是一直宣传沉船的时候，会让妇女儿童先走？\n之后，我们会用数据分析的方式验证猜测是否合理。\n 数据理解\n通过一些Python及其可视化的工具，我们可以快速对数据有初步的了解。\n比如：titanic是存储所有原始数据的pd.DataFrame，titanic.head()可以显示最开始的5行，titanic.describe()显示所有特征的统计结果，包括最大值、最小值、缺失数量、均值方差等。\n对所有原始特征有直观的了解后，可以知道，哪些特征是离散值，哪些是连续值，哪些需要预处理。\n利用热力图，可以直观地看到不同特征之间的相关性。\n对连续值，画出其分布图(plot_distribution())；对离散值，画出箱形图(plot_categories).\n通过这些技能，可以对选择哪些特征进行建模、如何进行数据预处理 心中有数。\n 数据预处理\n对于离散值(Categorical variables)，需要将其转化为数值类型才能进行下一步的建模。\n二类离散值可以简单地映射为(0, 1)，\n多类离散值需要利用pd.get_dummies()进行one hot编码。\n对缺失值进行填充。由于真实数据采集过程中的不确定性，有些行的某些列是缺失的，这时有2种选择：丢弃整个行，用有意义的值填充缺失值。\n在数据比较宝贵的情况(数据量小 或 缺失值过多）下，一般采取填充的方式。对于离散值，可以填充“Unknown”；对于连续值，一般填充其均值。\n特征工程。这是拉开不同选手之间水平的一项技能，需要一定的领域知识和对数据足够的敏感性。不过今年由于深度学习的原因，特征工程有被放弃的趋势。选手之前的差别主要靠调参。在Titanic中，如果你对20世纪初的西方足够了解的话，一些特征工程才能做。如，从姓名中提取出“Title”，是贵族、平民、还是职员。对船足够熟悉的话，可以从舱室提取出是几等舱，票号中提取出几等票。\n组装最后的数据集。数据集经过我们的预处理后，需要进行特征选择，并组装成可以进行建模的形式。一般是一个pd.DataFrame，还需要切分成 训练集(Train)、验证集(Valid) 和 测试集(Test)。\n 建模 和 模型评估\n这里也是大量工作所在。常用的机器学习模型要一个一个试，每个的参数也要进行调整后再试，然后用验证集评估，选出最好的。\n很多时候，还需要回到数据预处理的部分，选择不同的特征，进行不同的特征工程，再回来进行建模和评估。\n这部分属于枯燥的实验部分，因为需要大量的尝试和选择。当然，可以写自动化的脚本加速这些工作。\n 提交\n提交比较简单。主要是需要注意提交的方法和格式。一般比赛都会给一个提交的模板，帮助参赛者理解所要求的格式。\n我第一次提交因为预测值没有从浮点数转化为整数，分数只有0。之后解决这个问题后，获得了0.77033这样的分数，排名6242/9939。\n这次提交算是对整个流程的一次体验。\n我之后会继续特征工程和调参，以获得更高的分数。\n牛逼的是有很多人满分，之前听说会有泄露预测信息到特征中的bug，不知道是不是这个原因。\n 后记\n据今年找工作的师兄们和网络上的消息，今年算法工程师的岗位竞争十分激烈。很大程度是因为算法岗的高薪资，和去年毕业生尝到的甜头。大家纷纷从开发岗转去算法岗。众多数据挖掘的比赛也因此十分火爆，kaggle就是其中最火的一个比赛平台。我也打算花1个月时间蹭蹭热度，看看自己有没有做算法的天赋和能力。\n在kaggle上，我首先关注了欢哥(mgchbot)，和大师兄(sparkingarthur)。看了他们的Profile，真是很厉害的人呐。尤其是欢哥，不愧是KDD的双料冠军。大师兄也不赖，平时在我面前特别谦虚（也可能是欢哥这样的人一直在身边吧）。他们的kaggle排名分别是100，和1000（现在共有超过8w人）。由于我还没有任何比赛结束，所以排名为Unranked。向优秀的人学习，因为有40w+户口的诱惑。\n","categories":["kaggle"]},{"title":"Kick start 2019 round A","url":"/2019/03/24/kick-start-2019-round-A/","content":"[题目链接]\n这是我首次参加Kick start比赛。之前本科的时候，和舍友tls 参加过它的前身Code Jam。今年才正式准备Kick start的一系列比赛。原因是这是Google选拔软件工程师的途径，而Google是我的Dream Company。\n我于5月22日在清华参加了Google的校园宣讲会。在宣讲会上，前辈们也分外强调准备和参加Kick start的重要性。GG作为一家很左的公司，分外强调公平。而Kick start就是实现招聘公平的一个工具。毕竟相比其他公司的过分注重内推，Kick start给了弱势学校的学生一个机会。\n由于平台故障，最后25min无法提交。虽然我提前一个小时放弃比赛了，但是晚上收到邮件告知这个bug。如果没有这个Bug的话，我的排名可能还要后退。\n最后的排名是 600/3305.\n得分分别为\n\n\n\n\nTraining\nParcels\nContention\nTotal\n\n\n\n\n我的\n20\n15\n0\n35\n\n\n总分\n20\n35\n45\n100\n\n\n\n也就是说，我过了签到题和第二题的small case。\n题目的难度总体比LeetCode要难的多，最后只有2个人拿到了满分。\n 1. Training\n从一个N人的队伍中，挑出P人。要求这P个人的训练时长最小，训练时长为 技能点最大的人的技能点 - 每个人的技能点 之和。\nIntuition：\n先排序。然后用一个长度为P的窗口，不断滑动，求的最小值。\n时间复杂度：O(N log N), 因为排序。\n空间复杂度：O(N).\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;int&gt; &amp;skills, int N, int P) &#123;    sort(skills.begin(), skills.end());    int need_hour = 0;    for (int i = 0; i &lt; P - 1; i++) &#123;        need_hour += skills[P - 1] - skills[i];    &#125;    int ret = need_hour;    int left = 0, right = P - 1;    while (right &lt; N) &#123;        right++;        need_hour += (P - 1) * (skills[right] - skills[right - 1]);        need_hour -= skills[right - 1] - skills[left];        left++;        ret = min(ret, need_hour);    &#125;        return ret;&#125;int main() &#123;    int T;    cin &gt;&gt; T;        for (int i = 0; i &lt; T; i++) &#123;        int N, P;        cin &gt;&gt; N &gt;&gt; P;        vector&lt;int&gt; skills;        for (int j = 0; j &lt; N; j++) &#123;            int s;            cin &gt;&gt; s;            skills.push_back(s);        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; solution(skills, N, P) &lt;&lt; endl;    &#125;&#125;\n 2. Parcels\n给定一个R * C的网格。网格中分布着一些邮局，你只能新建造一个邮局。使得所有格子到达最近邮局的最大距离（定义为曼哈顿距离）最短。\nIntuition：\n我只想到了一种暴力的解法，过了small case。\n从邮局出发，更新所有格子的距离。\n新加邮局时，枚举所有可能的位置。\n时间复杂度: O((R * C)^2)\n空间复杂度: O(R * C).\n#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;// 这里函数名其实应该是 dfsvoid bfs(vector&lt;vector&lt;int&gt;&gt;&amp; distance, int R, int C, int i, int j, int depth) &#123;\tdistance[i][j] = depth;\tvector&lt;int&gt; di = &#123; -1, 0, 1, 0 &#125;;\tvector&lt;int&gt; dj = &#123; 0, 1, 0, -1 &#125;;\tfor (int k = 0; k &lt; 4; k++) &#123;\t\tint ni = i + di[k];\t\tint nj = j + dj[k];\t\tif (ni &lt; R &amp;&amp; nj &lt; C &amp;&amp; ni &gt;= 0 &amp;&amp; nj &gt;= 0 &amp;&amp; distance[ni][nj] &gt; depth + 1) &#123;\t\t\tbfs(distance, R, C, ni, nj, depth + 1);\t\t&#125;\t&#125;&#125;int solution(vector&lt;string&gt; &amp;grids, int R, int C) &#123;\tvector&lt;vector&lt;int&gt;&gt; distance(R, vector&lt;int&gt;(C, numeric_limits&lt;int&gt;::max()));\tfor (int i = 0; i &lt; R; i++) &#123;\t\tfor (int j = 0; j &lt; C; j++) &#123;\t\t\tif (grids[i][j] == &#x27;1&#x27;) &#123;\t\t\t\tbfs(distance, R, C, i, j, 0);\t\t\t&#125;\t\t&#125;\t&#125;\tint ret = numeric_limits&lt;int&gt;::max();\tfor (int i = 0; i &lt; R; i++) &#123;\t\tfor (int j = 0; j &lt; C; j++) &#123;\t\t\tif (grids[i][j] == &#x27;0&#x27;) &#123;\t\t\t\tauto distance_copy = distance;\t\t\t\tbfs(distance_copy, R, C, i, j, 0);\t\t\t\tint max_distance = 0;\t\t\t\tfor (int k = 0; k &lt; R; k++) &#123;\t\t\t\t\tmax_distance = max(max_distance, *max_element(distance_copy[k].begin(), distance_copy[k].end()));\t\t\t\t&#125;\t\t\t\tret = min(ret, max_distance);\t\t\t&#125;\t\t&#125;\t&#125;\treturn (ret == numeric_limits&lt;int&gt;::max()) ? 0 : ret;&#125;int main() &#123;\tint T;\tcin &gt;&gt; T;\tfor (int i = 0; i &lt; T; i++) &#123;\t\tint R, C;\t\tcin &gt;&gt; R &gt;&gt; C;\t\tvector&lt;string&gt; grids(R);\t\tfor (int j = 0; j &lt; R; j++) &#123;\t\t\tcin &gt;&gt; grids[j];\t\t&#125;\t\tcout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; solution(grids, R, C) &lt;&lt; endl;\t&#125;&#125;\n赛后学习官方的ANALYSIS，正确的解法是：\n首先考虑如下的子问题：给定一个最大距离K，我们是否可以通过增加一个邮局，使得最大距离小于等于K？\n这是一个判定问题。\n可以利用我的解法，但是只需要关心那些最大距离大于K的格子。利用这点不同，最后算法的效率会大幅提高。\n有了判定问题的解法，我们可以二分搜索出最优解。这也是一种讲 最优化问题 转化为 判定问题的方法。\n总的做法如下：\n\n首先求的所有格子到最近邮局的距离。可以通过BFS，从所有邮局开始搜索。因为每个格子访问一次，所以时间复杂度为O(R * C).\n对于所有到邮局距离超过K的格子，我们需要找到是否存在一个格子到这些格子的距离小于等于K。为了有效的实现这个步骤，注意到曼哈顿距离计算的等价公式为：dist((x1, y1), (x2, y2)) = max(abs(x1 + y1 - (x2 + y2)), abs(x1 - y1 - (x2 - y2))). 固定点(x2, y2), 最大的曼哈顿距离在 x1 + y1 或 x1 - y1 最大或最小时达到。对于所有最大到邮局距离超过K的格子，我们都计算x1 + y1 或 x1 - y1 最大 和 最小值，得到4个值。然后，再尝试所有可以放邮局的格子。每个格子我们都可以在常数时间内判定。所以此步骤的时间复杂度为RC + RC = O(RC)。\n二分搜索。总的时间复杂度为O(RC log(R+C)).\n\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;using namespace std;class Solution &#123;  vector&lt;set&lt;pair&lt;int, int&gt;&gt;&gt; manhatten; // [i] 表示距离为i的点的集合  vector&lt;int&gt; max_x_sub_y;  vector&lt;int&gt; min_x_sub_y;  vector&lt;int&gt; max_x_add_y;  vector&lt;int&gt; min_x_add_y;  void bfs(vector&lt;string&gt; &amp;grids, int R, int C) &#123;    vector&lt;vector&lt;bool&gt;&gt; visited(R, vector&lt;bool&gt;(C, false));    queue&lt;pair&lt;int, int&gt;&gt; q;    for (int i = 0; i &lt; R; ++i) &#123;      for (int j = 0; j &lt; C; ++j) &#123;        if (grids[i][j] == &#x27;1&#x27;) &#123;          visited[i][j] = true;          q.push(&#123;i, j&#125;);        &#125;      &#125;    &#125;    int level = 0;    while (!q.empty()) &#123;      int s = q.size();      for (int i = 0; i &lt; s; ++i) &#123;        auto current = q.front();        manhatten[level].insert(current);        q.pop();        vector&lt;int&gt; di = &#123;-1, 0, 1, 0&#125;;        vector&lt;int&gt; dj = &#123;0, -1, 0, 1&#125;;        for (int k = 0; k &lt; 4; ++k) &#123;          int ni = current.first + di[k];          int nj = current.second + dj[k];          if (ni &gt;= 0 &amp;&amp; ni &lt; R &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; C &amp;&amp;              visited[ni][nj] == false) &#123;            visited[ni][nj] = true;            q.push(&#123;ni, nj&#125;);          &#125;        &#125;      &#125;      ++level;    &#125;  &#125;  bool possible(vector&lt;string&gt; &amp;grids, int K, int R, int C) &#123;    int grids_count_larger_than_K =        accumulate(manhatten.cbegin() + K + 1, manhatten.cend(), 0,                   [](const auto &amp;lhs, const auto &amp;rhs) -&gt; int &#123;                     return lhs + rhs.size();                   &#125;);    if (grids_count_larger_than_K == 0)      return true;    int max_x_sub_y_K =        *max_element(max_x_sub_y.cbegin() + K + 1, max_x_sub_y.cend());    int min_x_sub_y_K =        *min_element(min_x_sub_y.cbegin() + K + 1, min_x_sub_y.cend());    int max_x_add_y_K =        *max_element(max_x_add_y.cbegin() + K + 1, max_x_add_y.cend());    int min_x_add_y_K =        *min_element(min_x_add_y.cbegin() + K + 1, min_x_add_y.cend());    for (int i = 0; i &lt; R; ++i) &#123;      for (int j = 0; j &lt; C; ++j) &#123;        if (grids[i][j] == &#x27;0&#x27;) &#123;          int distance = numeric_limits&lt;int&gt;::min();          distance = max(distance, abs(i - j - max_x_sub_y_K));          distance = max(distance, abs(i - j - min_x_sub_y_K));          distance = max(distance, abs(i + j - max_x_add_y_K));          distance = max(distance, abs(i + j - min_x_add_y_K));          if (distance &lt;= K)            return true;        &#125;      &#125;    &#125;    return false;  &#125;public:  int solution(vector&lt;string&gt; &amp;grids, int R, int C) &#123;    manhatten.resize(R + C);    bfs(grids, R, C);    max_x_sub_y.resize(R + C);    min_x_sub_y.resize(R + C);    max_x_add_y.resize(R + C);    min_x_add_y.resize(R + C);    for (int i = 0; i &lt; manhatten.size(); ++i) &#123;      max_x_sub_y[i] = numeric_limits&lt;int&gt;::min();      min_x_sub_y[i] = numeric_limits&lt;int&gt;::max();      max_x_add_y[i] = numeric_limits&lt;int&gt;::min();      min_x_add_y[i] = numeric_limits&lt;int&gt;::max();      for (const auto &amp;point : manhatten[i]) &#123;        max_x_sub_y[i] = max(max_x_sub_y[i], point.first - point.second);        min_x_sub_y[i] = min(min_x_sub_y[i], point.first - point.second);        max_x_add_y[i] = max(max_x_add_y[i], point.first + point.second);        min_x_add_y[i] = min(min_x_add_y[i], point.first + point.second);      &#125;    &#125;    int lo = 0, hi = R + C;    auto binary = [&amp;grids, R, C, this](int K) -&gt; bool &#123;      return this-&gt;possible(grids, K, R, C);    &#125;;    // [lo, hi)    while (lo &lt; hi) &#123;      int mid = lo + (hi - lo) / 2;      if (!binary(mid)) &#123;        lo = mid + 1;      &#125; else &#123;        hi = mid;      &#125;    &#125;    return lo;  &#125;&#125;;int main() &#123;  int T;  cin &gt;&gt; T;  for (int i = 0; i &lt; T; i++) &#123;    int R, C;    cin &gt;&gt; R &gt;&gt; C;    vector&lt;string&gt; grids(R);    for (int j = 0; j &lt; R; j++) &#123;      cin &gt;&gt; grids[j];    &#125;    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; Solution().solution(grids, R, C)         &lt;&lt; endl;  &#125;&#125;\n\n 3. Contention\n题意：\n给定Q个Bookings，N个seats, 每个booking用L和R表示，意思是索取从L到R的座位，包括L和R。\n后面的booking，如果前面的座位被占用的话，就只占用可以占用的那些座位。\n求一个最大的K，使得存在一个Bookings的序列。每个Booking都被满足最少K个座位。\n数据范围: Q 30000, N 10^6\n官方分析：\n观测有：给定一个booking序列，最后一个booking可以获得的seats数不依赖于前面的booking的顺序。\n所以，我们可以每次确定最后一个booking，然后不断向前挪。答案是Q步中，最小的座位预定数。\n另一个观察：每次向前挪的时候，我们可以从剩余的booking中贪心地选择最后一个请求：选择那个我们可以获得最多seats的请求。贪心的直觉证明是：最后的答案在向前挪的时候是非递增的。\n该题难度还是很大的，赛中只有2人做出来。我花了半天也还是无法很好地理解。所以题解暂时搁置了。\n","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2019 round B","url":"/2019/07/24/kick-start-2019-round-B/","content":"赛后补的题解。\n题目链接\n Building Palindromes\n给定长度为N的一个字符串，和Q个Query。每个query是一个range，可以得到字串。判断子串重新排列后是否回文。因为可以任意重排，所以子串中字符的顺序不重要，重要的是每个字符出现的频数。频数为奇数的字符数目为0或1，即可重排为回文串。\n因为N和Q的规模较大，10^5。平方算法会超时。这里借用前缀和的思路，快速计算子串字符频数。\n时间复杂度为线性。\n#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;using namespace std;int main(int argc, char const *argv[])&#123;    int T;    cin &gt;&gt; T;    for (int i = 1; i &lt;= T; ++i) &#123;        int N, Q;        cin &gt;&gt; N &gt;&gt; Q;        string s;        cin &gt;&gt; s;        vector&lt;vector&lt;int&gt;&gt; prefix(N+1);        prefix[0] = vector&lt;int&gt;(26, 0);        for (int j = 1; j &lt;= N; ++j) &#123;            prefix[j] = prefix[j-1];            ++prefix[j][s[j-1] - &#x27;A&#x27;];        &#125;        int ans = 0;        for (int j = 0; j &lt; Q; ++j) &#123;            int L, R;            cin &gt;&gt; L &gt;&gt; R;            const auto&amp; l = prefix[L-1], r = prefix[R];            int odd = 0;            for (int k = 0; k &lt; 26; ++k) &#123;                if ((r[k] - l[k]) % 2 == 1)                    ++odd;            &#125;            if (odd &lt;= 1)                ++ans;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n Energy Stones\n本题的思想是 贪心 + 动态规划 (一种0-1背包)。更多背包问题，可以参考背包九讲。\n难点在于，背包遍历的顺序需要用贪心的思路去排序的。\n对于S相同的小的测试集而言，L大的先去遍历。可以是的损失的能量最少。\n对于S不同的大的测试集而言，2个石头i, j的顺序由S_i * L_j决定，如果S_i * L_j &lt; S_j * L_i，则先去i损失的能量更少。\n贪心的正确性也很容易去证明。如果我们有一个吃石头的序列，则 必然是按照能量损失较小的顺序去吃的。否则交换一下顺序，可以获得更大的能量。\n时间复杂度: O(N * N * S_i).\n空间复杂度: O(N * N * S_i), 可以进一步优化到O(N * S_i)\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;vector&gt;using namespace std;struct Stone &#123;  int s, e, l;  bool operator&lt;(const Stone &amp;p) const &#123; return s * p.l &lt; l * p.s; &#125;&#125;;int main(int argc, char const *argv[]) &#123;  int T;  cin &gt;&gt; T;  for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;    int N;    cin &gt;&gt; N;    vector&lt;Stone&gt; data(N + 1);    int S_sum = 0;    for (int i = 1; i &lt;= N; ++i) &#123;      cin &gt;&gt; data[i].s &gt;&gt; data[i].e &gt;&gt; data[i].l;      S_sum += data[i].s;    &#125;    sort(data.begin() + 1, data.end());    vector&lt;vector&lt;int&gt;&gt; dp(N + 1, vector&lt;int&gt;(S_sum + 1));    for (int i = 1; i &lt;= N; ++i) &#123;      for (int time = 0; time &lt;= S_sum; ++time) &#123;        if (time &lt; data[i].s) &#123;          dp[i][time] = dp[i - 1][time];        &#125; else &#123;          dp[i][time] =              max(dp[i - 1][time],                  dp[i - 1][time - data[i].s] +                      max(0, data[i].e - data[i].l * (time - data[i].s)));        &#125;      &#125;    &#125;    int ans = 0;    for (int time = 0; time &lt;= S_sum; ++time) &#123;      ans = max(ans, dp[N][time]);    &#125;    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;  &#125;  return 0;&#125;\n Diverse Subarray\n本题和第一题一样，都需要用到前缀和，但这一转换其实并不是很明显。\n需要先把 types序列 转换成 增减事件序列，此时可以看出，增减事件的前缀和即是最后的我们需要优化的礼物数。\n然后，为了快速获取最大前缀和，可以使用 [线段树](// https://www.geeksforgeeks.org/maximum-prefix-sum-given-range/) 这一工具。实现O(log N)效率的查询一个Range中最大的前缀和，和O(log N)更新线段树。\n总的时间复杂度: O(N log N)\n\n初始化线段树 O(N log N)\n对于N个起点，更新、查询 线段树 O(log N)\n\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;limits&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;struct SegmentTree &#123;  struct Node &#123;    int sum = numeric_limits&lt;int&gt;::min();    int prefix = numeric_limits&lt;int&gt;::min();    bool isValid() const &#123;      return sum != numeric_limits&lt;int&gt;::min() &amp;&amp;             prefix != numeric_limits&lt;int&gt;::min();    &#125;    Node &amp;operator=(const Node &amp;rhs) &#123;      this-&gt;sum = rhs.sum;      this-&gt;prefix = rhs.prefix;      return *this;    &#125;  &#125;;  const int MAX_N = 1 &lt;&lt; 17;  // 存储线段树的全局数组  vector&lt;Node&gt; dat;  int n;  // 初始化  SegmentTree(int n_, int a[]) &#123;    // 为简单起见，把元素个数扩大到2的幂    n = 1;    while (n &lt; n_)      n *= 2;    // 把所有的值都设为INT_MAX    dat.resize(2 * n);    for (int i = 0; i &lt; n_; ++i) &#123;      update(i, a[i]);    &#125;  &#125;  void print() const &#123;    for (const auto &amp;d : dat) &#123;      cout &lt;&lt; &quot;&#123;&quot; &lt;&lt; d.sum &lt;&lt; &quot;, &quot; &lt;&lt; d.prefix &lt;&lt; &quot;&#125;, &quot;;    &#125;    cout &lt;&lt; endl;  &#125;  // 把第k个值(0-indexed)更新为a  void update(int k, int a) &#123;    // 叶子节点    k += n - 1;    dat[k].sum = a;    dat[k].prefix = a;    // 向上更新    while (k &gt; 0) &#123;      k = (k - 1) / 2;      if (!dat[2 * k + 2].isValid())        dat[k] = dat[2 * k + 1];      else &#123;        dat[k].sum = dat[2 * k + 1].sum + dat[2 * k + 2].sum;        dat[k].prefix = max(dat[2 * k + 1].prefix,                            dat[2 * k + 1].sum + dat[2 * k + 2].prefix);      &#125;    &#125;  &#125;  // 求[beg, end)的最小值  // 后面的参数是为了计算起来方便而转入的。  // k 是节点的编号, l, r表示这个节点对应的是[l, r)区间。  // 在外部调用时，用query(index, beg, end, 0, n)  Node query(int index, const int beg, const int end, int l, int r) const &#123;    // cout &lt;&lt; &quot;(&quot; &lt;&lt; index &lt;&lt; &quot;, &quot; &lt;&lt; l &lt;&lt; &quot;, &quot; &lt;&lt; r &lt;&lt; &quot;);&quot; &lt;&lt; endl;    Node ret;    // 如果[beg, end) 和 [l, r)不相交，则返回INT_MAX    if (r &lt;= beg || end &lt;= l)      return ret;    // 如果[beg, end)完全包含[l, r), 则返回当前节点的值    if (beg &lt;= l &amp;&amp; r &lt;= end)      return dat[index];    int mid = l + (r - l) / 2;    auto vl = query(index * 2 + 1, beg, end, l, mid);    auto vr = query(index * 2 + 2, beg, end, mid, r);    if (!vr.isValid()) &#123;      ret = vl;    &#125; else if (!vl.isValid()) &#123;      ret = vr;    &#125; else &#123;      ret.sum = vl.sum + vr.sum;      ret.prefix = max(vl.prefix, vl.sum + vr.prefix);    &#125;    return ret;  &#125;  Node queryMin(const int a, const int b) const &#123; return query(0, a, b, 0, n); &#125;&#125;;// https://www.geeksforgeeks.org/maximum-prefix-sum-given-range/int main(int argc, char const *argv[]) &#123;  int T;  cin &gt;&gt; T;  for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;    int N, S;    cin &gt;&gt; N &gt;&gt; S;    vector&lt;int&gt; A(N), events(N);    unordered_map&lt;int, vector&lt;int&gt;&gt; types; // type, &lt;index&gt;    for (int i = 0; i &lt; N; ++i) &#123;      cin &gt;&gt; A[i];      types[A[i]].push_back(i);      if (types[A[i]].size() &lt;= S) &#123;        events[i] = 1;      &#125; else if (types[A[i]].size() == S + 1) &#123;        events[i] = -S;      &#125; else &#123;        events[i] = 0;      &#125;    &#125;    SegmentTree st(N, events.data());    int ans = numeric_limits&lt;int&gt;::min();    for (int i = 0; i &lt; N; ++i) &#123;      auto r = st.queryMin(i, N);      ans = max(ans, r.prefix);      auto &amp;v = types[A[i]];      auto it = lower_bound(v.begin(), v.end(), i);      if (it + S &lt; v.end()) &#123;        st.update(*(it + S), 1);        if (it + S + 1 &lt; v.end())          st.update(*(it + S + 1), -S);      &#125;    &#125;    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;  &#125;  return 0;&#125;\n 后记\n练习了2场Kick Start，并实际参与1场。我发现自己的水平里Google的要求还差的远呢。Google的对算法的要求直逼ACM，竞赛选手会有很大优势的。我虽然水平有限，但还有时间可以进步。\n过去有6年的比赛题，每年8轮。足够练习2个月时间了。\n周末一场2019 Round D，我会参加练手。争取拿到第1题的全部分数 和 后2题的小 case的分数。\n加油，Forest！\n","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2019 round C","url":"/2019/07/25/kick-start-2019-round-C/","content":"赛后补的题解。\n题目链接\n主要参考的是 旷神 直播的解法，和官方 Analysis的解法。\n Wiggle Walk\n比较容易想到的是暴力解法。模拟整个命令执行过程，标记每个格子是否之前走过。\n时间复杂度: O(N ^ 2).\n虽然实际上凑巧可以AC，但比较冒险。理论上会在大的测试集上TLE。\n#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;pair&lt;int, int&gt; solve(const string&amp; instructions, const int R, const int C, const int Sr, const int Sc) &#123;    int current_x = Sr, current_y = Sc;    vector&lt;vector&lt;bool&gt;&gt; visited(R + 1, vector&lt;bool&gt; (C + 1, false));    visited[current_x][current_y] = true;    for (char c : instructions) &#123;        int dx, dy;        switch (c)        &#123;        case &#x27;N&#x27;:            dx = -1;            dy = 0;            break;        case &#x27;E&#x27;:            dx = 0;            dy = 1;            break;        case &#x27;W&#x27;:            dx = 0;            dy = -1;            break;        case &#x27;S&#x27;:            dx = 1;            dy = 0;            break;        default:            cerr &lt;&lt; &quot;Bad instruction: &quot; &lt;&lt; c &lt;&lt; endl;            break;        &#125;        do &#123;            current_x += dx;            current_y += dy;        &#125; while (visited[current_x][current_y] == true);        visited[current_x][current_y] = true;    &#125;    return &#123;current_x, current_y&#125;;&#125;int main() &#123;    int T;    cin &gt;&gt; T;    for (int i = 0; i &lt; T; ++i) &#123;        int N, R, C, Sr, Sc;        cin &gt;&gt; N &gt;&gt; R &gt;&gt; C &gt;&gt; Sr &gt;&gt; Sc;        string instructions;        cin &gt;&gt; instructions;        auto ans = solve(instructions, R, C, Sr, Sc);        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; endl;    &#125;    return 0;&#125;\n需要找到快速跳过已经走过格子的方法。一种是题解里给的，记录interval的方式。时间复杂度: O(N log N). 每次查询interval需要O(log N).\n#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cassert&gt;using namespace std;int getNext(set&lt;pair&lt;int, int&gt;&gt; &amp;visited, const int x, int direction) &#123;  auto it = visited.lower_bound(&#123;x + 1, x + 1&#125;);  assert(it != visited.begin());  --it;  if (direction &gt; 0)    return it-&gt;second;  else    return it-&gt;first - 1;&#125;void visitRow(set&lt;pair&lt;int, int&gt;&gt; &amp;row, int y) &#123;  auto it = row.lower_bound(&#123;y + 1, y + 1&#125;);  if (it == row.begin()) &#123;    it = row.insert(&#123;y, y + 1&#125;).first;  &#125; else &#123;    --it;    if (it-&gt;first &lt;= y &amp;&amp; it-&gt;second &gt; y) &#123;      return;    &#125; else if (it-&gt;second == y) &#123;      auto old = it;      it = row.insert(it, &#123;it-&gt;first, it-&gt;second + 1&#125;);      it = row.erase(old);    &#125; else &#123;      it = row.insert(&#123;y, y + 1&#125;).first;    &#125;  &#125;  // merge interval  if (next(it) != row.end() &amp;&amp; next(it)-&gt;first == it-&gt;second) &#123;    int end = next(it)-&gt;second;    int begin = it-&gt;first;    row.erase(next(it));    row.erase(it);    row.insert(&#123;begin, end&#125;);  &#125;&#125;void visit(vector&lt;set&lt;pair&lt;int, int&gt;&gt;&gt; &amp;visitedR,           vector&lt;set&lt;pair&lt;int, int&gt;&gt;&gt; &amp;visitedC, const int x, int y) &#123;  auto &amp;row = visitedR[x];  visitRow(row, y);  auto &amp;column = visitedC[y];  visitRow(column, x);&#125;pair&lt;int, int&gt; solve(const string &amp;instructions, const int R, const int C,                     const int Sr, const int Sc) &#123;  int current_x = Sr, current_y = Sc;  vector&lt;set&lt;pair&lt;int, int&gt;&gt;&gt; visitedR(R + 1);  vector&lt;set&lt;pair&lt;int, int&gt;&gt;&gt; visitedC(C + 1);  visit(visitedR, visitedC, current_x, current_y);  for (char c : instructions) &#123;    switch (c) &#123;    case &#x27;N&#x27;:      current_x = getNext(visitedC[current_y], current_x, -1);      break;    case &#x27;E&#x27;:      current_y = getNext(visitedR[current_x], current_y, 1);      break;    case &#x27;W&#x27;:      current_y = getNext(visitedR[current_x], current_y, -1);      break;    case &#x27;S&#x27;:      current_x = getNext(visitedC[current_y], current_x, 1);      break;    default:      cerr &lt;&lt; &quot;Bad instruction: &quot; &lt;&lt; c &lt;&lt; endl;      break;    &#125;    visit(visitedR, visitedC, current_x, current_y);  &#125;  return &#123;current_x, current_y&#125;;&#125;int main() &#123;  int T;  cin &gt;&gt; T;  for (int i = 0; i &lt; T; ++i) &#123;    int N, R, C, Sr, Sc;    cin &gt;&gt; N &gt;&gt; R &gt;&gt; C &gt;&gt; Sr &gt;&gt; Sc;    string instructions;    cin &gt;&gt; instructions;    auto ans = solve(instructions, R, C, Sr, Sc);    cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans.first &lt;&lt; &quot; &quot; &lt;&lt; ans.second &lt;&lt; endl;  &#125;  return 0;&#125;\n另一种是 邝神 直播中的方法。用并查集，需要注意的是union时，方向是重要的。时间复杂度为 O(N).\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;struct UF &#123;    int F[200010];    int find(int x) &#123;        if (F[x] == -1) return x;        return F[x] = find(F[x]);    &#125;    void init() &#123;        memset(F, -1, sizeof(F));    &#125;    void join(int x, int y) &#123;        int t1 = find(x);        int t2 = find(y);        if (t1 != t2) &#123;            F[t2] = t1;        &#125;    &#125;&#125;;UF N, E, W, S;map&lt;pair&lt;int, int&gt;, int&gt; p2Id;int tot;map&lt;int, pair&lt;int, int&gt;&gt; id2P;void init() &#123;    N.init();    E.init();    W.init();    S.init();    tot = 0;    p2Id.clear();    id2P.clear();&#125;int getId(int x, int y) &#123;    pair&lt;int, int&gt; p = make_pair(x, y);    if (!p2Id.count(p)) &#123;        p2Id[p] = tot;        id2P[tot] = p;        tot++;    &#125;    return p2Id[p];&#125;void gao(int x, int y) &#123;    int now = getId(x, y);    int w = getId(x, y-1);    int e = getId(x, y+1);    int n = getId(x-1, y);    int s = getId(x+1, y);    W.join(w, now);    E.join(e, now);    N.join(n, now);    S.join(s, now);&#125;pair&lt;int, int&gt; getNext(int x, int y, char dir) &#123;    int now = getId(x, y);    int nextId;    if (dir == &#x27;N&#x27;) &#123;        nextId = N.find(now);    &#125; else if (dir == &#x27;E&#x27;) &#123;        nextId = E.find(now);    &#125; else if (dir == &#x27;W&#x27;) &#123;        nextId = W.find(now);    &#125; else if (dir == &#x27;S&#x27;) &#123;        nextId = S.find(now);    &#125;    return id2P[nextId];&#125;char str[50010];int main() &#123;    int T;    int iCase = 0;    scanf(&quot;%d&quot;, &amp;T);    while (T--) &#123;        iCase++;        int N, R, C, sx, sy;        scanf(&quot;%d%d%d%d%d&quot;, &amp;N, &amp;R, &amp;C, &amp;sx, &amp;sy);        scanf(&quot;%s&quot;, str);        init();        gao(sx, sy);        pair&lt;int, int&gt; now = make_pair(sx, sy);        for (int i = 0; i &lt; N; ++i) &#123;            now = getNext(now.first, now.second, str[i]);            gao(now.first, now.second);        &#125;        printf(&quot;Case #%d: %d %d\\n&quot;, iCase, now.first, now.second);    &#125;    return 0;&#125;\n Circuit Board\n旷神用了比较暴力的解法。O(R * C^2).\n记录每个格子之前相差K的格子数。\n然后，枚举每列和K，扫描行，更新最大面积。\n观察数据规模，和实际测试，都是能过的。Kick start的时间复杂度基本上也是10^6这个量级。\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int a[310][310];int diff[310][310][310];int main() &#123;  int T;  int iCase = 0;  scanf(&quot;%d&quot;, &amp;T);  while (T--) &#123;    iCase++;    int R, C, K;    scanf(&quot;%d%d%d&quot;, &amp;R, &amp;C, &amp;K);    for (int i = 0; i &lt; R; i++) &#123;      for (int j = 0; j &lt; C; j++) &#123;        scanf(&quot;%d&quot;, &amp;a[i][j]);      &#125;    &#125;    for (int i = 0; i &lt; R; i++) &#123;      for (int j = 0; j &lt; C; ++j) &#123;        int Min = a[i][j];        int Max = a[i][j];        for (int k = j; k &lt; C; ++k) &#123;          Min = min(a[i][k], Min);          Max = max(a[i][k], Max);          diff[i][j][k] = Max - Min;        &#125;      &#125;    &#125;    int ans = 0;    for (int j = 0; j &lt; C; ++j) &#123;        for (int k = j; k &lt; C; ++k) &#123;            int now = 0;            for (int i = 0; i &lt; R; ++i) &#123;                if (diff[i][j][k] &lt;= K) &#123;                    ans = max(ans, (k - j + 1) * (i - now + 1));                &#125; else &#123;                    now = i + 1;                &#125;            &#125;        &#125;    &#125;    printf(&quot;Case #%d: %d\\n&quot;, iCase, ans);  &#125;  return 0;&#125;\n官方的解法是O(N log N)的。\n借助线段树快速查询最大最小值，二分确定满足K的右边界，largest-rectangle-under-histogram 获取最大矩形面积。\n十分考验就高级数据结构和算法的熟悉程度和快速实现能力。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;stack&gt;#include &lt;cmath&gt;using namespace std;// https://www.geeksforgeeks.org/min-max-range-queries-array/// https://www.geeksforgeeks.org/largest-rectangle-under-histogram/struct SegmentTree &#123;    vector&lt;pair&lt;int, int&gt;&gt; st;    int n = 0;    SegmentTree(const vector&lt;int&gt;&amp; a) &#123;        n = a.size();        int x = ceil(log2(n));        int max_size = std::pow(2, x + 1) - 1;        st.resize(max_size);        constructSTUtil(a, 0, n-1, 0);    &#125;    // A recursive function that constructs Segment Tree for array[ss..se].    // si is index of current node in segment tree st    void constructSTUtil(const vector&lt;int&gt;&amp; arr, int ss, int se, int si) &#123;        // If there is one element in array, store it in current node of segment tree and return        if (ss == se) &#123;            st[si].first = arr[ss];            st[si].second = arr[ss];            return;        &#125;        // If there are more than one elements, then recurse for left and right        // subtrees and store the minimum and maximum of two values in this nodee        int mid = ss + (se - ss) / 2;        constructSTUtil(arr, ss, mid, si*2+1);        constructSTUtil(arr, mid+1, se, si*2+2);        st[si].first = min(st[si*2+1].first, st[si*2+2].first);        st[si].second = max(st[si*2+1].second, st[si*2+2].second);    &#125;    /**     * A recursive function to get the minimun and maximum value in a     * given range of array indexes. The following are parameters for thie function.     *      * st --&gt; segment tree vector     * index --&gt; index of current node in the segment tree. Initially 0 is passed as root is always at index 0     * ss &amp;&amp; se --&gt; Starting and ending indexes of the segment represented by current node, i.e. st[index]     * qs &amp;&amp; qe --&gt; Starting and ending indexes of query range     */    pair&lt;int, int&gt; maxMinUtil(int ss, int se, int qs, int qe, int index) &#123;        // if segment of this node is a part of given range,        // then return the minimum and maximum node of the segment        if (ss &gt;= qs &amp;&amp; se &lt;= qe) &#123;            return st[index];        &#125;        // If segment of this node is outside the given range        if (se &lt; qs || ss &gt; qe) &#123;            return &#123;numeric_limits&lt;int&gt;::max(), numeric_limits&lt;int&gt;::min()&#125;;        &#125;        // If a part of this segment overlaps with the given range        int mid = ss + (se - ss) / 2;        auto left = maxMinUtil(ss, mid, qs, qe, index*2+1);        auto right = maxMinUtil(mid+1, se, qs, qe, index*2+2);        return &#123;min(left.first, right.first), max(left.second, right.second)&#125;;    &#125;    pair&lt;int, int&gt; maxMin(int qs, int qe) &#123;        if (qs &lt; 0 || qe &gt; n - 1 || qs &gt; qe) &#123;            cerr &lt;&lt; &quot;Invalid Input&quot; &lt;&lt; endl;            return &#123;numeric_limits&lt;int&gt;::max(), numeric_limits&lt;int&gt;::min()&#125;;        &#125;        return maxMinUtil(0, n-1, qs, qe, 0);    &#125;    int queryDiff(int qs, int qe) &#123;        auto ans = maxMin(qs, qe);        return ans.second - ans.first;    &#125;&#125;;int solve(const vector&lt;vector&lt;int&gt;&gt;&amp; board, int K) &#123;    int R = board.size();    int C = board[0].size();    vector&lt;vector&lt;int&gt;&gt; heigth(R, vector&lt;int&gt;(C));    for (int i = 0; i &lt; R; ++i) &#123;        auto maxMin = SegmentTree(board[i]);        for (int j = 0; j &lt; C; ++ j) &#123;            int lo = j, hi = C;            while (lo &lt; hi) &#123;                int mid = lo + (hi - lo) / 2;                if (maxMin.queryDiff(j, mid) &lt;= K) &#123;                    lo = mid + 1;                &#125; else &#123;                    hi = mid;                &#125;            &#125;            heigth[i][j] = lo - j;        &#125;    &#125;    int ans = 0;    for (int j = 0; j &lt; C; ++j) &#123;        stack&lt;int&gt; s;        int i = 0;        while (i &lt; R) &#123;            if (s.empty() || heigth[s.top()][j] &lt;= heigth[i][j]) &#123;                s.push(i);                ++i;            &#125; else &#123;                int tp = s.top();                s.pop();                ans = max(ans, heigth[tp][j] * (s.empty() ? i : i - s.top() - 1));            &#125;        &#125;        while (!s.empty()) &#123;            int tp = s.top();            s.pop();            ans = max(ans, heigth[tp][j] * (s.empty() ? i : i - s.top() - 1));        &#125;    &#125;    return ans;&#125; int main() &#123;  int T;  cin &gt;&gt; T;  for (int i = 1; i &lt;= T; ++i) &#123;      int R, C, K;      cin &gt;&gt; R &gt;&gt; C &gt;&gt; K;      vector&lt;vector&lt;int&gt;&gt; board(R, vector&lt;int&gt;(C));      for (int j = 0; j &lt; R; ++j) &#123;          for (int k = 0; k &lt; C; ++k) &#123;              cin &gt;&gt; board[j][k];          &#125;      &#125;      int ans = solve(board, K);      cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;  &#125;  return 0;&#125;\n Catch Some\n经典的DP问题。\n每种颜色的衬衫肯定只穿一次。因为2次所走的路肯定大于一次，而且观察到的狗的数量是一样的。\n每种颜色有2个最小花费，一种是需要返回到原点的，另一种是不需要。\ndp[i][j][0/1]表示使用了 (第i种颜色，观察了j个狗，不返回/返回到原点) 所需的最小花费。\n#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;using namespace std;int P[1010], A[1010];int dp[1010][1010][2];const int INF = 0x3f3f3f3f;vector&lt;int&gt; vec[1010];int main() &#123;    int T;    int iCase = 0;    scanf(&quot;%d&quot;, &amp;T);    while (T--) &#123;        iCase++;        int n, k;        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);        for (int i = 0; i &lt; n; ++i) &#123;            scanf(&quot;%d&quot;, &amp;P[i]);        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            scanf(&quot;%d&quot;, &amp;A[i]);        &#125;        for (int i = 1; i &lt;= 1000; ++i) &#123;            vec[i].clear();        &#125;        for (int i = 0; i &lt; n; ++i) &#123;            vec[A[i]].push_back(P[i]);        &#125;        for (int i = 1; i &lt;= 1000; ++i) &#123;            sort(vec[i].begin(), vec[i].end());        &#125;         for (int i = 0; i &lt;= 1000; ++i) &#123;            for (int j = 0; j &lt;= n; ++j) &#123;                dp[i][j][0] = dp[i][j][1] = INF;            &#125;        &#125;        dp[0][0][0] = dp[0][0][1] = 0;        for (int i = 0; i &lt; 1000; ++i) &#123;            for (int j = 0; j &lt;= n;++j) &#123;                if (dp[i][j][0] == INF &amp;&amp; dp[i][j][1] == INF) &#123;                    continue;                &#125;                int sz = vec[i+1].size();                for (int x = 0; x &lt;= sz; ++x) &#123;                    int tmp = x == 0 ? 0 : vec[i+1][x-1];                    dp[i+1][j+x][0] = min(dp[i+1][j+x][0], dp[i][j][0] + 2 * tmp);                    dp[i+1][j+x][1] = min(dp[i+1][j+x][1], dp[i][j][0] + tmp);                    dp[i+1][j+x][1] = min(dp[i+1][j+x][1], dp[i][j][1] + 2 * tmp);                &#125;            &#125;        &#125;        printf(&quot;Case #%d: %d\\n&quot;, iCase, dp[1000][k][1]);    &#125;&#125;\n 后记\n总结一下kick start的常考考点：\n\nDP/背包\n二分\n线段树\n\n","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2019 round D","url":"/2019/07/28/kick-start-2019-round-D/","content":"排名: 765 / 1866.\n X or What\n本题是找规律的题目，考察最xor的熟悉程度。事实上，我曾经很接近于正确解法了。但一头心思钻到 interval 题目用线段树求解的经验上，试图寻找节点记录什么信息。结果越走越偏。\n总结起来规律是这样的:\n题目中给了xor-even的定义。\n我们根据xor的性质有：\n\nodd xor odd -&gt; even\nodd xor even -&gt; odd\neven xor even -&gt; even\n\n想要最后xor-even，interval中的odd必须是偶数个。一个非常直接的思路就出来了。统计odd的数量，如果是偶数，那么最长的interval就是整个数组的长度。如果是奇数，则去掉头或尾，找最长的。\n#include &lt;set&gt;#include &lt;cstdio&gt;using namespace std;const int N = 1e5 + 5;int n, q;int a[N], v[N];int p[N];int even(int i) &#123;  int count = 0;  while (i &gt; 0) &#123;    count += i % 2;    i /= 2;  &#125;  return count;&#125;void read_input() &#123;  scanf(&quot;%d %d&quot;, &amp;n, &amp;q);  for (int i = 0; i &lt; n; ++i) &#123;    int x;    scanf(&quot;%d&quot;, &amp;x);    a[i] = even(x) &amp; 1;  &#125;  for (int i = 0; i &lt; q; ++i) &#123;      int x;    scanf(&quot;%d %d&quot;, p+i, &amp;x);    v[i] = even(x) &amp; 1;  &#125;&#125;void solve() &#123;  set&lt;int&gt; idx[2];  for (int i = 0; i &lt; n; ++i) &#123;    idx[a[i]].insert(i);  &#125;  for (int i = 0; i &lt; q; ++i) &#123;    if (a[p[i]] != v[i]) &#123;      idx[a[p[i]]].erase(p[i]);      a[p[i]] = v[i];      idx[a[p[i]]].insert(p[i]);    &#125;    if (i)      printf(&quot; &quot;);    if (idx[1].size() % 2 == 0) &#123;      printf(&quot;%d&quot;, n);    &#125;    else &#123;      int ans = max(*idx[1].rbegin(), n-*idx[1].begin()-1);      printf(&quot;%d&quot;, ans);    &#125;  &#125;  printf(&quot;\\n&quot;);&#125;int main() &#123;#ifdef LOCAL  time_t starttime = clock();#endif  int tt;  scanf(&quot;%d&quot;, &amp;tt);  for (int tc = 1; tc &lt;= tt; tc++) &#123;    printf(&quot;Case #%d: &quot;, tc);    read_input();    solve();#ifdef LOCAL    cerr &lt;&lt; &quot;~ TC#&quot; &lt;&lt; tc &lt;&lt; &quot; done! execution time: &quot; &lt;&lt;      (double)(clock()-starttime) / CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;#endif  &#125;  return 0;&#125;\n \n","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2019 round E","url":"/2019/08/29/kick-start-2019-round-E/","content":" Cherries Mesh\nMinimum spanning tree.\n尤其要注意Union-find的实现中，find要采用path compression的方法才能实现O(1).\n否则会超时。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct UF &#123;\tvector&lt;int&gt; parents;\tUF(int n) &#123;\t\tparents.resize(n);\t\tfor (int i = 0; i &lt; n; ++i) &#123;\t\t\tparents[i] = i;\t\t&#125;\t&#125;\tint find(int x) &#123;\t\treturn parents[x] == x ? x : (parents[x] = find(parents[x]));\t&#125;\tvoid unio(int x, int y) &#123;\t\tint px = find(x);\t\tint py = find(y);\t\tparents[px] = py;\t&#125;&#125;;int main() &#123;\tint T;\tcin &gt;&gt; T;\tfor (int i = 0; i &lt; T; ++i) &#123;\t\tint N, M;\t\tcin &gt;&gt; N &gt;&gt; M;\t\tUF uf(N);\t\tint ans = 0;\t\tfor (int j = 0; j &lt; M; ++j) &#123;\t\t\tint l, r;\t\t\tcin &gt;&gt; l &gt;&gt; r;\t\t\t--l;\t\t\t--r;\t\t\tif (uf.find(l) == uf.find(r)) &#123;\t\t\t\tcontinue;\t\t\t&#125;\t\t\tuf.unio(l, r);\t\t\tans += 1;\t\t&#125;\t\tans += (N - 1 - ans) * 2;\t\tcout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n Code-Eat Switcher\n Test set 1:\nS = 1 或 2。列不等式就可以求解。\n当S = 2时，有2个变量，不等式求解过程类似线性规划。\n比赛的时候思路是对的，但是因为S = 1时，返回值写错了，一直没有AC。当时一直在调S = 2时的逻辑，完全没有想到S = 1时会出错。\n#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;bool solve(const vector&lt;pair&lt;int, int&gt;&gt;&amp; energy, const int S, double code, double eat) &#123;    if (S == 1) &#123;        double Ci = energy[0].first;        double Ei = energy[0].second;        return code / Ci + eat / Ei &lt;= 1;    &#125; else if (S == 2) &#123;        double C1 = energy[0].first, C2 = energy[1].first;        double E1 = energy[0].second, E2 = energy[1].second;        if (C1 / C2 == E1 / E2) &#123;            vector&lt;pair&lt;int, int&gt;&gt; tmp = &#123;make_pair(energy[0].first + energy[1].first, energy[0].second + energy[1].second)&#125;;            return solve(tmp, 1, code, eat);        &#125;        double C = code, E = eat;        double x = (C / C2 - 1 + E / E2 - E1 / E2) / (C1 / C2 - E1 / E2);        double y = C / C2 - x * C1 / C2;        // cout &lt;&lt; &quot;result: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;|&quot; &lt;&lt; x * C1 + y * C2 &lt;&lt; &quot;, &quot; &lt;&lt; (1 - x) * E1 + (1 - y) * E2 &lt;&lt; &quot; | &quot; &lt;&lt;         // 1 - E / E2 + E1 / E2 - x * E1 / E2        // &lt;&lt; endl;        if (x &gt; 1) &#123;            return 1 - E / E2 + E1 / E2 - 1 * E1 / E2 &gt;= C / C2 - 1 * C1 / C2;        &#125;        if (y &gt; 1) &#123;            return (1 - E / E2 + E1 / E2 - 1) * (E2 / E1) &gt;= (C / C2 - 1) * (C2 / C1);        &#125;        if (x &lt; 0) &#123;            return 1 - E / E2 + E1 / E2 &gt;= C / C2;        &#125;        if (y &lt; 0) &#123;            return (1 - E / E2 + E1 / E2) * (E2 / E1) &gt;= (C / C2) * (C2 / C1);        &#125;        return true;        // return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt;= 1 &amp;&amp; y &lt;= 1;    &#125; else &#123;        return false;    &#125;&#125;int main()&#123;\tint T;\tcin &gt;&gt; T;\tfor (int i = 0; i &lt; T; ++i)\t&#123;\t\tint D, S;        cin &gt;&gt; D &gt;&gt; S;        string ans;        vector&lt;pair&lt;int, int&gt;&gt; energy(S);        for (int i = 0; i &lt; S; ++i) &#123;            cin &gt;&gt; energy[i].first &gt;&gt; energy[i].second;        &#125;        for (int i = 0; i &lt; D; ++i) &#123;            int A, B;            cin &gt;&gt; A &gt;&gt; B;            bool yes = solve(energy, S, A, B);            if (yes) &#123;                ans.push_back(&#x27;Y&#x27;);            &#125; else &#123;                ans.push_back(&#x27;N&#x27;);            &#125;        &#125;\t\tcout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;\t&#125;\treturn 0;&#125;\n Test Set 2\n观察有，对于每个slot，每获得1份eating能量，就会少收获Ci/EiC_i / E_iCi​/Ei​份coding能量。所以如果Ci/Ei&lt;Cj/EjC_i / E_i &lt; C_j / E_jCi​/Ei​&lt;Cj​/Ej​的话，更好的选择永远时i。\n根据这个观察，我们把slot根据Ci/EiC_i / E_iCi​/Ei​排序，计算E的前缀和和C的后缀和。每天使用二分查找找到满足eating的分界点，再判断是否满足coding。\n#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool solve(const vector&lt;pair&lt;int, int&gt;&gt; &amp;energy, const int S,           const vector&lt;int&gt; &amp;prefix, const vector&lt;int&gt; &amp;suffix, int code,           int eat) &#123;    auto it = lower_bound(prefix.begin(), prefix.end(), eat);    int index = distance(prefix.begin(), it);    if (index == S) &#123;        return false;    &#125;    double need;    if (index == 0) &#123;        need = eat;    &#125; else &#123;        need = eat - prefix[index - 1];    &#125;    double f = need / energy[index].second;    double code_have;    if (index == S - 1) &#123;        code_have = 0;    &#125; else &#123;        code_have = suffix[index + 1];    &#125;    double code_need = code - code_have;    return (1 - f) * energy[index].first &gt;= code_need;&#125;int main() &#123;    int T;    cin &gt;&gt; T;    for (int i = 0; i &lt; T; ++i) &#123;        int D, S;        cin &gt;&gt; D &gt;&gt; S;        string ans;        vector&lt;pair&lt;int, int&gt;&gt; energy(S);        for (int i = 0; i &lt; S; ++i) &#123;            cin &gt;&gt; energy[i].first &gt;&gt; energy[i].second;        &#125;        sort(energy.begin(), energy.end(),             [](const auto &amp;lhs, const auto &amp;rhs) -&gt; bool &#123;                 return lhs.first / static_cast&lt;double&gt;(lhs.second) &lt;                        rhs.first / static_cast&lt;double&gt;(rhs.second);             &#125;);        // build prefix cumulative for eating        vector&lt;int&gt; prefix(S);        int current = 0;        for (int i = 0; i &lt; S; ++i) &#123;            current += energy[i].second;            prefix[i] = current;        &#125;        // build suffix cumulative for coding        vector&lt;int&gt; suffix(S);        current = 0;        for (int i = S - 1; i &gt;= 0; --i) &#123;            current += energy[i].first;            suffix[i] = current;        &#125;        // binary search for each day        for (int i = 0; i &lt; D; ++i) &#123;            int A, B;            cin &gt;&gt; A &gt;&gt; B;            bool yes = solve(energy, S, prefix, suffix, A, B);            if (yes) &#123;                ans.push_back(&#x27;Y&#x27;);            &#125; else &#123;                ans.push_back(&#x27;N&#x27;);            &#125;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n Street Checkers\n一个数X是否是interesting的，可以转化为 |(# of odd divisors) - (# of even divisors)| &lt;= 2.\n对于R &lt; 106的数据集，我们可以把所有小于106的数，进行预处理获得其约束的个数，时间复杂度为O(sqrt(X))，然后建立[1, X]中interesting数目的prefix sum。对于query [L, R]，我们就可以O(1)获得答案了。总的时间复杂度为O(RmaxRmax+T)O(R_{max} \\sqrt{R_{max}} + T)O(Rmax​Rmax​​+T), 预处理 + T个测试用例.\n对于大的数据集，我们还需要继续观察。\n任何奇数的约数仍然是奇数。每个整数X都能写成X=A×2pX = A \\times 2 ^ pX=A×2p, 其中 A是一个奇数，X是非负整数。\n因此，我们可以把X的所有约数分为组, 其中d1d_1d1​,d2d_2d2​,…,dkd_kdk​是A的约数。\n{d1,d1∗2,d1∗22,…,d1∗2p}\\{d_1, d_1 * 2, d_1 * 2^2, \\dots, d_1 * 2^p\\}{d1​,d1​∗2,d1​∗22,…,d1​∗2p}\n{d2,d2∗2,d2∗22,…,d2∗2p}\\{d_2, d_2 * 2, d_2 * 2^2, \\dots, d_2 * 2^p\\}{d2​,d2​∗2,d2​∗22,…,d2​∗2p}\n…\\dots…\n{dk,dk∗2,dk∗22,…,dk∗2p}\\{d_k, d_k * 2, d_k * 2^2, \\dots, d_k * 2^p\\}{dk​,dk​∗2,dk​∗22,…,dk​∗2p}\n可以发现，奇约数的个数为k, (k &gt;= 1, 至少有个奇约数为1)。\n偶约数为k * X.\n奇偶之差为 ∣k(X−1)∣≤2|k(X-1)| \\le 2∣k(X−1)∣≤2.\n解为：\n\n\nCase 1: X = 0, k = 1 or 2\n\n\nCase 2: X = 1, k can be any value\n\n\nCase 3: X = 2, k = 1 or 2\n\n\nCase 4: X = 3, k = 1\n\n\nCase 1 表示 1 或 一个奇质数。\n\n\nCase 2 表示，A可以为任意奇数，则原数的形式为 $ 2*(2n + 1) = 4 * n + 2$, 可以通过O(1)算出。\n\n\nCase 3 表示, A 为 1 或 任意奇质数。也就是[L / 4, R / 4]中的奇质数个数。\n\n\nCase 4 只表示一个数 8.\n求质数的个数可以使用Sieve of Eratosthenes.\n\n\n时间复杂度: O(T∗(R−L+1)∗log(R))O(T * (R - L + 1) * log(\\sqrt{R}))O(T∗(R−L+1)∗log(R​))\n","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2019 round G","url":"/2019/10/20/kick-start-2019-round-G/","content":"本轮是今年的倒数第二轮，也是相对比较简单的一个轮次。\n我做出了第3题和1 2题的小数据集。第二题我本身的算法是对的，但是没有正确的评估最大的k的位数，并防止溢出操作，所以字大数据集上WA。第一题其实本身不难，只是我对约数不很敏感，导致错失没有想出更好的解法。总的来说，本轮是我最接近AC的轮次，运气相对不错，也提前1个小时完成了比赛。因为后来实在想不出解法 和 要注意的点了，就放弃了。\n Book Reading\n暴力法加memo可以直接过。可以我的记忆化写错了，忘记记忆了。导致TLE，损失了不少分数，太可惜 了。\n另外，能用long long就不要用int。否则最后的ans会溢出。\n时间复杂度: O(N log (N)).\n因为记忆化 的存在，计算的页数最多是1 + 1 / 2 + 1 / 3 + ... + 1 / N = log N, 即调和级数。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;using ll = long long;int main() &#123;    ll T;    cin &gt;&gt; T;    for (ll iCase = 1; iCase &lt;= T; ++iCase) &#123;        ll ans = 0;        ll N, M, Q;        cin &gt;&gt; N &gt;&gt; M &gt;&gt; Q;        vector&lt;bool&gt; pages(N + 1, true);        pages[0] = false;        for (ll i = 0; i &lt; M; ++i) &#123;            ll P;            cin &gt;&gt; P;            pages[P] = false;        &#125;        unordered_map&lt;ll, ll&gt; memo;        for (ll i = 0; i &lt; Q; ++i) &#123;            ll R;            cin &gt;&gt; R;            ll count = 0;            if (memo.find(R) != memo.end()) &#123;                count = memo[R];            &#125; else &#123;                for (ll j = 1; j * R &lt;= N; ++j) &#123;                    if (pages[j * R]) &#123;                        ++count;                    &#125;                &#125;                memo[R] = count;            &#125;            ans += count;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;&#125;\n The Equation\n本题要注意的点相对比较多，本身算法并不难。\n\nlong long  常数是1L。否则1默认 是int，会有溢出风险。\n我们不能从A中的最高位开始找，因为可能k会是更大的数。而应该从 M的角度考虑k的最大值，这里M是15位的，对应二进制50位。然而，我们同样不能从太高的位开始找，否则 N*( 1&lt;&lt;i )会溢出64位。鉴于N最大是1000，二进制10位。我们可以从50~53位开始找。\n\n因为要最大化k，所以我们可以使用贪心的思路，从高位向低位数，尽量放置1，否则放置0，超过要求回溯。\n因为有大量的回溯剪枝的存在，时间复杂度不是很好分析。但可以过大的数据集。\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;using ll = long long;ll backtracking(const vector&lt;ll&gt; &amp;bits, const ll N, const ll M, ll position,                ll accu, ll k) &#123;    ll one = bits[position];    ll zero = N - one;    // k always wants to be 1 in position i    ll i = position;    if (position &lt; 0) &#123;        return k;    &#125;    ll ret = -1;    if (accu + zero * (1L &lt;&lt; i) &lt;= M) &#123; // if one        ret = backtracking(bits, N, M, position - 1,                           accu + zero * (1L &lt;&lt; i),                           k + (1L &lt;&lt; i));    &#125;    if (ret == -1) &#123; // zero        if (accu + one * (1L &lt;&lt; i) &lt;= M) &#123;            ret = backtracking(bits, N, M, position - 1,                               accu + one * (1L &lt;&lt; i), k);        &#125;    &#125;    return ret;&#125;int main() &#123;    ll T;    cin &gt;&gt; T;    for (ll iCase = 1; iCase &lt;= T; ++iCase) &#123;        ll ans = 0;        ll N, M;        cin &gt;&gt; N &gt;&gt; M;        vector&lt;ll&gt; bits(64, 0);        ll max_position = 0;        for (ll i = 0; i &lt; N; ++i) &#123;            ll A;            cin &gt;&gt; A;            ll position = 0;            while (A &gt; 0) &#123;                ll last_bit = A % 2;                if (last_bit &gt; 0) &#123;                    ++bits[position];                    max_position = max(max_position, position);                &#125;                A = A / 2;                ++position;            &#125;        &#125;        ans = backtracking(bits, N, M, 53, 0, 0);        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;&#125;\n Shifts\n同第二题，我采用了回溯法加大量剪枝和记忆化，以枚举所有的组合。没想到竟然过了。\n题解给出的方法是采用 分治法，分别枚举2个小的集合的组合。然后再遍历所有组合，寻找合并后符合要求的组合数。\n#include &lt;cmath&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;using ll = long long;ll backtracking(const vector&lt;ll&gt; &amp;A, const vector&lt;ll&gt; &amp;B,                const vector&lt;ll&gt; &amp;suffixA, const vector&lt;ll&gt; &amp;suffixB, ll needA,                ll needB, ll position, map&lt;tuple&lt;ll, ll, ll&gt;, ll&gt; &amp;memo,                map&lt;tuple&lt;ll, ll&gt;, ll&gt; &amp;memoA, map&lt;tuple&lt;ll, ll&gt;, ll&gt; &amp;memoB) &#123;    const ll n = A.size();    if (position &gt;= n) &#123;        return needA &lt;= 0 &amp;&amp; needB &lt;= 0 ? 1 : 0;    &#125;    auto it = memo.find(&#123;needA, needB, position&#125;);    if (it != memo.end()) &#123;        return it-&gt;second;    &#125;    if (needA &lt;= 0 &amp;&amp; needB &lt;= 0) &#123;        return memo[&#123;needA, needB, position&#125;] = pow(3, n - position);    &#125;    if (needA &gt; suffixA[position] || needB &gt; suffixB[position]) &#123;        return memo[&#123;needA, needB, position&#125;] = 0;    &#125;    if (needA &lt;= 0) &#123;        auto it = memoA.find(&#123;needB, position&#125;);        if (it != memoA.end()) &#123;            return it-&gt;second;        &#125;    &#125;    if (needA &lt;= 0) &#123;        auto it = memoA.find(&#123;needB, position&#125;);        if (it != memoA.end()) &#123;            return it-&gt;second;        &#125;    &#125;    if (needB &lt;= 0) &#123;        auto it = memoB.find(&#123;needA, position&#125;);        if (it != memoB.end()) &#123;            return it-&gt;second;        &#125;    &#125;    ll ret = 0;    ret += backtracking(A, B, suffixA, suffixB, needA - A[position],                        needB - B[position], position + 1, memo, memoA, memoB);    ret += backtracking(A, B, suffixA, suffixB, needA, needB - B[position],                        position + 1, memo, memoA, memoB);    ret += backtracking(A, B, suffixA, suffixB, needA - A[position], needB,                        position + 1, memo, memoA, memoB);    if (needA &lt;= 0) &#123;        memoA[&#123;needB, position&#125;] = ret;    &#125;    if (needB &lt;= 0) &#123;        memoB[&#123;needA, position&#125;] = ret;    &#125;    return memo[&#123;needA, needB, position&#125;] = ret;&#125;int main() &#123;    ll T;    cin &gt;&gt; T;    for (ll iCase = 1; iCase &lt;= T; ++iCase) &#123;        ll N, H;        cin &gt;&gt; N &gt;&gt; H;        vector&lt;ll&gt; A(N), B(N), suffixA(N), suffixB(N);        for (int i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; A[i];        &#125;        for (int i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; B[i];        &#125;        if (N &gt; 0) &#123;            suffixA[N - 1] = A[N - 1];            suffixB[N - 1] = B[N - 1];        &#125;        for (int i = N - 2; i &gt;= 0; --i) &#123;            suffixA[i] = A[i] + suffixA[i + 1];            suffixB[i] = B[i] + suffixB[i + 1];        &#125;        map&lt;tuple&lt;ll, ll, ll&gt;, ll&gt; memo;        map&lt;tuple&lt;ll, ll&gt;, ll&gt; memoA;        map&lt;tuple&lt;ll, ll&gt;, ll&gt; memoB;        auto ans =            backtracking(A, B, suffixA, suffixB, H, H, 0, memo, memoA, memoB);        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;&#125;","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2019 round H","url":"/2019/11/25/kick-start-2019-round-H/","content":"由于欧洲这边夏令时的原因，处于UTC +1.00，所以本次比赛我是特意早上6点起来打的。打完后休息了一个小时，又和小伙伴去根特玩了一天。晚上回来的时候，才想起来Machine Learning的assignment 2当天截止，又疯狂地赶起了Deadline。事实证明，没有认真学习还是搞不定作业的。马马虎虎交上去了，总比不交好些。空白的题目，大方地告诉助教我就是不会。\n本次比赛是Kick start 2019的最后一个轮次，我还是很想参加的。今年我共参加了6轮kick start。虽然A轮就拿到了面试的邀请，但仍然不可马虎。各次的排名如下所示:\n\n\n\n轮次\nA\nD\nE\nF\nG\nH\n\n\n\n\nRank\n600\n765\n1566\n1341\n462\n330\n\n\nScore\n35\n27\n22\n11\n42\n41\n\n\n\n除了F轮，我当时在巴黎玩，趁晚上在青旅的功夫瞎做的外。其他轮次还是可以说是全力以赴的。\n总的名次是先下降后上升，并不能体现实力的变化，更多的是心态的改变。因为D轮次比较重要，当时也有同学一起竞争，不忍心与他比赛时交流。E轮次时，当时是在字节跳动的夏令营，和一个妹子一起做的。本身还是很想打好的，但由于并查集没有实现find的折叠，导致 超时。这也是之前没有注意到的盲点。其他3次结果相对好的轮次反而是没有包袱，更放松的时候。\n最近还意外地收获了Google北京 A day with Google的邀请。无奈我不再北京，只能拒绝了。另外，我还通过邮件向Google反映了Google所有招聘相关的Form中My University中都没有 Beihang University的选项（我猜测这可能是因为北航在美国商务部的黑名单上的原因）。Google很快解决了，我航以后再也不是野鸡大学了。\n本次做出签到题和第3题的小测试集1，算是正常发挥吧。\n A. H-index\n第一次做误解了题意，以为是求最后的H-index就可以了。简单地写了个二分查找用判定问题求最大值的解法。\n后来才发现是需要求每次论文的结果，之后又因编写了几个bug的问题影响了耗时。\nIntuition：\n随着论文的发表，H-index是单调递增的。利用这一特性，每次发表论文后，尝试去增加H-index.\n这里我利用里C++ STL set中有序的特点和基于节点的container再插入新节点后iterator的不变性，高效地实现了尝试增加H-index的操作。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;int MAX_N = 1e5 + 5;void solve(const vector&lt;int&gt; &amp;A, int N) &#123;    multiset&lt;int, std::greater&lt;int&gt;&gt; s;    int ans = 0;    auto it = s.begin();    for (int i = 0; i &lt; N; ++i) &#123;        int come = A[i];        if (come &gt; 0) &#123;            s.insert(come);            if (s.size() == 1) &#123;                it = s.begin();                if (come &gt;= 1) &#123;                    ans = 1;                &#125;            &#125;            else if (come &gt; *it) &#123;                --it;                // cout &lt;&lt; &quot; --it &quot; &lt;&lt; *it &lt;&lt; &quot; &quot;;                // if (next(it) != s.end()) &#123;                //     cout &lt;&lt; &quot; next(it): &quot; &lt;&lt; *(next(it)) &lt;&lt; &quot; &quot;;                // &#125;            &#125;            if (it != s.end() &amp;&amp; next(it) != s.end() &amp;&amp; *next(it) &gt;= ans + 1) &#123;                ++ans;                ++it;            &#125;        &#125;        cout &lt;&lt; ans &lt;&lt; &quot; &quot;;    &#125;&#125;int main() &#123;    int T;    cin &gt;&gt; T;    vector&lt;int&gt; A(MAX_N);    for (int iCase = 0; iCase &lt; T; ++iCase) &#123;        int N;        cin &gt;&gt; N;        for (int i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; A[i];        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase + 1 &lt;&lt; &quot;: &quot;;        solve(A, N);        cout &lt;&lt; endl;    &#125;&#125;\n B. Diagonal Puzzle\n比赛时试图通过回溯枚举所有的翻转找到最小解，时间复杂度O(2 ^ (4 * N))。没想到连最小的数据集都超时了。所以，题解都是通过赛后从官方的Analysis中看来得。\n 小测试集\n没必要枚举所有的翻转。我们可以只枚举同一个方向的翻转，然后检查是否另一个方向每条线上都同色。\n与主对角线平行的翻转有2 * N - 1个，与主对角线垂直的也有2 * N - 1个。\n检查同色的复杂度为O(N ^ 2).\n所以总的时间复杂度为O(2 ^ (2 * N - 1) * N ^ 2).\n 大测试集\n本解法基于一个有趣的观察，如果我们确定主对角线和反主对角线的翻转，为了确定最后全为白色，其余翻转可以因此确定。当N为奇数时，是主对角线和次反主对角线。N == 6， 7时的情况如下所示。\n\\..../ \\.......\\../. .\\..../..\\/.. ..\\../.../\\.. ...\\/.../..\\. .../\\../....\\ ../..\\.       ./....\\\n所以，我们可以枚举主对角线的翻转 情况 ，共4种，然后根据对角线上 的 其他元素的颜色，确定其他翻转 。最后检查是否符合全是白的要求。\n时间复杂度: O(4 * N ^ 2).\n此解法其实和我之前经常做的翻灯的题目很像，翻转一个灯，同时会翻转其周围的4个灯。最后求全部灭掉灯的步数。\n只需要枚举第一行的翻转，为了改变当前行的灯的状态，我们只能翻转下一行的灯，其余行会因此确定。\n题目在LeetCode上可以找到：LeetCode 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix.\n我的解法是从acwing获得的，还可以 看大雪菜的视频学习。\n 另一种解法\n将此问题转换成2-coloring的一种变形。每个格子都由2条线共享。如果格子是白的，2条线之一需要被翻转。如果格子是黑的，不需要翻转，或 都翻转。\n我们考虑每条对角线是图中的节点，格子是边。\n如果格子是黑的，对应的边连接的2个节点必须是相同颜色的。反之，必须是不同颜色的。\n可以通过DFS解决2-coloring的图问题。\n枚举root的颜色，DFS确定邻居的颜色，如果邻居的颜色已确定，则检查即可。更少的颜色就代表着翻的个数。\n边数 为 O(N^2), DFS的解法复杂度为O(|Edges|)。\n总的时间复杂度为O(N ^ 2).\n#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;vector&gt;using namespace std;using ll = long long;struct Line &#123;    ll difference;    bool positive;    vector&lt;weak_ptr&lt;Line&gt;&gt; same_color_neighbors, different_color_neighbors;    Line(ll d, bool p) : difference(d), positive(p) &#123;&#125;&#125;;bool dfs(shared_ptr&lt;Line&gt; root, set&lt;shared_ptr&lt;Line&gt;&gt; &amp;white,         set&lt;shared_ptr&lt;Line&gt;&gt; &amp;black) &#123;    if (root == nullptr)        return false;    ;    bool w = white.find(root) != white.end();    for (auto node : root-&gt;different_color_neighbors) &#123;        if (auto node_shared_ptr = node.lock()) &#123;            if (white.find(node_shared_ptr) == white.end() &amp;&amp;                black.find(node_shared_ptr) == black.end()) &#123;                auto &amp;color = w ? black : white;                color.insert(node_shared_ptr);                if (!dfs(node_shared_ptr, white, black))                    return false;            &#125; else if (white.find(node_shared_ptr) != white.end()) &#123;                if (w) &#123;                    return false;                &#125;            &#125; else &#123;                if (!w) &#123;                    return false;                &#125;            &#125;        &#125;    &#125;    for (auto node : root-&gt;same_color_neighbors) &#123;        if (auto node_shared_ptr = node.lock()) &#123;            if (white.find(node_shared_ptr) == white.end() &amp;&amp;                black.find(node_shared_ptr) == black.end()) &#123;                auto &amp;color = w ? white : black;                color.insert(node_shared_ptr);                if (!dfs(node_shared_ptr, white, black))                    return false;            &#125; else if (white.find(node_shared_ptr) != white.end()) &#123;                if (!w)                    return false;            &#125; else &#123;                if (w)                    return false;            &#125;        &#125;    &#125;    return true;&#125;ll solve(vector&lt;vector&lt;bool&gt;&gt; &amp;puzzle) &#123;    unordered_map&lt;int, shared_ptr&lt;Line&gt;&gt; positive, negative;    const int n = puzzle.size();    for (int i = 0; i &lt; n; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            int j_sub_i = j - i;            int j_add_i = j + i;            if (positive[j_sub_i] == nullptr) &#123;                positive[j_sub_i] = make_shared&lt;Line&gt;(j_sub_i, true);            &#125;            if (negative[j_add_i] == nullptr) &#123;                negative[j_add_i] = make_shared&lt;Line&gt;(j_add_i, false);            &#125;            if (puzzle[i][j]) &#123; // black                positive[j_sub_i]-&gt;same_color_neighbors.push_back(                    negative[j_add_i]);                negative[j_add_i]-&gt;same_color_neighbors.push_back(                    positive[j_sub_i]);            &#125; else &#123;                positive[j_sub_i]-&gt;different_color_neighbors.push_back(                    negative[j_add_i]);                negative[j_add_i]-&gt;different_color_neighbors.push_back(                    positive[j_sub_i]);            &#125;        &#125;    &#125;    set&lt;shared_ptr&lt;Line&gt;&gt; seen;    ll ans = 0;    for (auto &amp;direction : &#123;positive, negative&#125;) &#123;        for (auto p : direction) &#123;            auto node = p.second;            if (seen.find(node) == seen.end()) &#123;                set&lt;shared_ptr&lt;Line&gt;&gt; white, black;                white.insert(node);                if (!dfs(node, white, black)) &#123;                    return -1;                &#125;                ans += min(white.size(), black.size());                seen.insert(white.begin(), white.end());                seen.insert(black.begin(), black.end());            &#125;        &#125;    &#125;    return ans;&#125;int main(int argc, char const *argv[]) &#123;    ll T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        ll n;        cin &gt;&gt; n;        vector&lt;vector&lt;bool&gt;&gt; pullze(n, vector&lt;bool&gt;(n));        for (int i = 0; i &lt; n; ++i) &#123;            string row;            cin &gt;&gt; row;            for (int j = 0; j &lt; n; ++j) &#123;                if (row[j] == &#x27;#&#x27;)                    pullze[i][j] = true;                else                    pullze[i][j] = false;            &#125;        &#125;        ll ans = solve(pullze);        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n实现过程中，需要注意的点有：\n\n如何存储和构造Graph。\nDFS解法时，需要遍历所有的节点。因为整个图是可以分为多个联通子图的。只从一个root开始dfs得到的染色不完整。\n\n C. Elevanagram\n小测试集时，0 &lt;= A_i &lt;= 20，可以使用回溯法，尝试所有的正负号分配方式。\n时间复杂度：O(A_i ^ 9), 算上剪枝，复杂度会更低些。\n空间复杂度：O(9).\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;numeric&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;using ll = long long;ll plus_max;ll s;bool backtracking(const vector&lt;ll&gt; &amp;A, ll index, ll plus, ll accu) &#123;    if (plus &gt; plus_max) &#123;        return false;    &#125; else if (plus == plus_max) &#123;        return ((accu - (s - accu)) % 11) == 0;    &#125; else if (index == 0) &#123;        ll need_plus = plus_max - plus;        if (need_plus &gt; A[0]) &#123;            return false;        &#125; else &#123;            accu += need_plus;            return ((accu - (s - accu)) % 11) == 0;        &#125;    &#125; else &#123;        ll num = index + 1;        for (ll i = min(A[index], plus_max - plus); i &gt;= 0; --i) &#123;            if (backtracking(A, index - 1, plus + i, accu + num * i)) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;void solve(const vector&lt;ll&gt; &amp;A) &#123;    s = std::accumulate(A.begin(), A.end(), 0);    plus_max = s / 2 + s % 2;    s = 0;    for (int i = 0; i &lt; 9; ++i) &#123;        s += A[i] * (i + 1);    &#125;    if (backtracking(A, 8, 0, 0)) &#123;        cout &lt;&lt; &quot;YES&quot;;    &#125; else &#123;        cout &lt;&lt; &quot;NO&quot;;    &#125;&#125;int main() &#123;    int T;    cin &gt;&gt; T;    vector&lt;ll&gt; A(9);    for (int iCase = 0; iCase &lt; T; ++iCase) &#123;        for (int i = 0; i &lt; 9; ++i) &#123;            cin &gt;&gt; A[i];        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase + 1 &lt;&lt; &quot;: &quot;;        solve(A);        cout &lt;&lt; endl;    &#125;&#125;\n","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2020 round A","url":"/2020/03/22/kick-start-2020-round-A/","content":"新一年的kick start有了些许变化：\n\n所有测试结果正确与否立即返回。之前是大的数据集的测试结果赛后才能看到。相当于是降低了难度，减少了参赛者失误的代价。之前发生一点失误的话，大数据集的分数就没了。现在相当于是增加了一次罚时。\n题目从3到变成了4道，时间不变，增加了一道送分题。\n\nRank 570. 因为大家都是100分，所以最后比拼的都是时间。因为比赛是12:00~15:00, 所以我中间花了半个小时去吃饭。另外每个题目都不是一遍做对，都通过printf进行调试，花了不少时间。最快的大佬们都是20min就做完了。\n下个月约起来round B呀！4月19号早上7点。\nround A 题目地址\n Allocation\n刚开始以为是一道简单的背包问题，后来发现是更简单的贪心问题。因为是要求购买房子数目的最大值，而不是价值的最大值，或者说 房子的价值都为1. 所以贪心即可。简而言之，送分的签到题。\n把房子按照售价从小到大排序，先买便宜的房子。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; A(100005);int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int N, B;        cin &gt;&gt; N &gt;&gt; B;        for (int i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; A[i];        &#125;        sort(A.begin(), A.begin() + N);        int ans = 0;        int index = 0;        while (index &lt; N &amp;&amp; B &gt;= A[index]) &#123;            B -= A[index];            ++ans;            ++index;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt;endl;    &#125;    return 0;&#125;\n因为贪心的时候忘记检查index &lt; n了，导致一次WA罚时。\n Plates\n动态规划。\n状态转移方程：\n第i个stack，取走j个盘子，得到的最大Beaty value和。\ndp[i][j] = max&#123;dp[i-1][x] + top_sum[j - x] for x in [0, j]&#125;。\n时间复杂度: O(N * P * P) 50 * 1500 * 1500,\n空间复杂度: O(N * P) 50 * 1500 -&gt; O(P) 1500.\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; dp(1505, 0);vector&lt;int&gt; line(35);int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int N, K, P;        cin &gt;&gt; N &gt;&gt; K &gt;&gt; P;        fill(dp.begin(), dp.end(), 0);        for (int i = 0; i &lt; N; ++i) &#123;            for (int j = 0; j &lt; K; ++j) &#123;                cin &gt;&gt; line[j];                if (j &gt; 0)                    line[j] += line[j - 1];            &#125;            for (int j = P; j &gt; 0; --j) &#123;                int max_dp = dp[j];                for (int x = j - 1; x &gt;= 0 &amp;&amp; j - x - 1 &lt; K; --x) &#123;                    max_dp = max(max_dp, dp[x] + line[j - x - 1]);                &#125;                dp[j] = max_dp;                // cout &lt;&lt; dp[j] &lt;&lt; &quot;, &quot;;            &#125;            // cout &lt;&lt; endl;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; dp[P] &lt;&lt;endl;    &#125;    return 0;&#125;\n Workout\n对于K == 1的情况，可以直接采用贪心的策略，将最大的间隔等分。\n对于K &gt; 1的情况，可以采取将最优化问题转成判定问题的思路解决。\n最优化问题为：求最小的difficulty。\n判定问题为：difficulty == x可否实现, 时间复杂度为O(N * K)。\n然后判定问题的解的分布为: ... F F F T T T ...，我们要找到第一个T。\n采用二分法，搜索区间为[1, max(M_i) = 1^9], 时间复杂度为O(log 1e9)。\n故，总的有：\n时间复杂度: O(N * K * log 1e9),\n空间复杂度: O(N).\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; M(1e5 + 5);int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int N, K;        cin &gt;&gt; N &gt;&gt; K;        for (int i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; M[i];        &#125;        auto determine = [&amp;](int x) -&gt; bool &#123;            int used = 0;            for (int i = 0; i &lt; N - 1; ++i) &#123;                int difference = M[i + 1] - M[i];                while (difference &gt; x) &#123;                    ++used;                    if (used &gt; K)                        return false;                    difference -= x;                &#125;            &#125;            return true;        &#125;;        int lo = 1, hi = 1e9;        while (lo &lt; hi) &#123;            int mid = lo + (hi - lo) / 2;            auto deter = determine(mid);            // cout &lt;&lt; mid &lt;&lt; &quot;: &quot; &lt;&lt; deter &lt;&lt; endl;            if (deter) &#123;                hi = mid;            &#125; else &#123;                lo = mid + 1;            &#125;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; lo &lt;&lt;endl;    &#125;    return 0;&#125;\n Bundling\nTire + DFS + Greedy的思路。\n因为需要用到共同前缀，所以我们可以用Tire预处理字符串。\n用DFS搜索Trie，尝试尽量深地凑成一个group，这样得到的score更大。\n时间复杂度: O(characters.size()), 2 * 10 ^ 6.\n空间复杂度: O(characters.size()).\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;functional&gt;#include &lt;cassert&gt;using namespace std;struct Trie &#123;    int passby = 0;    int destination = 0;    array&lt;shared_ptr&lt;Trie&gt;, 26&gt; data;&#125;;void build_tire(shared_ptr&lt;Trie&gt; root, const string &amp;s, int index) &#123;    ++root-&gt;passby;    if (index == s.size()) &#123;        ++root-&gt;destination;        return;    &#125;    if (root-&gt;data[s[index] - &#x27;A&#x27;] == nullptr) &#123;        root-&gt;data[s[index] - &#x27;A&#x27;] = make_shared&lt;Trie&gt;();    &#125;    build_tire(root-&gt;data[s[index] - &#x27;A&#x27;], s, index + 1);&#125;int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int N, K;        cin &gt;&gt; N &gt;&gt; K;        auto root = make_shared&lt;Trie&gt;();        for (int i = 0; i &lt; N; ++i) &#123;            string s;            cin &gt;&gt; s;            build_tire(root, s, 0);        &#125;        int ans = 0;        // return left number        function&lt;int(shared_ptr&lt;Trie&gt;, int)&gt; dfs = [&amp;](shared_ptr&lt;Trie&gt; r,                                                       int depth) -&gt; int &#123;            if (r == nullptr)                return 0;            int now = r-&gt;destination;            for (int i = 0; i &lt; 26; ++i) &#123;                now += dfs(r-&gt;data[i], depth + 1);                // cout &lt;&lt;  depth &lt;&lt; &quot;: &quot; &lt;&lt; char(&#x27;A&#x27; + i) &lt;&lt; &quot;: &quot; &lt;&lt; now &lt;&lt; endl;            &#125;            ans += depth * (now / K);            return now % K;        &#125;;        int r = dfs(root, 0);        // cout &lt;&lt; &quot;r: &quot; &lt;&lt; r &lt;&lt; endl;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2020 round B","url":"/2020/04/19/kick-start-2020-round-B/","content":"\n\n\nID\nscore\nrank\nBike Tour\nBus Routes\nRobot Path Coding\nWandering Robot\nTime\n\n\n\n\nYoungForest\n74\n524\n5 + 7\n10 + 13\n11 + 16\n14 + 0\n1:35:18\n\n\n\n去年一共参加了6轮kickstart，成功拿到Google今年的实习邀请。可惜的是，由于疫情的原因，谷歌中国的暑期实习项目全部取消了。今年为了秋招名额，仍需继续参加kickstart。今天的round B轮次虽然在早上7点，但仍然有很多同学参加。遗憾的是，最后一题的时间复杂度过高，大的Test set TLE了。\n Bike Tour\n签到题。遍历一遍mountains, 寻找比前后都高的位置即可。\n时间复杂度: O(N),\n空间复杂度: O(N).\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int N;        cin &gt;&gt; N;        vector&lt;int&gt; mountains(N);        for (int i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; mountains[i];        &#125;        int ans = 0;        for (int i = 1; i &lt; N - 1; ++i) &#123;            if (mountains[i] &gt; mountains[i - 1] &amp;&amp;                mountains[i] &gt; mountains[i + 1]) &#123;                ++ans;            &#125;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n Bus Routes\n贪心。从后向前，选择每趟公交最晚的那班。\n时间复杂度：O(N), 我这里使用了尾递归的写法，和迭代一样，不需要额外的空间。\n空间复杂度：O(N).\n#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;functional&gt;using namespace std;using ll = long long;vector&lt;ll&gt; schedule(1005);int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int N;        ll D;        cin &gt;&gt; N &gt;&gt; D;        for (int i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; schedule[i];        &#125;        function&lt;ll(int, ll)&gt; f = [&amp;](int index, ll d) -&gt; ll &#123;            if (index == 0) &#123;                return (d / schedule[index]) * schedule[index];            &#125; else &#123;                return f(index - 1, (d / schedule[index]) * schedule[index]);            &#125;        &#125;;                cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; f(N-1, D) &lt;&lt; endl;    &#125;    return 0;&#125;\n Robot Path Decoding\n类似编译器支持函数调用，我们可以用一个栈存储父程序的状态。\n时间复杂度：O(N),\n空间复杂度: O(N).\n#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;using ll = long long;const ll mod = 1e9;int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        string instructions;        cin &gt;&gt; instructions;        pair&lt;ll, ll&gt; shift = &#123;0, 0&#125;;        stack&lt;ll&gt; st;        stack&lt;pair&lt;ll, ll&gt;&gt; st_shift;        char digit = &#x27;1&#x27;;        for (char c : instructions) &#123;            switch (c) &#123;            case &#x27;(&#x27;:                st.push(digit - &#x27;0&#x27;);                st_shift.push(shift);                shift = &#123;0, 0&#125;;                break;            case &#x27;)&#x27;: &#123;                ll X = st.top();                auto before_shift = st_shift.top();                st.pop();                st_shift.pop();                before_shift.first =                    (before_shift.first + X * shift.first + 12 * mod) % mod;                before_shift.second =                    (before_shift.second + X * shift.second + 12 * mod) % mod;                shift = before_shift;            &#125; break;            case &#x27;N&#x27;:                shift.second = (shift.second - 1 + mod) % mod;                break;            case &#x27;S&#x27;:                shift.second = (shift.second + 1) % mod;                break;            case &#x27;E&#x27;:                shift.first = (shift.first + 1) % mod;                break;            case &#x27;W&#x27;:                shift.first = (shift.first - 1 + mod) % mod;                break;            default:                break;            &#125;            digit = c;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; shift.first + 1 &lt;&lt; &quot; &quot; &lt;&lt; shift.second + 1             &lt;&lt; endl;    &#125;    return 0;&#125;\n Wandering Robot\n本题比赛时我只做出了小的case，大的数据会TLE。\n思路比较简单，用DP计算走到每个格子的概率。\ndp[i][j] = 0.5 * dp[i-1][j] + 0.5 * dp[i][j-1].\n然后算走到hole上边和左边的概率和，*0.5就是掉到洞里的概率。为了避免处理下边界和右边界的特殊情况，当hole触底时，我们可以通过向左扩展hole，把一定落在hole中的概率提前拦截。当hole触右时，也是类似的处理。\n时间复杂度：(W * T),\n空间复杂度：O(W).\n#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;using ll = long long;const ll mod = 1e9;const int MAX_WIDTH = 1e5 + 5;int main() &#123;    int T;    cin &gt;&gt; T;    vector&lt;double&gt; dp(MAX_WIDTH);    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int W, H, L, U, R, D;        cin &gt;&gt; W &gt;&gt; H &gt;&gt; L &gt;&gt; U &gt;&gt; R &gt;&gt; D;        --L;        --U;        double ans = 0;        if (D == H &amp;&amp; R == W) &#123;            ans = 1;        &#125; else &#123;            if (D == H) &#123;                // 触底                L = 0;            &#125;            if (R == W) &#123;                // 触右                U = 0;            &#125;            if (U == 0 &amp;&amp; L == 0) &#123;                ans = 1;            &#125; else &#123;                for (int i = 0; i &lt; D; ++i) &#123;                    for (int j = 0; j &lt; MAX_WIDTH; ++j) &#123;                        if (i &gt; 0 &amp;&amp; j &gt; 0) &#123;                            dp[j] = 0.5 * dp[j] + 0.5 * dp[j - 1];                        &#125; else if (j &gt; 0) &#123;                            dp[j] = 0.5 * dp[j - 1];                        &#125; else if (i &gt; 0) &#123;                            dp[j] = 0.5 * dp[j];                        &#125; else &#123;                            dp[j] = 1;                        &#125;                    &#125;                    if (L &gt; 0 &amp;&amp; i &gt;= U &amp;&amp; i &lt; D) &#123;                        ans += 0.5 * dp[L - 1];                    &#125;                    if (U &gt; 0 &amp;&amp; i == U - 1) &#123;                        for (int j = L; j &lt; R; ++j) &#123;                            ans += 0.5 * dp[j];                        &#125;                    &#125;                &#125;            &#125;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; (1 - ans) &lt;&lt; endl;    &#125;    return 0;&#125;\n一个重要的观察是，可以通过组合数的方式求解prop(i, j): 从零点走到(i, j)的概率，0-index.\nprop(i, j) = 0.5 ^ (the length path to (i, j)) * 可能路径的数量\n= 0.5 ^ (i + j) * Combination(i + j, j)\n为了快速计算组合数，我们可以预计算log(x!), 然后利用公式:\n2log2(n!/(k!×(n−k)!)/2n)=2log2n!−log2k!−log2(n−k)!−n2^{log_2(n! / (k! \\times (n-k)!) / 2^n)} = 2^{log_2 n! - log_2 k! - log_2 (n-k)! - n} \n2log2​(n!/(k!×(n−k)!)/2n)=2log2​n!−log2​k!−log2​(n−k)!−n\n时间复杂度: O(W + H),\n空间复杂度: O(W).\n#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;using ll = long long;const ll mod = 1e9;const int MAX_WIDTH = 1e5 + 5;double logfactor[2 * MAX_WIDTH];double CombinationDivide2N(ll n, ll m) &#123;    return powl(2, logfactor[n] - logfactor[m] - logfactor[n-m] - n);&#125;int main() &#123;    int T;    cin &gt;&gt; T;    // preprocess log(x!)    logfactor[0] = 0;    for (int i = 1; i &lt; 2 * MAX_WIDTH; ++i) &#123;        logfactor[i] = logfactor[i-1] + log2l(i);    &#125;    auto dp = [&amp;](int i, int j) -&gt; double &#123;        return CombinationDivide2N(i + j, j);    &#125;;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int W, H, L, U, R, D;        cin &gt;&gt; W &gt;&gt; H &gt;&gt; L &gt;&gt; U &gt;&gt; R &gt;&gt; D;        --L;        --U;        double ans = 0;        if (W &gt; MAX_WIDTH || H &gt; MAX_WIDTH) &#123;            ans = 1;        &#125; else if (D == H &amp;&amp; R == W) &#123;            ans = 1;        &#125; else &#123;            if (D == H) &#123;                // 触底                L = 0;            &#125;            if (R == W) &#123;                // 触右                U = 0;            &#125;            if (U == 0 &amp;&amp; L == 0) &#123;                ans = 1;            &#125; else &#123;                if (U &gt; 0) &#123;                    for (int i = L; i &lt; R; ++i) &#123;                        ans += 0.5 * dp(i, U - 1);                    &#125;                &#125;                if (L &gt; 0) &#123;                    for (int i = U; i &lt; D; ++i) &#123;                        ans += 0.5 * dp(L - 1, i);                    &#125;                &#125;            &#125;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; (1 - ans) &lt;&lt; endl;    &#125;    return 0;&#125;","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2020 round C","url":"/2020/05/18/kick-start-2020-round-C/","content":"\n\n\nID\nscore\nrank\nBike Tour\nBus Routes\nRobot Path Coding\nWandering Robot\nTime\n\n\n\n\nYoungForest\n74\n524\n5 + 7\n10 + 13\n11 + 16\n14 + 0\n1:35:18\n\n\n\n上个月因为Round B结果还不错，收到了Google CN HR的Congraduation邮件。本月再接再厉，为了进入Google的梦想而努力。\n A. Countdown\nOne pass. 寻找countdown的模式。由于开始数字一定为K，所以countdown的过程中如果失败了的话，可以直接从失败的位置继续寻找。\n时间复杂度: O(N),\n空间复杂度: O(N).\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int N, K;        cin &gt;&gt; N &gt;&gt; K;        vector&lt;int&gt; mountains(N);        for (int i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; mountains[i];        &#125;        int ans = 0;        for (int i = 0; i &lt; N; ) &#123;            if (mountains[i] == K) &#123;                int need = K - 1;                int j = 1;                while (i + j &lt; N &amp;&amp; need &gt;= 1 &amp;&amp; mountains[i+j] == need) &#123;                    ++j;                    --need;                &#125;                if (need == 0) ++ans;                i = i + j;            &#125; else &#123;                ++i;            &#125;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n B. Stable Wall\n题目本身比较难懂。但实质就是一个拓扑排序的问题，下面的必须先放。\n这里需要注意一个corner case：只有一行的情况。\n因为我第一版的代码，更新seen是在判断上下层关系时更新的。如果只有一行的话，就会忽略第一行的字母。\n把seen单独拿出来更新就可以了。\n时间复杂度: O(R * C * 26),\n空间复杂度: O(R * C + 26).\n#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123;    int T;    cin &gt;&gt; T;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int R, C;        cin &gt;&gt; R &gt;&gt; C;        vector&lt;string&gt; rows(R);        for (int i = 0; i &lt; R; ++i) &#123;            cin &gt;&gt; rows[i];        &#125;        string ans;        // 拓扑排序        unordered_map&lt;char, unordered_set&lt;char&gt;&gt; out;        unordered_map&lt;char, unordered_set&lt;char&gt;&gt; in;        unordered_set&lt;char&gt; seen;        queue&lt;char&gt; zeroIn;        for (int i = 0; i &lt; R; ++i) &#123;            for (int j = 0; j &lt; C; ++j) &#123;                seen.insert(rows[i][j]);            &#125;        &#125;        for (int i = 0; i + 1 &lt; R; ++i) &#123;            for (int j = 0; j &lt; C; ++j) &#123;                char down = rows[i + 1][j];                char up = rows[i][j];                if (down == up)                    continue;                out[down].insert(up);                in[up].insert(down);            &#125;        &#125;        for (char c : seen) &#123;            if (in[c].empty()) &#123;                zeroIn.push(c);            &#125;        &#125;        while (!zeroIn.empty()) &#123;            char base = zeroIn.front();            zeroIn.pop();            ans.push_back(base);            for (char up : out[base]) &#123;                in[up].erase(base);                if (in[up].empty()) &#123;                    zeroIn.push(up);                &#125;            &#125;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot;             &lt;&lt; (ans.size() == seen.size() ? ans : &quot;-1&quot;) &lt;&lt; endl;    &#125;    return 0;&#125;\n C. Perfect Subarray\n使用前缀和来快速求子数组和。然后用hashmap存储之前的前缀和。对于当前的前缀和遍历所有的平方数，寻找之前的前缀和。由于该题目会卡常数，所以需要用到一些竞赛用的技巧。\n如：\n\nunordered_map可以用reserve直接扩充为最大可能的大小；\n用数组代替hashmap, 下标有负数时，整体偏移一个常数.\n\n时间复杂度: O(N * sqrt(MAXSUM)) = O(N * 3000),\n空间复杂度: O(N + MAXSUM).\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;const ll MAXSQRT = 3163;const int mxN = 1e5 + 5;int seen[2*110*mxN];int main() &#123;    int T;    cin &gt;&gt; T;    const int mid = 105 * mxN + 2;    for (int iCase = 1; iCase &lt;= T; ++iCase) &#123;        int N;        cin &gt;&gt; N;        ll ans = 0;        int presum = 0;\t    memset(seen, 0, sizeof seen);        seen[presum + mid] = 1;        for (int i = 0; i &lt; N; ++i) &#123;            int A;            cin &gt;&gt; A;            presum += A;            for (int squareI = 0; squareI &lt;= MAXSQRT; ++squareI) &#123;                ans += seen[mid + presum - squareI*squareI];            &#125;            ++seen[mid + presum];        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n D. Candies\n题目operation有2种，分别为求区间和和更新某个值。十分适合用线段树解决。因为sweet score的定义不同于普通的求和，所以我们可以通过2个线段树的到sweet score. 分别维护 +1, -1, +1, … 和 +1, -2, +3, …。然后queryRange时，后者减去前者的某个倍数，再乘以+1/-1即可。\n在此，感谢花花的线段树模版，让我可以快速A掉此题。\n时间复杂度: O(N log N),\n空间复杂度: O(N).\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;class SegmentTreeNode &#123;private:    unique_ptr&lt;SegmentTreeNode&gt; left = nullptr, right = nullptr;    ll start = 0, end = 0;    ll val = 0;public:    SegmentTreeNode(ll value, ll start_, ll end_): val(value), start(start_), end(end_) &#123;&#125;    SegmentTreeNode(ll start_, ll end_): start(start_), end(end_) &#123;&#125;    static unique_ptr&lt;SegmentTreeNode&gt; buildTree(const vector&lt;ll&gt;&amp; nums, ll i, ll j) &#123;        if (i == j) &#123;            return make_unique&lt;SegmentTreeNode&gt;(nums[i], i, j);        &#125; else &#123;            ll mid = i + (j - i) / 2;            auto ret = make_unique&lt;SegmentTreeNode&gt;(i, j);            ret-&gt;left = buildTree(nums, i, mid);            ret-&gt;right = buildTree(nums, mid + 1, j);            ret-&gt;val = ret-&gt;left-&gt;val + ret-&gt;right-&gt;val;            return ret;        &#125;    &#125;    ll queryRange(ll i, ll j) const &#123;        if (i == start &amp;&amp; j == end) &#123;            return val;        &#125; else &#123;            ll mid = start + (end - start) / 2;            if (j &lt;= mid) &#123;                return left-&gt;queryRange(i, j);            &#125; else if (i &gt; mid) &#123;                return right-&gt;queryRange(i, j);            &#125; else &#123;                return left-&gt;queryRange(i, mid) + right-&gt;queryRange(mid + 1, j);            &#125;        &#125;    &#125;    void update(ll index, ll value) &#123;        if (start == index &amp;&amp; index == end) &#123;            val = value;        &#125; else &#123;            ll mid = start + (end - start) / 2;            if (mid &gt;= index) &#123;                left-&gt;update(index, value);            &#125; else &#123;                right-&gt;update(index, value);            &#125;            val = left-&gt;val + right-&gt;val;        &#125;    &#125;&#125;;int main() &#123;    ll T;    cin &gt;&gt; T;    for (ll iCase = 1; iCase &lt;= T; ++iCase) &#123;        ll N, Q;        cin &gt;&gt; N &gt;&gt; Q;        vector&lt;ll&gt; nums(N);        for (ll i = 0; i &lt; N; ++i) &#123;            cin &gt;&gt; nums[i];        &#125;        for (ll i = 0; i &lt; N; ++i) &#123;            if (i % 2 == 1)                nums[i] *= -1;        &#125;        auto positiveNegtive = SegmentTreeNode::buildTree(nums, 0, nums.size() - 1);        for (ll i = 0; i &lt; N; ++i) &#123;            nums[i] *= (i+1);        &#125;        auto multiTree = SegmentTreeNode::buildTree(nums, 0, nums.size() - 1);        ll ans = 0;        for (ll q = 0; q &lt; Q; ++q) &#123;            string op;            cin &gt;&gt; op;            ll start, end;            cin &gt;&gt; start &gt;&gt; end;            if (op == &quot;Q&quot;) &#123;                ans += ((start % 2 == 0) ? -1 : 1 ) * (multiTree-&gt;queryRange(start-1,end -1) - (start - 1) * positiveNegtive-&gt;queryRange(start-1, end-1));            &#125; else &#123;                ans += 0;                positiveNegtive-&gt;update(start-1, ((start % 2 == 0) ? -1 : 1) * end);                multiTree-&gt;update(start-1, ((start % 2 == 0) ? -1 : 1) * start * end);            &#125;        &#125;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; iCase &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2021 round A","url":"/2021/03/22/kick-start-2021-round-A/","content":"\n\n\nID\nscore\nrank\nK-Goodness String\nL Shaped Plots\nRabbit House\nChecksum\nPenalty Time\n\n\n\n\nYoungForest\n56\n1295\n5 + 7\n8 + 12\n9 + 15\n0\n1:40:55\n\n\n\n久违的参加了KickStart比赛。之前2年还因为想去Google的原因一直坚持打，不过人算不如天算，因为疫情原因实习和秋招都直接凉了。2年多参加了10+场比赛也“白”打了。\n今年参加真的是全凭兴趣。结果排名果然1000+。之前基本都是几百。\n不得说，从去年开始，KickStart简单也友好了很多。之前经常只能做出来1道半题。后来为了增加参赛范围，3题变四题，整体难度也降下来了。\n\n K-Goodness String\n签到题。统计字符串的goodness score，可知无论是增一还是减一的最小操作都是1.\n#include &lt;bits/stdc++.h&gt;using namespace std;int solve() &#123;    int N, K;    cin &gt;&gt; N &gt;&gt; K;    string s;    cin &gt;&gt; s;    int k = 0;    for (int i = 1; i &lt;= N / 2; ++i) &#123;        if (s[i - 1] != s[N - i + 1 - 1]) &#123;            ++k;        &#125;    &#125;    return abs(K - k);&#125;int main() &#123;    int T;    cin &gt;&gt; T;    for (int i = 0; i &lt; T; ++i) &#123;        auto ans = solve();        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n时间复杂度: O(N),\n空间复杂度: O(N).\n L Shaped Plots\n统计一个方向的L，其他方向的L可以通过 上下/左右翻转 和 旋转 共8种情况得到。\n用动态规划的思想更新当前位置左边的长度和上边的长度，求的以当前位置为拐点的L的数目。\n#include &lt;bits/stdc++.h&gt;using namespace std;int solve() &#123;    int R, C;    cin &gt;&gt; R &gt;&gt; C;    vector&lt;vector&lt;bool&gt;&gt; matrix(R, vector&lt;bool&gt; (C));    int x;    for (int i = 0; i &lt; R; ++i) &#123;        for (int j = 0; j &lt; C; ++j) &#123;            cin &gt;&gt; x;            matrix[i][j] = (x == 1);        &#125;    &#125;        auto reverseLeftRight = [&amp;]() -&gt; void &#123;        for (auto&amp; m : matrix) &#123;            reverse(m.begin(), m.end());        &#125;    &#125;;    auto reverseUpDown = [&amp;]() -&gt; void &#123;        for (int j = 0; j &lt; C; ++j) &#123;            for (int i = 0; i &lt; R - 1 - i; ++i) &#123;                swap(matrix[i][j], matrix[R - 1 - i][j]);            &#125;        &#125;    &#125;;    auto flip = [&amp;]() -&gt; void &#123;        vector&lt;vector&lt;bool&gt;&gt; newMatrix(C, vector&lt;bool&gt;(R));        for (int i = 0; i &lt; R; ++i) &#123;            for (int j = 0; j &lt; C; ++j) &#123;                newMatrix[j][i] = matrix[i][j];            &#125;        &#125;        matrix = move(newMatrix);        swap(R, C);    &#125;;    auto one = [&amp;]() -&gt; int &#123;        vector&lt;vector&lt;int&gt;&gt; dp(R, vector&lt;int&gt; (C));        int ans = 0;        for (int j = 0; j &lt; C; ++j) &#123;            dp[0][j] = matrix[0][j] ? 1 : 0;        &#125;        for (int i = 1; i &lt; R; ++i) &#123;            int left = 0;            for (int j = 0; j &lt; C; ++j) &#123;                if (matrix[i][j]) &#123;                    ++left;                    dp[i][j] = dp[i-1][j] + 1;                    const int up = dp[i][j] / 2;                    const int could = min(up, left);                    if (could &gt; 1) ans += could - 1;                &#125; else &#123;                    left = 0;                    dp[i][j] = 0;                &#125;            &#125;        &#125;        return ans;    &#125;;    auto two = [&amp;]() -&gt; int &#123;        int ans = 0;        ans += one();        reverseLeftRight();        ans += one();        return ans;    &#125;;    auto four = [&amp;]() -&gt; int &#123;        int ans = 0;        ans += two();        reverseUpDown();        ans += two();        return ans;    &#125;;    int ans = 0;    ans += four();    flip();    ans += four();    return ans;&#125;int main() &#123;    int T;    cin &gt;&gt; T;    for (int i = 0; i &lt; T; ++i) &#123;        auto ans = solve();        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n时间复杂度: O(8 * R * C)\n空间复杂度: O(R*C).\n Rabbit House\nBFS. 相邻位置差最多为1，从最高的cells开始搜索。\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;using pii = pair&lt;int, int&gt;;const vector&lt;pii&gt; directions = &#123;    &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;;ll solve() &#123;    int R, C;    cin &gt;&gt; R &gt;&gt; C;    vector&lt;vector&lt;ll&gt;&gt; matrix(R, vector&lt;ll&gt; (C));    unordered_map&lt;int, vector&lt;pii&gt;&gt; cells;    ll x;    ll maxHeight = 0;    for (int i = 0; i &lt; R; ++i) &#123;        for (int j = 0; j &lt; C; ++j) &#123;            cin &gt;&gt; matrix[i][j];            cells[matrix[i][j]].emplace_back(i, j);            maxHeight = max(maxHeight, matrix[i][j]);        &#125;    &#125;    queue&lt;pii&gt; q;    for (const auto&amp; p : cells[maxHeight]) &#123;        q.push(p);    &#125;    ll ans = 0;    ll height = maxHeight;    while (!q.empty() &amp;&amp; height &gt; 0) &#123;        const int s = q.size();        for (int x = 0; x &lt; s; ++x) &#123;            auto [i, j] = q.front();            q.pop();            for (pii d : directions) &#123;                const int ni = i + d.first;                const int nj = j + d.second;                if (ni &gt;= 0 &amp;&amp; ni &lt; R &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; C) &#123;                    if (matrix[ni][nj] &gt;= height) continue;                    q.emplace(ni, nj);                    ans += height - 1 - matrix[ni][nj];                    matrix[ni][nj] = height;                &#125;            &#125;        &#125;        for (const auto&amp; p : cells[height-1]) &#123;            q.push(p);        &#125;        --height;    &#125;        return ans;&#125;int main() &#123;    int T;    cin &gt;&gt; T;    for (int i = 0; i &lt; T; ++i) &#123;        auto ans = solve();        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n时间复杂度: O(R * C),\n空间复杂度: O(R * C).\n需要注意的2点是：\n\nBFS时，需要每次把高度相同的cells也加入队中。这些也是下次遍历的起点之一。\n另外最后的结果大于32位数，需要long long避免overflow的WA。\n我也因此多了3次WA罚时。\n\n Checksum\n比赛到最后一题已经非常累了。LeetCode周赛1小时+KickStart3小时，如此高强度的脑力活动，对人的精力已经是十分大的消耗了。因此，最后一题时我脑子已经不如一开始的清醒了。思考了一段时间后就放弃了。事实上，暴力法拿个小数据的分数对我平时的水平来说还是做的到的。\n赛后补题, 解法参考官方的Analysis。\n 暴力法 Test Set 1\n枚举所有的花费集合，判断是否可以推断出全部的棋盘。\n判断是否可以推断出全部元素可以使用BFS来进行，从行列唯一元素开始遍历，依次增加元素。其实DFS也行。\n时间复杂度: O(2(N2) * N ^ 2).\n 破环法 Test Set 2\n以行列号为节点，空缺元素为边，可以将原矩阵转换成一个二分图。行在一边，列在一边。\n单独的节点表示 该行/列的所有元素已知，可以直接忽略。\n节点度为1表示 该行/列只有一个未知元素，可以通过checksum推断，因此可以直接删掉。\n剩下的图组成一个无向有环权重图。\n原问题转换成 以最小代价删去一定的边，使得原图无环。\n可以采用贪心算法。从小到大遍历边，如果在环内，就删掉。判断是否在环内可以用暴力DFS解决。不通过这个边，看是否有另外一条路径从该边的一个节点到另一个节点。\n时间复杂度: 遍历所有剩下的边 * 判断环 = O(N ^ 2 * N ^ 2) = O(N^4).\n贪心算法的正确性证明参考 最小生成树 Kruskal 算法.\n 最大生成树 Test Set 3\n在解法2的基础上，事实上，我们可以通过最大生成树算法快速得到最后的状态。\n时间复杂度: Prim O(N^2), Kruskal O(N^2 * log N).\n#include &lt;bits/stdc++.h&gt;using namespace std;using ll = int;using pii = pair&lt;int, int&gt;;using tii = tuple&lt;int, int, int&gt;;class UF &#123;public:    vector&lt;int&gt; fa;    vector&lt;int&gt; sz;    int n;    int comp_cnt;    public:    UF(int _n): n(_n), comp_cnt(_n), fa(_n), sz(_n, 1) &#123;        iota(fa.begin(), fa.end(), 0);    &#125;        int findset(int x) &#123;        return fa[x] == x ? x : fa[x] = findset(fa[x]);    &#125;        void unite(int x, int y) &#123;        x = findset(x);        y = findset(y);        if (x != y) &#123;            if (sz[x] &lt; sz[y]) &#123;                swap(x, y);            &#125;            fa[y] = x;            sz[x] += sz[y];            --comp_cnt;        &#125;    &#125;        bool connected(int x, int y) &#123;        x = findset(x);        y = findset(y);        return x == y;    &#125;&#125;;ll solve()&#123;    int N;    cin &gt;&gt; N;    // construct the 2-partical graph    vector&lt;vector&lt;pii&gt;&gt; graph(2 * N);    vector&lt;tii&gt; edges;    ll x;    for (int i = 0; i &lt; N; ++i)    &#123;        for (int j = 0; j &lt; N; ++j)        &#123;            cin &gt;&gt; x;        &#125;    &#125;    for (int i = 0; i &lt; N; ++i)    &#123;        for (int j = 0; j &lt; N; ++j)        &#123;            cin &gt;&gt; x;            if (x &gt; 0)            &#123;                graph[i].push_back(&#123;j + N, x&#125;);                graph[j + N].push_back(&#123;i, x&#125;);                edges.emplace_back(x, i, j + N);            &#125;        &#125;    &#125;    for (int i = 0; i &lt; N; ++i)    &#123;        cin &gt;&gt; x;    &#125;    for (int i = 0; i &lt; N; ++i)    &#123;        cin &gt;&gt; x;    &#125;    sort(edges.begin(), edges.end(), greater&lt;&gt;());    UF uf(2*N);    ll cost = 0;    for (const auto&amp; e : edges) &#123;        if (uf.connected(get&lt;1&gt;(e), get&lt;2&gt;(e))) &#123;            cost += get&lt;0&gt;(e);        &#125; else &#123;            uf.unite(get&lt;1&gt;(e), get&lt;2&gt;(e));        &#125;    &#125;    return cost;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    for (int i = 0; i &lt; T; ++i)    &#123;        auto ans = solve();        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot; &lt;&lt; ans &lt;&lt; endl;    &#125;    return 0;&#125;\n我采用了Krusal, 因为写起来更好实现些。\n时间复杂度: O(N^2 * log N^2),\n空间复杂度: O(N^2).\n","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"kick start 2021 round B","url":"/2021/04/20/kick-start-2021-round-B/","content":"比赛时间是北京的19号上午7点到10点，因为恰好下午2点要交毕设初稿。最近忙着一直在写大论文。因此并未参加Round B. 现如今自己已经过了校招的年纪，打Kick Start纯粹是为了娱乐。\n赛后补题。\n比赛题目链接\n Increasing Substring\n签到题。DP，只需要和前一个字符比大小。\n#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;void solve() &#123;    int N ;    cin &gt;&gt; N;    string s;    cin &gt;&gt; s;    vector&lt;int&gt; dp(N);    for (int i = 0; i &lt; N; ++i) &#123;        if (i &gt; 0 &amp;&amp; s[i] &gt; s[i-1]) &#123;            dp[i] = dp[i-1] + 1;        &#125; else &#123;            dp[i] = 1;        &#125;        cout &lt;&lt; dp[i] &lt;&lt; &quot; &quot;;    &#125;&#125;int main() &#123;    int T;    cin &gt;&gt; T;    for (int i = 0; i &lt; T; ++i) &#123;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;;        solve();        cout &lt;&lt; endl;    &#125;    return 0;&#125;\n时间复杂度: O(N),\n空间复杂度: O(N) -&gt; O(1). 虽然我的实现是O(N)的，但其实dp数组是没必要存的，只关心前一个的值。\n Longest Progression\n遇到WA，是因为C++类型的原因。列在这里引以为戒。\n因为类型转换的原因，size() 和 -1比较时，-1永远大。\n#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;functional&gt;#include &lt;map&gt;using namespace std;using ll = int;template &lt;typename T, class Cmp&gt;ostream&amp; operator &lt;&lt;(ostream&amp; out, const unordered_set&lt;T, Cmp&gt;&amp; a) &#123;  out &lt;&lt; &quot;&#123;&quot;; bool first = true;  for (auto&amp; v : a) &#123; out &lt;&lt; (first ? &quot;&quot; : &quot;, &quot;); out &lt;&lt; v; first = 0;&#125; out &lt;&lt; &quot;&#125;&quot;;  return out;&#125;template &lt;typename U, typename T, class Cmp&gt;ostream&amp; operator &lt;&lt;(ostream&amp; out, const unordered_map&lt;U, T, Cmp&gt;&amp; a) &#123;  out &lt;&lt; &quot;&#123;&quot;; bool first = true;  for (auto&amp; p : a) &#123; out &lt;&lt; (first ? &quot;&quot; : &quot;, &quot;); out &lt;&lt; p.first &lt;&lt; &quot;:&quot; &lt;&lt; p.second; first = 0;&#125; out &lt;&lt; &quot;&#125;&quot;;  return out;&#125;int solve() &#123;    int N ;    cin &gt;&gt; N;    vector&lt;int&gt; nums(N);    for (int i = 0; i &lt; N; ++i) &#123;        cin &gt;&gt; nums[i];    &#125;    if (N &lt;= 3) return N;    vector&lt;int&gt; diff(N);    diff[0] = 0;    for (int i = 1; i &lt; N; ++i) &#123;        diff[i] = nums[i] - nums[i-1];    &#125;    int hi = N + 1;    int lo = 4;    auto binary = [&amp;](ll lo, ll hi, function&lt;bool(const ll)&gt; predicate) -&gt; int &#123;        // return first true        while (lo &lt; hi) &#123;            ll mid = lo + (hi - lo) / 2;            if (predicate(mid)) &#123;                hi = mid;            &#125; else &#123;                lo = mid + 1;            &#125;        &#125;        return lo;    &#125;;    auto pred = [&amp;](const ll x) -&gt; bool &#123;        unordered_map&lt;int, unordered_set&lt;int&gt;&gt; cnt;        map&lt;int, unordered_set&lt;int&gt;, greater&lt;int&gt;&gt; reverseCnt; // cnt-&gt;value, cnt-&gt;count        auto addCnt = [&amp;](const int i) -&gt; void &#123;            cnt[diff[i]].insert(i);            reverseCnt[cnt[diff[i]].size()].insert(diff[i]);            reverseCnt[cnt[diff[i]].size() - 1].erase(diff[i]);            if (reverseCnt[cnt[diff[i]].size() - 1].empty()) &#123;                reverseCnt.erase(cnt[diff[i]].size() - 1);            &#125;        &#125;;        auto eraseCnt = [&amp;](const int i) -&gt; void &#123;            auto&amp; first = cnt[diff[i]];            first.erase(first.find(i));            reverseCnt[cnt[diff[i]].size() + 1].erase(diff[i]);            if (reverseCnt[cnt[diff[i]].size() + 1].empty()) &#123;                reverseCnt.erase(cnt[diff[i]].size() + 1);            &#125;            if (first.empty()) &#123;                cnt.erase(diff[i]);            &#125;            reverseCnt[cnt[diff[i]].size()].insert(diff[i]);        &#125;;        for (int i = 1; i &lt; x; ++i) &#123;            addCnt(i);        &#125;        auto check = [&amp;](const int lastIdx) -&gt; bool &#123;            // cout &lt;&lt; lastIdx &lt;&lt; &quot; ... &quot; &lt;&lt; cnt &lt;&lt; &quot; &quot; &lt;&lt; maxDiffIndex &lt;&lt; &quot; &quot; &lt;&lt; maxDiffValue &lt;&lt; endl;            auto it = reverseCnt.begin();            const int maxDiffValue = it-&gt;first;            const int maxDiffIndex = *(it-&gt;second.begin());            if (maxDiffValue == x - 1) return true;            else if (maxDiffValue == x - 2 || maxDiffValue == x - 3) &#123;                vector&lt;int&gt; index;                index.reserve(2);                for (const auto&amp; p : cnt) &#123;                    if (p.first != maxDiffIndex) &#123;                        for (const auto&amp; idx : p.second) &#123;                            index.push_back(idx);                        &#125;                    &#125;                &#125;                if (maxDiffValue == x - 2) &#123;                    if (index[0] == lastIdx || index[0] == lastIdx - x + 2) return true;                    else return false;                &#125; else if (maxDiffValue == x - 3) &#123;                    if (index[1] &lt; index[0]) &#123;                        swap(index[0], index[1]);                    &#125;                    if (index[0] + 1 != index[1]) return false;                    if (nums[index[1]] - nums[index[0] - 1] == maxDiffIndex * 2) return true;                    else return false;                &#125; else return false;            &#125; else return false;        &#125;;        // cout &lt;&lt; &quot;Debug: &quot; &lt;&lt; maxDiffValue &lt;&lt; endl;        if (check(x-1)) return false;        // if check        for (int i = x; i &lt; N; ++i) &#123;            // cout &lt;&lt; &quot;before: &quot; &lt;&lt; cnt ;            eraseCnt(i - x + 1);            addCnt(i);            // cout &lt;&lt; &quot;after: &quot; &lt;&lt; cnt &lt;&lt; &quot; !!! &quot;;            if (check(i)) return false;        &#125;        return true;    &#125;;    // for (int i = 4; i &lt; hi; ++i) &#123;    //     cout &lt;&lt; i &lt;&lt; &quot;:&quot; &lt;&lt; pred(i) &lt;&lt; &quot; &quot;;    // &#125;    return binary(lo, hi, pred) - 1;&#125;int main() &#123;    int T;    cin &gt;&gt; T;    for (int i = 0; i &lt; T; ++i) &#123;        cout &lt;&lt; &quot;Case #&quot; &lt;&lt; i + 1 &lt;&lt; &quot;: &quot;;        cout &lt;&lt; solve();        cout &lt;&lt; endl;    &#125;    return 0;&#125;\n时间复杂度: O(N log N log N),\n空间复杂度: O(N).\n按理说 N = 10 ^ 5 不会超时，然而大的case还是TLE了。可能是被卡常数了。\n看了官方题解，时间复杂度是O(N)。多了两个log还是不行呀。\n Consecutive Primes\n Truck Delivery\n","categories":["KickStart"],"tags":["Competitive Programming"]},{"title":"快手实习生面试","url":"/2018/04/30/kuaishou-intern-interview/","content":"感谢@lxc师兄的内推和面试建议，我有幸可以参加快手推荐组算法实习生的面试，并最终通过面试被录取。\n虽然实习生的面试可能相对简单，但是我认为还是有参考价值的。\n刷实习算是一种最终找到好工作，进入梦想公司的途径吧（不能算是捷径，我实习的2份工作还是很累的。快手是我的第二份实习。）。\n现在实习终于稳定下来，毕设论文也还有一段时间才deadline，恰好抽出时间总结一下自己的面试和实习。\n希望可以指导到自己之后找其他实习或者是正式工作:)\n\n 面试\n我总共经历2轮面试，耗时近2个小时。\n总体感觉是准备的不很充分，很多地方有待提高。\n 一面\n面试官是一个胖胖的小哥哥，很友善，面试也很认真。\n我参加实习后，经常在开会和吃饭的时候遇到他，感觉很亲切；我们不在一个小组，但在同一大组。\n面试内容：\n\n给定一个数组，找到和最大的连续序列，返回和；\n翻转句子：如 today is wednesday! =&gt; wesdnesday is today!\nSQL相关：left join, right join, inner join区别；partition了解不。\n机器学习相关：准确率和召回率的定义\n\n 二面\n面试官是一个严肃的工程师，给我的印象是反应很快，可能是leader类的人物。\n但可惜的是，我入职之后在大组没有见过他。\n\n内存特别小时，在大量的数中找到数m的位置。\na = b时，b有可能在哪里获取？寄存器、cache、Memory、外存\n一个已排好序的数组，循环左移k位(k未知)，找到数m的位置。\nn个台阶，可以走1步或2步… 这个题他先问我做过吗？我说做过，就没再让我做。\n一颗二叉树，每个节点存一个数，找到两个数的最近公共父节点。\n多进程与多线程区别；\njava、C++ 多进程通信使用；\njava、C++ 网络通信 socket库使用。（这2个我没答好）\n机器学习的了解程度，损失函数是否研究过。\n\n 面试准备\n经过这次面试，我对面试的准备内容更加明确了：\n\n数据结构和算法是基础，必须好好复习和刷题的。\nSQL、机器学习和Hadoop只是是锦上添花的技能。\n手写代码和简答是面试的主要内容。\n\n因为事实上，我sql、机器学习、多线程的问题答得都很差，只有算法题马马虎虎答得还可以，都写出来了，虽然中间出现过一些错误而且耗时可能比较长（尤其是手写第一题的时候，还没进入状态，多花了些时间）。\n参考师兄的建议，我认为如下的准备路径和方式比较高效（我也还在准备当中）：\n\n数据结构和算法：cos226+算法第四版，the elements of interview\nsql: sql必知必会，runoob\n多线程：Java并发编程实践\n机器学习：周志华的“西瓜书&quot;\n\n 入职\n之前因为毕设的原因，还犹豫过到底要不要接受实习offer。\n经过咨询师兄和权衡利弊，我最终还是接受了offer，于4月19日入职。\n这份offer的待遇是：每天300，管午饭、下午茶和晚饭，水果牛奶雪糕随便吃。\n事实上是：\n每天税前300，实习生按劳务所得交税，超过800的部分要交给国家20%。\n午饭晚饭还是很棒的，尤其是午饭的自助餐，每次都吃撑。\n下午茶很简单，一个牛皮纸袋里有饮料、水果和零食，与想象中的有差距，但还是很使人满足的；我经常会剩一些带回去吃。\n从工作中的点点滴滴中，我可以感受到\n快手是一家技术很好、牛人很多的公司，现在在迅速扩张之中，几乎每周组内都有人入职（因此我才被录取？）。\n带我的2个mentor人也都很nice，我从工作中学习和成长了很多。\n","categories":["interview"],"tags":["intern","kuaishou"]},{"title":"latex 使用过程中遇到的问题","url":"/2018/03/27/latex-problems/","content":"笔者毕业设计论文的撰写使用了latex工具，遇到了许多问题，在此总结一下。\n pdf无法正常显示\n###　问题描述\n经过xelatex编译成功地文档无法正常显示pdf图片，显示的是一片空白。\n 原因\npdf文件的版本问题。查看其版本为1.7，xelatex默认按照1.5进行编译。\n 解决方案\nxelatex %.tex，此处加上–output-driver=“xdvipdfmx -V7”。即修改msmake.bat\nxelatex %mythesis%# =&gt;xelatex --output-driver=&quot;xdvipdfmx -V7&quot; %mythesis%","tags":["tex"]},{"title":"生死疲劳","url":"/2023/12/12/life-and-death-fatigue/","content":"豆瓣链接 生死疲劳\n评分这么高么。我高中时，莫言得了诺贝尔文学奖。当时跟风读了不少他的小说 如《丰乳肥臀》、《四十一炮》。想想当时的读书环境，竟然是某人买了一本书，然后全班感兴趣的人轮流借着读，也是十分有趣了。大学时，也继续读过《蛙》。莫言的小说总能让人读出一种被社会和时代压迫的感觉，也十分反映农民的辛苦和无奈，也是对社会变革无情的讽刺。在如今言论环境越来越差的背景下，希望更多的人可以读到这些书，这些书可以多活一阵子。 读过：剧情不错，人物关系也挺复杂。涉及建国后的50年历史，3代人。通过主人公的六世轮回，五世牲畜，见证那个时代。包括，土改，人民合作社/公社，大跃进，3年大饥荒，文革，大养猪，改革开放（中央出了修正主义）。一个亮点是，莫言 作为一个配角在小说中出现。既有自负，也有自嘲。不少口号，放在现在也不为过。\n生死疲劳，皆因贪念。无欲则刚，放下仇恨。西门闹经历五世轮回，最后放下仇恨，转世为畸形人。\n","categories":["读后感"],"tags":["Reading","生死疲劳"]},{"title":"Mac OS写入ntfs解决方案","url":"/2019/11/11/mac-write-ntfs-solution/","content":"使用Mac系统确实存在一些不方便的地方，比如 写入 NTFS的硬盘或U盘。默认情况下，MAC 只支持读取NTFS。不过只要你有勇气折腾，解决方案还是很简单的。\n 最推荐方法\nMounty for NTFS\n优点：免费，小巧\n缺点：不hack，其实就是命令行的包装。有些同学可能更喜欢命令行的方式。\n 最hack的方法\nsudo umount &quot;/Volumes/Seagate Expansion Drive&quot;sudo mount -t ntfs -o rw,auto,nobrowse /dev/disk3s1 ~/ntfs-volume\nreference: mounty\n经过一段时间的斗争，我还是采用了安装第三方应用的推荐方法。因为命令行确实经常忘记或是输错，每次都要重新Google，与我使用Mac系统想要的优雅方便不符。\n","categories":["Tech"],"tags":["Mac"]},{"title":"将博客园中的随笔迁移到Hexo","url":"/2016/11/22/move-posts-from-cnblogs-to-Hexo/","content":"有关如何将其他博客上的文章迁移到Hexo上, 官方文档给出了一些指引. 我也是根据官方文档进行了将自己之前在博客园中的随笔迁移到新博客上的尝试. 这个过程中遇到过一些问题, 再此给出解决方法.\n\n 未安装迁移插件\n博客园需要用rss迁移, 我根据文档, $ npm install hexo-migrator-rss --save 安装了相关的插件, 但在运行迁移命令$ hexo migrate rss &lt;source&gt;时, 报出了如下错误:\nundefined migrator plugin is not installed.Installed migrator plugins:For more help, you can check the online docs: http://hexo.io/\n我在stackoverflow上找到了答案. 原来是需要在博客所在的目录下运行安装插件命令$ npm install hexo-migrator-rss --save才可以. 看来还是我不熟悉nodejs的原因, 因为nodejs的包管理安装默认是局部的, 安装在当前文件夹下的.\n在博客所在目录下重新安装&quot;hexo-migrator-rss&quot;插件, 问题解决.\n 迁移后的文章只有摘要和超链接\n成功迁移后, 我兴奋地立即查看了迁移结果, 结果发现, 迁移的文章只有摘要和链接到博客园原文章的超链接, 就想下图一样. 这显然不是我想要的.\n\n可以发现这是由于博客园导出的rss就是这样的. 通过观察, 我发现rss的链接只是一个包含文章信息的xml文件, 也就是说, 如果我们可以得到有完整文章信息的xml文件就可以了. 恰好博客园的备份功能可以提供这样的文件. 将rss链接换为备份文件的链接, 在运行迁移命令就可以将完整的文章迁移到Hexo了. 下面是完整迁移的效果.\n\n不过这样的迁移还是丢失了标签这样的信息, 不尽如人意.\n 奇怪的格式问题\n迁移成功后发现, 有两篇文章的格式变得很奇怪, 正文都很正常, 但引用, 插入代码的地方就会排版很乱. 但另一篇却很完美. 通过观察迁移的xml文件内容发现, 那两篇文章的内容是html格式的, 而另一篇是Markdown格式的. 这时我才想起, 最初的两篇随笔是用博客园推荐的TinyMCE编辑器编写的, 后来才转投Markdown的. 所以, Hexo当然不能完美的支持.\n","categories":["折腾"],"tags":["Hexo"]},{"title":"硕士3年复盘","url":"/2021/07/03/my-3-years-master/","content":"本科毕业时，我写了4年的总结：大学4年复盘. 现在转眼之间3年过去了，我已研究生毕业，即将进入职场。\n虽然经历了半年延毕，但最后还是有惊无险的成功毕业了。上周完成了去武汉的毕业旅行，周末回到北京搬家和准备入职。带着对未来美好的期望，我踌躇满志。\n 硕士3年\n3年前，因为本科成绩优异。我最后走上了保研这条看似光鲜亮丽的路。\n虽然经历了诸多坎坷和焦虑，但我并不后悔这样的选择。\n对于我这样的小镇做题家，这样的结果和发展道路属实更加稳妥，风险更低，收益也相对可观。\n回顾研究生这3年，我有很多事情没有干成功。\n研一上被老板派去文远知行实习，工作还算辛苦和圆满，但最后不欢而散。其实一开始就不愿意去，迫于牛老板的淫威。见我的吐槽。短期挣到了每月3k的工资，长期浪费了时间。\n研一下转做水科院项目，因为甲方扯皮和技术储备不足，最后成了一个深坑，不了了之了。\n研一除了帮牛老板干活外，还需要上课。把毕业需要的学分都修完。因为时间精力分散和重要程度降低的原因，我成绩并没本科好。不过也没人在乎这个成绩。\n研二下+研三，一直在写小论文和大论文。小论文修改数十次，投稿3次，2次被拒，一次被老板嫌弃会议级别而撤稿，均以失败告终。大论文被老板多次贬低，吓的毕不了业。然而答辩时，和其他同学一对比，发现自己的工作做的其实很不错。\n也干成了自己想干的一些事儿。\n研二上去比利时交换，体验了一下留学生活，并且把欧洲几乎玩了一个遍。事后证明，这确实是很幸运的。因为第二年，就爆发了全球性的新冠疫情。旅游变成了一项不可能的活动，尤其是出国旅行。\n在交换的过程中，与npy相识、相知、最后相恋。也算是一段美妙的姻缘。\n研二暑假通过亚马逊的远程实习，之后顺利拿到了亚马逊的offer。也算是稍稍弥补了因为突如其来的疫情而不能去谷歌的遗憾。\n 未来憧憬\n马上就要进入职场，成为一名光荣的打工人了。\n给自己职业规划的几点忠告：\n做一个靠谱的人。\n工作后不能再像读书时那样放任自由了。很多时候都应付牛老师，自己并没有听老师的话。然而这样确实利大于弊。一则我并不喜爱科研，读论文、写论文 对我来说如同上坟。二则我摸鱼多出的时间也并没有荒废，而是用来做自己喜欢的事情，比如刷算法题、学习C++。这些事情也更好地帮助我完成了自己的目标：找到一份好的工作。而听牛老师的话对他的好处更多，对我的好处更少。三则我们毕业没有论文要求。虽然在牛老师的恐吓中，我尝试发了3次小论文，2次被拒，1次老师嫌会议不好，撤稿了。最后勉强搞了一篇专利。毕业答辩的时候才发现，其他同学的毕业设计很多都做的比我差多了，大约相当于我本科时的水平。之前每天担忧毕不了业，都是牛老板吓我们，我们自己吓自己，能把自己吓死了。其实毕业要求并没有想象的高。也可以理解，因为虽然北航6系优秀的同学很多，我们实验室也卷的很，但我们的水平还是处于总体中上的。研究生的最后一年，我的知识和经验相对成熟后，我才了解到，自己可能被PUA了。只有让学生恐慌，觉得自己不行，牛老师才能更好地掌握他的权力。\n然而，工作之后又是另外一番场景。毕竟拿钱办事儿，经理作为你的老板也不会像父母和老师那样惯着你了。靠谱作为一项我认为工作最重要的品质。让经理放心把任务交给你，同事和你合作时更舒心。对职业成长和发展都十分有好处。\n学会攒钱储蓄和投资理财。\n下周入职，但是发现入职前半个月已经几乎花光了积蓄，不得不向父亲要钱。大头是租房，其次是毕业旅行，然后是配置生活用品，包括家具、调味品、厨具，这些花费很多都超出我的预计。当我意识到危险的时候，信用卡已经欠款33k了。虽然我之前储蓄了4w, 但是因为对支出的预计不足，我有12k放在了理财里，一时拿不出来。因此在下个月10号信用卡出账单前，大概有6k的缺口，只能找爸爸要钱了。他甚至连我的银行卡号都没有。我很多年没有直接要钱了，一直靠自己生活。通过实习和学校发补助攒钱。我之前预料到一毕业会比较需要钱，因此攒了4w，但没想到这么缺钱。成年人的生活真是太难了。\n之前尝试买基金，但基本上都以亏钱为主，做了韭菜。但也因此成长了不少，算是入门了投资理财。\n因为之后我打算去欧洲/北美发展，不想在国内卷了。一开始刚去的时候，肯定还是需要花费一大笔钱做周转。\n以后买房、买车、娶老婆、养孩子，都需要钱，因此需要早日开始准备。\n注重职业发展。\n读了19年书，现在正式进入打工人行列。相比之下，打工的时间可能更长，预计40年。因此，需要好好规划一下，有一个好的开始，不断积累，产生复利效应。\n当前的职业规划是：一直做SDE，做到SDE3以上。在大厂工作。去欧洲/美帝生活。\n根据我的职业规划，现在要做的主要有3件事儿：1. 提高自己的SDE素质，面向工作和面试；2. 英语口语；3. 锻炼身体。\n 岁月是把杀猪刀\n最后附上自己读研前和读研后的2张照片，再次感叹岁月是把杀猪刀。3年过去了。分别是22岁和25岁的我。\n\n\n","categories":["dairy"],"tags":["life"]},{"title":"大学4年复盘","url":"/2018/10/03/my-4-years-college/","content":"2014年9月，我误打误撞来到了北航计算机学院。没想到“侯门一入深如海，从此萧郎是路人“，从一个从没有接触过代码的小鲜肉，成长为未来的工程师。这四年的时光是我技术和三观成长的重要阶段，可以说，大学塑造了之后的我。其中，有值得肯定的部分，也有我现在一心想要摒弃的缺点。\n北航的课程以基础扎实著称。计算机科学的基础课程：计算机组成原理、操作系统、编译原理、计算机网络，分别分布大二大三在4个学期，每学期这些基础课都属于重课，需要花费大量的精力。现在看来，重视这些基础课程简直太正确了。我大四参加了多场实习面试和实习，深刻体会到这些基础在面试和工作中的重要程度。只是当时大多数学生的motivation不足，并不能理解学院的良苦用心。我自认为在学院学习成绩名列前茅，奖学金和各种证书也拿了一大把。但对于这些cs基础，并不敢叫嚣自己理解了，更多地是谦虚地告诉自己，很多还需要补习。年轻的时候欠下的帐迟早要还的。这四年来，貌似学了很多，其实学到很少。其实，最好的学习方法是，在学院的课程配合下，主动地进行学习。阅读每个topic的扩展材料，而不是老师把材料的链接放在ppt上，自己连下载都不下载。多多上网搜集信息，泡图书馆。\n虽然平时经常和朋友们吐槽课程设置不合理，但我不得不承认，计算机学院的很多本科课程的设置还是极其合理并富有前瞻性的，尤其是结合其他高校的课程设置来看。北航计算机学院全国第三的排名也并非浪得虚名。比如，大一上的大学计算机基础就是教python，更可怕的是，是几乎所有专业的同学都要学，不限于计算机，还有人文、经济、数学、飞行器。后来写的代码多了，才知道掌握python确实是必要的。尤其是15年后，机器学习大火之后。python是机器学习的必备语言。而据我所知，并没有其他高校从14年就将python设置为全校的必修课。\n大一的时候，我们要上很多课，其中大多数是数学课，编程课程每学期只有一两节。每门数学课还都是大课重课，需要花费很多的精力。包括 数学分析、高等代数、概率与统计这些基础课程，也有 离散数学、集合论、图论 这些和计算机相关的数学课。当时大家都笑称，“进错了专业，其实是数学系”。之前有过编程经验的同学更是无法理解，因为他们选择计算机专业时就期待着更多实践课程，可以动手写代码。现在看来，对数学课的重视一点也不为过。只是当初too young, too naive，无法理解老师们的良苦用心。真的就像大一时候班主任告诉我们的一样，基础数学课的有用程度是 概率统计 &gt; 线性代数 &gt; 微积分。后来接触机器学习后，才知道数学真TMD重要。年轻的时候总是认为自己很牛逼，知道自己需要什么，不需要什么；认为学院很傻逼，老师很古板。其实呀，真正傻逼的还是自己。\n大学期间究竟要不要参加各类比赛呢？我认为完全没必要，除非你对该比赛有强烈的兴趣，或者比赛的经历和奖项可以给你带来足够的收益。\n从现在看来，我参加比赛的经历并未获得足够的收益，反而投入了一部分时间和经历。\n我大学期间参加过各种各样的比赛，主要集中于学科竞赛和编程比赛。首先是数学建模竞赛，估计是很多大学生都有机会参与的。我曾经和2位同学一起参加了2016年的美赛和国赛。现在看来是一件蛮可笑的事情。我们之前没有任何关于建模的数学基础和写作训练，试图水一个奖项，最后当然竹篮打水一场空。诚然很多同学也是熬夜几天，水了一个二等奖，但这个奖项的收益有多大呢？美赛几乎都是中国人在参加，大家也知道奖项并不能证明你的能力。大一上数学分析的时候，杨小远老师就说，她在数学学院招收研究生的时候，发现很多人都有美赛的奖项，但面试一问就露馅了，数学和建模能力一般。获奖更多的是抱大腿和比赛本身的水分。\n所以，我认为，很多时候，奖项只是锦上添花的东西，更重要的是，你在准备比赛和参加比赛的过程中，收获的能力和成长。\n我在大二的时候，也参加过大学生数学竞赛（非数学类）。在竞赛的培训期间，因为太难了，很多材料都只做了不到1/3。就是这样，我竟意外地获得了全国三等奖。但实话说，这个奖项对我没多大作用（当然对评奖学金是有用的），而且我在准备竞赛的时候并没有全力以赴，收获到的能力和成长都是有限的。\n大学期间，我一直没想明白自己以后要做什么。没有清晰的目标，就没有细致的规划。很多机会其实也就这样错过了，机会总是留给有准备的人的。这样时间不能说是浪费掉了，但却没有被高效利用起来。大一大二大三一直在上课。由于高考的失利阴云一直笼罩在我的心里，我到了大学仍然学习很认真，生怕落后。大三到了决定出路的时候，自己才发现周围少部分同学早早地准备了出国、保研、工作，此时正是丰收前的最后冲刺。而我像大多数人一样，匆匆忙忙地度过了大学的前几年。我由于成绩不错，被老师鼓动保研了。\n就像很多游戏里的职业系统一样，玩家达到某一等级后，就可以选择不同的职业，专学该职业的技能，购买该职业的装备。有经验的玩家会早早准备着这一步，可能从0级就决定好之后的职业了。然后向着这个职业修炼，因此技能点和金钱一点也不浪费。而我就像新手玩家一样，早期由于晋升道路很明显和固定，一路打怪升级，由于天赋玩的还不错。但到了选择职业这一步，就蒙蔽了。货比三家，还是选择了人数最多的职业。心想，选的人多自然有其道理。进入职业后，由于前期的专项积累不够，与有经验的玩家有差距甚至是被吊打，也不足为奇了。\n大四在外实习了一年，接触了业界的不少前辈。从75后到80后，还有不少90后。通过比较和自己在实验室的生活，我发现自己更适合和喜欢工作。我本身性格内向，对数理也很感兴趣，大学接触编程后，也是兴趣盎然。相比很多同学对编程的不温不火，甚至排斥，我对编程可以算是热爱了。大二折腾了一年，自学了Linux、git、鼓捣个人博客、网站。这些折腾到后来给了我丰厚的回报，尤其是Linux和git 2项，在之后的工作学习中有大量的使用。数学上的优势也让我可以接触到算法岗的工作。但由于没有丝毫准备，当时的我并不能放弃读研，转而工作。因为程序员的短缺，我本科毕业找到一份看上去还不错的工作不难。但并不能找到顶尖的工作。程序员也分很多种，前端、后端，架构、算法。我也不清楚其中的差别，莽莽撞撞地去工作很危险。所以，我就打算继续读研了。趁着读研期间的学生身份，多出去实习几次。一是可以体验不同的工种，找到自己适合的；二是可以锻炼自己的能力，丰富简历内容，为明后年找工作做准备。\n以上，就是我大学四年的复盘。主要集中在学习和人生规划方面。因为我认为这些才是大学生需要主要思考的问题。\n我的大学生活绝不能算是成功，相反，与身边优秀的人相比，可以算是失败了。所以，这篇文章，更多的是教训、而不是经验。希望自己以后可以引以为戒。\n 岁月是把杀猪刀\n岁月是把杀猪刀，有些人千刀万剐，有些人刀枪不入。\n\n\n","categories":["dairy"]},{"title":"英伦游学所见所思","url":"/2016/08/25/my-britain-trip/","content":"今年暑假，有幸参加我航高等工程学院和剑桥东方交流会联合承办的英国交流营。该交流营为期两周，内容充实，形式多样，让我深刻了解了英国的人文文化和中国人留学情况，圆满完成自己行前的目标。接下来，我就整个整理进行整理，分享给大家，希望对大家有所帮助。\n\n这是我第一次有机会出国，也算是人生的一个标志事件，自己的心情也是十分激动的，半个学期都在期待这次交流。去英国前，英国脱欧公投，以几百万的微弱优势脱欧成功，首相卡梅隆辞职，英镑暴跌10%，我们又无形中省了一笔钱。经过几个月的行前筹备，我们终于踏上了这块离家乡八千公里的国度，开始为期两周的游学。所谓游学，既有紧张的环英之旅，从南到北，又从北到南，逛了很多自然人文景观；又有在剑桥的5天充实的学习生活，杜伦大学的一晚借宿，爱丁堡大学的参观游览，曼彻斯特大学的交流学习，伦敦大学的两天体会。14天的交流营，从希思罗机场到希思罗机场，可以说整个人都被洗脑了。被洗脑的原因有很多，我在下面分几个方面细细道来。\n关于留学方面。这次团队19位学生，其中包括3名博士，3名研究生，13名本科生；大多人都是抱着以后留学的打算来的。虽然每个人的志向不同，留学的目标也不都是英国，但来到这里可以参观体会很多英国著名的大学，了解这里的留学政策和留学生情况。在每个大学，我们基本上都有该校的学生做为导师，引领我们更好地了解这个大学，这些人有的是中国留学生，还有一个就是北航的，有些是其他国家的，比如在剑桥的墨西哥留学生朱莉。尤其是在剑桥大学呆的这5天，上午剑桥东方交流会会邀请剑桥的一些大牛教授给我们上各种专业、文化课程，虽然这些课程上课的过程不一定和剑桥真实情况完全一样，但却足够让我们体验到像剑桥这样的世界一流大学的上课是怎样的。他们还邀请到剑桥的招生办负责人，给我们介绍剑桥的留学情况，细心解答我们提出的各种问题。下午，我们一般都是各种参观交流和文化体验，像punting，参观著名的三一学院、圣约翰学院、国王学院，参观语言中心。我们在一天晚上还观看了国王学院学生演出的莎士比亚的四大喜剧之一的《皆大欢喜》。虽然看不懂戏剧的内容，但在草地上冻了2个小时的经历还是令我印象深刻。尤其让我印象深刻的是参观了卡文迪许实验室。卡文迪许实验室可谓物理学史上最著名的实验室，一直以来作为物理人的圣地。之前我一直有误解，认为卡文迪许实验室是为了纪念钮称测量万有引力常量的那个卡文迪许而建造的，所以被命名为“卡文迪许实验室”。来到这里才知道，卡文迪许实验室是剑桥大学的一位校长威廉·卡文迪许捐资建造的，所以以出资人的姓氏命名；值得一提的是，威廉·卡文迪许是测量万有引力常量的亨利·卡文迪许的近亲，同属声名显赫的卡文迪许家族。这座建成于1874年的物理实验室，先后培养出催生了近30位诺贝尔奖学者，拥有大量足以影响人类进步的重要科学成果，包括发现电子、中子、发现原子核的结构、发现DNA的双螺旋结构等，为人类的科学发展作出了举足轻重的贡献。我们怀着崇敬的心情在新的卡文迪许实验室外进行了合影留恋活动，以纪念在此的交流活动和受到的洗礼。这次交流活动时间虽然比较短，但让我受益颇丰，坚定了我留学的信念，也交到了很多志同道合的朋友，使我在前行的道路上感到不再孤单。\n英国的食物是世界出名的糟糕。有多糟糕呢？你可以在大街上找到各种菜，中国菜、印度菜、泰国菜、墨西哥菜、意大利菜、法国菜……唯独没有英国自己的餐馆。唯一比较有特色的炸鱼薯条，简直连肯德基的炸鸡和薯条都比不上。难怪在英留学的中国留学生都学会了自己做菜，外面吃贵不说，还吃不到什么好的。直到我们亲身体验了两周的英国食物之后，才对此有了深深的认同。几乎每日的全英早餐给我们每个人都留下了深刻的印象。刚开始的时候，大家还很新鲜，认为味道还不错，样式很多，还极富有营养价值；不过吃了几日，就有些受不了。原来全英早餐的意思是，全英国每天都吃。现在回国吃到包子豆浆、油条豆腐脑，别提多幸福了。\n在文化方面，我也受到了很大的震撼。\n我们在英期间恰值里约奥运会，可以看得出，英国人对于奥运会的热情还是很高的。在我们参观庄园的时候，遇到一个英国人，他见我是中国人面孔，就问我是哪里来的？我说中国。他就很高兴地说中国在奥运会表现很棒，又列举了跳水、体操、乒乓球、举重等中国很强的大项，赞美之声不绝于口。当时中国金牌榜还是排名第二的，我们在英呆的第二周，英国的金牌数量超过中国，并一直保持到了奥运会结束。在travelodge住宿的3天晚上，我每天晚上的娱乐活动都是看电视，看英国的电视都说些什么。BBC-1整天都在播放关于奥运会的节目，BBC相当于国内的CCTV，可见媒体对于奥运会的关注程度。在英国的各个酒吧中，奥运会和足球是永恒的主题。不过英国媒体和大众多关注自行车、赛艇这样的英国强势项目，其他的关注比较少，这与国内很相似，我们国内关注的也多是本国的传统优势项目。\n英国的绅士文化。英国作为一个老牌的资本主义国家，曾经是日不落帝国，掌握世界霸权长达一个世纪，如今虽无往日风光，但也是资本主义强国，仅次于美日德。众所周知，英国资产阶级革命是一场不彻底的、妥协的革命，不仅保留了王室，还保留了很大一部分贵族的存在，这些新贵族如今形成了独特的乡绅文化。英国人，不论什么情况下，都要说“Thank you”，这种谢谢已经不止是谢谢的意思了，更多的是一种文化，很多时候让我们不知所措，也好跟着说”Thank you“。英国人喜欢排队，这是我们在旅途过程中感受很深的，所谓”queue文化”。他们喜欢排队，很多时候会不自觉排队，有时候感觉挺可笑的。\n英国的气候。我们从小从教课书中获得的印象是，英国永远在下雨。来到这里后，得知并不是这样，或者说不准确。据留学生说，英国的天更多的是”grey”，更像多云。有太阳的天是少数，当晴天的时候，英国人就会都出来，坐在草坪上晒太阳，然后一天什么都不干。我们都称之为“腐朽的资本主义“。英国人从来不打伞，因为很多时候不需要，英国的雨下起来一般都不大，而且下的时间不长，打起伞来比较纠结，不如不打。\n苏格兰。英格兰、苏格兰、不列颠、大不列颠、英国……这些名字可能大多数中国人可能并不十分清楚谁是谁，而苏格兰和英格兰几百年的爱恨情仇，倒是被中国人调侃的很多。我们这次的行程有一部分就是在苏格兰完成的。在苏格兰，你绝对看不到英国的Union Jack旗，取而代之的是苏格兰自己的旗子。苏格兰甚至还有苏格兰银行印发自己的钱币，“就是不花你的钱 ”。苏格兰前些阵子还在闹独立，进行独立公投，首相卡梅伦哭着请求苏格兰不要离开，不过最后投票的结果还是留在英国了。在此次脱欧公投中，苏格兰大多选择留欧，理由是：凡是英格兰支持的，我们都反对；凡是英格兰反对的，我们都支持。苏格兰和伦敦一起，成为留欧阵营。无奈苏格兰人比较少，并未影响局势，脱欧后，又有了苏格兰打算先脱英，再加入欧盟的传言。从文化上，苏格兰和英格兰的差别也比较大。苏格兰虽然没有自己的语言，都说英语，但他们的口音确实也独树一帜。苏格兰有自己的文化，苏格兰小短裙、苏格兰风琴、苏格兰诗人……被中国人所熟知的《哈利波特》的作者，J·K 罗琳就是在苏格兰爱丁堡的大象咖啡馆完成。在世界杯和欧洲杯上，苏格兰和英格兰也都是有自己的球队的。总之，来到苏格兰确实看到了别样的英国。\n英国的两周体验生活到现在已经结束了，虽然时差还没倒过来，就急着写了这篇总结。在英交流结束的时候，大家都很不舍，从互相不认识的彬彬有礼，到彼此熟知的促膝长谈，不过毕竟大家都在北航，以后还有很多机会相聚；而那些英国的可爱的人们，以后恐怕很难再见了。可爱巨大的胖司机，小巧玲珑的juile，爱丁堡和牛津的导师们，还有孔老师和高老师，我们在一起拥有了一段很美好的回忆，我会永远记住你们的。\n 后记\n\n在贝克街221B和&quot;卷福&quot;的合影。因为中国游客比较多，他可是会说中文哒。获得合影许可后，我说“Thank you”，他礼貌地回了句“举手之劳”。\n","categories":["dairy"],"tags":["travel"]},{"title":"我的沙航故事","url":"/2016/05/25/my-shahe-story/","content":"还有一个半月就要离开沙河这个“破”地方了，没想到在这里已经呆了将近两年，所以现在写我的沙航故事最合适不过了。\n回头看看自己从小鲜肉沦为了老腊肉，当初对大学生活的新鲜感早已消失殆尽，变为日复一日地为课业忙碌，有时候真的想改变改变自己的状态，过上自己曾经憧憬的大学生活，但在面对大的体制，才感到自己的渺小和无助，只能以“为了国家民族的利益”聊以安慰。在这里我不想过多吐槽，只想和大家分享一下在沙航的这两年经历，给后来人一个参考，也给自己留一个log，方便以后查看。\n\n我来自离北京很近的地方——山西，和大家一样，我也是经历高考过来的，至于高考和报志愿的琐碎本身就可以另写一本书，所以我在这里不予赘述。初来沙航的时候，我像所有新生一样对大学生活充满了向往，只怪当初太天真，相信了高中老师画的大饼。一开始，按照自己对理想大学生活的想象，我参加了很多的学生组织，包括社团和学生会。很多组织的活动我在后来慢慢地不参与了，也就自动退出了，唯独保持了在校学生会的存在。说到校学生会，这个也可以写一本书，其中的机缘巧合，人情世故绝对可以吸引人们的眼球，回头看看，现在在学生会的关系成为我仅剩不多的与外系的交流通道，尤其在成为死宅男之后，这样的机会更是弥足珍贵，不过马上由于地理的原因就要退部了，想想还有点舍不得呢。虽然我之后也参加了一些志愿活动和“猪脚”工作，认识了很多有趣的人，但这样长达2年的学生工作还是只此一个。至于我怎样成为宅男的，那是后话。\n我决定拿一整段话，来说我在北航的学习，因为它完全毁了我理想的大学生活。首先，大学中要学的东西真的很多，自己刚开始也是按部就班地学，但仍感到力不从心，直到经历过很多次“烤漆”之后，我仍不相信自己具有“一周一学期，一天一门课”的能力（好吧，我承认自己平时没有好好学习）。其次，当你适应这种快速学习后，发现有些课业的学习并不止于此，尤其是在计算机科学这个领域，很多实验需要调试，即使你设计的很好，但仍无法避免bug，当你碰到“蜜汁”错误的时候，除了“相信自己的代码是对的”之外，“多喝热水，重启试试，不行就分”也不失是一种方法，讲真，重启有的时候真的可以解决很多“蜜汁”错误。最后，谈谈大家在大学都爱谈的“自主学习”，如何利用自己的空闲时间。在大学，除了完成必要的课业任务，大家还真的各干各的，把很多时间花在奇怪的地方。写小说的有之，整天写代码的有之，一天到晚玩游戏的有之，整天呆在自习室的有之。有人说“在哈佛，社交、睡觉、学习，只能选两样。大多数人放弃了睡觉。”在北航虽然没那么严重，但也存在时间分配问题。像我这样爱睡觉的宝宝，只好放弃社交了（好吧，我承认我又在为自己的宅找借口了）。两年来，我别的不敢说比的过舍友们，但在睡觉上，无论是时间还是频率，我要称第二，没人敢自称第一。\n大学时光已经快要度过一半了，另一半注定要由于升学或就业的压力，有些变味，受制于现实。现在想想，还是在沙河的两年最无忧无虑，最纯了。\n过去值得留恋，现在值得珍惜，未来值得期待。\n总之，开心就好。\n\n","categories":["dairy"]},{"title":"Optimize Cortana in Searching Local files and Folders","url":"/2017/08/12/optimize-cortana-in-searching-local-files-and-folders/","content":" Problem description\nWhen I used the Cortana, the personal assistant of Windows 10, I found that it is confusing that searching\nfunction worked badly sometimes but well sometimes. To improve my productivity, I googled this problem and\nencounter a good solution.\n Reference\nhttps://www.windowscentral.com/how-add-new-cortana-search-file-locations-windows-10\n","categories":["折腾"],"tags":["Windows"]},{"title":"owncloud setup on server","url":"/2017/08/20/owncloud-setup-on-server/","content":" 简介\nowncloud是一个私有云解决方案，可以替代百度云。其提供企业版和个人版，个人可以利用服务器搭建个人版的owncloud。官网提供了多种服务器端解决方案。其中，自己编译可以获得最新版的owncloud；owncloud也提供了各大发行版软件库的二进制安装包，更方便快速，更适合个人的应用。\n\n 服务器环境\n腾讯云的一台云主机。操作系统版本为Ubuntu 14.04.5 LTS (GNU/Linux 3.13.0-105-generic x86_64)。\n 搭建过程\n 安装owncloud\n通过apt库安装owncloud。同时会安装很多依赖包，如apache2，php环境等。\n 启动apache服务\nservice httpd start\n 管理和设置owncloud\n在浏览器的地址栏输入ip/owncloud或域名/owncloud，设置好管理员账户和密码就好了。\n 配置MySQL\n参考\nmysql --user=root --password\n Client install\n windows\n Android\n Linux\n","tags":["Ubuntu","Owncloud"]},{"title":"pkg-config","url":"/2019/03/17/pkg-config/","content":"最近在学习google-test的使用和源码，在make install的时候发现除了向/usr/local/中安装了头文件，/usr/lib/中安装了shared library外，还向/usr/local/lib/pkgconfig/中安装了2个.pc文件。所以说，这个pkg-config是个什么东西呢？\n从一份Guide中，我们可以发现pkg-config的所有有用的基本信息。\n Overview\n现代的计算机系统使用很多层的组件以向用户提供API。一个很大的难点在于如何合适地将这些不同层的组件整合起来。pkg-config这一工具收集了安装在系统上的库的metadata, 用户可以很方便地查看这些metadata。比如，google-test安装的其中一个pc文件gtest.pc的内容是：\n包含使用gtest库的所有信息，如头文件安装位置、shared library的位置，编译时需要的编译选项。可以说，使用gtest看这些metadata就够了。\nprefix=$&#123;pcfiledir&#125;/../..libdir=$&#123;prefix&#125;/libincludedir=$&#123;prefix&#125;/includeName: gtestDescription: GoogleTest (without main() function)Version: 1.9.0URL: https://github.com/google/googletestLibs: -L$&#123;libdir&#125; -lgtest Cflags: -I$&#123;includedir&#125; -DGTEST_HAS_PTHREAD=1 \n计算机系统上没有一个如pkg-config的metadata系统的话，定位和获得系统提供的服务的细节将会很难。\n对于一个开发者，安装你的包的时候同时安装pkg-config将会极大地方便你的API被用户使用。\npkg-config最主要的使用是当程序编译和链接一个库的时候提供必要的细节。这些元信息被存储在pkg-config文件中。这些文件以.pc为后缀，存放在pkg-config工具知道的特定路径里。\n一个.pc文件中包含2种信息，metadata keywords和freeform variables。\n前者以keyword开头，后接冒号和value，如“Name: gtest&quot;。\n后者用=连接变量的值和名字，如&quot;prefix=…&quot;。\nkeywords是由pkg-config定义和导出的。\nvariables不是必须的，但是可以被用来表示pkg-config没有涉及的信息 或是 被keywords使用以增加keywords定义的灵活性。\n一个pc文件最好对应一个library文件。文件名(除了后缀)也最好相同。\n最重要的metadata域是Requires, Requires.private, Cflags, Libs 和 Libs.private。它们可以被外部的工程用来编译和链接到这个library。优先使用private域，以避免暴露不必要的库给用户。如果用户不不直接使用requires library的symbols，就不应该直接链接到该库。\n","categories":["Programming"],"tags":["C++"]},{"title":"对CPU 内存 硬盘读写 网络 进行压力测试","url":"/2017/01/14/pressure-test-to-CPU-memory-disk-network-IO/","content":"近来实验室的师兄有个需求, 写4个小程序, 分别对内存, CPU, 硬盘, 网络进行压力测试, 要求测试程序有压力档位可以调, 比如压力可以分为大, 中, 小. 二话不说, 撸起袖子加油干. 需求很简单, 但实现起来却并不简单, 笔者边学习, 边写程序, 才勉强完成任务.\n\n 测试环境\nUbuntu 14.04\n CPU\n受编程之美的第一章&quot;让CPU占有率曲线听你指挥&quot;启发, 我很快地完成了对CPU的压力测试程序.\n 基本思路\n确定一个小周期, 笔者的周期设置为100, 这个值可以通过改变PIECE的值来改变, 周期为 100 * PIECE.\n在每个周期中, stress%的时间用于一个死循环, 剩下 (100-stress)%的时间usleep(注意sleep和usleep的区别).\n 程序源代码\n\n 使用方法\n$ 程序名 stress    # 其中 0&lt;=stress&lt;=100$ # 例子$ gcc cpu_benchmark.c -o cpu_benchmark.out$ cpu_benchmark.out 50\n 硬盘读写\n对硬盘进行读写的压力测试, 我是分别通过两个程序实现的.\n 硬盘读操作\n 基本思路\n与CPU的压力测试类似, 在一个周期(1s)里, 先从硬盘里读取特定大小(speed)的数据, 周期的剩余时间sleep.\n 程序源代码\n\n 使用方法\n$ python3 disk_read.py 硬盘名 level    # 其中level可以是0, 1, 2, 3$ # 例子$ python3 disk_read.py /dev/vda 2\n 硬盘写操作\n 基本思想\n硬盘写操作的压力测试与读操作类似. 在一个周期内(1s)向一个文件中写入特定大小的数据, 之后删掉, 在周期的剩余时间内sleep.\n为了向文件中写数据, 笔者使用了命令\ndd if=/dev/zero of=/path/to/targetfile bs=1024k count=speed conv=fdatasync &gt; /dev/null 2&gt; /dev/null.\n该命令从/dev/zero中读取数据(其实是无效数据, /dev/zero 经常被作为初始化文件的数据源), 写入到/path/to/targetfile中. 为了不使dd产生的错误输出和标准输出影响本程序的可读性, 使用重定向了. /dev/null 是一个黑洞设备, 可以向其输入任何数据而不会产生坏的影响.\n 程序源代码\n\n 使用方法\n$ python3 disk_write.py 硬盘名 level    # 其中level可以是0, 1, 2, 3$ # 例子$ python3 disk_write.py /dev/vda 2\n 内存\n 基本思想\n对内存的测试, 笔者的师兄向笔者介绍了memtester这个程序. 具体安装及使用方法:\n$ # 安装$ sudo apt-get install memtester$ # 从PHYSADDR处分配MEMORY大小的内存, 测试ITERATIONS次.$ sudo memtester [-p PHYSADDR] &lt;MEMORY&gt; [ITERATIONS]\n一般情况下, 不需要指定PHYSADDR, 因为可能将其他进程占用的内存破坏掉, 存在一定的危险性.\n利用memtester这个程序, 笔者进行简单加工, 就完成了需求.\n 程序源代码\n\n 使用方法\n$ python3 memory_benchmark.py &lt;MEMORY&gt; [ITERATIONS]$ # 例子$ python3 memory_benchmark.py 3m 10$ python3 memory_benchmark.py 2m \n 网络\n师兄的需求是需要公网压力测试, 查找了很多资料, 大多数工具都是测网速的, 而不是可以指定上下行速率进行测试. 幸运的是, 找了几天之后, 终于找到一个工具iperf可以勉强完成任务.\n 基本思路\n一台机器作为服务器, 另一台机器作为客户端, 客户端向服务器发包, 服务器接受, 连接使用UDP连接. 这也就是说, 如果没有服务器的话, 客户端仍然可以对网络上行进行压力测试; 但没有客户端, 服务器则没法对网络下行进行压力测试. 简单地说, 服务器(下行)是被动的, 客户端(上行)是主动的, 没人收包仍然可以狂发包, 但没人发包, 无论如何是收不到包的.\n 安装\n$ sudo apt-get install iperf\n 使用方法\n 服务器\n启动服务器\n$ iperf -s\n 客户端\n$ iperf -c 服务器ip -b 压力值$ # 比如:$ iperf -c 123.206.61.77 -b 11m\n 参考\nLinux下如何监控网络\nLinux网络测试和监控\n[Linux] 局域网中测试网速\n","categories":["Laboratory"],"tags":["benchmark"]},{"title":"论推荐系统如何改造和奴役你的思维","url":"/2018/07/03/recommender-systems-of-popular-apps/","content":"应园子的邀请，我撰写了一篇关于现今流行的内容app的推荐系统的研究与讨论的文章。\n事情的起因是这样：\n园子同学是知乎的重度用户，曾经有一段时间每天画在刷知乎的时间超过1个小时，其三观深受知乎的影响。\n我提醒她：\n不是知乎主动改造你的三观；\n而是根据知乎的推荐，你越刷只会加深自己的固有倾向。\n比如，你是一个比较右的人，推荐系统最后推的都是你愿意点进去看的。\n增加用户花在产品上的时间是推荐系统的目标，而不是解决用户的问题￼。这样想想是不是挺可怕的\n这样的推荐系统就会导致，你最后只会看到你自己想看的东西。\n\n园子顿时对推荐系统产生了浓厚的兴趣，并“报复”我：\n要不我给你布置个任务吧：正好你最近在研究推荐系统，要不你查查资料，看看目前各大内容APP的推荐系统都是怎么做的，有哪些思路，整理成一篇文章怎么样￼￼\n\n\n促使我整理2个月来的实习经验，以及查阅大量公开的资料。\n最后总结成为这篇对各大内容APP的推荐系统的研究文章。\n本文的目标群众是每天与推荐系统打交道（使用各大内容APP）但又对推荐系统一无所知的同学。\n首先，根据app下载量和对园子的影响力，我认为各大内容APP有：\n\n知乎\n网易云音乐\n快手\n淘宝\n\n本文还用了很多来自：Netflix, Amazon, Google News, Facebook 这些国外大厂的例子对推荐系统加以说明，因为这些app虽然国内的同学不熟悉，但在推荐系统业内属于引领者。\n 推荐系统的2大类\n 基于内容的过滤\n此种过滤只依赖于item的数据。\n在一个推荐系统中，被推荐和消费的就是item。如：在今日头条这样的新闻客户端中，一条新闻就是一个item，知乎 -&gt; 一个回答, 网易云音乐 -&gt; 一首歌，快手 -&gt; 一个短视频，淘宝 -&gt; 一个商品。\n根据用户填的问卷信息（针对新用户。一般新用户进入一个应用时，都会选择一些自己的兴趣），或者根据用户的评分（针对老用户。老用户会产生很多评分，或其他action，体现出其兴趣），我们发现他对民谣感兴趣，我们就继续给他推荐其它他未消费过的民谣类歌曲。\n这里的民谣只是一个tag，表示歌曲的类型，除此之外可能还有歌手名等tag可以利用。\n 协同过滤\n此种过滤依赖于其他用户的数据。\n协同过滤基于这样的假设：与你类似的用户喜欢的东西，可能你也会喜欢。\n这就跟你朋友推荐给你的东西与一个陌生人推荐给你的东西相比，更可能符合你的胃口。因为你的朋友在一定程度上是与你相像的，拥有一些共同的标签。而且根据心理学的研究，人们也倾向于与与自己更像的人交朋友。\n协同过滤的原理简而言之就是，找到一群和你相像的用户，把他们喜欢或消费过的item推荐给你。\n“相像”的定义有许多，一般会综合考虑用户的基础信息和行为信息。\n比如：\n如果你的基础信息中有“年龄24岁，女人”，Netflix会把24岁的女人看的多的片子也推给你。\n行为信息在Amazon上的体现就是：“你买了A，大部分买了A的用户，同样也买了B，你要不要买B”。\n在拥有大量用户的情况下，协同过滤的效果是要好于基于内容过滤的。\n其原因可以归咎为：用户自己也不能很确切地定义自己喜欢什么，然而身体是诚实的。这也说成是大数据会比你更了解你。\n而且在协同过滤的帮助下，app在你的调教下会越用越好用，越用越舒心，你花在其上的时间也越来越多。\n这对老用户的粘性是非常强的。不过反过来说，当你一段时间不使用该app后，你会发现其推荐的内容就不像之前那样符合你的口味了。\n当然基于内容的过滤也是很有用。尤其是当一个新用户刚刚登录，还未产生很多动作和基础信息来找到和他相像的人的时候。\n吸引新用户是十分重要的，特别是在一个app快速成长的时期。\n相对应的，业内会有1日留存率，3日留存率，7日留存率还表示推荐系统对新用户的吸引程度。\n 各大内容app使用的推荐系统\n各个厂用的主要推荐算法基本都属于协同过滤的那一大类，由于应用场景的不尽相同（新闻、商品、音乐、电影），使用的算法也不一样。\n为了实现冷启动（新用户刚使用时获得比较好的推荐效果），各个厂也会使用基于内容的过滤和基于规则的推荐。\n由于推荐系统都是基于内容的公司的核心竞争力，完全公开的是没有的。\n而且据一位业界专家所说，每个厂使用的推荐算法基本相同，都是公开的那些；不一样的只是参数、数据和规则；最后推荐的结果也趋于一致。\n我们只能在不同的应用场景下进行一些猜测，比如，在内容为音乐的网易云音乐会使用什么样的推荐算法。\n 知乎\n知乎的内容以文字为主，现在还加入了很多视频的内容。\n作为一个“高素质”人群的问答社区，知乎问题的分类和描述都比较清晰，这有利于更好的推荐。\n分析知乎在推荐页给我的推荐内容，知乎的推荐以回答为主，之外还有少量的live和广告。\n由于我对live了解不多，这里主要猜测一下“回答”的推荐过程。\n最开始知乎的首页是 推荐 和 关注 放在一起的，现在分开了，又加了热门这一页面。\n通过推荐页的提示“关注话题获取精准内容推荐”，可以看出，推荐页的内容主要依据的是你关注的话题。这相当于是基于内容过滤的场景。\n从结果来看，向我推荐的回答大多是我显式选择的关注话题或者是于此相关的话题（如下图2所示：话题之间有父子、相关等关系），\n\n\n 网易云音乐\n网易云音乐的推荐可以分为3个板块：私人FM，每日推荐，推荐歌单。\n\n私人FM有3个主要操作：\n\n喜欢\n删除\n跳过\n\n除此之外还有一些其他的隐式操作，如 完整听完一首歌曲，调节进度条，看评论时长等可以利用。\n我们可以将这些行为分为2大类：喜欢和不喜欢。\n根据程度不同，可以赋给不同操作不同的喜欢值。\n如显式地点击喜欢和完整地听完这首歌都代表喜欢，不过前者更强一点，可以赋给更高的喜欢值。\n用户对播放的歌曲产生的所有操作最后求和可以得到用户对这首歌的喜欢程度。\n用户在听过一段时间私人FM之后，会产生一系列的操作。\n我们就可以得到用户听过的所有的歌曲的喜欢程度。\n利用这些信息，再通过协同过滤的一些经典算法，就可以向用户推荐他没有听过的歌曲了。\n所以说，私人FM听的越多，推荐效果会越好。\n每日推荐一般会与你最近听过的歌曲有关。也就是说，歌曲的兴趣对今天推荐的影响随时间衰减比较快。\n比如，你昨天听了电音，比较喜欢，接连听了几首，可能还“喜欢”了一些。今天的每日推荐就会推更多的电音给你。\n推荐歌单算是比较容易推荐的一个板块。因为歌单都是专家或是爱好者组建的，将很多歌曲按照某一标准归为一类。每个歌单还都有自己的标签可以利用。如摇滚、英伦、另类、独立。这些标签都是区分性很强的。\n在向我推荐的歌单里，一般包含几首我“喜爱”的歌曲。由此可见，推荐歌单使用了“我喜欢的音乐”中的信息。如果几首你喜欢的音乐同时出现在一个歌单中，那么很大程度上可以预测，这个歌单中的其他音乐也会被你喜欢。\n 快手\n快手作为一个短视频平台，每天用户会产生大量的视频。视频相对而言是不那么好推荐的，因为\n\n视频内的语义现在用机器理解还是很困难的\n被推荐的内容几乎都是冷启动的，也就是说要争取推荐最新上传的视频\n\n在这种情况下，快手可能使用了标签这一信息作为推荐的主要依据。\n用户上传的视频可以被用户自己打上各种标签：社会摇，炫技，教程，小吃等。\n依靠这些标签把用户和视频聚成不同的类。这样新上传的视频就可以利用用户在老视频上产生的操作了。\n 淘宝\n淘宝作为一个c2c的电商平台，推荐系统的指标与其他b2c电商（如 亚马逊）有所不同。\n评价一个推荐系统好坏的指标中有一个是对冷门产品的发掘能力，即对长尾的尾端进行推荐。\n使用推荐系统将冷门产品的商家和顾客联系起来是淘宝的一个卖点，因为淘宝上的商品实在太多了。没有你买不到，只有你想不到。\n根据亚马逊公开的一些信息，电商系统的推荐系统核心可以用一句话概括：买了商品A的人，同样也买了B，你买B呀？\n 为什么说推荐系统在改造和奴役你的思维\n对于一个内容app的推荐系统来说，推荐好不好的指标最后都会反应在用户停留在该app上的时间。\n在互联网上网人数趋于饱和的情况下，整个市场用户时间数不会像之前那样快速增长，如何抢夺用户宝贵的时间就成个各个内容推荐系统的目标。\n为了让你停留在本应用的时间增加，各大内容app可谓用心良苦。\n如知乎现在移动端网站会向app内导流。之前即使用户不登陆、在移动端网页上也可以享受到所有的信息。\n现在在移动端网页上只能看到一个回答的开始部分，想要浏览完整部分就不许下载并进入知乎的app才可以。\n很大程度上降低了用户体验。比如我的朋友经常会分享一些知乎上的回答或问题给我，我必须点击多次用app打开才能看到完整信息，很是不爽。\n今日头条之前也因为三俗内容被政府多次约谈。就是因为相比其他的新闻，低俗、色情的东西更容易吸引网民们的眼球。\n就像本文最开始谈到的那样，推荐系统为了增加用户停留的时间。只会一味地迎合用户的喜好，无论用户的喜好是否正确。\n整个过程就是一个正反馈。你思想比较右，推荐系统会推符合你口味的内容，加深你的兴趣。\n对一个成年人来说，还有甄别内容和选择平台的能力。\n对于广大的未成年人，无疑会是一种误导。再加上现在互联网内容的监管并不是很完善。为了利益，推荐系统推给未成年人的不会是正能量，只会是娱乐导向、甚至低俗的内容。这对未成年人的思想塑造会有很不好的影响。\n其实很多成年人又成熟多少呢？想想你被推荐的内容，想想你花在这些内容app上的时间。\n在此引用一句古话：“良药苦口利于病，忠言逆耳利于行”。然而作为推荐系统，只会给你说好听的，你喜欢听的。\n在潜移默化之中，你的思想已经被推荐系统所改造和奴役了。\n依赖于推荐系统的内容也是一种懒惰的表现。相比 主动去获取信息，直接接受推荐系统的内容 要容易、愉快的多。但要记住，懒惰是有代价的，你的思想将不可避免地变得狭隘。\n 如何避免推荐系统的恶果\n 多读书\n无论知乎给你怎样的错觉，书本上的内容在质量上还是高的多。\n我最近读了一本斌卡的《一平米健身》，相比知乎上的健身类回答，内容的质量要高的多。\n毕竟相比在网络上写个回答来说，出书的门槛和花费的精力要多的多。\n尤其是，书本上还承载着互联网之前人们的原创思想。这是知乎上所没有的。当然，经过不断搬运，许多&quot;知乎er&quot;把书本上的知识运用在回答中。不过这些都是经过加工和断章取义的，也有不少从某本书上搬一段话就获得高赞的案例。\n 与优秀的人交朋友\n与优秀的人交朋友，聊天，比起把时间花在追随大v的言论要有用的多。\n我总认为，一个人在互联网上呈现给你的是他想给你看的部分，不完全。\n相比之下，虽然面对面的交流也通常是会掩盖本性的，但这种信息交互是双向的，而非通过follow关系的单向信息输出。\n而且，不知道大家有没有这样的感觉。与优秀的人交流时，自己会花更多的精力去思考，而非听完就完事儿了。在知乎这些平台上，看完之后的热度保持的并不长久。\n 接触不同的内容，才能够塑造一个完整的三观\n不要只看自己喜欢的，也要听取不同的声音。党同伐异是人类的天性。如果你不刻意去避免这一人性上的缺点的话，推荐系统会像一个谄媚的奸臣一样，只说你想听的，而你可能就会想历史上的昏君一样，荒废了朝政。广开言路，逆耳忠言才是明君应有的表现。\n比方说，当你听到与你不同的言论，不要先想着反驳对方，试着想想为什么对方会这样想？\n每个人的想法都是其经历和体验的体现，没有相应的经历，很难会理解一些不一样的事情。这个时候不要着急去反驳对方，而是试着丰富自己的阅历。\n之前说的2条“多读书、与优秀的人交朋友”都是丰富自己阅历的高效途径。\n 后记\n希望大家作为一个成年人，拥有一个独立的三观，不要被推荐系统和自己的懒惰而奴役。\n","tags":["tech"]},{"title":"recursion","url":"/2019/02/11/recursion/","content":"本文根据LeetCode上的教程 Introduction to Algorithms - Recursion I 整理而成。目的在于帮助笔者自己更熟悉“递归”这一重要的编程概念，如果能够同时对他人产生帮助，那更好不过了。\n本文的结构和LeetCode上的完全相同，分为 简介、递归原则、复现关系、备忘录、复杂度分析、总结 6个部分。\n 简介\n本Card的目的，回答以下问题：\n\n什么是递归？递归如何工作？\n如何递归地解决一个问题？\n如何分析一个递归算法的时间复杂度和空间复杂度？\n如何以一种更好的方式应用递归？\n\n 递归的原理\n每次递归函数调用自身，都将给定问题变为子问题。递归过程一直继续指导子问题可以不通过进一步递归就可以直接解决。\n递归函数避免无限递归的必要属性：\n\n递归结束条件(base cases)\n一套规则(recurrence relation)，可以将所有其他的cases规约为base cases。\n\n递归函数中可以有多个地方调用本身。\n 例子 翻转字符串\nvoid printReverse(const char *str) &#123;    if (!*str) return;  // base case    printReverse(str + 1);    putchar(*str);&#125;\n 递归函数\n如果一个问题存在递归解法，我们就可以遵循下列步骤去实现它。\n我们定义该问题为函数F(x)可以实现，其中X是函数的输入，同时表示了问题的范围。\n在函数F(X)中，我们实现以下步骤：\n\n将问题拆分成更小的范围，x_1 \\belong X, x_2 \\belong X, ..., x_n \\belong X.\n递归调用函数F(x_1), F(x_2), ..., F(x_n)以解决X的子问题。\n最后，处理子问题的解，组合成对应X的解。\n\n Recurrence Relation\n定义：一个问题的解和其子问题的解之间的关系。\n 例子：Pascal’s Triangle\n定义：杨辉三角是一系列数字组成三角形的形状。在杨辉三角中，每行最左和最右的数字永远是1. 对于剩余的数字，每个数字是它前一行正上方2个数字之和。\n用数学公式表达出来就是，Recurrence Relation为\nf(i,j)=f(i−1,j−1)+f(i−1,j),f(i, j) = f(i-1, j-1) + f(i-1, j),f(i,j)=f(i−1,j−1)+f(i−1,j),\nbase cases为：\nf(i,j)=1,ifj=1orj=if(i, j) = 1, if j = 1 or j = if(i,j)=1,ifj=1orj=i.\n其中，f(i,j)f(i, j)f(i,j)表示第i行第j个数。\n Memoization 备忘录\n 递归过程中重复的计算\n递归解法常常是十分符合直觉和容易编码的。但大多数时候，在递归过程中，重复计算导致了性能上的损失。\n备忘录法(Memoization)\n即是一个通用的避免重复计算的技术。\n是的，这个词没有拼错，不是Memorization。\n定义：为了避免重复计算，我们可以在一个cache中存储中间子问题的结果，以便之后再次使用它们的时候不需要重复计算。\n备忘录的实现可以通过hashmap实现。尤其是在OOP中，利用装饰器可以实现通用的Memoization。\n 例子 斐波那契数\n斐波那契数的多种解法，其中有时间复杂度为O(log n)的Binets法和公式法，令人印象十分深刻.\n Complexity Analysis 复杂度分析\n递归算法的复杂度有时候不是显而易见的，要通过一些套路分析。\n尾递归是一种特殊的技术，可以消减递归栈的使用，优化空间复杂度，使其和迭代算法相同。\n Time Complexity 时间复杂度\n递归算法的时间复杂度为：\nO(T) = R * O(s),\n其中，R为递归调用的数量，O(s)为每次递归调用产生的计算复杂度。\n一般来说，R更难算一点，O(s)的计算和非递归算法的时间复杂度分析一样。\n借助execution tree的技术，我们可以更好地分析递归调用的数量。\nexecution tree是展示具体情况下递归调用流的一棵树，每个节点代表一次调用，节点上的值表示调用时的参数。\n这棵树的节点数目就是R。\n需要特别注意的是，当使用Memoization技术时，execution tree的变化。\n Space Complexity 空间复杂度\n递归算法的空间使用主要分为2部分：\n\nrecursion related\nnon-recursion related\n\n recursion related\n学过编译原理的我们都知道，每次函数调用都要在栈上压入：\n\n函数的返回地址\n函数参数\n函数的本地变量\n\n递归算法的函数调用栈的深度是从初始case到base case.\n non-recursion related\n全局变量使用的空间，主要在堆上分配。比如，memoization 要使用的hashmap。\n Tail Recursion 尾递归\n尾递归是一种递归调用是递归函数的最后指令，而且函数中只有一个递归调用。\n尾递归的一个很好的例子。注意，non_tail_recursion在最后的递归调用后还有计算。\npublic class Main &#123;      private static int helper_non_tail_recursion(int start, int [] ls) &#123;    if (start &gt;= ls.length) &#123;      return 0;    &#125;    // not a tail recursion because it does some computation after the recursive call returned.    return ls[start] + helper_non_tail_recursion(start+1, ls);  &#125;  public static int sum_non_tail_recursion(int [] ls) &#123;    if (ls == null || ls.length == 0) &#123;      return 0;    &#125;    return helper_non_tail_recursion(0, ls);  &#125;  //---------------------------------------------  private static int helper_tail_recursion(int start, int [] ls, int acc) &#123;    if (start &gt;= ls.length) &#123;      return acc;    &#125;    // this is a tail recursion because the final instruction is the recursive call.    return helper_tail_recursion(start+1, ls, acc+ls[start]);  &#125;      public static int sum_tail_recursion(int [] ls) &#123;    if (ls == null || ls.length == 0) &#123;      return 0;    &#125;    return helper_tail_recursion(0, ls, 0);  &#125;&#125;\n尾递归消除递归栈的原理：\n编译器知道在从callee中返回之后，会立刻再次返回，不需要再利用函数调用栈中保存的数据。只需要一个栈帧就可以了，所有层共用一个栈帧，所以返回时可以跳过整个递归栈。\n并不是所有语言的编译器都支持尾递归优化的。比如，C, C++支持，而Python, Java不支持。\n尾递归通常也不是那么好实现。需要\n递归调用只出现在最后一个指令，如果需要调用多个函数，或是对返回值进行计算，就没法尾递归了。\n而且细心的同学可以发现尾递归和迭代(loop)的相似之处。事实上，有些函数式编程语言甚至不支持loop，只有递归，完全可以实现迭代。因为我们平时使用loop居多，尾递归很少。如果需要写尾递归时（一般是在一些面试的要求中），可以先写loop版本的代码。然后试着把其中的局部变量更新改成尾递归中的参数，往往就可以写出优雅的（但对于大多数人可读性并不高）的尾递归代码了。\n 总结\n解决递归问题的套路：\n\n定义递归函数\n写下recurrence relation和base case\n使用Memoization消除重复计算，如果存在的话\n如果可能的话，使用尾递归实现递归算法，以消减空间复杂度\n\n","categories":["Programming"],"tags":["Algorithm","LeetCode"]},{"title":"深痛悼念 左耳朵耗子","url":"/2023/05/15/rip-hao/","content":"R.I.P.\n有幸和 左耳朵耗子 在同一个群里刷题。大家得知消息以为是谣言，还at了他。但多方消息佐证，现在应该是真的了。\n\n我最早也是通过他的博客 酷壳 – COOLSHELL认识他的，好像是VIM系列吧。当时我还在上大学，刚刚开始计算机学习。他的博客对我帮助很大。\n\n我最接近猝死的是 大三上学期，做 编译 实验到早上6点。当时感觉不行了，心脏不太舒服。就回宿舍睡觉了。从那以后就躺平了，不卷了，不再追求上进了。读研的时候，我们学院有个大二的学第就在图书馆猝死了，是做 计组实验 做的。我也是经历过计组的人，想想也确实是压力太大了。工作后，更是每年国内计算机行业都有猝死的新闻。\n最后，再给从事程序员的同行们介绍一个Github repo: 程序员延寿指南 geekan/HowToLiveLonger. 活着真好，好好珍惜。\n\n","categories":["Life"],"tags":["RIP"]},{"title":"商汤见习计算机视觉实习生","url":"/2018/12/09/sensetime-intern-interview/","content":"上周给在商汤实习的同学发了简历，和HR约了本周四的面试，周五就又接到HR的电话，商议Offer的事宜。不得不说，商汤招聘的效率还是很高的。这也从另一个侧面反应出，其十分缺人手的事实。很多商汤的同学都在询问我，有没有其他的同学可以推荐过来实习。\n商汤校友被誉为“北航实验室”。因为其招聘了大量的北航实习生，正式员工很多也是实习生直接转正的，本科的时候，就有几乎一个班都在那里实习。\n而我面试的时候，推我的是我的一个一直在那里实习的同学，一面的面试官是我大三编译实验课的助教，二三面的面试官也都是我的本科同学。可以说，如果你是北航的学生，那么进入商汤会比其他学校容易很多。\n我面的组是&quot;商汤研究院基础技术与工具组“，算是在研究院里偏工程的组了。总体的面试过程还是很硬核，很高能的。好几次我都以为自己不行了，好在面试官及时给出一些hint，帮助我走下去。下面，我记录一下3个面试的流程。\n 一面\n一面面试官是此组的lead，今年刚刚毕业转正。我一直觉得他很眼熟，后来和同学交流过后才想起来，这不是2年前检查我编译实验的助教哥哥嘛！\n因为是lead给自己招人，所以一面总体上节奏很紧，内容也很充实。依次问了我职业规划、项目经历和2道算法题。\n职业规划主要是与将来实习工作内容相关，从超级硬核的嵌入式和操作系统，到优化深度学习框架和库，再到优化计算机视觉的策略和算法。\n项目经历主要问了我的2次实习和毕业设计，并问了我对之前的哪部分工作和实习最感兴趣。我当然把之前的实习都表扬了一边，然后再比较出自己对快手的实习最喜欢了。从和面试官的问答过程中我感受到，他对面试者是否真的想做某件工作、是否\b对其感兴趣很看重。\n算法题有2道：\n\n给出一个01串，给出0和1数目相等的最长子串的长度。比如’00100110011’的最长字串的长度为10.\n有1-n个路灯，\b对其进行n次操作，第i次操作为将编号是i的\b倍数的路灯状态取反。初始状态为都灭，问对于给定的\bn，最后有几盏灯是亮的。\n\n都不算很难的题目，虽然没能一下子解决，但最后都在面试官的hint下成功解决了。表现的不算太好，也不算很差。想解法的时候一度感觉自己要凉了，要丢人了。好在问题本身不是很难，经过更多的思考和尝试还是解答出来了。只有第一道题要求手写代码了，我用Python很快写完了。我用二维列表实现的桶，面试官指出，用Map难道不是更优雅吗？第二题\b解法过于简单，没必要写代码。\n经验\b总结就是，虽然我代码能力还行，LeetCode也刷了有100道Easy难度的题目，但并没有形成自己的一套解题的流程，也没有对于每一类问题的归纳总结，可以快速地找出合适的\b算法。\n更多的是依靠灵感和尝试。比如第一道题，我最开始一筹莫展，但再尝试几次后，偶然想到可以\b先把前缀和计算出来(遇0减一，遇1加一)，之后就迎刃而解了。和LeetCode上一些字符串比较的问题很像。\n这种依靠灵感和尝试的解决方案，首先不是每次都奏效，如果状态不好，可能就不行了；其次是不靠谱，做题的时候心里没谱，对于题目能不能成功解决心惊胆战的。\n所以，\b在面对未来更多的面试和dream job之前，形成自己稳定可靠的解题流程是必要的。\n 二面\n二面的面试官是我的本科同学，但平时交流并不多，他属于比较geek的类型。\n这位同学刚开始比较不善言辞，问我一面都面了什么，会写什么。我判断他作为面试官的经历其实也不多，并不擅长。稍稍有些放松和欣喜。\n不过很快，他真的是用技术教我重新做人了。慢慢熟悉起来之后，他也进入了面试的状态。从操作系统(从shell敲入命令到程序被执行中间发生了什么，进程的建立过程)问到编译器(编译的过程，每一步的细节)，从编译优化(循环展开)问到CPython的实现(全局变量的处理，Python是如何运行的)，看到我用过Django，又问我框架的实现，model的实现。问我哪门语言比较熟，我说Python，就问了我很多Python实现的问题。问我看过什么Python的大型项目的代码吗？我只好汗颜地说没有。\n整场面试除了刚开始几分钟比较轻松外，后面的节奏越来越快。每个问题都是越来越深入，直到我实在回答不上来为止。\n应对这种类型的面试，我只能说，CSAPP和SICP的真的很重要。虽然我都只看了几章，但硬是凭着不深的记忆硬扯。比如Python的运行过程，我之前根本没有了解过。刚开始只说是解释运行，对方要求更详细些，从开始到运行完毕的过程是怎样的？我想Lisp也是解释语言，就把老早之前在SICP上看过的Lisp运行过程说了下。面试后我查了查Python的运行过程，惊喜地发现真的差不多。CSAPP对编译和进程有很深入的介绍，如果对这2章更熟一点，我面试时一定会更从容。没有读过大型项目的源码也是我的短板。说实话，真的没有多少人读过很多大型项目的源码。但是我们是要向大牛看齐的，多读读源码，才能成为更优秀的程序员。\n 三面\n三面的面试官也是我的本科同学，稍微还熟悉些。最后一面由不同组的同学负责，被称为跨组面试。防止有组内私自招收不合格员工的情况发生。\n既然比较熟，面试过程就比较轻松了。先是依次问了项目经历，之后又问了1道语言题和一道算法题。\n语言题涉及到Python的闭包，\n就是理解\n[lambda x: x + i for i in range(4)]\n和\ndef func1(i):    return lambda x: x + i[func1(i) for i in range(4)]\n的区别。\n不知道多少年前看过廖雪峰Python的教程上闭包相关的内容，只有些许印象，平时也不用。只记得变量i有时会变化，产生意料之外的结果，比如前者。好在在面试官的hint下有惊无险。\n算法题是关于DP的，\n给定n &lt;= 20, a_i &lt; 100, 整数s，求解有多少种\b正负号的填法使得等式成立$$ \\sum_i^{n} \\pm a_i = s $$\n我给出解法后，\b面试官又问，构造表的时候s为负数时怎么办？\n 后记 | 感悟\n有一个清晰的职业规划和技能方向是十分重要的。平时和师兄聊天的时候可以说自己也不知道做啥，不知道对啥最感兴趣。但面试时这样说肯定就gg了，最好最自己有比较清晰的认识，知道自己的兴趣，职业规划，当然这些和面试职位的需求相符那就更好了。如果不相符的话，大概率也会gg，搞不好还会被喷（参考我5月时面试face++的面试经历，在我的博客上可以找到https://youngforest.github.io/2018/08/14/face-interview/）。\n今年算法岗大火，以至于供过于求。算法岗也处于程序员鄙视链的上游，薪水也比研发岗高一些。\n但我结合自己的经历和体验，发现自己还是对写代码比较感兴趣，写出更优雅，performance更高的代码，满足用户的需求，产生impact。我就很开心和满足了。虽然做程序员很辛苦，但是我很开心。没必要追求别人认为好的职业(鄙视链大概是：研究员 &gt; 算法岗 &gt; 研发岗 &gt; 其他)。\n我以后也会顺着研发这个方向规划自己的职业，学习必要技能的。\n我曾经给好友说过，“我想写一辈子代码”。现在仍然是这样，而且更加坚定了。\n","categories":["interview"],"tags":["intern","sensetime"]},{"title":"山东游记","url":"/2018/09/14/shandong-trip/","content":"8月21号 至 8月28号，带着自我放逐的心情，我去山东玩了7天。小时候（2008年）曾跟着爸爸和旅行团来过山东旅游，经典的旅游城市，包括青岛、烟台、威海 和 隔海相望的大连，都逛了一圈。当时年纪尚小，天真烂漫，只觉得不用上学，来到陌生的地方旅游，十分有趣。如今十年过去了，同样的景点，却有不一样的心情和感受。\n此次旅行是临时决定的。之前同学叫着去重庆做毕业旅行，我由于种种原因没去成。8月中旬后，经历了情感上的波折和三毛流浪文学的洗脑，恰好有山东的同学(我们可以称之为“女声男”，因为其声音特别有雌性)邀请我去山东一起玩。我便答应了。希望通过此次旅行让心情好过一点，让匆忙的旅行占据自己的大脑，不去想不该想的苦恼。\n\n办完了学校的事情，买了21号晚上的硬座票，踏上6个小时去济南的火车。到达济南后，我在火车站对面的一家“潼关肉夹馍”，补充了些能量；更重要的是给手机充了电。因为前半年摔了几次手机，可能是什么硬件坏掉了，手机掉电比较快，不像之前可以一撑撑一天。这家店再次证明了：火车站周边的饭店果然味道很差。之后赶往济南汽车站，坐上去 莱芜 的流水车。跟随女声男的指示，我在张家洼下了车。他来接我的时候，手机只有1%的电量了。由于舟车劳顿，我先在女声男的卧室里睡了一觉。中午一起吃他妈妈做的饭。饭菜味道很一般，但还算丰盛。下午去市区，逛了超市，看了场电影《快把我哥带走》。莱芜确实是个生活很方便的地方。路上车也不多，各种基础设施和娱乐场所都很多。晚上，在张家洼吃火锅。之后女声男开车，载着我和他妈前往北边的雪野湖，看水、散步。去的过程中，我的膀胱爆炸。我们直接在路边停车，解决了膀胱的压力。回到家里，我们又和色长、涂导开了2局农药，才睡觉。\n行程的第二天。我们按照计划去泰山玩。从莱芜坐流水车到泰安，然后换乘公交到泰山脚下。公交车还坐反了方向，坐了一站下车后。我指着身后的山说：咱们傻逼了，应该冲着山的方向走。从11点开始爬山，花了近5个小时终于登顶。开始登山的时候还发生了一件有趣的事情。女声男打算买个自拍杆，拍照更方便些。买下后才发现，我的米6没有3.5mm的耳机孔，他的Max屏幕太大，装不上。好说歹说，店家才给我们退了。作为五岳之首，泰山吸引了全国各地的游客前来，登泰山的游客很多。海拔1532.7米，孔子讲“登东山而小鲁，登泰山而小天下”。登上山顶，眺望山下，才发现，登泰山只能小泰安。后来想想，地球是圆的，登珠穆朗玛峰都不可能小天下。泰山景区的建设也完善。全程都是很宽的台阶，说是登山，其实全称都在爬台阶。每隔一段就有个休息点，一般有食物和水，还有各种纪念品。下山按照计划，乘坐缆车到山腰的中天门，再坐中巴到山下。缆车真是排队半小时，下山5分钟。之后坐拼车回莱芜，准备明早去烟台莱州看海，顺便找另一个同学玩。值得说的一点是，山东不愧是经济发达的东部省份，生活各种方便。乘车、买门票、坐缆车都可以使用移动支付。当然，出门玩还是需要带现金的。比如坐中巴就只能用现金。\n\n行程的第三天。由于没买到去莱州的汽车票，我们临时改变行程，去了旅游城市 青岛。开始了青岛3日游。青岛不愧是旅游城市，各种吃喝玩乐和景点建设的十分齐全。在这里，我真正体会到旅游的热情。第一天，体验了青岛的公交、参观了啤酒博物馆、在海滨第一浴场游了泳。青岛的公交车司机素质比北京不知道高到哪里去，对乘客和游客很友善。北京的司机师傅可能是平时压力比较大吧，总是没有好脸色给乘客。啤酒博物馆里，我们参观了青岛啤酒的历史和生产线。品尝了正宗的“原浆”和“纯生”青岛啤酒。下午在海滨第一浴场游泳。好在不是周末，人虽多，但还没有到下饺子的盛况。脚踩在细软的沙滩上，沐浴着和睦的阳光；沉浸在被阳光晒得十分暖和的海水中，享受海浪的冲击和海风的吹拂…美滋滋。当然也品尝到不少海水的苦涩。\n\n\n青岛的第二天。\n一大早，去八大处风景区，见识了权贵住的别墅，在公主楼前徘徊了半天。然后去旁边的海边赶海。所谓赶海就是，趁着落潮的时候，在充满礁石的海边捡各种海鲜。由于技艺不精、工具不全和时候比较晚，自然收获不多。甚至还在海里摔了一跤。这里还遇到了在岩石上照婚纱照的情侣，和照全家福的青岛人。不得不说，这里风景真心不错。大海、蓝天、城市、市民，形成一幅和谐的画面。\n然后打车去了 海军博物馆，参观了“坚船利炮”。核潜艇由于人太多，没有上去“开”。\n沿着海岸线，我们出发去“监狱”。路上随便找了个店，吃了些饺子。德国监狱 更多的是爱国主义教育。宣传日占时期，日本法西斯的暴行。有趣的是，在买票的时候，售票员由于和我们聊天，还被其他游客diss了。售票员检查我们的学生证，发现已经毕业一个月了，但看到是“北京航空航天大学”，说是她女儿想上这所学校，开飞机。问了问分数线的情况。我们一个山西考生，一个上海考生，自然不知道山东(高考大省)的情况。而且我航也不是培养开飞机人才的呀！所以就瞎说一通，混了个半价门票。\n参观完监狱后，我们沿着海边一直走，来到了栈桥。这个地方我依稀有些印象，10年前也曾经来过。不过如今已经物是人非，我也不是曾经的我了。女声男嫌桥上人太多，就没有上去。我一个人转了20分钟，在桥头伫立了一会儿，看着大海和远方的城市、山丘，陷入了对往日的沉思。在栈桥上，可以看到上午参观过的海军博物馆。我们相当于一直在沿着海岸线走。\n晚上我们又来到栈桥，坐在桥头的石头上，享受着海风尽情地吹拂。在海边吹风时，看到明月当空，还是会想起她。\n我们还在中山街逛了一遍，吃了小吃，参观了各种礼品店。小小破费一晚。\n\n\n\n青岛的第三天。\n参观了酒店附近的天主教堂、劈材院、建设银行旧址。我们的酒店就在老城区，离中山街、栈桥都特别近。\n进入天主教堂时，里面的主教在宣扬天主教认同的夫妻关系，我们还见证了6个教徒入教。人民生活在苦难中，向宗教寻求慰藉。\n劈材院是一个小吃街。由于我们是上午去的，没什么人，店铺也开的不多。\n然后坐公交去汽车站，乘大巴回莱芜。\n回到莱芜又在张家洼村的院子里吃了露天的烧烤。\n\n\n行程第六天–济南。\n由于女声男感冒了（另一个原因是太宅了），我只好一个人去济南玩。\n坐汽车到济南，直奔提前订好的青旅(济南滨湖青年旅舍)。这是我第一次独自住青旅，也是第一次在国内住青旅。这家青旅的优点在于位置好，紧邻大明湖畔。一个10人间的混住房间，但只有我和一个大叔住。大叔是个有趣的人。他来济南的目的是躲避花粉。他工作在辽宁。每年入秋会南下，避免过敏。今年去过北京和石家庄，最后来到济南，感觉这里空气不错，就找了家青旅（相对酒店便宜的多），打算住上十几天。我下午出去玩的时候，他在床上躺着，晚上10点回来的时候，还在床上躺着。第二天早上我出去玩的时候，他还躺着。中午我回来退宿和他道别时，他还躺着。不是在睡觉，就是在玩手机。\n济南的景点比较有限，也比较集中。由于交通更方便的原因，我第一天下午和晚上逛了 大明湖、五龙潭、趵突泉、泉城广场、芙蓉街。晚饭在芙蓉街吃小吃，吃到撑。济南作为泉城，水真多。我甚至看到马路边上的井盖都在咕咕地向外冒水(而女生男听说了，分析说更可能是城市排水系统出了问题)。慕名而去的趵突泉，其实一般，只有3股大泉咕咕的往外冒，早已不复当年盛况。据说曾今还停过水，近年来政府治理地下水位，才重新复涌。\n\n\n\n行程第七天–千佛山。\n济南必去的地方有3个：大明湖、跑突泉、千佛山。千佛山在城市的南郊，所以我安排在了第二天上午。千佛山不算高，也不难爬。我一个半小时上去，一个小时下来，在山顶休息了半小时。登上千佛山，可以俯瞰整个济南。千佛山上还有很多佛教和道教的庙宇、雕塑。我不是很懂，大多数景点也只是走马观花而过。\n回青旅的路上吃了济南名吃–把子肉。确实挺好吃的，肥而不腻。我点了一片肉，一碗米饭，就这样吃了。\n济南到临汾只有一辆直达车，全程5个小时多，向北途径石家庄、太原，才向南到达临汾。济南西站远离市区，坐公交坐了一个半小时才到，中间还需要换乘。\n晚上8点抵达临汾西站，结束了7天的旅行。\n\n 后记\n离开富庶的东部强省山东，回到破败的中部弱省山西。没有对比就没有伤害。十年前，不知道父亲过来旅行时，没有被这些感染，产生走出山西的想法吗？如果是那样的话，作为儿子的我，现在一定会过的更好吧。而我还没有见识过足够的地方，自己也不知道将来会待在哪里。起码北京这个城市没有产生让我特别想长期居住在这里的想法。趁年轻，多走一走，多看一看，再做决定吧。\n我在青岛时会想，自己老了(也不一定要十分老，但起码要财务自由)以后，就每一年换一个地方住。租上一年的房子，和自己爱的人一起探索这个地方。体验不同的工作和生活。这样的话，这一生一定会更精彩。\n","categories":["dairy"],"tags":["travel"]},{"title":"C语言分割字符串 - YoungForest","url":"/2016/10/11/slipt-string-by-C/","content":"【摘要】最近在做一道C语言题目的时候需要用到分割字符串，本来想自己手写的，也不会很麻烦，但想到其他语言都有分割字符串的库函数，C语言怎么会没有呢？所以，在网上搜了一搜，果然有这样的函数，还是很好用的，在此总结。 在C语言手册中可以很方便地查到strtok的用法，要注意的一点是，除了首次调用时，第一个参数要传 阅读全文\n"},{"title":"ssh免密登陆服务器","url":"/2018/05/08/ssh-login-remote-server-without-password/","content":"以下命令仅针对Unix-like系统。\nWindows是不需要这样的解决方法的，Windows下很多类Putty工具都可以选择&quot;记住密码&quot;来实现免密登陆。\n我在Mac上没有找到类似记住密码的解决方案，但使用Key事实上是更安全的一种方式。\n\n step1: 生成rsa密钥对\nssh-keygen -t rsa\n step2: 上传rsa公钥到服务器\ncat id_rsa.pub | ssh -p 26757 root@138.128.193.150 &#x27;cat &gt;&gt; .ssh/authorized_keys&#x27;\n step3: 更改权限\nssh -p 26757 root@138.128.193.150 &quot;chmod 700 .ssh; chmod 640 .ssh/authorized_keys&quot;\n step4: success!\nssh -p 26757 root@138.128.193.150\nreference:\nssh-passwordless-login-using-ssh-keygen-in-5-easy-steps\n","categories":["折腾"],"tags":["tech"]},{"title":"个性化sublime","url":"/2017/01/18/sublime-personlize/","content":"[摘要] sublime text3是一款强大的editor, 我从大二下开始正式使用, 经过半年的不断摸索, 将sublime配置成为个性化的editor, 满足了我日常编码的大部分需求.\n 为不同的语言进行不同的配置\n首先, 打开该语言的任意个文件, Sublime Text 3 -&gt; Preferences -&gt; Settings - Syntax Specific进入该语言设置文件, 修改设置文件并保存即可.\n参考: 为不同语言设置不同缩进\n Color Scheme\nsublime text 3 默认的主题是Monokai(dark), 感觉还是挺养眼的, 但缺点是markdown的支持特别差. 我还比较喜欢的另一个主题Solarized(dark)也是这样, 默认提供的Solarized与在vim中的体验相去甚远. 所以我通过Package Contorl安装了Solarized Color Scheme这个主题, 与vim对照如下, 还是比较养眼.\n\n\n","categories":["折腾"],"tags":["sublime"]},{"title":"微软苏州面试","url":"/2018/06/01/suzhou-microsoft-interview/","content":"在@lxc师兄的内推下，我有幸可以前往 苏州微软，面试O365部门的暑期实习生。虽然最后失败了，但从这次失败的经历中，我学习到很多。\n总结在此，为未来的找实习和工作做准备。\n\n 面试环节\n 一面\n\n尾递归，斐波那契（不会）\n合并2个列表\nmakefile 编译顺序确定\nmemcpy的实现方式和安全问题\n\n 用尾递归优化递归斐波那契数列\n斐波那契数列大家应该都很熟悉，高中数学课本上提到的经典递归数列。\n其数学定义为：\nfn={fn−1+fn−2if n&gt;21if n=0,1f_n = \\begin{cases}\nf_{n-1} + f_{n-2} &amp; \\quad \\text{if } n &gt; 2 \\\\\n1 &amp; \\quad \\text{if } n = 0, 1\n\\end{cases}\nfn​={fn−1​+fn−2​1​if n&gt;2if n=0,1​\n根据数学递推式，很容易地可以写出递归版的斐波那契数列：\ndef fibonacci(n):    if n == 0:        return 0    elif n == 1:        return 1    else:        return fibonacci(n-1) + fibonacci(n-2)\n根据函数调用的原理，每次需要递归调用2次本函数，当参数为n时，需要的栈帧的数目为O(2^n)。\n可以利用尾递归来优化这个问题。\n尾递归是尾调用的一种递归调用形式。\n我对尾递归的理解是\n函数式编程中使用函数调用以实现循环的方式。\n所以，首先给出内存占用为O(1)的斐波那契数列循环实现。\ndef fibonacci(n):    if n == 0:        return 0    f_n_sub_1 = 1    f_n_sub_2 = 0    i = n    while i &gt; 1:        f_n_sub_1, f_n_sub_2 = f_n_sub_1 + f_n_sub_2, f_n_sub_1        i -= 1    return f_n_sub_1\n从循环实现可以看出，整个循环实现需要2个变量(f_n_sub_1和f_n_sub_2)来记录中间的结果，\n一个循环变量(i)以控制循环次数(即循环结束条件)。\n将这些变量当作函数的参数即可得到尾递归版本的斐波那契数列实现。\ndef fibonacci(n):    def func(n, ret1, ret2):        if n == 0:            return ret1        else:            return func(n - 1, ret2, ret1 + ret2)    return func(n, 0, 1)\n memcpy的实现方式和安全性问题\n也是一个字节一个字节的复制。不是我想当然的认为一整块一整块的复制，这样会更快。\n回忆计算机组成原理的知识：\nCPU和Memory之间由总线连接，一次（一个时钟周期）只能读取和写入一个字的数据。\n安全性：很不安全。\n回忆操作系统的知识：进程的内存空间映射到物理内存。\n直接一个一个字节从低到高地复制粘贴容易覆盖到其他指针指到的数据（破坏了其他指针的数据）甚至本身的数据。\n比如memcpy一个大小为200字节的指针(地址100)到地址200，会把自己的数据(200-300)的部分先覆盖掉，之后的copy就都是错的。（这是面试官给出的解释，但我后来发现，这点是不一定不成立的。因为之后我查了一些标准库中memcpy的实现，这种情况下可能会采用自后向前复制的方法防止覆盖要复制的数据。\n无保护措施的gcc\n有保护措施\n）\n 面试官指点\n面试时在Notepad里写代码，在纸上写代码，和在白板上写，\n容易程度或方便程度是：\n白板 &gt; 纸 &gt; Notepad\n被告知面试题目后，首先要考虑清楚初始条件和具体要求，不清楚的一定要和面试官问清楚，不要上来就写。\n否则后来发现歧义，再问时就晚了。\n 其他收获\n有时间一定要好好看看SICP，函数式编程的尾递归在其中就有讲。\n面试官估计也读过。\n 二面\n\n求树的最深度\n最大和的链\n可以拐弯的最大和的链\n数组权重最大的重新排序（不会）\n\n 其他收获\n在面试时，ACM选手有天然的优势。\n该面试官本科时，可能玩过ACM，因为他说“数组权重”那道题是他上学时自己出得。\np.s. 面试官说他也毕业不久。\n 三面\n周二去苏州参加完面试后，周五出结果，约了第二周周二的视频面试。\n说实话，视频面试前我还真有点紧张，而且由于学校出了点状况，上午才知道下午有视频面试。\n仓促之前，也没有午睡，休息好。面试之前特别困。\n好在真正到面试时，肾上腺素上升，不困了。\n三面的面试官也很nice。\n听说我熟悉SQL，就出了一道SQL题目给我。\n类似教务管理系统。有3张表：学生（学号，姓名），课程表（课程ID，课程名），选课表（学号，课程ID，成绩）。\n查询每个学生的数学成绩和语文成绩，结果为（姓名，数学成绩，语文成绩）。\n刚开始假设每个学生都选了数学和语文，后来取消了这个假设（考察outer join）。\n 第二道题\n第二道题目考察IEEE的一种round实现。\n首先，列出一些数字，让我观察规律。\n在面试官的引导下，我猜测出来了：四舍六入五看下一位。\n之后使用C语言实现这一ieee_round。\n 结果\nNo Hire.\n\n很遗憾，Lead面试官最后给的是No Hire。他认为你编写代码能力不稳固。你的优点是思考能力很强，缺点是不善于展现和询问，不能从错误中获取新的解决办法，今后需要加强这方面。\n希望你研究生期间继续努力，欢迎再加入苏州微软。\n\nLead面试官的眼光还是蛮准的，给出的建议的是一针见血的。我会继续努力，早日达到微软爸爸的要求的。\n除此之外，一开始说好的报销火车票最后也没给报，经济上还损失了1200￥。\n","categories":["interview"],"tags":["intern","Microsoft"]},{"title":"实现terminal代理","url":"/2016/11/02/terminal-proxy-configuration/","content":" 问题\n作为一名Linuxer，熟练使用终端是一项必备技能，但终端中有时下载安装功能速度很慢，令人崩溃.我自然而然想到了可否加个代理,提高速度。我之前一直用shadowsocks,浏览器使用switchyProxy,实现了初步的科学上网。那么,终端中是否有类似的工具呢？答案是肯定的。通过科学搜索，我成功解决了terminal中的科学上网问题，在此总结一下，希望可以帮到大家。\n\n 准备工具\nshadowsocks, polipo\n shadowsocks\nDownload and Install Client\n Install Command-line Client\npip install shadowsocksapt-get install shadowsocks-libevcpan Net::Shadowsocks\nshadowsocks的配置可以参考这篇文章, 我很久之前配置的,这里就不回忆了(忘得差不多了).\n让我们直接从polipo开始吧.\n polipo\npolipo有多种安装方式,可以使用Python的包管理工具pip直接安装,也可以用各个操作系统的包管理工具安装.我更推荐后者,因为个人认为这样更好管理罢了.这里以Ubuntu为例.\napt-cache search polipoadzapper - proxy advertisement zapper add-onpolipo - lightweight, caching web proxypolipo-dbg - debug package for polipo\n第二个包就是给我们这些小白使用的,安装它\nsudo apt-get install polipo\n安装好之后默认自启的,\n我们要先修改它的配置文件(/etc/polipo/config):\nlogSyslog = truelogFile = /var/log/polipo/polipo.loglogLevel = 4 # 没有这句话的话`sudo polipo -v`会出现无法查看log文件的情况socksParentProxy = &quot;localhost:1080&quot; # 这里假设shadowsocks的local port为1080socksProxyType = socks5 # 是不是和SwitchyProxy的设置很像?\n具体各个配置选项可以参考文件/usr/share/doc/polipo/examples/config.sample.\n配置好之后,我们需要重启polipo服务(每次修改配置文件需要重启服务才能加载)\nsudo service polipo stop;sudo service polipo start;\n或者直接\nsudo service polipo restart;\n可以用\nsudo polipo -v\n查看具体各个配置项,可以看到我们之前的更改生效了.\n 测试\n配置完成后,怎么才知道自己是否已经可以科学上网了呢?\n可以使用以下命令:\n~$ curl -i http://ip.cn当前 IP：60.xxx.xxx.x 来自：中国北京北京 xxx/电信\n~$ http_proxy=http://localhost:8123 curl -i http://ip.cn # polipo的默认端口为8123,如有需要可以自行改动当前 IP：xxx.xxx.xxx.xx0 来自：美国加利福尼亚州洛杉矶\n这样就算成功了.\n最近发现&quot;ip.cn&quot;这个网站不能用了，500访问错误。可以将其替换为“ipinfo.io/ip”就可以了i，这是另一个返回你的公网IP的网站。\n还有一些其他的网站提供类似的返回IP的服务:\ncurl ifconfig.mecurl icanhazip.comcurl ipecho.net/plaincurl ifconfig.co\n从浏览器中获得自己公网IP的方法:\n\nGoogle\nDuckDuckGo\nWolframalpha, 推荐\n\n 更进一步\n每次都打这么长的命令http_proxy=http://localhost:8123着实不是我们想要的,为了方便使用,可以在终端键入export http_proxy=http://localhost:8123,表示对该终端所有命令生效;或者更进一步,在.bashrc中加入export http_proxy=http://localhost:8123,每次启动终端时自动执行.如果不想要每次都走代理,可以像我一样,在.bashrc中加入alias hp=&quot;http_proxy=http://localhost:8123&quot;,每次需要代理时,只需要在命令前面加hp 就好了.\n 为git配置代理\ngit clone的速度很是感人, 只有几十k, 为git配置代理也是很简单的.\nAdd the following setting to the http items of .gitconfig files.\n[http]proxy = &lt;address of the proxy server&gt;:&lt;port of the proxy server&gt;\nYou can also configure it using the following config command:\ngit config --global http.proxy &lt;address of the proxy server&gt;:&lt;port of the proxy server&gt;\nssh形式连接Github\n在终端中尽情享受科学上网吧!\n","categories":["折腾"],"tags":["Linux"]},{"title":"不同时间戳总结 - YoungForest","url":"/2016/09/28/timestamp-summary/","content":"【摘要】最近在实验室帮师兄做一些项目，遇到各种没见过的时间戳，在此总结一下。 Unix时间 关于这个时间，大家一般都比较了解，记录了从1970年1月1日0时0分0秒开始到现在的总秒数。 这篇文章中有关于Unix时间和各种常用时间的关系，在这里分享一下。 Window NT时间 The 18-digit Ac 阅读全文\n"},{"title":"pair 作为 unordered_map unordered_set 的键值 C++","url":"/2020/05/27/unordered-map-hash-pair-c/","content":"今天在做一道AtCoder的题目，有个test case一直TLE。研究这个测试用例和其他用例的区别，苦思不得其解。后来把unordered_map换成map就过了。虽然在小数据集上hashmap和treemap区别不大，但数据量大的话，hashmap还是好些。所以最佳实践是，在不需要排序特性时，就用hashmap。\n而且之前也从来没有遇到过hashmap比treemap效果差这么多的原因。最后花了一上午时间，才定位到是我的 pair 的hash函数实现太糟糕了。因为C++ STL中并没有pair的hash特化，所以如果想把pair当作键用在unordered_map中的话，就需要自己实现hash函数。我直接从网上抄了一个实现, 直接将 std::hash&lt;T&gt;()(pair.first) ^ std::hash&lt;U&gt;()(pair.second)。为了避免误人子弟，我就不贴代码了。正是抄的这个实现害苦我了，hash函数碰撞严重，导致效率低下。令人惊讶的是，这种错误的实现遍布全网，无论是中文的还是英文的。我从犄角旮旯（stackoverflow问题的评论区中）里才找到问题所在和正确的实现。所以特意总结此博文，避免更多的同学踩坑。\n\nstd::hash()(x.first) ^ std::hash()(x.second); - that’s a spectacularly collision-prone way to hash a pair, as every pair with two identical value hashes to 0, and every pair {a, b} hashes the same as {b, a}. For vaguely demanding use, much better to find a hash_combine function and employ that.\n\n惊讶的是，一看到这个评论，我就像中电一样。忽然记起，多年前，当我还是一只小白时，读《C++ 标准库（第二版）》时，作者就已经给出了绝佳的解决方案。我匆忙翻出珍藏的《C++ 标准库（第二版）》的unordered_map对应章节，“7.9.2 Creating and Controlling Unordered Container&quot;，把任意结构hash化的代码搬出来，模版如下：\n#include &lt;functional&gt;// from boost (functional/hash):// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html templatetemplate &lt;typename T&gt;inline void hash_combine(std::size_t &amp;seed, const T &amp;val) &#123;    seed ^= std::hash&lt;T&gt;()(val) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);&#125;// auxiliary generic functions to create a hash value using a seedtemplate &lt;typename T&gt; inline void hash_val(std::size_t &amp;seed, const T &amp;val) &#123;    hash_combine(seed, val);&#125;template &lt;typename T, typename... Types&gt;inline void hash_val(std::size_t &amp;seed, const T &amp;val, const Types &amp;... args) &#123;    hash_combine(seed, val);    hash_val(seed, args...);&#125;template &lt;typename... Types&gt;inline std::size_t hash_val(const Types &amp;... args) &#123;    std::size_t seed = 0;    hash_val(seed, args...);    return seed;&#125;struct pair_hash &#123;    template &lt;class T1, class T2&gt;    std::size_t operator()(const std::pair&lt;T1, T2&gt; &amp;p) const &#123;        return hash_val(p.first, p.second);    &#125;&#125;;#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() &#123;    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;    return 0;&#125;\n也有Tuple版本的hash实现，我更新回答在了StackOverflow。有需要的同学可以自取+点赞。\n修改了hash_pair的实现后，我如愿地AC了。一个hash函数的错误，我花了一上午时间解决。并由此从多年前的学习经验中获益。当时我苦读《C++标准库》时，并没有对这段代码特别注意。由此可见，多读书总是没坏处的。\n平时因为Google搜索很方便，遇到问题总是倾向于简单地 复制粘贴。通常情况下，问题就解决了。这样固然可以更快地完成任务，效果也不错。但这种不求甚解的思想对自己的成长是十分不利的。所以需要遇到问题深入钻研（当然是在时间足够的情况下），多读一些经典的书。很多问题和解决方案，经典的书本都已给出了。读书也更能启发自己思考和成长。本次的pair的 unordered_map实践就是最好的证明。\n","categories":["Programming"],"tags":["C++","hash","unordered_map"]},{"title":"vscode include 万能头文件 bits/stdc++.h","url":"/2020/05/18/vscode-include-bits-stdc-h/","content":"最近经常打kickstart需要include万能头文件bits/stdc++.h，然而，我喜爱的编辑器vs code总是不能正确地找到该头文件，会有红色波浪线表示错误。作为程序员的我完全不能忍受，所以尝试解决该问题。在网络上搜了很多解决方案，大多数并不能直接地解决我的问题。所以，我总结自己的解决方案于此，方便各位取用。\n编程环境:\ng++ 9.1.0, Mac 10.14.2, vs code 1.45.1\n总的思路是:\n\n寻找gcc编译器头文件的路径,\n更改VS Code设置，让其用上面的路径可以找到bits/stdc++.h\n\ngcc-9 -v -E -x c++ -\n\n图中所示，就是编译器默认找的路径顺序。将这些路径全部加到vscode的includePath里。\n\n\nDone!\n","categories":["Programming"],"tags":["vscode","gcc"]},{"title":"Work With Two Github Accounts Simultaneously","url":"/2017/12/12/work-with-two-github-accounts/","content":"笔者3个月前来到偶数科技公司实习，学习工作都用公司配的Mac。一分价钱一分货，Mac确实比自己15年买的5000RMB的HP好用多了。所以除了工作之外，学习和实验室的任务也渐渐迁移到Mac上。现在遇到的一个比较棘手的问题是，如何使自己工作的GitHub账号与个人的账号不冲突，同时方便地使用。\n在查阅过相关资料后，我实现了如下的解决方案。\n\n全局默认使用公司的账号，对于需要公司账号的地方不做任何处理。\n个人的仓库进行特殊处理。\n\n在本地创建ssh密钥\n在个人GitHub设置中配置ssh公钥\n修改~/.ssh/config\n\n# Personal github userHost github.ys        HostName github.com        User git        IdentityFile ~/.ssh/id_rsa_personal_github\n\nclone仓库时，使用ssh链接，并将github.com替换为github.ys\n对于已有的仓库，更改.git/config的“remote”项，链接与4中相同\n配置local commit。\n\ngit config user.email yangsen758@foxmail.comgit config user.name YoungForest\n为了使hexo可以自动deploy，需要更改hexo下的_config.yml文件中repo链接，类似clone。\n# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.ys:YoungForest/youngforest.github.io.git  branch: master","tags":["git"]}]