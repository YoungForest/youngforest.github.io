{
    "version": "https://jsonfeed.org/version/1",
    "title": "YoungForest's blog • All posts by \"algorithm\" tag",
    "description": "佛系更新；生活、学习",
    "home_page_url": "https://youngforest.github.io",
    "items": [
        {
            "id": "https://youngforest.github.io/2019/12/14/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/",
            "url": "https://youngforest.github.io/2019/12/14/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/",
            "title": "Find all unique pairs of maximum and second maximum elements 子数组的最大值和次大值对",
            "date_published": "2019-12-14T22:07:31.000Z",
            "content_html": "<p>问题的根源是有个同学问了个lucky number的问题<a href=\"https://codeforces.com/problemset/problem/280/B\">Codeforces 280B</a>, <a href=\"https://codeforces.com/problemset/problem/281/D\">Codeforces 281D</a>也是同样的问题。</p>\n<p><a href=\"https://www.geeksforgeeks.org/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/\">Find all unique pairs of maximum and second maximum elements over all sub-arrays in O(NlogN)</a></p>\n<p>幸运数的定义为：数组中子数组的最大值和次大值的XOR值。寻找所有幸运数中的最大的。</p>\n<p>Brute force 的解法是枚举所有的子数组，时间复杂度为O(N ^ 2).<br />\n有没有更优的方法呢？<br />\n今天要讨论的就是这个问题。</p>\n<h2 id=\"通用的解法快速寻找-最大次大值对-算法\"><a class=\"markdownIt-Anchor\" href=\"#通用的解法快速寻找-最大次大值对-算法\"></a> 通用的解法，快速寻找 最大次大值对 算法</h2>\n<p>寻找子数组中最大值和次大值其实是有快速算法的:<br />\n<a href=\"https://www.geeksforgeeks.org/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/\">Find all unique pairs of maximum and second maximum elements over all sub-arrays in O(NlogN)</a></p>\n<p>基于这个的观察：数组中的每个数，如果想要成为次大值，就只能和向前的第一个比他大的数 或 向后的第一个比他大的数组成。<br />\n我们可以维护一个 单调递减栈，加入新数时，维持单调递增需要弹出所有小于它的数，这时新数就是被弹出来的数后面的第一个比他大的数；栈顶中最大的数 就是 新数 向前的第一个比他大的数。</p>\n<p>时间复杂度: O(N),<br />\n空间复杂度: O(N).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll N;</span><br><span class=\"line\">    cin &gt;&gt; N;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">nums</span><span class=\"params\">(N)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i = <span class=\"number\">0</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack&lt;ll&gt; st;</span><br><span class=\"line\">    st.<span class=\"built_in\">push</span>(nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i = <span class=\"number\">1</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.<span class=\"built_in\">empty</span>() &amp;&amp; nums[i] &gt; st.<span class=\"built_in\">top</span>()) &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, nums[i] ^ st.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, nums[i] ^ st.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"我独立思考出的解法\"><a class=\"markdownIt-Anchor\" href=\"#我独立思考出的解法\"></a> 我独立思考出的解法</h2>\n<p>我的解法利用了XOR的性质，如果换成别的运算就不通用了。</p>\n<p>首先遍历一遍找到最高的位数。<br />\n再遍历一遍找到最高的位数为1的那些数，我们先称其为 最高数。<br />\n从这些最高数出发，往两边扩充，直到遇到另一个最高数，在这个过程中寻找次大数并更新幸运数的最大值。可以证明，每个数最多被找2次。<br />\n所以，总的时间复杂度是 O(N), 空间复杂度 O(N).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> N;</span><br><span class=\"line\">    cin &gt;&gt; N;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">nums</span><span class=\"params\">(N)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i = <span class=\"number\">0</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> MAX_BIT_BEGIN = <span class=\"number\">40</span>;</span><br><span class=\"line\">    vector&lt;vector&lt;ll&gt;&gt; <span class=\"built_in\">flag</span>(MAX_BIT_BEGIN + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;ll&gt;(<span class=\"number\">2</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i : nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ll j = <span class=\"number\">0</span>; j &lt;= MAX_BIT_BEGIN; ++j) &#123;</span><br><span class=\"line\">            ++flag[j][((i &gt;&gt; j) &amp; <span class=\"number\">1</span>)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll max_bit = MAX_BIT_BEGIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; max_bit &gt;= <span class=\"number\">0</span>; --max_bit) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag[max_bit][<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span> &amp;&amp; flag[max_bit][<span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max_bit == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (max_bit &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        vector&lt;ll&gt; max_bit_is_1_indexs;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ll i = <span class=\"number\">0</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (((nums[i] &gt;&gt; max_bit) &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                max_bit_is_1_indexs.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ll index : max_bit_is_1_indexs) &#123;</span><br><span class=\"line\">            ll second_max = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ll i = index - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; ((nums[i] &gt;&gt; max_bit) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">                 --i) &#123;</span><br><span class=\"line\">                second_max = <span class=\"built_in\">max</span>(second_max, nums[i]);</span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, nums[index] ^ second_max);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            second_max = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ll i = index + <span class=\"number\">1</span>; i &lt; N &amp;&amp; ((nums[i] &gt;&gt; max_bit) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">                 ++i) &#123;</span><br><span class=\"line\">                second_max = <span class=\"built_in\">max</span>(second_max, nums[i]);</span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, nums[index] ^ second_max);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Algorithm"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/09/06/LeetCode-134-Gas-Station/",
            "url": "https://youngforest.github.io/2019/09/06/LeetCode-134-Gas-Station/",
            "title": "LeetCode 134 Gas Station",
            "date_published": "2019-09-06T15:56:01.000Z",
            "content_html": "<p><a href=\"https://leetcode.com/problems/gas-station/description/\">题目描述</a></p>\n<p>本题是我2月份Google实习生电话面试遇到的一道题目。我当时做的很混乱，一面直接挂了。今天看到<a href=\"https://zhuanlan.zhihu.com/p/81412559\">同学发的讲解</a>，决定重新尝试一下这道题目。毕竟自己这半年来刷了有500+道题目，算法实力有一定的增长。我只看到了讲解的题目，并没有看内容，算是自己半年后可以独立解决这个问题了吧。AC后，我竟然都哭了，为当时实力不济而伤心。不知道之后还有那么好的机会吗？<br />\n这半年也参加了3次Kick start，除了第一次的A轮收到简历通知外，D轮和E轮都挂了。<br />\n就像我之前反复讲的，我很想去Google，微软这样的外企，自己也为之付出了半年的努力。希望努力会有回报吧！如果可以拿到明年暑期的Google或微软的暑期实习，我就奖励自己一次端午节假期去韩国的自由行。有青梅竹马在那里，可以去找她。</p>\n<p>本题的思路是这样的:</p>\n<p>首先暴力的O(N^2)解法很简单.<br />\n枚举所有的起点，从起点出发模拟循环的过程。<br />\n可以用2个前缀和数组gas_prefix和cost_prefix追踪油量和花费，保证油量永远大于等于花费。</p>\n<p>然后尝试进一步的优化，思考不同起点之间的信息是否可以互相利用。<br />\n观察有, 如果在第i个加油站油量小于花费了，则从起点到i（包含）的加油站都不必作为起点尝试了。因为如果<code>起点 &lt; j &lt;= i</code>，则<code>j</code>作为起点，到<code>i</code>时的gas_prefix = 旧起点的gas_prefix - 旧起点到j的gas_prefix, 同理cost_prefix = 旧起点的cost_prefix- 旧起点到j的cost_prefix. 因为旧起点到j是成功的，所以有<code>旧起点到j的gas_prefix &gt;= 旧起点到j的cost_prefix</code>, 所以gas_prefix还是小于 cost_prefix。j就不用尝试了，可以直接跳过。<br />\n所以我们有了在O(N)的复杂度下的解法，起点直接跳到失败节点之后。</p>\n<p>同学的解法是通过反证法证明这一优化正确性的，也是很好的方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">canCompleteCircuit</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; gas, vector&lt;<span class=\"type\">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">const</span> <span class=\"type\">int</span> n = gas.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">gas_prefix</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">cost_prefix</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> begin_index = <span class=\"number\">0</span>; begin_index &lt; n; ) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (; i &lt; n; ++i) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    gas_prefix[i] = gas[(begin_index + i) % n];</span><br><span class=\"line\">                    cost_prefix[i] = cost[(begin_index + i) % n];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    gas_prefix[i] = gas_prefix[i - <span class=\"number\">1</span>] + gas[(begin_index + i) % n];</span><br><span class=\"line\">                    cost_prefix[i] = cost_prefix[i - <span class=\"number\">1</span>] + cost[(begin_index + i) % n];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (gas_prefix[i] &lt; cost_prefix[i]) &#123;</span><br><span class=\"line\">                    begin_index += i + <span class=\"number\">1</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == n) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> begin_index;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Algorithm"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/02/11/recursion/",
            "url": "https://youngforest.github.io/2019/02/11/recursion/",
            "title": "recursion",
            "date_published": "2019-02-11T12:58:52.000Z",
            "content_html": "<p>本文根据LeetCode上的教程 <a href=\"https://leetcode.com/explore/learn/card/recursion-i/\">Introduction to Algorithms - Recursion I</a> 整理而成。目的在于帮助笔者自己更熟悉“递归”这一重要的编程概念，如果能够同时对他人产生帮助，那更好不过了。</p>\n<p>本文的结构和LeetCode上的完全相同，分为 简介、递归原则、复现关系、备忘录、复杂度分析、总结 6个部分。</p>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>本Card的目的，回答以下问题：</p>\n<ol>\n<li>什么是递归？递归如何工作？</li>\n<li>如何递归地解决一个问题？</li>\n<li>如何分析一个递归算法的时间复杂度和空间复杂度？</li>\n<li>如何以一种更好的方式应用递归？</li>\n</ol>\n<h2 id=\"递归的原理\"><a class=\"markdownIt-Anchor\" href=\"#递归的原理\"></a> 递归的原理</h2>\n<p>每次递归函数调用自身，都将给定问题变为子问题。递归过程一直继续指导子问题可以不通过进一步递归就可以直接解决。</p>\n<p>递归函数避免无限递归的必要属性：</p>\n<ol>\n<li>递归结束条件(<strong>base cases</strong>)</li>\n<li>一套规则(<strong>recurrence relation</strong>)，可以将所有其他的cases规约为base cases。</li>\n</ol>\n<p>递归函数中可以有多个地方调用本身。</p>\n<h3 id=\"例子-翻转字符串\"><a class=\"markdownIt-Anchor\" href=\"#例子-翻转字符串\"></a> 例子 翻转字符串</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printReverse</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*str) <span class=\"keyword\">return</span>;  <span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"built_in\">printReverse</span>(str + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(*str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归函数\"><a class=\"markdownIt-Anchor\" href=\"#递归函数\"></a> 递归函数</h3>\n<p>如果一个问题存在递归解法，我们就可以遵循下列步骤去实现它。</p>\n<p>我们定义该问题为函数<code>F(x)</code>可以实现，其中<code>X</code>是函数的输入，同时表示了问题的范围。</p>\n<p>在函数<code>F(X)</code>中，我们实现以下步骤：</p>\n<ol>\n<li>将问题拆分成更小的范围，<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \\belong at position 5: x_1 \\̲b̲e̲l̲o̲n̲g̲ ̲X, x_2 \\belong …'>x_1 \\belong X, x_2 \\belong X, ..., x_n \\belong X</span>.</li>\n<li>递归调用函数<code>F(x_1), F(x_2), ..., F(x_n)</code>以解决<code>X</code>的子问题。</li>\n<li>最后，处理子问题的解，组合成对应<code>X</code>的解。</li>\n</ol>\n<h2 id=\"recurrence-relation\"><a class=\"markdownIt-Anchor\" href=\"#recurrence-relation\"></a> Recurrence Relation</h2>\n<p>定义：一个问题的解和其子问题的解之间的关系。</p>\n<h3 id=\"例子pascals-triangle\"><a class=\"markdownIt-Anchor\" href=\"#例子pascals-triangle\"></a> 例子：Pascal’s Triangle</h3>\n<p>定义：杨辉三角是一系列数字组成三角形的形状。在杨辉三角中，每行最左和最右的数字永远是1. 对于剩余的数字，每个数字是它前一行正上方2个数字之和。</p>\n<p>用数学公式表达出来就是，Recurrence Relation为<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">f(i, j) = f(i-1, j-1) + f(i-1, j),</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span></span></span></span></p>\n<p>base cases为：<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>i</mi><mi>f</mi><mi>j</mi><mo>=</mo><mn>1</mn><mi>o</mi><mi>r</mi><mi>j</mi><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">f(i, j) = 1, if j = 1 or j = i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>.</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i, j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>表示第i行第j个数。</p>\n<h2 id=\"memoization-备忘录\"><a class=\"markdownIt-Anchor\" href=\"#memoization-备忘录\"></a> Memoization 备忘录</h2>\n<h3 id=\"递归过程中重复的计算\"><a class=\"markdownIt-Anchor\" href=\"#递归过程中重复的计算\"></a> 递归过程中重复的计算</h3>\n<p>递归解法常常是十分<strong>符合直觉</strong>和<strong>容易编码</strong>的。但大多数时候，在递归过程中，重复计算导致了性能上的损失。</p>\n<p><strong>备忘录法(Memoization)</strong><br />\n即是一个通用的避免重复计算的技术。<br />\n是的，这个词没有拼错，不是Memorization。</p>\n<p>定义：为了避免重复计算，我们可以在一个cache中存储中间子问题的结果，以便之后再次使用它们的时候不需要重复计算。</p>\n<p>备忘录的实现可以通过hashmap实现。尤其是在OOP中，利用装饰器可以实现通用的Memoization。</p>\n<h3 id=\"例子-斐波那契数\"><a class=\"markdownIt-Anchor\" href=\"#例子-斐波那契数\"></a> 例子 斐波那契数</h3>\n<p><a href=\"https://leetcode.com/articles/climbing-stairs/\">斐波那契数的多种解法</a>，其中有时间复杂度为O(log n)的<strong>Binets法</strong>和<strong>公式法</strong>，令人印象十分深刻.</p>\n<h2 id=\"complexity-analysis-复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#complexity-analysis-复杂度分析\"></a> Complexity Analysis 复杂度分析</h2>\n<p>递归算法的复杂度有时候不是显而易见的，要通过一些套路分析。</p>\n<p>尾递归是一种特殊的技术，可以消减递归栈的使用，优化空间复杂度，使其和迭代算法相同。</p>\n<h3 id=\"time-complexity-时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#time-complexity-时间复杂度\"></a> Time Complexity 时间复杂度</h3>\n<p>递归算法的时间复杂度为：<br />\nO(T) = R * O(s),<br />\n其中，R为递归调用的数量，O(s)为每次递归调用产生的计算复杂度。<br />\n一般来说，R更难算一点，O(s)的计算和非递归算法的时间复杂度分析一样。</p>\n<p>借助execution tree的技术，我们可以更好地分析递归调用的数量。<br />\nexecution tree是展示具体情况下递归调用流的一棵树，每个节点代表一次调用，节点上的值表示调用时的参数。<br />\n这棵树的节点数目就是R。</p>\n<p>需要特别注意的是，当使用Memoization技术时，execution tree的变化。</p>\n<h3 id=\"space-complexity-空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#space-complexity-空间复杂度\"></a> Space Complexity 空间复杂度</h3>\n<p>递归算法的空间使用主要分为2部分：</p>\n<ol>\n<li>recursion related</li>\n<li>non-recursion related</li>\n</ol>\n<h4 id=\"recursion-related\"><a class=\"markdownIt-Anchor\" href=\"#recursion-related\"></a> recursion related</h4>\n<p>学过编译原理的我们都知道，每次函数调用都要在栈上压入：</p>\n<ol>\n<li>函数的返回地址</li>\n<li>函数参数</li>\n<li>函数的本地变量</li>\n</ol>\n<p>递归算法的函数调用栈的深度是从初始case到base case.</p>\n<h4 id=\"non-recursion-related\"><a class=\"markdownIt-Anchor\" href=\"#non-recursion-related\"></a> non-recursion related</h4>\n<p>全局变量使用的空间，主要在堆上分配。比如，memoization 要使用的hashmap。</p>\n<h3 id=\"tail-recursion-尾递归\"><a class=\"markdownIt-Anchor\" href=\"#tail-recursion-尾递归\"></a> Tail Recursion 尾递归</h3>\n<p>尾递归是一种递归调用是递归函数的最后指令，而且函数中只有一个递归调用。</p>\n<p>尾递归的一个很好的例子。注意，non_tail_recursion在最后的递归调用后还有计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">helper_non_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= ls.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// not a tail recursion because it does some computation after the recursive call returned.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ls[start] + helper_non_tail_recursion(start+<span class=\"number\">1</span>, ls);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">sum_non_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ls == <span class=\"literal\">null</span> || ls.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_non_tail_recursion(<span class=\"number\">0</span>, ls);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//---------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">helper_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> [] ls, <span class=\"type\">int</span> acc)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= ls.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// this is a tail recursion because the final instruction is the recursive call.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_tail_recursion(start+<span class=\"number\">1</span>, ls, acc+ls[start]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">sum_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ls == <span class=\"literal\">null</span> || ls.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_tail_recursion(<span class=\"number\">0</span>, ls, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尾递归消除递归栈的原理：<br />\n编译器知道在从callee中返回之后，会立刻再次返回，不需要再利用函数调用栈中保存的数据。只需要一个栈帧就可以了，所有层共用一个栈帧，所以返回时可以跳过整个递归栈。</p>\n<p>并不是所有语言的编译器都支持尾递归优化的。比如，C, C++支持，而Python, Java不支持。</p>\n<p>尾递归通常也不是那么好实现。需要<br />\n递归调用只出现在最后一个指令，如果需要调用多个函数，或是对返回值进行计算，就没法尾递归了。</p>\n<p>而且细心的同学可以发现尾递归和迭代(loop)的相似之处。事实上，有些函数式编程语言甚至不支持loop，只有递归，完全可以实现迭代。因为我们平时使用loop居多，尾递归很少。如果需要写尾递归时（一般是在一些面试的要求中），可以先写loop版本的代码。然后试着把其中的局部变量更新改成尾递归中的参数，往往就可以写出优雅的（但对于大多数人可读性并不高）的尾递归代码了。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h2>\n<p>解决递归问题的套路：</p>\n<ol>\n<li>定义递归函数</li>\n<li>写下recurrence relation和base case</li>\n<li>使用Memoization消除重复计算，如果存在的话</li>\n<li>如果可能的话，使用尾递归实现递归算法，以消减空间复杂度</li>\n</ol>\n",
            "tags": [
                "Algorithm",
                "LeetCode"
            ]
        }
    ]
}