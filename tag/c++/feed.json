{
    "version": "https://jsonfeed.org/version/1",
    "title": "YoungForest's blog • All posts by \"c++\" tag",
    "description": "佛系更新；生活、学习",
    "home_page_url": "https://youngforest.github.io",
    "items": [
        {
            "id": "https://youngforest.github.io/2020/05/27/best-implement-to-use-pair-as-key-to-std-unordered-map-in-C/",
            "url": "https://youngforest.github.io/2020/05/27/best-implement-to-use-pair-as-key-to-std-unordered-map-in-C/",
            "title": "Best implement to use pair as key to std::unordered_map in C++",
            "date_published": "2020-05-27T11:29:34.000Z",
            "content_html": "<p>Reference: <a href=\"https://www.mica.edu.vn/perso/Vu-Hai/EE3490/Ref/The%20C++Standard%20Library%20-%202nd%20Edition.pdf\">C++ Standard Library: A tutorial and reference, Second version</a> Chapter 7.9.2: Creating and Controlling unordered Container</p>\n<p>All solutions I found in Google use <code>XOR</code> to generate hashcode of <code>pair</code>, which is totally bad. see <a href=\"https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\">why-is-xor-the-default-way-to-combine-hashes</a>. However, the book has given us the best solution, using <code>hash_combine</code>, which is taken from <code>Boost</code>. The solution is much better than XOR when I tested it in Online Judge(<a href=\"https://atcoder.jp/contests/abc168/tasks/abc168_e\">Atcoder</a>). I organized the code as a template as follow. You can copy and paste it as much as you can. And it is convenient to change it to fit any custom struct/class.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// from boost (functional/hash):</span></span><br><span class=\"line\"><span class=\"comment\">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_combine</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    seed ^= std::<span class=\"built_in\">hash</span>&lt;T&gt;()(val) + <span class=\"number\">0x9e3779b9</span> + (seed &lt;&lt; <span class=\"number\">6</span>) + (seed &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// auxiliary generic functions to create a hash value using a seed</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> std::<span class=\"type\">size_t</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"type\">size_t</span> seed = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">pair_hash</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\">    <span class=\"function\">std::<span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hash_val</span>(p.first, p.second);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;</span><br><span class=\"line\">    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>There is a hash implementation for <code>Tuple</code>. I updated the answer in<a href=\"https://stackoverflow.com/a/62035742/6393787\">StackOverflow</a>。Please go there if you need hash tuple.</p>\n",
            "tags": [
                "C++",
                "hash",
                "unordered_map",
                "English"
            ]
        },
        {
            "id": "https://youngforest.github.io/2020/05/27/unordered-map-hash-pair-c/",
            "url": "https://youngforest.github.io/2020/05/27/unordered-map-hash-pair-c/",
            "title": "pair 作为 unordered_map unordered_set 的键值 C++",
            "date_published": "2020-05-27T10:57:01.000Z",
            "content_html": "<p>今天在做<a href=\"https://atcoder.jp/contests/abc168/tasks/abc168_e\">一道AtCoder的题目</a>，有个test case一直TLE。研究这个测试用例和其他用例的区别，苦思不得其解。后来把unordered_map换成map就过了。虽然在小数据集上hashmap和treemap区别不大，但数据量大的话，hashmap还是好些。所以最佳实践是，在不需要排序特性时，就用hashmap。<br />\n而且之前也从来没有遇到过hashmap比treemap效果差这么多的原因。最后花了一上午时间，才定位到是我的 pair 的hash函数实现太糟糕了。因为C++ STL中并没有pair的hash特化，所以如果想把pair当作键用在unordered_map中的话，就需要自己实现hash函数。我直接从网上抄了一个实现, 直接将 <code>std::hash&lt;T&gt;()(pair.first) ^ std::hash&lt;U&gt;()(pair.second)</code>。为了避免误人子弟，我就不贴代码了。正是抄的这个实现害苦我了，hash函数碰撞严重，导致效率低下。令人惊讶的是，这种错误的实现遍布全网，无论是中文的还是英文的。我从犄角旮旯（<a href=\"https://stackoverflow.com/questions/20590656/error-for-hash-function-of-pair-of-ints\">stackoverflow问题</a>的评论区中）里才找到问题所在和正确的实现。所以特意总结此博文，避免更多的同学踩坑。</p>\n<blockquote>\n<p>std::hash<T>()(x.first) ^ std::hash<T>()(x.second); - that’s a spectacularly collision-prone way to hash a pair, as every pair with two identical value hashes to 0, and every pair {a, b} hashes the same as {b, a}. For vaguely demanding use, much better to find a hash_combine function and employ that.</p>\n</blockquote>\n<p>惊讶的是，一看到这个评论，我就像中电一样。忽然记起，多年前，当我还是一只小白时，读《C++ 标准库（第二版）》时，作者就已经给出了绝佳的解决方案。我匆忙翻出珍藏的《C++ 标准库（第二版）》的unordered_map对应章节，“7.9.2 Creating and Controlling Unordered Container&quot;，把任意结构hash化的代码搬出来，模版如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// from boost (functional/hash):</span></span><br><span class=\"line\"><span class=\"comment\">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_combine</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    seed ^= std::<span class=\"built_in\">hash</span>&lt;T&gt;()(val) + <span class=\"number\">0x9e3779b9</span> + (seed &lt;&lt; <span class=\"number\">6</span>) + (seed &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// auxiliary generic functions to create a hash value using a seed</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> std::<span class=\"type\">size_t</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"type\">size_t</span> seed = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">pair_hash</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\">    <span class=\"function\">std::<span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hash_val</span>(p.first, p.second);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;</span><br><span class=\"line\">    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也有Tuple版本的hash实现，我更新回答在了<a href=\"https://stackoverflow.com/a/62035742/6393787\">StackOverflow</a>。有需要的同学可以自取+点赞。</p>\n<p>修改了hash_pair的实现后，我如愿地AC了。一个hash函数的错误，我花了一上午时间解决。并由此从多年前的学习经验中获益。当时我苦读《C++标准库》时，并没有对这段代码特别注意。由此可见，多读书总是没坏处的。</p>\n<p>平时因为Google搜索很方便，遇到问题总是倾向于简单地 复制粘贴。通常情况下，问题就解决了。这样固然可以更快地完成任务，效果也不错。但这种不求甚解的思想对自己的成长是十分不利的。所以需要遇到问题深入钻研（当然是在时间足够的情况下），多读一些经典的书。很多问题和解决方案，经典的书本都已给出了。读书也更能启发自己思考和成长。本次的pair的 unordered_map实践就是最好的证明。</p>\n",
            "tags": [
                "C++",
                "hash",
                "unordered_map"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/12/15/Cpp-generator-implement/",
            "url": "https://youngforest.github.io/2019/12/15/Cpp-generator-implement/",
            "title": "C++ 中实现生成器(Generator, yield in Python)",
            "date_published": "2019-12-15T21:34:30.000Z",
            "content_html": "<p>问题的起因是因为LeetCode上的一个题目<a href=\"https://leetcode.com/problems/iterator-for-combination/\">1286. Iterator for Combination</a>。最完美的实现是利用 生成器(Generator)，也就是Python中的<code>yield</code>。但是我不会，只实现了一个提前计算，然后存起来的解法。并不优雅，赛后，学习了一个C++中Generator的实现，在此分享下。因为我并未在网上找到很好的中文的关于此的文章。</p>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/05/05/Effective-Modern-C/",
            "url": "https://youngforest.github.io/2019/05/05/Effective-Modern-C/",
            "title": "Effective Modern C++",
            "date_published": "2019-05-05T19:27:23.000Z",
            "content_html": "<p><a href=\"https://book.douban.com/review/10131903/\">我的书评</a></p>\n",
            "tags": [
                "C++",
                "C++11"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/03/17/pkg-config/",
            "url": "https://youngforest.github.io/2019/03/17/pkg-config/",
            "title": "pkg-config",
            "date_published": "2019-03-17T19:52:38.000Z",
            "content_html": "<p>最近在学习<a href=\"https://github.com/google/googletest\">google-test</a>的使用和源码，在<code>make install</code>的时候发现除了向<code>/usr/local/</code>中安装了头文件，<code>/usr/lib/</code>中安装了shared library外，还向<code>/usr/local/lib/pkgconfig/</code>中安装了2个<code>.pc</code>文件。所以说，这个pkg-config是个什么东西呢？</p>\n<p>从一份<a href=\"https://people.freedesktop.org/~dbn/pkg-config-guide.html\">Guide</a>中，我们可以发现<code>pkg-config</code>的所有有用的基本信息。</p>\n<h2 id=\"overview\"><a class=\"markdownIt-Anchor\" href=\"#overview\"></a> Overview</h2>\n<p>现代的计算机系统使用很多层的组件以向用户提供API。一个很大的难点在于如何合适地将这些不同层的组件整合起来。<code>pkg-config</code>这一工具收集了安装在系统上的库的metadata, 用户可以很方便地查看这些metadata。比如，google-test安装的其中一个pc文件<code>gtest.pc</code>的内容是：</p>\n<p>包含使用gtest库的所有信息，如头文件安装位置、shared library的位置，编译时需要的编译选项。可以说，使用gtest看这些metadata就够了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prefix=$&#123;pcfiledir&#125;/../..</span><br><span class=\"line\">libdir=$&#123;prefix&#125;/lib</span><br><span class=\"line\">includedir=$&#123;prefix&#125;/include</span><br><span class=\"line\"></span><br><span class=\"line\">Name: gtest</span><br><span class=\"line\">Description: GoogleTest (without main() function)</span><br><span class=\"line\">Version: 1.9.0</span><br><span class=\"line\">URL: https://github.com/google/googletest</span><br><span class=\"line\">Libs: -L$&#123;libdir&#125; -lgtest </span><br><span class=\"line\">Cflags: -I$&#123;includedir&#125; -DGTEST_HAS_PTHREAD=1 </span><br></pre></td></tr></table></figure>\n<p>计算机系统上没有一个如<code>pkg-config</code>的metadata系统的话，定位和获得系统提供的服务的细节将会很难。<br />\n对于一个开发者，安装你的包的时候同时安装<code>pkg-config</code>将会极大地方便你的API被用户使用。</p>\n<p><code>pkg-config</code>最主要的使用是当程序编译和链接一个库的时候提供必要的细节。这些元信息被存储在<code>pkg-config</code>文件中。这些文件以<code>.pc</code>为后缀，存放在<code>pkg-config</code>工具知道的特定路径里。<br />\n一个<code>.pc</code>文件中包含2种信息，metadata keywords和freeform variables。<br />\n前者以keyword开头，后接冒号和value，如“Name: gtest&quot;。<br />\n后者用=连接变量的值和名字，如&quot;prefix=…&quot;。<br />\nkeywords是由<code>pkg-config</code>定义和导出的。<br />\nvariables不是必须的，但是可以被用来表示<code>pkg-config</code>没有涉及的信息 或是 被keywords使用以增加keywords定义的灵活性。</p>\n<p>一个pc文件最好对应一个library文件。文件名(除了后缀)也最好相同。</p>\n<p>最重要的metadata域是Requires, Requires.private, Cflags, Libs 和 Libs.private。它们可以被外部的工程用来编译和链接到这个library。优先使用private域，以避免暴露不必要的库给用户。如果用户不不直接使用requires library的symbols，就不应该直接链接到该库。</p>\n",
            "tags": [
                "C++"
            ]
        }
    ]
}