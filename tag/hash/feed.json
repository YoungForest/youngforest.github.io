{
    "version": "https://jsonfeed.org/version/1",
    "title": "YoungForest's blog • All posts by \"hash\" tag",
    "description": "佛系更新；生活、学习",
    "home_page_url": "https://youngforest.github.io",
    "items": [
        {
            "id": "https://youngforest.github.io/2020/05/27/best-implement-to-use-pair-as-key-to-std-unordered-map-in-C/",
            "url": "https://youngforest.github.io/2020/05/27/best-implement-to-use-pair-as-key-to-std-unordered-map-in-C/",
            "title": "Best implement to use pair as key to std::unordered_map in C++",
            "date_published": "2020-05-27T04:29:34.000Z",
            "content_html": "<p>Reference: <a href=\"https://www.mica.edu.vn/perso/Vu-Hai/EE3490/Ref/The%20C++Standard%20Library%20-%202nd%20Edition.pdf\">C++ Standard Library: A tutorial and reference, Second version</a> Chapter 7.9.2: Creating and Controlling unordered Container</p>\n<p>All solutions I found in Google use <code>XOR</code> to generate hashcode of <code>pair</code>, which is totally bad. see <a href=\"https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\">why-is-xor-the-default-way-to-combine-hashes</a>. However, the book has given us the best solution, using <code>hash_combine</code>, which is taken from <code>Boost</code>. The solution is much better than XOR when I tested it in Online Judge(<a href=\"https://atcoder.jp/contests/abc168/tasks/abc168_e\">Atcoder</a>). I organized the code as a template as follow. You can copy and paste it as much as you can. And it is convenient to change it to fit any custom struct/class.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// from boost (functional/hash):</span></span><br><span class=\"line\"><span class=\"comment\">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_combine</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    seed ^= std::<span class=\"built_in\">hash</span>&lt;T&gt;()(val) + <span class=\"number\">0x9e3779b9</span> + (seed &lt;&lt; <span class=\"number\">6</span>) + (seed &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// auxiliary generic functions to create a hash value using a seed</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> std::<span class=\"type\">size_t</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"type\">size_t</span> seed = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">pair_hash</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\">    <span class=\"function\">std::<span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hash_val</span>(p.first, p.second);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;</span><br><span class=\"line\">    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>There is a hash implementation for <code>Tuple</code>. I updated the answer in<a href=\"https://stackoverflow.com/a/62035742/6393787\">StackOverflow</a>。Please go there if you need hash tuple.</p>\n",
            "tags": [
                "C++",
                "hash",
                "unordered_map",
                "English"
            ]
        },
        {
            "id": "https://youngforest.github.io/2020/05/27/unordered-map-hash-pair-c/",
            "url": "https://youngforest.github.io/2020/05/27/unordered-map-hash-pair-c/",
            "title": "pair 作为 unordered_map unordered_set 的键值 C++",
            "date_published": "2020-05-27T03:57:01.000Z",
            "content_html": "<p>今天在做<a href=\"https://atcoder.jp/contests/abc168/tasks/abc168_e\">一道AtCoder的题目</a>，有个test case一直TLE。研究这个测试用例和其他用例的区别，苦思不得其解。后来把unordered_map换成map就过了。虽然在小数据集上hashmap和treemap区别不大，但数据量大的话，hashmap还是好些。所以最佳实践是，在不需要排序特性时，就用hashmap。<br />\n而且之前也从来没有遇到过hashmap比treemap效果差这么多的原因。最后花了一上午时间，才定位到是我的 pair 的hash函数实现太糟糕了。因为C++ STL中并没有pair的hash特化，所以如果想把pair当作键用在unordered_map中的话，就需要自己实现hash函数。我直接从网上抄了一个实现, 直接将 <code>std::hash&lt;T&gt;()(pair.first) ^ std::hash&lt;U&gt;()(pair.second)</code>。为了避免误人子弟，我就不贴代码了。正是抄的这个实现害苦我了，hash函数碰撞严重，导致效率低下。令人惊讶的是，这种错误的实现遍布全网，无论是中文的还是英文的。我从犄角旮旯（<a href=\"https://stackoverflow.com/questions/20590656/error-for-hash-function-of-pair-of-ints\">stackoverflow问题</a>的评论区中）里才找到问题所在和正确的实现。所以特意总结此博文，避免更多的同学踩坑。</p>\n<blockquote>\n<p>std::hash<T>()(x.first) ^ std::hash<T>()(x.second); - that’s a spectacularly collision-prone way to hash a pair, as every pair with two identical value hashes to 0, and every pair {a, b} hashes the same as {b, a}. For vaguely demanding use, much better to find a hash_combine function and employ that.</p>\n</blockquote>\n<p>惊讶的是，一看到这个评论，我就像中电一样。忽然记起，多年前，当我还是一只小白时，读《C++ 标准库（第二版）》时，作者就已经给出了绝佳的解决方案。我匆忙翻出珍藏的《C++ 标准库（第二版）》的unordered_map对应章节，“7.9.2 Creating and Controlling Unordered Container&quot;，把任意结构hash化的代码搬出来，模版如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// from boost (functional/hash):</span></span><br><span class=\"line\"><span class=\"comment\">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_combine</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    seed ^= std::<span class=\"built_in\">hash</span>&lt;T&gt;()(val) + <span class=\"number\">0x9e3779b9</span> + (seed &lt;&lt; <span class=\"number\">6</span>) + (seed &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// auxiliary generic functions to create a hash value using a seed</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> std::<span class=\"type\">size_t</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"type\">size_t</span> seed = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">pair_hash</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\">    <span class=\"function\">std::<span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hash_val</span>(p.first, p.second);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;</span><br><span class=\"line\">    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也有Tuple版本的hash实现，我更新回答在了<a href=\"https://stackoverflow.com/a/62035742/6393787\">StackOverflow</a>。有需要的同学可以自取+点赞。</p>\n<p>修改了hash_pair的实现后，我如愿地AC了。一个hash函数的错误，我花了一上午时间解决。并由此从多年前的学习经验中获益。当时我苦读《C++标准库》时，并没有对这段代码特别注意。由此可见，多读书总是没坏处的。</p>\n<p>平时因为Google搜索很方便，遇到问题总是倾向于简单地 复制粘贴。通常情况下，问题就解决了。这样固然可以更快地完成任务，效果也不错。但这种不求甚解的思想对自己的成长是十分不利的。所以需要遇到问题深入钻研（当然是在时间足够的情况下），多读一些经典的书。很多问题和解决方案，经典的书本都已给出了。读书也更能启发自己思考和成长。本次的pair的 unordered_map实践就是最好的证明。</p>\n",
            "tags": [
                "C++",
                "hash",
                "unordered_map"
            ]
        }
    ]
}