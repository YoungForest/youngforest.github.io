{
    "version": "https://jsonfeed.org/version/1",
    "title": "YoungForest's blog • All posts by \"leetcode\" tag",
    "description": "佛系更新；生活、学习",
    "home_page_url": "https://youngforest.github.io",
    "items": [
        {
            "id": "https://youngforest.github.io/2019/04/06/LeetCode-258-Add-Digits/",
            "url": "https://youngforest.github.io/2019/04/06/LeetCode-258-Add-Digits/",
            "title": "LeetCode 258 Add Digits",
            "date_published": "2019-04-06T09:08:06.000Z",
            "content_html": "<p>今天刷题的时候遇到一个有趣的题目，求一个数字各个位相加的和，知道和小于10。<a href=\"https://leetcode.com/problems/add-digits/description/\">链接</a>.<br />\n题目本身并不难，递归或者迭代都可以解决。但如何在O(1)的复杂度内求解，才是真正的考点。</p>\n<p>答案很简单: 1 + (num - 1) % 9.<br />\n有兴趣的可以看看证明和扩展: <a href=\"https://en.wikipedia.org/wiki/Digital_root#Congruence_formula\">wikipedia</a>.</p>\n",
            "tags": [
                "LeetCode"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/02/17/Queue-and-Stack/",
            "url": "https://youngforest.github.io/2019/02/17/Queue-and-Stack/",
            "title": "Queue and Stack",
            "date_published": "2019-02-17T09:33:33.000Z",
            "content_html": "<p>今天我们一起学习2种重要的数据结构：队列 和 栈。<br />\n本文根据LeetCode上的Explore教程 <a href=\"https://leetcode.com/explore/featured/card/queue-stack/\">Introduction to Data Structure - Queue &amp; Stack</a> 整理而成。</p>\n<h2 id=\"introduction\"><a class=\"markdownIt-Anchor\" href=\"#introduction\"></a> Introduction</h2>\n<p>最常用的Collection是数组(Array)，其最常使用的获取数据的操作是随机获取(Random access), 在C++中一般称作 subscribe。<br />\n但是有时，我们想要限制处理数据的顺序。最常见的限制是：先进先出(First in first out), 后进先出(Last in first out)。分别对应2种数据结构 队列(Queue) 和 栈(Stack)。</p>\n<p>我们从 定义、实现 和 每种数据结构的内置操作 分别学习 队列 和 栈。<br />\n学习目标：</p>\n<ol>\n<li>理解数据处理顺序FIFO和LIFO的原则；</li>\n<li>手动实现数据结构；</li>\n<li>熟悉语言内置的Queue和Stack；</li>\n<li>解决基础的Queue-related问题，尤其是BFS；</li>\n<li>解决基础的Stack-related问题；</li>\n<li>理解系统的栈如何帮助你，在解决dfs和其他递归问题的时候。</li>\n</ol>\n<h2 id=\"queue-first-in-first-out-data-structure\"><a class=\"markdownIt-Anchor\" href=\"#queue-first-in-first-out-data-structure\"></a> Queue: First-in-first-out Data Structure</h2>\n<h3 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\"></a> 定义</h3>\n<p>先进先出 最普遍的比喻是排队(也就是队列), 最早进入队列的人最早被服务到。<br />\n所以队列总共只有2个modify 方法：</p>\n<ul>\n<li>enqueue</li>\n<li>dequeue</li>\n</ul>\n<h3 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\"></a> 实现</h3>\n<p>Queue并不是基础的数据结构，我们可以用内置的数组来实现它。在C++中，Queue是container adapter, 并不是真正的container，其内部其实是deque。</p>\n<p>实现实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyQueue</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">// store elements</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; data;       </span><br><span class=\"line\">        <span class=\"comment\">// a pointer to indicate the start position</span></span><br><span class=\"line\">        <span class=\"type\">int</span> p_start;            </span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">MyQueue</span>() &#123;p_start = <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">        <span class=\"comment\">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">enQueue</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">            data.<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">deQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p_start++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">/** Get the front item from the queue. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Front</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data[p_start];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">/** Checks whether the queue is empty or not. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p_start &gt;= data.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    MyQueue q;</span><br><span class=\"line\">    q.<span class=\"built_in\">enQueue</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    q.<span class=\"built_in\">enQueue</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!q.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; q.<span class=\"built_in\">Front</span>() &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.<span class=\"built_in\">deQueue</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!q.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; q.<span class=\"built_in\">Front</span>() &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.<span class=\"built_in\">deQueue</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!q.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; q.<span class=\"built_in\">Front</span>() &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环队列-circular-queue\"><a class=\"markdownIt-Anchor\" href=\"#循环队列-circular-queue\"></a> 循环队列 Circular Queue</h3>\n<p>在之前的实现中，p_start之前的内存空间是被浪费掉的。为了充分利用，我们可以在内部使用循环利用array。</p>\n<p>Circular Queue也叫做&quot;Ring Buffer&quot;。</p>\n<p>Ring Buffer的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCircularQueue</span> &#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; data;</span><br><span class=\"line\">    <span class=\"type\">int</span> head;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class=\"line\">    <span class=\"built_in\">MyCircularQueue</span>(<span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        data.<span class=\"built_in\">insert</span>(data.<span class=\"built_in\">begin</span>(), k, <span class=\"number\">0</span>);</span><br><span class=\"line\">        head = <span class=\"number\">0</span>;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">enQueue</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isFull</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        data[(head + size) % data.<span class=\"built_in\">size</span>()] = value;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">deQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isEmpty</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head = (head + <span class=\"number\">1</span>) % data.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Get the front item from the queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Front</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isEmpty</span>()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[head];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Get the last item from the queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Rear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isEmpty</span>()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[(head + size - <span class=\"number\">1</span>) % data.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Checks whether the circular queue is empty or not. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Checks whether the circular queue is full or not. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == data.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyCircularQueue* obj = new MyCircularQueue(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_1 = obj-&gt;enQueue(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_2 = obj-&gt;deQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj-&gt;Front();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj-&gt;Rear();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_5 = obj-&gt;isEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_6 = obj-&gt;isFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"queue的应用\"><a class=\"markdownIt-Anchor\" href=\"#queue的应用\"></a> Queue的应用</h3>\n<p>最典型的应用，BFS。<br />\nBFS(Breadth-first Search)一般用来发现从根节点到目标节点的最短距离。</p>\n<p>应用BFS的场景：</p>\n<ul>\n<li>do traversal</li>\n<li>find the shortest path</li>\n</ul>\n<p>场景中常使用的数据结构：</p>\n<ul>\n<li>图</li>\n<li>树</li>\n</ul>\n<p>在具体应用中，BFS里的节点可能是<strong>真正的节点</strong>或<strong>状态</strong>，边可能是<strong>真正的边</strong>或<strong>状态间的转移</strong>。</p>\n<p>BFS的模版，一定要背下来，以后面试或做题提高速度和bug-free的可能。</p>\n<h4 id=\"template-1\"><a class=\"markdownIt-Anchor\" href=\"#template-1\"></a> template 1</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the length of the shortest path between root and target node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">BFS</span><span class=\"params\">(Node root, Node target)</span> &#123;</span><br><span class=\"line\">    Queue&lt;Node&gt; queue;  <span class=\"comment\">// store all nodes which are waiting to be processed</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;       <span class=\"comment\">// number of steps neeeded from root to current node</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    add root to queue;</span><br><span class=\"line\">    <span class=\"comment\">// BFS</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue is not empty) &#123;</span><br><span class=\"line\">        step = step + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// iterate the nodes which are already in the queue</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> the first node in queue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">                add next to queue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            remove the first node from queue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;          <span class=\"comment\">// there is no path from root to target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"template-2\"><a class=\"markdownIt-Anchor\" href=\"#template-2\"></a> template 2</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the length of the shortest path between root and target node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">BFS</span><span class=\"params\">(Node root, Node target)</span> &#123;</span><br><span class=\"line\">    Queue&lt;Node&gt; queue;  <span class=\"comment\">// store all nodes which are waiting to be processed</span></span><br><span class=\"line\">    Set&lt;Node&gt; visited;  <span class=\"comment\">// store all the nodes that we&#x27;ve visited</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;       <span class=\"comment\">// number of steps neeeded from root to current node</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    add root to queue;</span><br><span class=\"line\">    add root to visited;</span><br><span class=\"line\">    <span class=\"comment\">// BFS</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue is not empty) &#123;</span><br><span class=\"line\">        step = step + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// iterate the nodes which are already in the queue</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> the first node in queue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next is not in used) &#123;</span><br><span class=\"line\">                    add next to queue;</span><br><span class=\"line\">                    add next to visited;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                remove the first node from queue;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;          <span class=\"comment\">// there is no path from root to target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在每一轮中，队列中的节点都是等待被处理的。</li>\n<li>没经历一次外层的while循环，都离root更远一步， step++。</li>\n</ol>\n<h4 id=\"template-2-2\"><a class=\"markdownIt-Anchor\" href=\"#template-2-2\"></a> template 2</h4>\n<p>在图中，确保每个节点不被多次访问很重要。否则BFS会陷入无限循环。此时，我们增加一个<code>hashset</code>用来标注是否节点已经被访问到。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the length of the shortest path between root and target node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">BFS</span><span class=\"params\">(Node root, Node target)</span> &#123;</span><br><span class=\"line\">    Queue&lt;Node&gt; queue;  <span class=\"comment\">// store all nodes which are waiting to be processed</span></span><br><span class=\"line\">    Set&lt;Node&gt; visited;  <span class=\"comment\">// store all the nodes that we&#x27;ve visited</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;       <span class=\"comment\">// number of steps neeeded from root to current node</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    add root to queue;</span><br><span class=\"line\">    add root to visited;</span><br><span class=\"line\">    <span class=\"comment\">// BFS</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue is not empty) &#123;</span><br><span class=\"line\">        step = step + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// iterate the nodes which are already in the queue</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> the first node in queue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next is not in used) &#123;</span><br><span class=\"line\">                    add next to queue;</span><br><span class=\"line\">                    add next to visited;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            remove the first node from queue;   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;          <span class=\"comment\">// there is no path from root to target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>什么情况下可以不使用visited呢？</p>\n<ol>\n<li>你确定不会出现重复访问的情况。比如，遍历树的时候。</li>\n<li>你确实想要把一个节点加入队列多次。</li>\n</ol>\n<h2 id=\"栈-stack\"><a class=\"markdownIt-Anchor\" href=\"#栈-stack\"></a> 栈 Stack</h2>\n<p>提到栈，我就想起周杰伦的《七里香》。歌中唱到，</p>\n<blockquote>\n<p>雨下整夜，我的栈溢出就像雨水。</p>\n</blockquote>\n<p>在LIFO数据结构中，最新被添加的元素最早被处理。在栈中，添加元素的操作叫做push(压栈)，移除元素的操作叫做pop（弹出）。虽然在C++中，queue的操作也是同样的名字，但在大多数语言中，push 和 pop是stack专有的。</p>\n<p>像队列一样，绝大多数语言提供了built-in的stack库，你不需要重复造轮子，只需要熟悉stack的常用操作，包括 push, pop, top（获取栈顶元素）。</p>\n<h3 id=\"单调栈的应用\"><a class=\"markdownIt-Anchor\" href=\"#单调栈的应用\"></a> 单调栈的应用</h3>\n<p><a href=\"https://leetcode.com/explore/featured/card/queue-stack/230/usage-stack/1363/\">https://leetcode.com/explore/featured/card/queue-stack/230/usage-stack/1363/</a></p>\n<p>Intution: 维护一个单调递减的栈，遍历一遍数组T，如果将其放入栈中，把栈中比它小的元素都pop出来，并计算出相应的间隔。</p>\n<p>时间复杂度：O(n),<br />\n空间复杂度: O(n).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dailyTemperatures</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(T.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        stack&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; s; <span class=\"comment\">// temperature, day</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; T.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>() &amp;&amp; s.<span class=\"built_in\">top</span>().first &lt; T[i]) &#123;</span><br><span class=\"line\">                pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; current = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                result[current.second] = i - current.second;</span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(&#123;T[i], i&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"stack-和-dfs\"><a class=\"markdownIt-Anchor\" href=\"#stack-和-dfs\"></a> stack 和 DFS</h3>\n<p>DFS是stack的重要应用之一，可以用来寻找从根节点到目标节点的路径(注意不一定是最短)。DFS是回溯的一种算法，只有到达最深的节点才进行回溯，尝试其他路径。</p>\n<h4 id=\"dfs-模版-1递归版本\"><a class=\"markdownIt-Anchor\" href=\"#dfs-模版-1递归版本\"></a> DFS 模版 1，递归版本</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Return true if there is a path from cur to target.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">DFS</span><span class=\"params\">(Node cur, Node target, Set&lt;Node&gt; visited)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (next : each neighbor of cur) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next is not in visited) &#123;</span><br><span class=\"line\">            add next to visted;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"keyword\">if</span> <span class=\"title function_\">DFS</span><span class=\"params\">(next, target, visited)</span> == <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"dfs-模版-2迭代版本\"><a class=\"markdownIt-Anchor\" href=\"#dfs-模版-2迭代版本\"></a> DFS 模版 2，迭代版本</h4>\n<p>递归版本的优点是实现起来更加简单。缺点是，如果递归深度太深，会stack overflow。<br />\n这时，你可能会想要用 BFS 或者 用显式的栈实现DFS。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Return true if there is a path from cur to target.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">DFS</span><span class=\"params\">(<span class=\"type\">int</span> root, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">    Set&lt;Node&gt; visited;</span><br><span class=\"line\">    Stack&lt;Node&gt; stack;</span><br><span class=\"line\">    add root to stack;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (s is not empty) &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> the top element in stack;</span><br><span class=\"line\">        remove the cur from the stack;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next is not in visited) &#123;</span><br><span class=\"line\">                add next to visited;</span><br><span class=\"line\">                add next to stack;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的逻辑和递归解法相同。只不过我们使用<code>while</code>循环和显式的<code>stack</code>来模仿系统栈。</p>\n<h3 id=\"implement-queue-using-stacks\"><a class=\"markdownIt-Anchor\" href=\"#implement-queue-using-stacks\"></a> <a href=\"https://leetcode.com/explore/featured/card/queue-stack/239/conclusion/1386/\">Implement Queue using Stacks</a></h3>\n<p>用栈来实现队列。<br />\n我记得在程序员面试金典上遇到过一样的题目，感觉是一道很经典的题目。需要面试者对队列和栈都非常熟悉才行。</p>\n<p>Intuition: 队列是FIFO，栈是LIFO，所以我们可以用2个栈来实现一个队列。定义将一个栈装入另一个栈的操作为<strong>颠倒</strong>。我们可以通过<strong>颠倒</strong>, 将LIFO变为FIFO，而且只有在需要dequeue的时候，才需要做颠倒的操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyQueue</span> &#123;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; a, b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"built_in\">MyQueue</span>() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        a.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!a.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                b.<span class=\"built_in\">push</span>(a.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">                a.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = b.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        b.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!a.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                b.<span class=\"built_in\">push</span>(a.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">                a.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.<span class=\"built_in\">empty</span>() &amp;&amp; b.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyQueue obj = new MyQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.peek();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"implement-stack-using-queues\"><a class=\"markdownIt-Anchor\" href=\"#implement-stack-using-queues\"></a> <a href=\"https://leetcode.com/explore/featured/card/queue-stack/239/conclusion/1387/\">Implement Stack using Queues</a></h3>\n<p>那么如何用FIFO实现LIFO呢？解法可能不是那么明显，但却十分简单。每次push时，都把队列里的元素重新入对一遍，就把最后入对的放到第一个位置了。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h2>\n<p>dfs 和 bfs 属于想法简单，但实现起来不容易，尤其是bug-free并且快速地实现更属不易。<br />\n由于考察的编程基础涉及广泛，面试官也特别喜欢考类似的题目。几个模版必须熟练背会才行。</p>\n<p>队 和 栈 更是基础的数据结构。在计算机科学中随处可见，虽然很多时候不会直接考察，但很多算法都要用到。熟练手写stack 和 queue 和使用built-in的stack 和 queue是每个合格程序员的基础。</p>\n",
            "tags": [
                "LeetCode"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/02/11/recursion/",
            "url": "https://youngforest.github.io/2019/02/11/recursion/",
            "title": "recursion",
            "date_published": "2019-02-11T04:58:52.000Z",
            "content_html": "<p>本文根据LeetCode上的教程 <a href=\"https://leetcode.com/explore/learn/card/recursion-i/\">Introduction to Algorithms - Recursion I</a> 整理而成。目的在于帮助笔者自己更熟悉“递归”这一重要的编程概念，如果能够同时对他人产生帮助，那更好不过了。</p>\n<p>本文的结构和LeetCode上的完全相同，分为 简介、递归原则、复现关系、备忘录、复杂度分析、总结 6个部分。</p>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>本Card的目的，回答以下问题：</p>\n<ol>\n<li>什么是递归？递归如何工作？</li>\n<li>如何递归地解决一个问题？</li>\n<li>如何分析一个递归算法的时间复杂度和空间复杂度？</li>\n<li>如何以一种更好的方式应用递归？</li>\n</ol>\n<h2 id=\"递归的原理\"><a class=\"markdownIt-Anchor\" href=\"#递归的原理\"></a> 递归的原理</h2>\n<p>每次递归函数调用自身，都将给定问题变为子问题。递归过程一直继续指导子问题可以不通过进一步递归就可以直接解决。</p>\n<p>递归函数避免无限递归的必要属性：</p>\n<ol>\n<li>递归结束条件(<strong>base cases</strong>)</li>\n<li>一套规则(<strong>recurrence relation</strong>)，可以将所有其他的cases规约为base cases。</li>\n</ol>\n<p>递归函数中可以有多个地方调用本身。</p>\n<h3 id=\"例子-翻转字符串\"><a class=\"markdownIt-Anchor\" href=\"#例子-翻转字符串\"></a> 例子 翻转字符串</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printReverse</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*str) <span class=\"keyword\">return</span>;  <span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"built_in\">printReverse</span>(str + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(*str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归函数\"><a class=\"markdownIt-Anchor\" href=\"#递归函数\"></a> 递归函数</h3>\n<p>如果一个问题存在递归解法，我们就可以遵循下列步骤去实现它。</p>\n<p>我们定义该问题为函数<code>F(x)</code>可以实现，其中<code>X</code>是函数的输入，同时表示了问题的范围。</p>\n<p>在函数<code>F(X)</code>中，我们实现以下步骤：</p>\n<ol>\n<li>将问题拆分成更小的范围，<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \\belong at position 5: x_1 \\̲b̲e̲l̲o̲n̲g̲ ̲X, x_2 \\belong …'>x_1 \\belong X, x_2 \\belong X, ..., x_n \\belong X</span>.</li>\n<li>递归调用函数<code>F(x_1), F(x_2), ..., F(x_n)</code>以解决<code>X</code>的子问题。</li>\n<li>最后，处理子问题的解，组合成对应<code>X</code>的解。</li>\n</ol>\n<h2 id=\"recurrence-relation\"><a class=\"markdownIt-Anchor\" href=\"#recurrence-relation\"></a> Recurrence Relation</h2>\n<p>定义：一个问题的解和其子问题的解之间的关系。</p>\n<h3 id=\"例子pascals-triangle\"><a class=\"markdownIt-Anchor\" href=\"#例子pascals-triangle\"></a> 例子：Pascal’s Triangle</h3>\n<p>定义：杨辉三角是一系列数字组成三角形的形状。在杨辉三角中，每行最左和最右的数字永远是1. 对于剩余的数字，每个数字是它前一行正上方2个数字之和。</p>\n<p>用数学公式表达出来就是，Recurrence Relation为<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">f(i, j) = f(i-1, j-1) + f(i-1, j),</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span></span></span></span></p>\n<p>base cases为：<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>i</mi><mi>f</mi><mi>j</mi><mo>=</mo><mn>1</mn><mi>o</mi><mi>r</mi><mi>j</mi><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">f(i, j) = 1, if j = 1 or j = i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>.</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i, j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>表示第i行第j个数。</p>\n<h2 id=\"memoization-备忘录\"><a class=\"markdownIt-Anchor\" href=\"#memoization-备忘录\"></a> Memoization 备忘录</h2>\n<h3 id=\"递归过程中重复的计算\"><a class=\"markdownIt-Anchor\" href=\"#递归过程中重复的计算\"></a> 递归过程中重复的计算</h3>\n<p>递归解法常常是十分<strong>符合直觉</strong>和<strong>容易编码</strong>的。但大多数时候，在递归过程中，重复计算导致了性能上的损失。</p>\n<p><strong>备忘录法(Memoization)</strong><br />\n即是一个通用的避免重复计算的技术。<br />\n是的，这个词没有拼错，不是Memorization。</p>\n<p>定义：为了避免重复计算，我们可以在一个cache中存储中间子问题的结果，以便之后再次使用它们的时候不需要重复计算。</p>\n<p>备忘录的实现可以通过hashmap实现。尤其是在OOP中，利用装饰器可以实现通用的Memoization。</p>\n<h3 id=\"例子-斐波那契数\"><a class=\"markdownIt-Anchor\" href=\"#例子-斐波那契数\"></a> 例子 斐波那契数</h3>\n<p><a href=\"https://leetcode.com/articles/climbing-stairs/\">斐波那契数的多种解法</a>，其中有时间复杂度为O(log n)的<strong>Binets法</strong>和<strong>公式法</strong>，令人印象十分深刻.</p>\n<h2 id=\"complexity-analysis-复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#complexity-analysis-复杂度分析\"></a> Complexity Analysis 复杂度分析</h2>\n<p>递归算法的复杂度有时候不是显而易见的，要通过一些套路分析。</p>\n<p>尾递归是一种特殊的技术，可以消减递归栈的使用，优化空间复杂度，使其和迭代算法相同。</p>\n<h3 id=\"time-complexity-时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#time-complexity-时间复杂度\"></a> Time Complexity 时间复杂度</h3>\n<p>递归算法的时间复杂度为：<br />\nO(T) = R * O(s),<br />\n其中，R为递归调用的数量，O(s)为每次递归调用产生的计算复杂度。<br />\n一般来说，R更难算一点，O(s)的计算和非递归算法的时间复杂度分析一样。</p>\n<p>借助execution tree的技术，我们可以更好地分析递归调用的数量。<br />\nexecution tree是展示具体情况下递归调用流的一棵树，每个节点代表一次调用，节点上的值表示调用时的参数。<br />\n这棵树的节点数目就是R。</p>\n<p>需要特别注意的是，当使用Memoization技术时，execution tree的变化。</p>\n<h3 id=\"space-complexity-空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#space-complexity-空间复杂度\"></a> Space Complexity 空间复杂度</h3>\n<p>递归算法的空间使用主要分为2部分：</p>\n<ol>\n<li>recursion related</li>\n<li>non-recursion related</li>\n</ol>\n<h4 id=\"recursion-related\"><a class=\"markdownIt-Anchor\" href=\"#recursion-related\"></a> recursion related</h4>\n<p>学过编译原理的我们都知道，每次函数调用都要在栈上压入：</p>\n<ol>\n<li>函数的返回地址</li>\n<li>函数参数</li>\n<li>函数的本地变量</li>\n</ol>\n<p>递归算法的函数调用栈的深度是从初始case到base case.</p>\n<h4 id=\"non-recursion-related\"><a class=\"markdownIt-Anchor\" href=\"#non-recursion-related\"></a> non-recursion related</h4>\n<p>全局变量使用的空间，主要在堆上分配。比如，memoization 要使用的hashmap。</p>\n<h3 id=\"tail-recursion-尾递归\"><a class=\"markdownIt-Anchor\" href=\"#tail-recursion-尾递归\"></a> Tail Recursion 尾递归</h3>\n<p>尾递归是一种递归调用是递归函数的最后指令，而且函数中只有一个递归调用。</p>\n<p>尾递归的一个很好的例子。注意，non_tail_recursion在最后的递归调用后还有计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">helper_non_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= ls.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// not a tail recursion because it does some computation after the recursive call returned.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ls[start] + helper_non_tail_recursion(start+<span class=\"number\">1</span>, ls);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">sum_non_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ls == <span class=\"literal\">null</span> || ls.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_non_tail_recursion(<span class=\"number\">0</span>, ls);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//---------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">helper_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> [] ls, <span class=\"type\">int</span> acc)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= ls.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// this is a tail recursion because the final instruction is the recursive call.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_tail_recursion(start+<span class=\"number\">1</span>, ls, acc+ls[start]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">sum_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ls == <span class=\"literal\">null</span> || ls.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_tail_recursion(<span class=\"number\">0</span>, ls, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尾递归消除递归栈的原理：<br />\n编译器知道在从callee中返回之后，会立刻再次返回，不需要再利用函数调用栈中保存的数据。只需要一个栈帧就可以了，所有层共用一个栈帧，所以返回时可以跳过整个递归栈。</p>\n<p>并不是所有语言的编译器都支持尾递归优化的。比如，C, C++支持，而Python, Java不支持。</p>\n<p>尾递归通常也不是那么好实现。需要<br />\n递归调用只出现在最后一个指令，如果需要调用多个函数，或是对返回值进行计算，就没法尾递归了。</p>\n<p>而且细心的同学可以发现尾递归和迭代(loop)的相似之处。事实上，有些函数式编程语言甚至不支持loop，只有递归，完全可以实现迭代。因为我们平时使用loop居多，尾递归很少。如果需要写尾递归时（一般是在一些面试的要求中），可以先写loop版本的代码。然后试着把其中的局部变量更新改成尾递归中的参数，往往就可以写出优雅的（但对于大多数人可读性并不高）的尾递归代码了。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h2>\n<p>解决递归问题的套路：</p>\n<ol>\n<li>定义递归函数</li>\n<li>写下recurrence relation和base case</li>\n<li>使用Memoization消除重复计算，如果存在的话</li>\n<li>如果可能的话，使用尾递归实现递归算法，以消减空间复杂度</li>\n</ol>\n",
            "tags": [
                "Algorithm",
                "LeetCode"
            ]
        },
        {
            "id": "https://youngforest.github.io/2018/10/26/LeetCode-380-Insert-Delete-GetRandomO-1/",
            "url": "https://youngforest.github.io/2018/10/26/LeetCode-380-Insert-Delete-GetRandomO-1/",
            "title": "LeetCode #380 Insert Delete GetRandom O(1)",
            "date_published": "2018-10-26T15:19:20.000Z",
            "content_html": "<p>此题的重点在于理解“average O(1) time”，这是也是时间复杂度分析中的一个重要概念&quot;amortized&quot;。<br />\n在 算法第4版 中，很多数据结构的操作的分析都是用的这个方法。所以，“amortized time complexity&quot;常常和对应的数据结构的操作相对应。我5月时面试旷世科技的时候，第二题问的是构造一个维护最大值的队的数据结构，最后要求操作的时间复杂度是“amortized O(1)&quot;。很遗憾，当时我对“amortized&quot;这一概念还不熟悉，对最差情况下的时间复杂度分析的倒是可以，虽然在面试官的引导下最后得出正确答案，但可想而知，最后的结果是no hire。</p>\n<p>Description: <a href=\"https://leetcode.com/problems/insert-delete-getrandom-o1/description/\">https://leetcode.com/problems/insert-delete-getrandom-o1/description/</a><br />\nSolution: None<br />\nDifficulty: Medium</p>\n<p><a href=\"https://leetcode.com/problems/insert-delete-getrandom-o1/discuss/85401/Java-solution-using-a-HashMap-and-an-ArrayList-along-with-a-follow-up.-(131-ms)\">answer</a></p>\n<p>关键点在于，利用hashmap查找效率为O(1),ArrayList很方便用下标来产生随机数。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">RandomizedSet</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Initialize your data structure here.</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.array = []</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.index_map = &#123;&#125;</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">insert</span>(<span class=\"params\">self, val</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class=\"line\"><span class=\"string\">        :type val: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> val <span class=\"keyword\">in</span> <span class=\"variable language_\">self</span>.index_map:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.index_map[val] = <span class=\"built_in\">len</span>(<span class=\"variable language_\">self</span>.array)</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.array.append(val)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">remove</span>(<span class=\"params\">self, val</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class=\"line\"><span class=\"string\">        :type val: int</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: bool</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> val <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> <span class=\"variable language_\">self</span>.index_map:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.array[<span class=\"variable language_\">self</span>.index_map[val]] = <span class=\"variable language_\">self</span>.array[-<span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.index_map[<span class=\"variable language_\">self</span>.array[-<span class=\"number\">1</span>]] = <span class=\"variable language_\">self</span>.index_map[val]</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.array.pop()</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.index_map.pop(val)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">getRandom</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        Get a random element from the set.</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: int</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        rnd = random.randint(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(<span class=\"variable language_\">self</span>.array)-<span class=\"number\">1</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">self</span>.array[rnd]</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"># obj = RandomizedSet()</span></span><br><span class=\"line\"><span class=\"comment\"># param_1 = obj.insert(val)</span></span><br><span class=\"line\"><span class=\"comment\"># param_2 = obj.remove(val)</span></span><br><span class=\"line\"><span class=\"comment\"># param_3 = obj.getRandom()</span></span><br></pre></td></tr></table></figure>",
            "tags": [
                "LeetCode"
            ]
        },
        {
            "id": "https://youngforest.github.io/2018/10/25/LeetCode-15-3Sum/",
            "url": "https://youngforest.github.io/2018/10/25/LeetCode-15-3Sum/",
            "title": "LeetCode #15 3Sum",
            "date_published": "2018-10-25T15:54:23.000Z",
            "content_html": "<p>这道很经典的题目我恰好在面试“景驰”的时候遇到过，当时是二面的Eric问的。我没做过这道题，但与之关联的2Sum做过（毕竟是LeetCode的首题，大概很多人都做过）。而且算法第4版中讨论算法复杂度的时候，用的也是一样的问题（细节可能不同，比如要求了结果中没有重复的triplet…），当时还有些印象。顺利地写出了O(n^2)时间复杂度的Solution，虽然事后发现有些小bug，比如list的sort是inplace的。但无伤大雅。<br />\n今天我把面试时的solution整理了一下，submit后竟然Time Limit Exceeded了。</p>\n<p>Description: <a href=\"https://leetcode.com/problems/3sum/description/\">https://leetcode.com/problems/3sum/description/</a><br />\nSolution: None<br />\nDifficulty: Medium</p>\n<h2 id=\"面试时的solution\"><a class=\"markdownIt-Anchor\" href=\"#面试时的solution\"></a> 面试时的solution</h2>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">threeSum</span>(<span class=\"params\">self, nums</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        mymap = &#123;&#125;</span><br><span class=\"line\">        results = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i + <span class=\"number\">1</span>, <span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> - nums[i] - nums[j] <span class=\"keyword\">in</span> mymap:</span><br><span class=\"line\">                    a = [- nums[i] - nums[j], nums[i], nums[j]]</span><br><span class=\"line\">                    a.sort()</span><br><span class=\"line\">                    results.add(<span class=\"built_in\">tuple</span>(a))</span><br><span class=\"line\">            mymap[nums[i]] = i</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">            re.append(<span class=\"built_in\">list</span>(a))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re</span><br></pre></td></tr></table></figure>\n<h2 id=\"解决超时问题\"><a class=\"markdownIt-Anchor\" href=\"#解决超时问题\"></a> 解决超时问题</h2>\n<p>reference[<a href=\"https://fizzbuzzed.com/top-interview-questions-1/\">https://fizzbuzzed.com/top-interview-questions-1/</a>]</p>\n<p>总的思想是，O(n^2)的时间复杂度已经不能再低了。更多的是尝试一些小的技巧，降低时间复杂度中的常数。</p>\n<h3 id=\"先排序\"><a class=\"markdownIt-Anchor\" href=\"#先排序\"></a> 先排序</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">threeSum</span>(<span class=\"params\">self, nums</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        mymap = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">        results = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &gt; <span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[i] == nums[i-<span class=\"number\">2</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(i + <span class=\"number\">1</span>, <span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> j != i + <span class=\"number\">1</span> <span class=\"keyword\">and</span> nums[j] == nums[j-<span class=\"number\">1</span>]:</span><br><span class=\"line\">                    <span class=\"keyword\">continue</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> - nums[i] - nums[j] <span class=\"keyword\">in</span> mymap:</span><br><span class=\"line\">                    a = [- nums[i] - nums[j], nums[i], nums[j]]</span><br><span class=\"line\">                    a.sort()</span><br><span class=\"line\">                    results.add(<span class=\"built_in\">tuple</span>(a))</span><br><span class=\"line\">            mymap.add(nums[i])</span><br><span class=\"line\">        </span><br><span class=\"line\">        re = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> a <span class=\"keyword\">in</span> results:</span><br><span class=\"line\">            re.append(<span class=\"built_in\">list</span>(a))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> re</span><br></pre></td></tr></table></figure>\n<p>增加了排序，和2层循环中的判断，使得重复的triplet出现的次数更少(<code>result.add(tuple(a))</code>被执行的次数更少)。<br />\n观察之前TLE的Test case可以发现，leetcode卡了重复的triplet这块。python <code>set.add</code>操作的时间复杂度为O(1)，所以还是被卡了常数。</p>\n<h3 id=\"two-pointer-空间复杂度降为o1\"><a class=\"markdownIt-Anchor\" href=\"#two-pointer-空间复杂度降为o1\"></a> two pointer, 空间复杂度降为O(1)</h3>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">threeSum</span>(<span class=\"params\">self, nums</span>):</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">        :type nums: List[int]</span></span><br><span class=\"line\"><span class=\"string\">        :rtype: List[List[int]]</span></span><br><span class=\"line\"><span class=\"string\">        &quot;&quot;&quot;</span></span><br><span class=\"line\">        nums.sort()</span><br><span class=\"line\">        results = []</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(nums)):</span><br><span class=\"line\">            <span class=\"comment\"># never let i refer to the same value twice</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i != <span class=\"number\">0</span> <span class=\"keyword\">and</span> nums[i] == nums[i-<span class=\"number\">1</span>]:</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">                </span><br><span class=\"line\">            j = i + <span class=\"number\">1</span></span><br><span class=\"line\">            k = <span class=\"built_in\">len</span>(nums) - <span class=\"number\">1</span></span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">while</span> j &lt; k:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> nums[i] + nums[j] + nums[k] == <span class=\"number\">0</span>:</span><br><span class=\"line\">                    results.append([nums[i], nums[j], nums[k]])</span><br><span class=\"line\">                    j += <span class=\"number\">1</span></span><br><span class=\"line\">                    k -= <span class=\"number\">1</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span> j &lt; k <span class=\"keyword\">and</span> nums[j] == nums[j-<span class=\"number\">1</span>]: <span class=\"comment\"># never let j refer the same value twice</span></span><br><span class=\"line\">                        j += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">elif</span> nums[i] + nums[j] + nums[k] &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                    j += <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    k -= <span class=\"number\">1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> results</span><br></pre></td></tr></table></figure>\n<p>第一次提交上去仍然是超时，然而啥也没改再次提交就Accepted了。看来leetcode也是看脸。</p>\n",
            "tags": [
                "LeetCode"
            ]
        }
    ]
}