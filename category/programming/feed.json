{
    "version": "https://jsonfeed.org/version/1",
    "title": "YoungForest's blog • All posts by \"programming\" category",
    "description": "佛系更新；生活、学习",
    "home_page_url": "https://youngforest.github.io",
    "items": [
        {
            "id": "https://youngforest.github.io/2023/07/01/Codeforces-Educational-Codeforces-Round-151/",
            "url": "https://youngforest.github.io/2023/07/01/Codeforces-Educational-Codeforces-Round-151/",
            "title": "Codeforces Educational Codeforces Round 151",
            "date_published": "2023-07-01T15:33:20.000Z",
            "content_html": "<p><a href=\"https://codeforces.com/contest/1845\">比赛链接</a><br />\n<a href=\"https://codeforces.com/blog/entry/117791\">官方题解</a></p>\n<p>做出了前2题，卡在第三题了。<br />\nRating change: 1407 -&gt; 1378</p>\n<h2 id=\"a-forbidden-integer\"><a class=\"markdownIt-Anchor\" href=\"#a-forbidden-integer\"></a> <a href=\"https://codeforces.com/contest/1845/problem/A\">A. Forbidden Integer</a></h2>\n<p>分类讨论。如果可以选1的话，那肯定可以组成任意数字。<br />\n如果不能的话，可以选2和3，也可以组成除1以外任意的数字。<br />\n如果只能选2的话，那么只能组成偶数。</p>\n<p>时间复杂度: O(t * n),</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(t):</span><br><span class=\"line\">    n, k, x = <span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, <span class=\"built_in\">input</span>().split())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> k == <span class=\"number\">1</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;NO&#x27;</span>)</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">elif</span> k == <span class=\"number\">2</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> n % <span class=\"number\">2</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;YES&#x27;</span>)</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(n//<span class=\"number\">2</span>)</span><br><span class=\"line\">                <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n//<span class=\"number\">2</span>):</span><br><span class=\"line\">                    <span class=\"built_in\">print</span>(<span class=\"number\">2</span>, end=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">                <span class=\"built_in\">print</span>()</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;NO&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;YES&#x27;</span>)</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(n//<span class=\"number\">2</span>)</span><br><span class=\"line\">            <span class=\"keyword\">while</span> n &gt; <span class=\"number\">3</span>:</span><br><span class=\"line\">                <span class=\"built_in\">print</span>(<span class=\"number\">2</span>, end=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">                n -= <span class=\"number\">2</span></span><br><span class=\"line\">            <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;YES&#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">            <span class=\"built_in\">print</span>(<span class=\"number\">1</span>, end=<span class=\"string\">&#x27; &#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>()</span><br></pre></td></tr></table></figure>\n<h2 id=\"b-come-together\"><a class=\"markdownIt-Anchor\" href=\"#b-come-together\"></a> <a href=\"https://codeforces.com/contest/1845/problem/B\">B. Come Together</a></h2>\n<p>分类讨论，B，C 在不同象限，最长公用路线不同。</p>\n<p>时间复杂度: O(t),<br />\n空间复杂度: O(1).</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">t = <span class=\"built_in\">int</span>(<span class=\"built_in\">input</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(t):</span><br><span class=\"line\">    A = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, <span class=\"built_in\">input</span>().split()))</span><br><span class=\"line\">    B = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, <span class=\"built_in\">input</span>().split()))</span><br><span class=\"line\">    C = <span class=\"built_in\">list</span>(<span class=\"built_in\">map</span>(<span class=\"built_in\">int</span>, <span class=\"built_in\">input</span>().split()))</span><br><span class=\"line\">    B[<span class=\"number\">0</span>] = B[<span class=\"number\">0</span>] - A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    B[<span class=\"number\">1</span>] = B[<span class=\"number\">1</span>] - A[<span class=\"number\">1</span>]</span><br><span class=\"line\">    C[<span class=\"number\">0</span>] = C[<span class=\"number\">0</span>] - A[<span class=\"number\">0</span>]</span><br><span class=\"line\">    C[<span class=\"number\">1</span>] = C[<span class=\"number\">1</span>] - A[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># if B and C are in the same quadrant</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (B[<span class=\"number\">0</span>] * C[<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> B[<span class=\"number\">1</span>] * C[<span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>) \\</span><br><span class=\"line\">        <span class=\"keyword\">or</span> (B[<span class=\"number\">0</span>] * C[<span class=\"number\">0</span>] == <span class=\"number\">0</span> <span class=\"keyword\">and</span> B[<span class=\"number\">1</span>] * C[<span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>) \\</span><br><span class=\"line\">        <span class=\"keyword\">or</span> (B[<span class=\"number\">0</span>] * C[<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> B[<span class=\"number\">1</span>] * C[<span class=\"number\">1</span>] == <span class=\"number\">0</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(B[<span class=\"number\">0</span>]), <span class=\"built_in\">abs</span>(C[<span class=\"number\">0</span>])) + <span class=\"number\">1</span> + <span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(B[<span class=\"number\">1</span>]), <span class=\"built_in\">abs</span>(C[<span class=\"number\">1</span>])) + <span class=\"number\">1</span> - <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> B[<span class=\"number\">0</span>] * C[<span class=\"number\">0</span>] &lt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> B[<span class=\"number\">1</span>] * C[<span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>: <span class=\"comment\"># the same side but different quadrant</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(B[<span class=\"number\">1</span>]), <span class=\"built_in\">abs</span>(C[<span class=\"number\">1</span>])) + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> B[<span class=\"number\">0</span>] * C[<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span> <span class=\"keyword\">and</span> B[<span class=\"number\">1</span>] * C[<span class=\"number\">1</span>] &lt;= <span class=\"number\">0</span>: <span class=\"comment\"># the same side but different quadrant</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"built_in\">min</span>(<span class=\"built_in\">abs</span>(B[<span class=\"number\">0</span>]), <span class=\"built_in\">abs</span>(C[<span class=\"number\">0</span>])) + <span class=\"number\">1</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>: <span class=\"comment\"># opposite quadrant</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-strong-password\"><a class=\"markdownIt-Anchor\" href=\"#c-strong-password\"></a> <a href=\"https://codeforces.com/contest/1845/problem/C#\">C. Strong Password</a></h2>\n<p>暴力方法很简单，回溯枚举所有符合l, r限制的密码，然后判断是否是s的子序列。<br />\n然而，回溯这步时间复杂度就是对数的了。</p>\n<p>正确的解法是贪心，对于每个位置，尽量取其在s中最靠右的数。<br />\n时间复杂度: O(m*D + n), n = s.length, D = r_i - l_i = 10</p>\n",
            "tags": [
                "codeforces",
                "contest"
            ]
        },
        {
            "id": "https://youngforest.github.io/2020/05/27/best-implement-to-use-pair-as-key-to-std-unordered-map-in-C/",
            "url": "https://youngforest.github.io/2020/05/27/best-implement-to-use-pair-as-key-to-std-unordered-map-in-C/",
            "title": "Best implement to use pair as key to std::unordered_map in C++",
            "date_published": "2020-05-27T11:29:34.000Z",
            "content_html": "<p>Reference: <a href=\"https://www.mica.edu.vn/perso/Vu-Hai/EE3490/Ref/The%20C++Standard%20Library%20-%202nd%20Edition.pdf\">C++ Standard Library: A tutorial and reference, Second version</a> Chapter 7.9.2: Creating and Controlling unordered Container</p>\n<p>All solutions I found in Google use <code>XOR</code> to generate hashcode of <code>pair</code>, which is totally bad. see <a href=\"https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\">why-is-xor-the-default-way-to-combine-hashes</a>. However, the book has given us the best solution, using <code>hash_combine</code>, which is taken from <code>Boost</code>. The solution is much better than XOR when I tested it in Online Judge(<a href=\"https://atcoder.jp/contests/abc168/tasks/abc168_e\">Atcoder</a>). I organized the code as a template as follow. You can copy and paste it as much as you can. And it is convenient to change it to fit any custom struct/class.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// from boost (functional/hash):</span></span><br><span class=\"line\"><span class=\"comment\">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_combine</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    seed ^= std::<span class=\"built_in\">hash</span>&lt;T&gt;()(val) + <span class=\"number\">0x9e3779b9</span> + (seed &lt;&lt; <span class=\"number\">6</span>) + (seed &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// auxiliary generic functions to create a hash value using a seed</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> std::<span class=\"type\">size_t</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"type\">size_t</span> seed = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">pair_hash</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\">    <span class=\"function\">std::<span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hash_val</span>(p.first, p.second);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;</span><br><span class=\"line\">    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>There is a hash implementation for <code>Tuple</code>. I updated the answer in<a href=\"https://stackoverflow.com/a/62035742/6393787\">StackOverflow</a>。Please go there if you need hash tuple.</p>\n",
            "tags": [
                "C++",
                "hash",
                "unordered_map",
                "English"
            ]
        },
        {
            "id": "https://youngforest.github.io/2020/05/27/unordered-map-hash-pair-c/",
            "url": "https://youngforest.github.io/2020/05/27/unordered-map-hash-pair-c/",
            "title": "pair 作为 unordered_map unordered_set 的键值 C++",
            "date_published": "2020-05-27T10:57:01.000Z",
            "content_html": "<p>今天在做<a href=\"https://atcoder.jp/contests/abc168/tasks/abc168_e\">一道AtCoder的题目</a>，有个test case一直TLE。研究这个测试用例和其他用例的区别，苦思不得其解。后来把unordered_map换成map就过了。虽然在小数据集上hashmap和treemap区别不大，但数据量大的话，hashmap还是好些。所以最佳实践是，在不需要排序特性时，就用hashmap。<br />\n而且之前也从来没有遇到过hashmap比treemap效果差这么多的原因。最后花了一上午时间，才定位到是我的 pair 的hash函数实现太糟糕了。因为C++ STL中并没有pair的hash特化，所以如果想把pair当作键用在unordered_map中的话，就需要自己实现hash函数。我直接从网上抄了一个实现, 直接将 <code>std::hash&lt;T&gt;()(pair.first) ^ std::hash&lt;U&gt;()(pair.second)</code>。为了避免误人子弟，我就不贴代码了。正是抄的这个实现害苦我了，hash函数碰撞严重，导致效率低下。令人惊讶的是，这种错误的实现遍布全网，无论是中文的还是英文的。我从犄角旮旯（<a href=\"https://stackoverflow.com/questions/20590656/error-for-hash-function-of-pair-of-ints\">stackoverflow问题</a>的评论区中）里才找到问题所在和正确的实现。所以特意总结此博文，避免更多的同学踩坑。</p>\n<blockquote>\n<p>std::hash<T>()(x.first) ^ std::hash<T>()(x.second); - that’s a spectacularly collision-prone way to hash a pair, as every pair with two identical value hashes to 0, and every pair {a, b} hashes the same as {b, a}. For vaguely demanding use, much better to find a hash_combine function and employ that.</p>\n</blockquote>\n<p>惊讶的是，一看到这个评论，我就像中电一样。忽然记起，多年前，当我还是一只小白时，读《C++ 标准库（第二版）》时，作者就已经给出了绝佳的解决方案。我匆忙翻出珍藏的《C++ 标准库（第二版）》的unordered_map对应章节，“7.9.2 Creating and Controlling Unordered Container&quot;，把任意结构hash化的代码搬出来，模版如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// from boost (functional/hash):</span></span><br><span class=\"line\"><span class=\"comment\">// see http://www.boost.org/doc/libs/1_35_0/doc/html/hash/combine.html template</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_combine</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    seed ^= std::<span class=\"built_in\">hash</span>&lt;T&gt;()(val) + <span class=\"number\">0x9e3779b9</span> + (seed &lt;&lt; <span class=\"number\">6</span>) + (seed &gt;&gt; <span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// auxiliary generic functions to create a hash value using a seed</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">void</span> <span class=\"title\">hash_val</span><span class=\"params\">(std::<span class=\"type\">size_t</span> &amp;seed, <span class=\"type\">const</span> T &amp;val, <span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">hash_combine</span>(seed, val);</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Types&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> std::<span class=\"type\">size_t</span> <span class=\"title\">hash_val</span><span class=\"params\">(<span class=\"type\">const</span> Types &amp;... args)</span> </span>&#123;</span><br><span class=\"line\">    std::<span class=\"type\">size_t</span> seed = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">hash_val</span>(seed, args...);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> seed;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">pair_hash</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\">    <span class=\"function\">std::<span class=\"type\">size_t</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"type\">const</span> std::pair&lt;T1, T2&gt; &amp;p)</span> <span class=\"type\">const</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">hash_val</span>(p.first, p.second);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    unordered_map&lt;pair&lt;ll, ll&gt;, ll, pair_hash&gt; slopeCount;</span><br><span class=\"line\">    unordered_set&lt;pair&lt;ll, ll&gt;, pair_hash&gt; seen;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也有Tuple版本的hash实现，我更新回答在了<a href=\"https://stackoverflow.com/a/62035742/6393787\">StackOverflow</a>。有需要的同学可以自取+点赞。</p>\n<p>修改了hash_pair的实现后，我如愿地AC了。一个hash函数的错误，我花了一上午时间解决。并由此从多年前的学习经验中获益。当时我苦读《C++标准库》时，并没有对这段代码特别注意。由此可见，多读书总是没坏处的。</p>\n<p>平时因为Google搜索很方便，遇到问题总是倾向于简单地 复制粘贴。通常情况下，问题就解决了。这样固然可以更快地完成任务，效果也不错。但这种不求甚解的思想对自己的成长是十分不利的。所以需要遇到问题深入钻研（当然是在时间足够的情况下），多读一些经典的书。很多问题和解决方案，经典的书本都已给出了。读书也更能启发自己思考和成长。本次的pair的 unordered_map实践就是最好的证明。</p>\n",
            "tags": [
                "C++",
                "hash",
                "unordered_map"
            ]
        },
        {
            "id": "https://youngforest.github.io/2020/05/18/vscode-include-bits-stdc-h/",
            "url": "https://youngforest.github.io/2020/05/18/vscode-include-bits-stdc-h/",
            "title": "vscode include 万能头文件 bits/stdc++.h",
            "date_published": "2020-05-18T09:41:29.000Z",
            "content_html": "<p>最近经常打kickstart需要include万能头文件<code>bits/stdc++.h</code>，然而，我喜爱的编辑器vs code总是不能正确地找到该头文件，会有红色波浪线表示错误。作为程序员的我完全不能忍受，所以尝试解决该问题。在网络上搜了很多解决方案，大多数并不能直接地解决我的问题。所以，我总结自己的解决方案于此，方便各位取用。</p>\n<p>编程环境:<br />\ng++ 9.1.0, Mac 10.14.2, vs code 1.45.1</p>\n<p>总的思路是:</p>\n<ol>\n<li>寻找gcc编译器头文件的路径,</li>\n<li>更改VS Code设置，让其用上面的路径可以找到<code>bits/stdc++.h</code></li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc-9 -v -E -x c++ -</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/vscode-include-bits-stdc-h/gcc-include-path.png\" alt=\"gcc include path\" /></p>\n<p>图中所示，就是编译器默认找的路径顺序。将这些路径全部加到vscode的includePath里。</p>\n<p><img src=\"/images/vscode-include-bits-stdc-h/vscode-include-path.png\" alt=\"vscode-include-path\" /></p>\n<p><img src=\"/images/vscode-include-bits-stdc-h/vscode-settings.png\" alt=\"vscode-settings\" /></p>\n<p>Done!</p>\n",
            "tags": [
                "vscode",
                "gcc"
            ]
        },
        {
            "id": "https://youngforest.github.io/2020/04/12/codeforces-round-633-Div2/",
            "url": "https://youngforest.github.io/2020/04/12/codeforces-round-633-Div2/",
            "title": "codeforces round 633 Div2",
            "date_published": "2020-04-12T21:06:55.000Z",
            "content_html": "<p><a href=\"https://codeforces.com/blog/entry/75913\">官方题解</a></p>\n<p>codeforces上题目一般高于平时的面试题。如果是为了面试的话，只刷LeetCode就可以了。不过如果是对算法和竞赛感兴趣，强烈鼓励试一试。题目的数量和质量都远超LeetCode。而且为不同水平的同学有不同的赛道，题目难度也不同。对于高水平玩家来说，竞赛体验会好的多。</p>\n<p>我目前共参加过2场Div.2，rating 1480。没错，初始值是1500，我反而掉下来了。</p>\n<h2 id=\"a-filling-diamonds\"><a class=\"markdownIt-Anchor\" href=\"#a-filling-diamonds\"></a> A. Filling Diamonds</h2>\n<p>可以用动态规划的方式思考这个问题。对于长度为n的belt来说，共有2种状态：</p>\n<ol start=\"0\">\n<li></li>\n</ol>\n<p><br />\n/</p>\n<p>和<br />\n1.<br />\n/<br />\n\\</p>\n<p>状态转移方程有:<br />\ndp[n][0] = dp[n-1][1] + dp[n-1][0],<br />\ndp[n][1] = dp[n-1][1].</p>\n<p>对于初始值有:<br />\ndp[0][1] = 1,<br />\ndp[0][0] = 0.</p>\n<p>答案为: dp[n][0].</p>\n<p>通过该方程可以很快地得出<code>dp[n][0] = n</code>。</p>\n<p>时间复杂度: O(1),<br />\n空间复杂度: O(1).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n;</span><br><span class=\"line\">        cin &gt;&gt; n;</span><br><span class=\"line\">        cout &lt;&lt; n &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>出题人也很骄傲地说，这是目前最简单的Div.2 A了。代码很简单，但是思路还挺巧妙。</p>\n<h2 id=\"b-sorted-adjacent-differences\"><a class=\"markdownIt-Anchor\" href=\"#b-sorted-adjacent-differences\"></a> B. Sorted Adjacent Differences</h2>\n<p>贪心。先排序，从中间开始选，向右跳一下，向左跳一下。</p>\n<p>时间复杂度: O(n log n),<br />\n空间复杂度: O(n).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> SIZE = <span class=\"number\">1e5</span> + <span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(SIZE)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n;</span><br><span class=\"line\">        cin &gt;&gt; n;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">            cin &gt;&gt; a[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(), a.<span class=\"built_in\">begin</span>() + n);</span><br><span class=\"line\">        <span class=\"type\">int</span> current = (n - <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = current, right = current;</span><br><span class=\"line\">        <span class=\"type\">bool</span> direction = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"comment\">// [left, right]</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (current &gt;= <span class=\"number\">0</span> &amp;&amp; current &lt; n) &#123;</span><br><span class=\"line\">            cout &lt;&lt; a[current] &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (direction) &#123;</span><br><span class=\"line\">                ++right;</span><br><span class=\"line\">                current = right;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                --left;</span><br><span class=\"line\">                current = left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            direction = !direction;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"c-powered-addition\"><a class=\"markdownIt-Anchor\" href=\"#c-powered-addition\"></a> C. Powered Addition</h2>\n<p>问题可以转化为: 可以给数组中的任何数 加 最多 2^k - 1. 使得整个数组非递减。求最小的k.</p>\n<p>时间复杂度: O(N),<br />\n空间复杂度: O(N).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> T;</span><br><span class=\"line\">    cin &gt;&gt; T;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (T--) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n;</span><br><span class=\"line\">        cin &gt;&gt; n;</span><br><span class=\"line\">        ll max_value_in_array = numeric_limits&lt;ll&gt;::<span class=\"built_in\">min</span>();</span><br><span class=\"line\">        ll max_demand = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)&#123;</span><br><span class=\"line\">            ll current;</span><br><span class=\"line\">            cin &gt;&gt; current;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current &gt; max_value_in_array) &#123;</span><br><span class=\"line\">                max_value_in_array = current;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                max_demand = <span class=\"built_in\">max</span>(max_demand, max_value_in_array - current);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ll could_present = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (could_present &lt;= max_demand) &#123;</span><br><span class=\"line\">            ++ans;</span><br><span class=\"line\">            could_present *= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n",
            "tags": [
                "codeforces",
                "contest"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/12/15/Cpp-generator-implement/",
            "url": "https://youngforest.github.io/2019/12/15/Cpp-generator-implement/",
            "title": "C++ 中实现生成器(Generator, yield in Python)",
            "date_published": "2019-12-15T21:34:30.000Z",
            "content_html": "<p>问题的起因是因为LeetCode上的一个题目<a href=\"https://leetcode.com/problems/iterator-for-combination/\">1286. Iterator for Combination</a>。最完美的实现是利用 生成器(Generator)，也就是Python中的<code>yield</code>。但是我不会，只实现了一个提前计算，然后存起来的解法。并不优雅，赛后，学习了一个C++中Generator的实现，在此分享下。因为我并未在网上找到很好的中文的关于此的文章。</p>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/12/14/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/",
            "url": "https://youngforest.github.io/2019/12/14/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/",
            "title": "Find all unique pairs of maximum and second maximum elements 子数组的最大值和次大值对",
            "date_published": "2019-12-14T22:07:31.000Z",
            "content_html": "<p>问题的根源是有个同学问了个lucky number的问题<a href=\"https://codeforces.com/problemset/problem/280/B\">Codeforces 280B</a>, <a href=\"https://codeforces.com/problemset/problem/281/D\">Codeforces 281D</a>也是同样的问题。</p>\n<p><a href=\"https://www.geeksforgeeks.org/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/\">Find all unique pairs of maximum and second maximum elements over all sub-arrays in O(NlogN)</a></p>\n<p>幸运数的定义为：数组中子数组的最大值和次大值的XOR值。寻找所有幸运数中的最大的。</p>\n<p>Brute force 的解法是枚举所有的子数组，时间复杂度为O(N ^ 2).<br />\n有没有更优的方法呢？<br />\n今天要讨论的就是这个问题。</p>\n<h2 id=\"通用的解法快速寻找-最大次大值对-算法\"><a class=\"markdownIt-Anchor\" href=\"#通用的解法快速寻找-最大次大值对-算法\"></a> 通用的解法，快速寻找 最大次大值对 算法</h2>\n<p>寻找子数组中最大值和次大值其实是有快速算法的:<br />\n<a href=\"https://www.geeksforgeeks.org/find-all-unique-pairs-of-maximum-and-second-maximum-elements-over-all-sub-arrays-in-onlogn/\">Find all unique pairs of maximum and second maximum elements over all sub-arrays in O(NlogN)</a></p>\n<p>基于这个的观察：数组中的每个数，如果想要成为次大值，就只能和向前的第一个比他大的数 或 向后的第一个比他大的数组成。<br />\n我们可以维护一个 单调递减栈，加入新数时，维持单调递增需要弹出所有小于它的数，这时新数就是被弹出来的数后面的第一个比他大的数；栈顶中最大的数 就是 新数 向前的第一个比他大的数。</p>\n<p>时间复杂度: O(N),<br />\n空间复杂度: O(N).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stack&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll N;</span><br><span class=\"line\">    cin &gt;&gt; N;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">nums</span><span class=\"params\">(N)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i = <span class=\"number\">0</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    stack&lt;ll&gt; st;</span><br><span class=\"line\">    st.<span class=\"built_in\">push</span>(nums[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i = <span class=\"number\">1</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!st.<span class=\"built_in\">empty</span>() &amp;&amp; nums[i] &gt; st.<span class=\"built_in\">top</span>()) &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, nums[i] ^ st.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">            st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!st.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            ans = <span class=\"built_in\">max</span>(ans, nums[i] ^ st.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        st.<span class=\"built_in\">push</span>(nums[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"我独立思考出的解法\"><a class=\"markdownIt-Anchor\" href=\"#我独立思考出的解法\"></a> 我独立思考出的解法</h2>\n<p>我的解法利用了XOR的性质，如果换成别的运算就不通用了。</p>\n<p>首先遍历一遍找到最高的位数。<br />\n再遍历一遍找到最高的位数为1的那些数，我们先称其为 最高数。<br />\n从这些最高数出发，往两边扩充，直到遇到另一个最高数，在这个过程中寻找次大数并更新幸运数的最大值。可以证明，每个数最多被找2次。<br />\n所以，总的时间复杂度是 O(N), 空间复杂度 O(N).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> N;</span><br><span class=\"line\">    cin &gt;&gt; N;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;ll&gt; <span class=\"title\">nums</span><span class=\"params\">(N)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i = <span class=\"number\">0</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">        cin &gt;&gt; nums[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> MAX_BIT_BEGIN = <span class=\"number\">40</span>;</span><br><span class=\"line\">    vector&lt;vector&lt;ll&gt;&gt; <span class=\"built_in\">flag</span>(MAX_BIT_BEGIN + <span class=\"number\">1</span>, <span class=\"built_in\">vector</span>&lt;ll&gt;(<span class=\"number\">2</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ll i : nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ll j = <span class=\"number\">0</span>; j &lt;= MAX_BIT_BEGIN; ++j) &#123;</span><br><span class=\"line\">            ++flag[j][((i &gt;&gt; j) &amp; <span class=\"number\">1</span>)];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ll max_bit = MAX_BIT_BEGIN;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; max_bit &gt;= <span class=\"number\">0</span>; --max_bit) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag[max_bit][<span class=\"number\">0</span>] &gt; <span class=\"number\">0</span> &amp;&amp; flag[max_bit][<span class=\"number\">1</span>] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (max_bit == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (max_bit &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        vector&lt;ll&gt; max_bit_is_1_indexs;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ll i = <span class=\"number\">0</span>; i &lt; N; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (((nums[i] &gt;&gt; max_bit) &amp; <span class=\"number\">1</span>) == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                max_bit_is_1_indexs.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ll ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ll index : max_bit_is_1_indexs) &#123;</span><br><span class=\"line\">            ll second_max = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ll i = index - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span> &amp;&amp; ((nums[i] &gt;&gt; max_bit) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">                 --i) &#123;</span><br><span class=\"line\">                second_max = <span class=\"built_in\">max</span>(second_max, nums[i]);</span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, nums[index] ^ second_max);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            second_max = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ll i = index + <span class=\"number\">1</span>; i &lt; N &amp;&amp; ((nums[i] &gt;&gt; max_bit) &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>;</span><br><span class=\"line\">                 ++i) &#123;</span><br><span class=\"line\">                second_max = <span class=\"built_in\">max</span>(second_max, nums[i]);</span><br><span class=\"line\">                ans = <span class=\"built_in\">max</span>(ans, nums[index] ^ second_max);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    ll ans = <span class=\"built_in\">solve</span>();</span><br><span class=\"line\">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Algorithm"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/07/16/gitbook/",
            "url": "https://youngforest.github.io/2019/07/16/gitbook/",
            "title": "用gitbook写一本书",
            "date_published": "2019-07-16T14:34:35.000Z",
            "content_html": "<p>与博客不同，一本书相对内容更为完成，更为体系。博客相比之下就零散的多。不过优秀的系列博客也常常被改编成书。<br />\n如果你想分享规模更大，成体系的知识的话，写本小书是个很好的选择。<br />\n本文介绍一个工具<code>GitBook</code>，可以用Markdown写书，放在GitHub上，生成网页版和PDF版本的书籍。相较传统的Latex，更简单方便。适合当代程序员。</p>\n<p>本文参考的资料主要来源于<a href=\"https://github.com/GitbookIO/gitbook/blob/master/docs/setup.md\">官网</a>，相较之下，重点更突出，可以快速地 初始化、撰写、发布 一本书。</p>\n<p>Install gitbook command line tool:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gitbook-cli -g</span><br></pre></td></tr></table></figure>\n<p>Create a book:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitbook init ./directory</span><br></pre></td></tr></table></figure>\n<p>Preview and serve your book:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitbook serve</span><br></pre></td></tr></table></figure>\n<p>Or build the static website:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitbook build</span><br></pre></td></tr></table></figure>\n<p>Debug for better error message with stack trace:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gitbook build ./ --log=debug --debug</span><br></pre></td></tr></table></figure>",
            "tags": []
        },
        {
            "id": "https://youngforest.github.io/2019/04/06/LeetCode-258-Add-Digits/",
            "url": "https://youngforest.github.io/2019/04/06/LeetCode-258-Add-Digits/",
            "title": "LeetCode 258 Add Digits",
            "date_published": "2019-04-06T16:08:06.000Z",
            "content_html": "<p>今天刷题的时候遇到一个有趣的题目，求一个数字各个位相加的和，知道和小于10。<a href=\"https://leetcode.com/problems/add-digits/description/\">链接</a>.<br />\n题目本身并不难，递归或者迭代都可以解决。但如何在O(1)的复杂度内求解，才是真正的考点。</p>\n<p>答案很简单: 1 + (num - 1) % 9.<br />\n有兴趣的可以看看证明和扩展: <a href=\"https://en.wikipedia.org/wiki/Digital_root#Congruence_formula\">wikipedia</a>.</p>\n",
            "tags": [
                "LeetCode"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/03/17/pkg-config/",
            "url": "https://youngforest.github.io/2019/03/17/pkg-config/",
            "title": "pkg-config",
            "date_published": "2019-03-17T19:52:38.000Z",
            "content_html": "<p>最近在学习<a href=\"https://github.com/google/googletest\">google-test</a>的使用和源码，在<code>make install</code>的时候发现除了向<code>/usr/local/</code>中安装了头文件，<code>/usr/lib/</code>中安装了shared library外，还向<code>/usr/local/lib/pkgconfig/</code>中安装了2个<code>.pc</code>文件。所以说，这个pkg-config是个什么东西呢？</p>\n<p>从一份<a href=\"https://people.freedesktop.org/~dbn/pkg-config-guide.html\">Guide</a>中，我们可以发现<code>pkg-config</code>的所有有用的基本信息。</p>\n<h2 id=\"overview\"><a class=\"markdownIt-Anchor\" href=\"#overview\"></a> Overview</h2>\n<p>现代的计算机系统使用很多层的组件以向用户提供API。一个很大的难点在于如何合适地将这些不同层的组件整合起来。<code>pkg-config</code>这一工具收集了安装在系统上的库的metadata, 用户可以很方便地查看这些metadata。比如，google-test安装的其中一个pc文件<code>gtest.pc</code>的内容是：</p>\n<p>包含使用gtest库的所有信息，如头文件安装位置、shared library的位置，编译时需要的编译选项。可以说，使用gtest看这些metadata就够了。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prefix=$&#123;pcfiledir&#125;/../..</span><br><span class=\"line\">libdir=$&#123;prefix&#125;/lib</span><br><span class=\"line\">includedir=$&#123;prefix&#125;/include</span><br><span class=\"line\"></span><br><span class=\"line\">Name: gtest</span><br><span class=\"line\">Description: GoogleTest (without main() function)</span><br><span class=\"line\">Version: 1.9.0</span><br><span class=\"line\">URL: https://github.com/google/googletest</span><br><span class=\"line\">Libs: -L$&#123;libdir&#125; -lgtest </span><br><span class=\"line\">Cflags: -I$&#123;includedir&#125; -DGTEST_HAS_PTHREAD=1 </span><br></pre></td></tr></table></figure>\n<p>计算机系统上没有一个如<code>pkg-config</code>的metadata系统的话，定位和获得系统提供的服务的细节将会很难。<br />\n对于一个开发者，安装你的包的时候同时安装<code>pkg-config</code>将会极大地方便你的API被用户使用。</p>\n<p><code>pkg-config</code>最主要的使用是当程序编译和链接一个库的时候提供必要的细节。这些元信息被存储在<code>pkg-config</code>文件中。这些文件以<code>.pc</code>为后缀，存放在<code>pkg-config</code>工具知道的特定路径里。<br />\n一个<code>.pc</code>文件中包含2种信息，metadata keywords和freeform variables。<br />\n前者以keyword开头，后接冒号和value，如“Name: gtest&quot;。<br />\n后者用=连接变量的值和名字，如&quot;prefix=…&quot;。<br />\nkeywords是由<code>pkg-config</code>定义和导出的。<br />\nvariables不是必须的，但是可以被用来表示<code>pkg-config</code>没有涉及的信息 或是 被keywords使用以增加keywords定义的灵活性。</p>\n<p>一个pc文件最好对应一个library文件。文件名(除了后缀)也最好相同。</p>\n<p>最重要的metadata域是Requires, Requires.private, Cflags, Libs 和 Libs.private。它们可以被外部的工程用来编译和链接到这个library。优先使用private域，以避免暴露不必要的库给用户。如果用户不不直接使用requires library的symbols，就不应该直接链接到该库。</p>\n",
            "tags": [
                "C++"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/02/17/Queue-and-Stack/",
            "url": "https://youngforest.github.io/2019/02/17/Queue-and-Stack/",
            "title": "Queue and Stack",
            "date_published": "2019-02-17T17:33:33.000Z",
            "content_html": "<p>今天我们一起学习2种重要的数据结构：队列 和 栈。<br />\n本文根据LeetCode上的Explore教程 <a href=\"https://leetcode.com/explore/featured/card/queue-stack/\">Introduction to Data Structure - Queue &amp; Stack</a> 整理而成。</p>\n<h2 id=\"introduction\"><a class=\"markdownIt-Anchor\" href=\"#introduction\"></a> Introduction</h2>\n<p>最常用的Collection是数组(Array)，其最常使用的获取数据的操作是随机获取(Random access), 在C++中一般称作 subscribe。<br />\n但是有时，我们想要限制处理数据的顺序。最常见的限制是：先进先出(First in first out), 后进先出(Last in first out)。分别对应2种数据结构 队列(Queue) 和 栈(Stack)。</p>\n<p>我们从 定义、实现 和 每种数据结构的内置操作 分别学习 队列 和 栈。<br />\n学习目标：</p>\n<ol>\n<li>理解数据处理顺序FIFO和LIFO的原则；</li>\n<li>手动实现数据结构；</li>\n<li>熟悉语言内置的Queue和Stack；</li>\n<li>解决基础的Queue-related问题，尤其是BFS；</li>\n<li>解决基础的Stack-related问题；</li>\n<li>理解系统的栈如何帮助你，在解决dfs和其他递归问题的时候。</li>\n</ol>\n<h2 id=\"queue-first-in-first-out-data-structure\"><a class=\"markdownIt-Anchor\" href=\"#queue-first-in-first-out-data-structure\"></a> Queue: First-in-first-out Data Structure</h2>\n<h3 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\"></a> 定义</h3>\n<p>先进先出 最普遍的比喻是排队(也就是队列), 最早进入队列的人最早被服务到。<br />\n所以队列总共只有2个modify 方法：</p>\n<ul>\n<li>enqueue</li>\n<li>dequeue</li>\n</ul>\n<h3 id=\"实现\"><a class=\"markdownIt-Anchor\" href=\"#实现\"></a> 实现</h3>\n<p>Queue并不是基础的数据结构，我们可以用内置的数组来实现它。在C++中，Queue是container adapter, 并不是真正的container，其内部其实是deque。</p>\n<p>实现实例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyQueue</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"comment\">// store elements</span></span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; data;       </span><br><span class=\"line\">        <span class=\"comment\">// a pointer to indicate the start position</span></span><br><span class=\"line\">        <span class=\"type\">int</span> p_start;            </span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">MyQueue</span>() &#123;p_start = <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">        <span class=\"comment\">/** Insert an element into the queue. Return true if the operation is successful. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">enQueue</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">            data.<span class=\"built_in\">push_back</span>(x);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/** Delete an element from the queue. Return true if the operation is successful. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">deQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            p_start++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">/** Get the front item from the queue. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Front</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data[p_start];</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">/** Checks whether the queue is empty or not. */</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span>  </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> p_start &gt;= data.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    MyQueue q;</span><br><span class=\"line\">    q.<span class=\"built_in\">enQueue</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">    q.<span class=\"built_in\">enQueue</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!q.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; q.<span class=\"built_in\">Front</span>() &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.<span class=\"built_in\">deQueue</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!q.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; q.<span class=\"built_in\">Front</span>() &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    q.<span class=\"built_in\">deQueue</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!q.<span class=\"built_in\">isEmpty</span>()) &#123;</span><br><span class=\"line\">        cout &lt;&lt; q.<span class=\"built_in\">Front</span>() &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"循环队列-circular-queue\"><a class=\"markdownIt-Anchor\" href=\"#循环队列-circular-queue\"></a> 循环队列 Circular Queue</h3>\n<p>在之前的实现中，p_start之前的内存空间是被浪费掉的。为了充分利用，我们可以在内部使用循环利用array。</p>\n<p>Circular Queue也叫做&quot;Ring Buffer&quot;。</p>\n<p>Ring Buffer的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyCircularQueue</span> &#123;</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; data;</span><br><span class=\"line\">    <span class=\"type\">int</span> head;</span><br><span class=\"line\">    <span class=\"type\">int</span> size;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. Set the size of the queue to be k. */</span></span><br><span class=\"line\">    <span class=\"built_in\">MyCircularQueue</span>(<span class=\"type\">int</span> k) &#123;</span><br><span class=\"line\">        data.<span class=\"built_in\">insert</span>(data.<span class=\"built_in\">begin</span>(), k, <span class=\"number\">0</span>);</span><br><span class=\"line\">        head = <span class=\"number\">0</span>;</span><br><span class=\"line\">        size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Insert an element into the circular queue. Return true if the operation is successful. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">enQueue</span><span class=\"params\">(<span class=\"type\">int</span> value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isFull</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        data[(head + size) % data.<span class=\"built_in\">size</span>()] = value;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Delete an element from the circular queue. Return true if the operation is successful. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">deQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isEmpty</span>())</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        </span><br><span class=\"line\">        head = (head + <span class=\"number\">1</span>) % data.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Get the front item from the queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Front</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isEmpty</span>()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[head];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Get the last item from the queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">Rear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">isEmpty</span>()) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[(head + size - <span class=\"number\">1</span>) % data.<span class=\"built_in\">size</span>()];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Checks whether the circular queue is empty or not. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Checks whether the circular queue is full or not. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isFull</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> size == data.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyCircularQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyCircularQueue* obj = new MyCircularQueue(k);</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_1 = obj-&gt;enQueue(value);</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_2 = obj-&gt;deQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj-&gt;Front();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj-&gt;Rear();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_5 = obj-&gt;isEmpty();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_6 = obj-&gt;isFull();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"queue的应用\"><a class=\"markdownIt-Anchor\" href=\"#queue的应用\"></a> Queue的应用</h3>\n<p>最典型的应用，BFS。<br />\nBFS(Breadth-first Search)一般用来发现从根节点到目标节点的最短距离。</p>\n<p>应用BFS的场景：</p>\n<ul>\n<li>do traversal</li>\n<li>find the shortest path</li>\n</ul>\n<p>场景中常使用的数据结构：</p>\n<ul>\n<li>图</li>\n<li>树</li>\n</ul>\n<p>在具体应用中，BFS里的节点可能是<strong>真正的节点</strong>或<strong>状态</strong>，边可能是<strong>真正的边</strong>或<strong>状态间的转移</strong>。</p>\n<p>BFS的模版，一定要背下来，以后面试或做题提高速度和bug-free的可能。</p>\n<h4 id=\"template-1\"><a class=\"markdownIt-Anchor\" href=\"#template-1\"></a> template 1</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the length of the shortest path between root and target node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">BFS</span><span class=\"params\">(Node root, Node target)</span> &#123;</span><br><span class=\"line\">    Queue&lt;Node&gt; queue;  <span class=\"comment\">// store all nodes which are waiting to be processed</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;       <span class=\"comment\">// number of steps neeeded from root to current node</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    add root to queue;</span><br><span class=\"line\">    <span class=\"comment\">// BFS</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue is not empty) &#123;</span><br><span class=\"line\">        step = step + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// iterate the nodes which are already in the queue</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> the first node in queue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">                add next to queue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            remove the first node from queue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;          <span class=\"comment\">// there is no path from root to target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"template-2\"><a class=\"markdownIt-Anchor\" href=\"#template-2\"></a> template 2</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the length of the shortest path between root and target node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">BFS</span><span class=\"params\">(Node root, Node target)</span> &#123;</span><br><span class=\"line\">    Queue&lt;Node&gt; queue;  <span class=\"comment\">// store all nodes which are waiting to be processed</span></span><br><span class=\"line\">    Set&lt;Node&gt; visited;  <span class=\"comment\">// store all the nodes that we&#x27;ve visited</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;       <span class=\"comment\">// number of steps neeeded from root to current node</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    add root to queue;</span><br><span class=\"line\">    add root to visited;</span><br><span class=\"line\">    <span class=\"comment\">// BFS</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue is not empty) &#123;</span><br><span class=\"line\">        step = step + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// iterate the nodes which are already in the queue</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> the first node in queue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next is not in used) &#123;</span><br><span class=\"line\">                    add next to queue;</span><br><span class=\"line\">                    add next to visited;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                remove the first node from queue;   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;          <span class=\"comment\">// there is no path from root to target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在每一轮中，队列中的节点都是等待被处理的。</li>\n<li>没经历一次外层的while循环，都离root更远一步， step++。</li>\n</ol>\n<h4 id=\"template-2-2\"><a class=\"markdownIt-Anchor\" href=\"#template-2-2\"></a> template 2</h4>\n<p>在图中，确保每个节点不被多次访问很重要。否则BFS会陷入无限循环。此时，我们增加一个<code>hashset</code>用来标注是否节点已经被访问到。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Return the length of the shortest path between root and target node.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">BFS</span><span class=\"params\">(Node root, Node target)</span> &#123;</span><br><span class=\"line\">    Queue&lt;Node&gt; queue;  <span class=\"comment\">// store all nodes which are waiting to be processed</span></span><br><span class=\"line\">    Set&lt;Node&gt; visited;  <span class=\"comment\">// store all the nodes that we&#x27;ve visited</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">step</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;       <span class=\"comment\">// number of steps neeeded from root to current node</span></span><br><span class=\"line\">    <span class=\"comment\">// initialize</span></span><br><span class=\"line\">    add root to queue;</span><br><span class=\"line\">    add root to visited;</span><br><span class=\"line\">    <span class=\"comment\">// BFS</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (queue is not empty) &#123;</span><br><span class=\"line\">        step = step + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// iterate the nodes which are already in the queue</span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> the first node in queue;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> step <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next is not in used) &#123;</span><br><span class=\"line\">                    add next to queue;</span><br><span class=\"line\">                    add next to visited;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            remove the first node from queue;   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;          <span class=\"comment\">// there is no path from root to target</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>什么情况下可以不使用visited呢？</p>\n<ol>\n<li>你确定不会出现重复访问的情况。比如，遍历树的时候。</li>\n<li>你确实想要把一个节点加入队列多次。</li>\n</ol>\n<h2 id=\"栈-stack\"><a class=\"markdownIt-Anchor\" href=\"#栈-stack\"></a> 栈 Stack</h2>\n<p>提到栈，我就想起周杰伦的《七里香》。歌中唱到，</p>\n<blockquote>\n<p>雨下整夜，我的栈溢出就像雨水。</p>\n</blockquote>\n<p>在LIFO数据结构中，最新被添加的元素最早被处理。在栈中，添加元素的操作叫做push(压栈)，移除元素的操作叫做pop（弹出）。虽然在C++中，queue的操作也是同样的名字，但在大多数语言中，push 和 pop是stack专有的。</p>\n<p>像队列一样，绝大多数语言提供了built-in的stack库，你不需要重复造轮子，只需要熟悉stack的常用操作，包括 push, pop, top（获取栈顶元素）。</p>\n<h3 id=\"单调栈的应用\"><a class=\"markdownIt-Anchor\" href=\"#单调栈的应用\"></a> 单调栈的应用</h3>\n<p><a href=\"https://leetcode.com/explore/featured/card/queue-stack/230/usage-stack/1363/\">https://leetcode.com/explore/featured/card/queue-stack/230/usage-stack/1363/</a></p>\n<p>Intution: 维护一个单调递减的栈，遍历一遍数组T，如果将其放入栈中，把栈中比它小的元素都pop出来，并计算出相应的间隔。</p>\n<p>时间复杂度：O(n),<br />\n空间复杂度: O(n).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dailyTemperatures</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(T.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        stack&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt;&gt; s; <span class=\"comment\">// temperature, day</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; T.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!s.<span class=\"built_in\">empty</span>() &amp;&amp; s.<span class=\"built_in\">top</span>().first &lt; T[i]) &#123;</span><br><span class=\"line\">                pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; current = s.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                result[current.second] = i - current.second;</span><br><span class=\"line\">                s.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            s.<span class=\"built_in\">push</span>(&#123;T[i], i&#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"stack-和-dfs\"><a class=\"markdownIt-Anchor\" href=\"#stack-和-dfs\"></a> stack 和 DFS</h3>\n<p>DFS是stack的重要应用之一，可以用来寻找从根节点到目标节点的路径(注意不一定是最短)。DFS是回溯的一种算法，只有到达最深的节点才进行回溯，尝试其他路径。</p>\n<h4 id=\"dfs-模版-1递归版本\"><a class=\"markdownIt-Anchor\" href=\"#dfs-模版-1递归版本\"></a> DFS 模版 1，递归版本</h4>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Return true if there is a path from cur to target.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">DFS</span><span class=\"params\">(Node cur, Node target, Set&lt;Node&gt; visited)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (next : each neighbor of cur) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (next is not in visited) &#123;</span><br><span class=\"line\">            add next to visted;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"keyword\">if</span> <span class=\"title function_\">DFS</span><span class=\"params\">(next, target, visited)</span> == <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"dfs-模版-2迭代版本\"><a class=\"markdownIt-Anchor\" href=\"#dfs-模版-2迭代版本\"></a> DFS 模版 2，迭代版本</h4>\n<p>递归版本的优点是实现起来更加简单。缺点是，如果递归深度太深，会stack overflow。<br />\n这时，你可能会想要用 BFS 或者 用显式的栈实现DFS。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Return true if there is a path from cur to target.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"title function_\">DFS</span><span class=\"params\">(<span class=\"type\">int</span> root, <span class=\"type\">int</span> target)</span> &#123;</span><br><span class=\"line\">    Set&lt;Node&gt; visited;</span><br><span class=\"line\">    Stack&lt;Node&gt; stack;</span><br><span class=\"line\">    add root to stack;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (s is not empty) &#123;</span><br><span class=\"line\">        <span class=\"type\">Node</span> <span class=\"variable\">cur</span> <span class=\"operator\">=</span> the top element in stack;</span><br><span class=\"line\">        remove the cur from the stack;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span> <span class=\"keyword\">if</span> cur is target;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Node next : the neighbors of cur) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next is not in visited) &#123;</span><br><span class=\"line\">                add next to visited;</span><br><span class=\"line\">                add next to stack;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>实现的逻辑和递归解法相同。只不过我们使用<code>while</code>循环和显式的<code>stack</code>来模仿系统栈。</p>\n<h3 id=\"implement-queue-using-stacks\"><a class=\"markdownIt-Anchor\" href=\"#implement-queue-using-stacks\"></a> <a href=\"https://leetcode.com/explore/featured/card/queue-stack/239/conclusion/1386/\">Implement Queue using Stacks</a></h3>\n<p>用栈来实现队列。<br />\n我记得在程序员面试金典上遇到过一样的题目，感觉是一道很经典的题目。需要面试者对队列和栈都非常熟悉才行。</p>\n<p>Intuition: 队列是FIFO，栈是LIFO，所以我们可以用2个栈来实现一个队列。定义将一个栈装入另一个栈的操作为<strong>颠倒</strong>。我们可以通过<strong>颠倒</strong>, 将LIFO变为FIFO，而且只有在需要dequeue的时候，才需要做颠倒的操作。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyQueue</span> &#123;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; a, b;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"built_in\">MyQueue</span>() &#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        a.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!a.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                b.<span class=\"built_in\">push</span>(a.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">                a.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> ret = b.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        b.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!a.<span class=\"built_in\">empty</span>()) &#123;</span><br><span class=\"line\">                b.<span class=\"built_in\">push</span>(a.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">                a.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> b.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.<span class=\"built_in\">empty</span>() &amp;&amp; b.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyQueue obj = new MyQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.peek();</span></span><br><span class=\"line\"><span class=\"comment\"> * bool param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"implement-stack-using-queues\"><a class=\"markdownIt-Anchor\" href=\"#implement-stack-using-queues\"></a> <a href=\"https://leetcode.com/explore/featured/card/queue-stack/239/conclusion/1387/\">Implement Stack using Queues</a></h3>\n<p>那么如何用FIFO实现LIFO呢？解法可能不是那么明显，但却十分简单。每次push时，都把队列里的元素重新入对一遍，就把最后入对的放到第一个位置了。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h2>\n<p>dfs 和 bfs 属于想法简单，但实现起来不容易，尤其是bug-free并且快速地实现更属不易。<br />\n由于考察的编程基础涉及广泛，面试官也特别喜欢考类似的题目。几个模版必须熟练背会才行。</p>\n<p>队 和 栈 更是基础的数据结构。在计算机科学中随处可见，虽然很多时候不会直接考察，但很多算法都要用到。熟练手写stack 和 queue 和使用built-in的stack 和 queue是每个合格程序员的基础。</p>\n",
            "tags": [
                "LeetCode"
            ]
        },
        {
            "id": "https://youngforest.github.io/2019/02/11/recursion/",
            "url": "https://youngforest.github.io/2019/02/11/recursion/",
            "title": "recursion",
            "date_published": "2019-02-11T12:58:52.000Z",
            "content_html": "<p>本文根据LeetCode上的教程 <a href=\"https://leetcode.com/explore/learn/card/recursion-i/\">Introduction to Algorithms - Recursion I</a> 整理而成。目的在于帮助笔者自己更熟悉“递归”这一重要的编程概念，如果能够同时对他人产生帮助，那更好不过了。</p>\n<p>本文的结构和LeetCode上的完全相同，分为 简介、递归原则、复现关系、备忘录、复杂度分析、总结 6个部分。</p>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>本Card的目的，回答以下问题：</p>\n<ol>\n<li>什么是递归？递归如何工作？</li>\n<li>如何递归地解决一个问题？</li>\n<li>如何分析一个递归算法的时间复杂度和空间复杂度？</li>\n<li>如何以一种更好的方式应用递归？</li>\n</ol>\n<h2 id=\"递归的原理\"><a class=\"markdownIt-Anchor\" href=\"#递归的原理\"></a> 递归的原理</h2>\n<p>每次递归函数调用自身，都将给定问题变为子问题。递归过程一直继续指导子问题可以不通过进一步递归就可以直接解决。</p>\n<p>递归函数避免无限递归的必要属性：</p>\n<ol>\n<li>递归结束条件(<strong>base cases</strong>)</li>\n<li>一套规则(<strong>recurrence relation</strong>)，可以将所有其他的cases规约为base cases。</li>\n</ol>\n<p>递归函数中可以有多个地方调用本身。</p>\n<h3 id=\"例子-翻转字符串\"><a class=\"markdownIt-Anchor\" href=\"#例子-翻转字符串\"></a> 例子 翻转字符串</h3>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printReverse</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!*str) <span class=\"keyword\">return</span>;  <span class=\"comment\">// base case</span></span><br><span class=\"line\">    <span class=\"built_in\">printReverse</span>(str + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(*str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归函数\"><a class=\"markdownIt-Anchor\" href=\"#递归函数\"></a> 递归函数</h3>\n<p>如果一个问题存在递归解法，我们就可以遵循下列步骤去实现它。</p>\n<p>我们定义该问题为函数<code>F(x)</code>可以实现，其中<code>X</code>是函数的输入，同时表示了问题的范围。</p>\n<p>在函数<code>F(X)</code>中，我们实现以下步骤：</p>\n<ol>\n<li>将问题拆分成更小的范围，<span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \\belong at position 5: x_1 \\̲b̲e̲l̲o̲n̲g̲ ̲X, x_2 \\belong …'>x_1 \\belong X, x_2 \\belong X, ..., x_n \\belong X</span>.</li>\n<li>递归调用函数<code>F(x_1), F(x_2), ..., F(x_n)</code>以解决<code>X</code>的子问题。</li>\n<li>最后，处理子问题的解，组合成对应<code>X</code>的解。</li>\n</ol>\n<h2 id=\"recurrence-relation\"><a class=\"markdownIt-Anchor\" href=\"#recurrence-relation\"></a> Recurrence Relation</h2>\n<p>定义：一个问题的解和其子问题的解之间的关系。</p>\n<h3 id=\"例子pascals-triangle\"><a class=\"markdownIt-Anchor\" href=\"#例子pascals-triangle\"></a> 例子：Pascal’s Triangle</h3>\n<p>定义：杨辉三角是一系列数字组成三角形的形状。在杨辉三角中，每行最左和最右的数字永远是1. 对于剩余的数字，每个数字是它前一行正上方2个数字之和。</p>\n<p>用数学公式表达出来就是，Recurrence Relation为<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo><mo>+</mo><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">f(i, j) = f(i-1, j-1) + f(i-1, j),</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mpunct\">,</span></span></span></span></p>\n<p>base cases为：<br />\n<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mn>1</mn><mo separator=\"true\">,</mo><mi>i</mi><mi>f</mi><mi>j</mi><mo>=</mo><mn>1</mn><mi>o</mi><mi>r</mi><mi>j</mi><mo>=</mo><mi>i</mi></mrow><annotation encoding=\"application/x-tex\">f(i, j) = 1, if j = 1 or j = i</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">r</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.65952em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">i</span></span></span></span>.</p>\n<p>其中，<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>f</mi><mo stretchy=\"false\">(</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">f(i, j)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">)</span></span></span></span>表示第i行第j个数。</p>\n<h2 id=\"memoization-备忘录\"><a class=\"markdownIt-Anchor\" href=\"#memoization-备忘录\"></a> Memoization 备忘录</h2>\n<h3 id=\"递归过程中重复的计算\"><a class=\"markdownIt-Anchor\" href=\"#递归过程中重复的计算\"></a> 递归过程中重复的计算</h3>\n<p>递归解法常常是十分<strong>符合直觉</strong>和<strong>容易编码</strong>的。但大多数时候，在递归过程中，重复计算导致了性能上的损失。</p>\n<p><strong>备忘录法(Memoization)</strong><br />\n即是一个通用的避免重复计算的技术。<br />\n是的，这个词没有拼错，不是Memorization。</p>\n<p>定义：为了避免重复计算，我们可以在一个cache中存储中间子问题的结果，以便之后再次使用它们的时候不需要重复计算。</p>\n<p>备忘录的实现可以通过hashmap实现。尤其是在OOP中，利用装饰器可以实现通用的Memoization。</p>\n<h3 id=\"例子-斐波那契数\"><a class=\"markdownIt-Anchor\" href=\"#例子-斐波那契数\"></a> 例子 斐波那契数</h3>\n<p><a href=\"https://leetcode.com/articles/climbing-stairs/\">斐波那契数的多种解法</a>，其中有时间复杂度为O(log n)的<strong>Binets法</strong>和<strong>公式法</strong>，令人印象十分深刻.</p>\n<h2 id=\"complexity-analysis-复杂度分析\"><a class=\"markdownIt-Anchor\" href=\"#complexity-analysis-复杂度分析\"></a> Complexity Analysis 复杂度分析</h2>\n<p>递归算法的复杂度有时候不是显而易见的，要通过一些套路分析。</p>\n<p>尾递归是一种特殊的技术，可以消减递归栈的使用，优化空间复杂度，使其和迭代算法相同。</p>\n<h3 id=\"time-complexity-时间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#time-complexity-时间复杂度\"></a> Time Complexity 时间复杂度</h3>\n<p>递归算法的时间复杂度为：<br />\nO(T) = R * O(s),<br />\n其中，R为递归调用的数量，O(s)为每次递归调用产生的计算复杂度。<br />\n一般来说，R更难算一点，O(s)的计算和非递归算法的时间复杂度分析一样。</p>\n<p>借助execution tree的技术，我们可以更好地分析递归调用的数量。<br />\nexecution tree是展示具体情况下递归调用流的一棵树，每个节点代表一次调用，节点上的值表示调用时的参数。<br />\n这棵树的节点数目就是R。</p>\n<p>需要特别注意的是，当使用Memoization技术时，execution tree的变化。</p>\n<h3 id=\"space-complexity-空间复杂度\"><a class=\"markdownIt-Anchor\" href=\"#space-complexity-空间复杂度\"></a> Space Complexity 空间复杂度</h3>\n<p>递归算法的空间使用主要分为2部分：</p>\n<ol>\n<li>recursion related</li>\n<li>non-recursion related</li>\n</ol>\n<h4 id=\"recursion-related\"><a class=\"markdownIt-Anchor\" href=\"#recursion-related\"></a> recursion related</h4>\n<p>学过编译原理的我们都知道，每次函数调用都要在栈上压入：</p>\n<ol>\n<li>函数的返回地址</li>\n<li>函数参数</li>\n<li>函数的本地变量</li>\n</ol>\n<p>递归算法的函数调用栈的深度是从初始case到base case.</p>\n<h4 id=\"non-recursion-related\"><a class=\"markdownIt-Anchor\" href=\"#non-recursion-related\"></a> non-recursion related</h4>\n<p>全局变量使用的空间，主要在堆上分配。比如，memoization 要使用的hashmap。</p>\n<h3 id=\"tail-recursion-尾递归\"><a class=\"markdownIt-Anchor\" href=\"#tail-recursion-尾递归\"></a> Tail Recursion 尾递归</h3>\n<p>尾递归是一种递归调用是递归函数的最后指令，而且函数中只有一个递归调用。</p>\n<p>尾递归的一个很好的例子。注意，non_tail_recursion在最后的递归调用后还有计算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">helper_non_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= ls.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// not a tail recursion because it does some computation after the recursive call returned.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ls[start] + helper_non_tail_recursion(start+<span class=\"number\">1</span>, ls);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">sum_non_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ls == <span class=\"literal\">null</span> || ls.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_non_tail_recursion(<span class=\"number\">0</span>, ls);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//---------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">helper_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> start, <span class=\"type\">int</span> [] ls, <span class=\"type\">int</span> acc)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (start &gt;= ls.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// this is a tail recursion because the final instruction is the recursive call.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_tail_recursion(start+<span class=\"number\">1</span>, ls, acc+ls[start]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">sum_tail_recursion</span><span class=\"params\">(<span class=\"type\">int</span> [] ls)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ls == <span class=\"literal\">null</span> || ls.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> helper_tail_recursion(<span class=\"number\">0</span>, ls, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>尾递归消除递归栈的原理：<br />\n编译器知道在从callee中返回之后，会立刻再次返回，不需要再利用函数调用栈中保存的数据。只需要一个栈帧就可以了，所有层共用一个栈帧，所以返回时可以跳过整个递归栈。</p>\n<p>并不是所有语言的编译器都支持尾递归优化的。比如，C, C++支持，而Python, Java不支持。</p>\n<p>尾递归通常也不是那么好实现。需要<br />\n递归调用只出现在最后一个指令，如果需要调用多个函数，或是对返回值进行计算，就没法尾递归了。</p>\n<p>而且细心的同学可以发现尾递归和迭代(loop)的相似之处。事实上，有些函数式编程语言甚至不支持loop，只有递归，完全可以实现迭代。因为我们平时使用loop居多，尾递归很少。如果需要写尾递归时（一般是在一些面试的要求中），可以先写loop版本的代码。然后试着把其中的局部变量更新改成尾递归中的参数，往往就可以写出优雅的（但对于大多数人可读性并不高）的尾递归代码了。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h2>\n<p>解决递归问题的套路：</p>\n<ol>\n<li>定义递归函数</li>\n<li>写下recurrence relation和base case</li>\n<li>使用Memoization消除重复计算，如果存在的话</li>\n<li>如果可能的话，使用尾递归实现递归算法，以消减空间复杂度</li>\n</ol>\n",
            "tags": [
                "Algorithm",
                "LeetCode"
            ]
        }
    ]
}